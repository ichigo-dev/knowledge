[{"term":"バイナリ","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"バイナリ","content":"\n**バイナリ**は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が扱うデータの一種で、[2進数](../../discrete_mathematics/_/chapters/radix.md#2進数)で表現されたデータを指す。\n\n[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)において[プログラム](../../../programming/_/chapters/programming.md#プログラム)やデータは、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)内にバイナリ形式で格納されている。[プログラム](../../../programming/_/chapters/programming.md#プログラム)の実行には、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)がバイナリを解釈して命令を処理する必要がある。同様に、データもバイナリ形式で格納され、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)がその内容を解釈して利用する。\n\n"},{"term":"ビット","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"ビット","content":"\n**ビット**(bit)は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で扱われるデータの最小単位で、 $0$ か $1$ の値を持つ。ビットという言葉は\"Binary digit\"からきており、情報を格納するための最小単位であるため、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内のすべての情報はビット列（[バイナリ](#バイナリ)）で表現される。また、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)はビット単位の[論理演算](../../discrete_mathematics/_/chapters/logical_operation.md#論理演算)の組み合わせにより様々な処理を行っている。\n\n"},{"term":"バイト","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"バイト","content":"\n**バイト**(byte)は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で扱われるデータの単位のひとつで、8[ビット](#ビット)を1つにまとめたもの。1バイト（=8[ビット](#ビット)）は256通りの情報を表現することができる。[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が扱う[ファイル](../../../computer/software/_/chapters/file_system.md#ファイル)のサイズは一般的にバイト単位で表現される。\n\n"},{"term":"ワード","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"ワード","content":"\n**ワード**は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で扱われるデータの単位のひとつで、通常は16[ビット](#ビット)（2[バイト](#バイト)）か32[ビット](#ビット)（4[バイト](#バイト)）、あるいは64[ビット](#ビット)（8[バイト](#バイト)）の長さを持つ。[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)や[レジスタ](../../../computer/hardware/_/chapters/processor.md#レジスタ)、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)などでデータを扱う際の基本単位となる。\n\nワードの長さ（**ワードサイズ**）は、[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)の[アーキテクチャ](../../../computer/hardware/_/chapters/processor.md#cpuアーキテクチャ)や設計によって異なる。16[ビット](#ビット)のワードを使用する[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)は16ビットCPU、32[ビット](#ビット)のワードを使用する[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)は32ビットCPUと呼ばれ、現在では64[ビット](#ビット)の[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)が主流となっている。ワードサイズが大きい[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)ほど一度に扱えるデータ量が大きくなるため、より高速な処理が可能となる。\n\n[プログラミング](../../../programming/_/chapters/programming.md#プログラミング)における[基本データ型](../../../programming/_/chapters/data_type.md#プリミティブ型)も、一般的には[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)のワードサイズに合わせた大きさとなっている。例えば、[C言語](../../../programming/_/chapters/programming_language.md#c言語)では `int` [型](../../../programming/_/chapters/data_type.md#型)は32[ビット](#ビット)、 `short` [型](../../../programming/_/chapters/data_type.md#型)は16[ビット](#ビット)の情報を格納するための[型](../../../programming/_/chapters/data_type.md#型)となっている。\n\n"},{"term":"ワードサイズ","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"ワード","content":"\n**ワード**は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で扱われるデータの単位のひとつで、通常は16[ビット](#ビット)（2[バイト](#バイト)）か32[ビット](#ビット)（4[バイト](#バイト)）、あるいは64[ビット](#ビット)（8[バイト](#バイト)）の長さを持つ。[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)や[レジスタ](../../../computer/hardware/_/chapters/processor.md#レジスタ)、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)などでデータを扱う際の基本単位となる。\n\nワードの長さ（**ワードサイズ**）は、[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)の[アーキテクチャ](../../../computer/hardware/_/chapters/processor.md#cpuアーキテクチャ)や設計によって異なる。16[ビット](#ビット)のワードを使用する[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)は16ビットCPU、32[ビット](#ビット)のワードを使用する[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)は32ビットCPUと呼ばれ、現在では64[ビット](#ビット)の[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)が主流となっている。ワードサイズが大きい[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)ほど一度に扱えるデータ量が大きくなるため、より高速な処理が可能となる。\n\n[プログラミング](../../../programming/_/chapters/programming.md#プログラミング)における[基本データ型](../../../programming/_/chapters/data_type.md#プリミティブ型)も、一般的には[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)のワードサイズに合わせた大きさとなっている。例えば、[C言語](../../../programming/_/chapters/programming_language.md#c言語)では `int` [型](../../../programming/_/chapters/data_type.md#型)は32[ビット](#ビット)、 `short` [型](../../../programming/_/chapters/data_type.md#型)は16[ビット](#ビット)の情報を格納するための[型](../../../programming/_/chapters/data_type.md#型)となっている。\n\n"},{"term":"MSB","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"msb","content":"\n**MSB**（**最上位ビット**: Most Significant Bit）は、[ビット](#ビット)列において一番左の[ビット](#ビット)。\n\n[2進数](../../discrete_mathematics/_/chapters/radix.md#2進数)の正負の数の表現において、MSBが $0$ の場合その数は正の数として、 $1$ の場合その数は負の数として扱われる。\n\nまた、[ビッグエンディアン方式](../../information_theory/_/chapters/coding_theory.md#ビッグエンディアン)のデータ表現においては、MSBがデータの先頭となる。\n\n"},{"term":"LSB","link":"./note/ja/./basics/_/chapters/computer_and_number.md","flagment":"lsb","content":"\n**LSB**（**最下位ビット**: Least Significant Bit）は、[ビット](#ビット)列において一番右の[ビット](#ビット)。\n\n[リトルエンディアン方式](../../information_theory/_/chapters/coding_theory.md#リトルエンディアン)のデータ表現においては、LSBがデータの先頭となる。\n\n\n"},{"term":"位取り記数法","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"位取り記数法","content":"\n**位取り記数法**(Positional notation)は、数値を表現する方法のひとつで、あらかじめ決められた $n$ 種類の記号（数字）により数を表現する。一般的には、記号としてアラビア数字やアルファベットを使用するが、それ以外のもの（漢数字など）を用いてもよい。\n\n位取り基数法においては、一般的に[10進法](#10進数)が使用されており、コンピュータの世界では[2進法](#2進数)や[16進法](#16進数)もよく利用される。\n\n> [基数](#基数)となる自然数 $n$ に対して、\n> \n> ```math\n> 0, 1, \\cdots, n-1\n> ```\n> \n> の数字に任意の記号を対応させる。これを、\n>\n> ```math\n> a_m a_{m-1} \\cdots a_0.b_1 b_2 \\cdots b_k\n> ```\n>\n> という数値列で表現すると、この[基数](#基数)で表される数字列は、[10進数](#10進数)で次の数字を表す。\n>\n> ```math\n> a_m \\times n^m + a_{m-1} \\times n^{m-1} + \\cdots a_1 \\times n + a_0 + \\frac{b_1}{n} + \\frac{b_2}{n^2} +\\cdots + \\frac{b_k}{n^k}\n> ```\n\n\n"},{"term":"基数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"基数","content":"\n**基数**(Radix)は、[位取り記数法](#位取り記数法)で数を表現する際に、各桁の重み付けの基本となる数。基数が $n$ のときの[位取り記数法](#位取り記数法)のことを**n進数**（**n進法**）という。\n\n[10進数](#10進数)の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。\n\n[位取り記数法](#位取り記数法)で表された数の各桁には基数による**重み**がかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \\cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $1/n$ 倍となる。\n\n基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（[基数変換](#基数変換)を行う）必要がある。\n\n"},{"term":"n進数（n進法）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"基数","content":"\n**基数**(Radix)は、[位取り記数法](#位取り記数法)で数を表現する際に、各桁の重み付けの基本となる数。基数が $n$ のときの[位取り記数法](#位取り記数法)のことを**n進数**（**n進法**）という。\n\n[10進数](#10進数)の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。\n\n[位取り記数法](#位取り記数法)で表された数の各桁には基数による**重み**がかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \\cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $1/n$ 倍となる。\n\n基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（[基数変換](#基数変換)を行う）必要がある。\n\n"},{"term":"重み","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"基数","content":"\n**基数**(Radix)は、[位取り記数法](#位取り記数法)で数を表現する際に、各桁の重み付けの基本となる数。基数が $n$ のときの[位取り記数法](#位取り記数法)のことを**n進数**（**n進法**）という。\n\n[10進数](#10進数)の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。\n\n[位取り記数法](#位取り記数法)で表された数の各桁には基数による**重み**がかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \\cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $1/n$ 倍となる。\n\n基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（[基数変換](#基数変換)を行う）必要がある。\n\n"},{"term":"10進数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"10進数","content":"\n**10進数**は、最も身近な[位取り記数法](#位取り記数法)で、 $0$ から $9$ までの10つの数字を用いて数を表す。1つの桁は $10$ になると位が上がる。ある桁の1つ上の桁は[重み](#基数)が $10$ 倍になり、1つ下の桁は[重み](#基数)が $1/10$ 倍になる。\n\n$123.456_{10}$ は、[位取り記数法](#位取り記数法)の定義より次のように表現できる。\n\n```math\n1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0 + 4 \\times 10^{-1} + 5 \\times 10^{-2} + 6 \\times 10^{-3} = 123.456\n```\n\n"},{"term":"2進数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"2進数","content":"\n**2進数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内部でデータを表現するために使用されている[位取り記数法](#位取り記数法)で、 $0$ と $1$ の2つの数字を用いて数を表す。1つの桁は $2$ になると位が上がる。ある桁の1つ上の桁は[重み](#基数)が $2$ 倍になり、1つ下の桁は[重み](#基数)が $1/2$ 倍になる。\n\n2進数 $n$ 桁で表現できる数は $2^n$ 通りとなる。1桁なら2通り、2桁なら4通り、3桁なら8通り、8桁なら256通りといった具合。\n\n$101.001_2$ は[10進数](#10進数)で次の数を表している。\n\n```math\n1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 + 0 \\times 2^{-1} + 0 \\times 2^{-2} + 1 \\times 2^{-3} = 5.125\n```\n\n"},{"term":"8進数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"8進数","content":"\n**8進数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内部のデータを表現するために使用されることのある[位取り記数法](#位取り記数法)で、 $0$ から $8$ までの8つの数字を用いて数を表す。1つの桁は $8$ になると位が上がる。ある桁の1つ上の桁は[重み](#基数)が $8$ 倍になり、1つ下の桁は[重み](#基数)が $1/8$ 倍になる。\n\n[2進数](#2進数)の3桁を1つにまとめたものと等価となり、[2進数](#2進数)との[基数変換](#基数変換)が容易である。\n\n$123.456_8$ は[10進数](#10進数)で次の数を表している。\n\n```math\n1 \\times 8^2 + 2 \\times 8^1 + 3 \\times 8^0 + 4 \\times 8^{-1} + 5 \\times 8^{-2} + 6 \\times 8^{-3} \\simeq 83.590\n```\n\n"},{"term":"16進数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"16進数","content":"\n**16進数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内部のデータを表現するために使用されることのある[位取り記数法](#位取り記数法)で、 $0$ から $9$ までの10つの数字と $\\rm{A}$ から $\\rm{F}$ までのアルファベットを用いて数を表す。1つの桁は $16$ になると位が上がる。ある桁の1つ上の桁は[重み](#基数)が $16$ 倍になり、1つ下の桁は[重み](#基数)が $1/16$倍になる。\n\n[2進数](#2進数)の4桁を1つにまとめたものと等価となり、[2進数](#2進数)との[基数変換](#基数変換)が容易である。\n\n$123.\\rm{ABC}_{16}$ は[10進数](#10進数)で次の数を表している。\n\n```math\n1 \\times 16^2 + 2 \\times 16^1 + 3 \\times 16^0 + 10 \\times 16^{-1} + 11 \\times 16^{-2} + 12 \\times 16^{-3} \\simeq 291.671\n```\n\n"},{"term":"基数変換","link":"./note/ja/./basics/discrete_mathematics/_/chapters/radix.md","flagment":"基数変換","content":"\n**基数変換**は、ある[基数](#基数)で表された数を別の[基数](#基数)で表現するための計算。一般的には数を[10進数](#10進数)で表現することが多いため、[10進数](#10進数)と[n進数](#基数)との変換が重要となる。\n\n"},{"term":"符号ビット","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"符号ビット","content":"\n**符号ビット**は、[2進数](./radix.md#2進数)で表された数において数の正負を意味する[ビット](../../../_/chapters/computer_and_number.md#ビット)。一般的には、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を符号ビットとし、符号ビットが $0$ ならば正の数、 $1$ ならば負の数として扱う。\n\n"},{"term":"補数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"補数","content":"\n**補数**は、[n進数](./radix.md#基数)のある数に対して足し合わせることでちょうど $n$ のべき乗（あるいは $n$ のべき乗から1を引いたもの）になる自然数のうち、最小のもの。言い換えると、ある数に足し合わせることで桁が1つ上がる数。例として、 $560_{10}$ に対する補数は $440_{10}$ （ $560_{10} + 440_{10} = 1000_{10}$ となるため）となる。\n\n補数を使用することで、負の数の表現や演算が用意になるため、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や回路設計において重要な概念となっている。\n\n"},{"term":"1の補数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"2の補数","content":"\n**2の補数**は、[2進数](./radix.md#2進数)において負の数を表現する際に用いられる表現方法。これは、[符号ビット](#符号ビット)を含めた全ての[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転したもの（**1の補数**）に1を加算することで求めることができる。\n\n2の補数を使用するのは、1の補数を用いるよりも表現できる数の範囲が $1$ 広いためである。n[ビット](../../../_/chapters/computer_and_number.md#ビット)の[2進数](./radix.md#2進数)が表現できる数の範囲は、1の補数を用いた場合は $-(2^{n-1} - 1) \\sim (2^{n-1} - 1)$ となり、2の補数を用いた場合は $-2^{n-1} \\sim (2^{n-1} - 1)$ となる。これは1の補数では $0$ が正と負の2種類存在してしまうためである。\n\n"},{"term":"2の補数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"2の補数","content":"\n**2の補数**は、[2進数](./radix.md#2進数)において負の数を表現する際に用いられる表現方法。これは、[符号ビット](#符号ビット)を含めた全ての[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転したもの（**1の補数**）に1を加算することで求めることができる。\n\n2の補数を使用するのは、1の補数を用いるよりも表現できる数の範囲が $1$ 広いためである。n[ビット](../../../_/chapters/computer_and_number.md#ビット)の[2進数](./radix.md#2進数)が表現できる数の範囲は、1の補数を用いた場合は $-(2^{n-1} - 1) \\sim (2^{n-1} - 1)$ となり、2の補数を用いた場合は $-2^{n-1} \\sim (2^{n-1} - 1)$ となる。これは1の補数では $0$ が正と負の2種類存在してしまうためである。\n\n"},{"term":"固定小数点数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"固定小数点数","content":"\n**固定小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、整数部と小数部の桁数をあらかじめ決めておいて、それぞれを固定した[ビット](../../../_/chapters/computer_and_number.md#ビット)幅で表現する数値。あらかじめ小数点の位置を決めておくので扱いやすい一方で、表現できる数値の範囲が限定されてしまう。[浮動小数点数](#浮動小数点数)よりも高速で処理できるという利点がある。\n\n"},{"term":"浮動小数点数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"基数部","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"符号部","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"指数部","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"仮数部","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"正規化","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"単精度形式","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"倍精度形式","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"浮動小数点数","content":"\n**浮動小数点数**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で小数を表現する方法のひとつで、数値を桁の並びを表す仮数部と小数点の位置を表す指数部に分割して表現する。限られた[バイト](../../../_/chapters/computer_and_number.md#バイト)数の中で効率よく小数を表現するための方法で、[固定小数点数](#固定小数点数)に比べて同じ[ビット](../../../_/chapters/computer_and_number.md#ビット)数でも広い範囲の数を表すことができる。\n\n浮動小数点数では数を $\\rm{数値} = (\\rm{符号部}) \\rm{仮数部} \\times \\rm{基数部}^{\\rm{指数部}}$ の形式で考える。\n\n- **基数部**は[2進数](./radix.md#2進数)であれば必ず $2$ となる（[n進数](./radix.md#基数)では $n$ となる）\n- **符号部**は[数の正負](#数の正負)を表す\n- **指数部**には[基数](./radix.md#基数)に対する指数部分を[2進数](./radix.md#2進数)で表記したものを格納する\n- **仮数部**には正規化した小数点数以下の値を格納する\n\n小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の[最上位ビット](../../../_/chapters/computer_and_number.md#msb)が $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、**正規化**という。\n\n[IEEE754](https://ja.wikipedia.org/wiki/IEEE_754)によって規定された浮動小数点数には単精度形式と倍精度形式があり、**単精度形式**では32[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部8[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部23[ビット](../../../_/chapters/computer_and_number.md#ビット)）、**倍精度形式**では64[ビット](../../../_/chapters/computer_and_number.md#ビット)（符号部1[ビット](../../../_/chapters/computer_and_number.md#ビット)、指数部11[ビット](../../../_/chapters/computer_and_number.md#ビット)、仮数部52[ビット](../../../_/chapters/computer_and_number.md#ビット)）で表現する。\n\n\n"},{"term":"BCDコード","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"bcdコード","content":"\n**BCDコード**(Binary Coded Decimal)は、[10進数](./radix.md#10進数)の1桁を[2進数](./radix.md#2進数)の4桁（1[ビット](../../../_/chapters/computer_and_number.md#ビット)=1ニブル）に対応させて表現する符号化形式。これは、数字を表すコードの基本となっている。\n\nBCDコードは[10進数](./radix.md#10進数)を直接扱うことができるため、[10進数](./radix.md#10進数)の計算を行う際に、[丸め誤差](./arithmetic_operation_and_precision.md#丸め誤差)を気にする必要がなくなる。\n\n| 10進数 | BCDコード |\n| -----: | --------: |\n|    $0$ |    $0000$ |\n|    $1$ |    $0001$ |\n|    $2$ |    $0010$ |\n|    $3$ |    $0011$ |\n|    $4$ |    $0100$ |\n|    $5$ |    $0101$ |\n|    $6$ |    $0110$ |\n|    $7$ |    $0111$ |\n|    $8$ |    $1000$ |\n|    $9$ |    $1001$ |\n\n"},{"term":"ゾーン10進数（アンパック10進数）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"ゾーン10進数","content":"\n**ゾーン10進数**（**アンパック10進数**）は、[10進数](./radix.md#10進数)を1[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する方法で、上位4[ビット](../../../_/chapters/computer_and_number.md#ビット)（**ゾーン部**）は文字コードの種類を表し、下位4[ビット](../../../_/chapters/computer_and_number.md#ビット)は数値を表す[BCDコード](#bcdコード)が入る。また、最下位桁のゾーン部は符号部として使用する。\n\n[JISコード](../../../information_theory/_/chapters/character_representation.md#jisコード)形式では数字を表す文字の上位4[ビット](../../../_/chapters/computer_and_number.md#ビット)を $0011$ としている。また符号部は数が正の場合は $1100$ 、負の場合は $1101$ となる。\n\n```\n"},{"term":"ゾーン部","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"ゾーン10進数","content":"\n**ゾーン10進数**（**アンパック10進数**）は、[10進数](./radix.md#10進数)を1[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する方法で、上位4[ビット](../../../_/chapters/computer_and_number.md#ビット)（**ゾーン部**）は文字コードの種類を表し、下位4[ビット](../../../_/chapters/computer_and_number.md#ビット)は数値を表す[BCDコード](#bcdコード)が入る。また、最下位桁のゾーン部は符号部として使用する。\n\n[JISコード](../../../information_theory/_/chapters/character_representation.md#jisコード)形式では数字を表す文字の上位4[ビット](../../../_/chapters/computer_and_number.md#ビット)を $0011$ としている。また符号部は数が正の場合は $1100$ 、負の場合は $1101$ となる。\n\n```\n"},{"term":"パック10進数","link":"./note/ja/./basics/discrete_mathematics/_/chapters/numeric_representation.md","flagment":"パック10進数","content":"\n**パック10進数**は、[10進数](./radix.md#10進数)1桁を[BCDコード](#bcdコード)で表現し、最下位の4[ビット](../../../_/chapters/computer_and_number.md#ビット)に符号を付加する。パック10進数は必ず[バイト](../../../_/chapters/computer_and_number.md#バイト)単位で扱われ、偶数桁の場合は符号部を含めて8[ビット](../../../_/chapters/computer_and_number.md#ビット)の倍数にならないため、先頭に $0000$ を追加する。\n\n```\n"},{"term":"シフト演算","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"シフト演算","content":"\n**シフト演算**は、ある数の各桁の数値を左あるいは右にずらすことで、その数のべき乗を計算する方法。[n進法](./radix.md#基数)において桁を左へシフトすると数は元の $n$ 倍に、右へシフトすると数は元の $1/n$ 倍になる。\n\n[2進数](./radix.md#2進数)の[ビット](../../../_/chapters/computer_and_number.md#ビット)列は、左に $k$ [ビット](../../../_/chapters/computer_and_number.md#ビット)シフトすることで元の数の $2^k$ 倍に、右に $k$ [ビット](../../../_/chapters/computer_and_number.md#ビット)シフトすることで元の数の $2^{-k}$ 倍になる。ただし、あらかじめ決められた[ビット](../../../_/chapters/computer_and_number.md#ビット)幅をあふれた[ビット](../../../_/chapters/computer_and_number.md#ビット)は捨てられるため、必ず正しい結果になるとは限らない。\n\n"},{"term":"論理シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"論理シフト","content":"\n**論理シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として扱わずに[シフト演算](#シフト演算)を行う方法。[符号ビット](./numeric_representation.md#符号ビット)が存在しないため、負の数を扱うことはできない。\n\n**論理右シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を右に指定された数だけシフトし、左端には $0$ を埋める演算。\n\n**論理左シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n"},{"term":"論理右シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"論理シフト","content":"\n**論理シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として扱わずに[シフト演算](#シフト演算)を行う方法。[符号ビット](./numeric_representation.md#符号ビット)が存在しないため、負の数を扱うことはできない。\n\n**論理右シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を右に指定された数だけシフトし、左端には $0$ を埋める演算。\n\n**論理左シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n"},{"term":"論理左シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"論理シフト","content":"\n**論理シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として扱わずに[シフト演算](#シフト演算)を行う方法。[符号ビット](./numeric_representation.md#符号ビット)が存在しないため、負の数を扱うことはできない。\n\n**論理右シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を右に指定された数だけシフトし、左端には $0$ を埋める演算。\n\n**論理左シフト**は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n"},{"term":"算術シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"算術シフト","content":"\n**算術シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として固定して[シフト演算](#シフト演算)を行う方法。\n\n**算術右シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を右に指定された数だけシフトし、左端には[符号ビット](./numeric_representation.md#符号ビット)と同じ値を繰り返して埋める演算。\n\n**算術左シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n\n"},{"term":"算術右シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"算術シフト","content":"\n**算術シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として固定して[シフト演算](#シフト演算)を行う方法。\n\n**算術右シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を右に指定された数だけシフトし、左端には[符号ビット](./numeric_representation.md#符号ビット)と同じ値を繰り返して埋める演算。\n\n**算術左シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n\n"},{"term":"算術左シフト","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"算術シフト","content":"\n**算術シフト**は、[最上位ビット](../../../_/chapters/computer_and_number.md#msb)を[符号ビット](./numeric_representation.md#符号ビット)として固定して[シフト演算](#シフト演算)を行う方法。\n\n**算術右シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を右に指定された数だけシフトし、左端には[符号ビット](./numeric_representation.md#符号ビット)と同じ値を繰り返して埋める演算。\n\n**算術左シフト**は、符号付き[ビット](../../../_/chapters/computer_and_number.md#ビット)列の[符号ビット](./numeric_representation.md#符号ビット)以外の[ビット](../../../_/chapters/computer_and_number.md#ビット)を左に指定された数だけシフトし、右端には $0$ を埋める演算。\n\n\n"},{"term":"誤差","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"誤差","content":"\n**誤差**は、正確な値と計算結果の差異を指す用語。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)は有限の桁数でしか数値を扱うことができないので、扱える数の範囲が決まっている。そのため、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が内部で扱う値と真の値の間には、誤差を生じる可能性がある。\n\n[浮動小数点数](./numeric_representation.md#浮動小数点数)は表現できる数の精度が限られているため、小数点以下の値が正確に表現できない可能性がある。[10進数](./radix.md#10進数)で表したときに有限小数であっても、[2進数](./radix.md#2進数)に変換すると無限小数となる場合もあるので注意が必要（ $0.01_{10}$ など）。\n\n整数の四則演算や[シフト演算](#シフト演算)においても、[オーバフロー](#オーバフロー)などの誤差が発生する場合がある。\n\nこれらの誤差を最小限に抑えるためには、適切なビット数で表現したり、演算の順序を変えるといった工夫が必要になる。\n\n"},{"term":"桁落ち","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"桁落ち","content":"\n**桁落ち**は、値がほぼ等しい2つの数値の差を求めたときに、元の数より有効桁数が減ってしまうことで生じる[誤差](#誤差)。次の例では、元の数の有効桁数は10桁であるが、計算後の有効桁数は2桁になっている。\n\n```math\n\\begin{eqnarray}\n0.00123456789_{10} - 0.001234567_{10} & = & 0.00000000089_{10} \\\n1.23456789_{10} \\times 10^{-3} - 1.234567_{10} \\times 10^{-3} & = & 8.9_{10} \\times 10^{-10}\n\\end{eqnarray}\n```\n\n[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が扱う[浮動小数点数](./numeric_representation.md#浮動小数点数)は、[基数部](./numeric_representation.md#浮動小数点数)が[正規化](./numeric_representation.md#浮動小数点数)されるため、数の右側にある $0$ が正しい値であるか[正規化](./numeric_representation.md#浮動小数点数)によって付与された値であるかが保証できない。\n\n"},{"term":"情報落ち","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"情報落ち","content":"\n**情報落ち**は、有効桁数が限られた計算において、絶対値が非常に大きい数と小さい数で加算や減算を行った時に、小さい方の数が計算結果に反映されない[誤差](#誤差)。次の例では、有効桁数が8桁であるとすると、計算結果に小さい方の数の情報が失われている。\n\n```math\n\\begin{eqnarray}\n1234.5678_{10} + 0.0000001_{10} & = & 1234.5678001_{10} \\simeq 1234.5678_{10} \\\n1.2345678_{10} \\times 10^3 + 1_{10} \\times 10^{-7} & = & 1.2345678001_{10} \\times 10^3 \\simeq 1.2345678_{10} \\times 10^3\n\\end{eqnarray}\n```\n\n"},{"term":"丸め誤差","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"丸め誤差","content":"\n**丸め誤差**は、有効桁数が限られた数値の表現において、切り捨て、切り上げ、四捨五入などを行うことによって、下位の桁が削除されて発生する[誤差](#誤差)。例えば、[10進数](./radix.md#10進数)の $\\frac{1}{3}$ は、3桁までの有効桁数で表現すると $0.333_{10}$ となり、本来の値から近似された値となっている。また、 $0.1_{10}$ を10回足し合わせると、[10進数](./radix.md#10進数)では $1_{10}$ となるが、[2進数](./radix.md#2進数)では丸め誤差により $1_{10}$ よりもわずかに小さくなる。\n\n"},{"term":"打ち切り誤差","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"打ち切り誤差","content":"\n**打ち切り誤差**は、有効桁数が限られた計算において、計算結果の小数部を切り捨てることで生じる[誤差](#誤差)。小数点以下の桁数が多い演算においては、打ち切り誤差が顕著になる。\n\n"},{"term":"オーバフロー（桁あふれ）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"オーバフロー","content":"\n**オーバフロー**（**桁あふれ**）は、演算の結果が、決められた桁数の中で表すことができる数値の範囲を超えることで発生する[誤差](#誤差)。例えば、1[バイト](../../../_/chapters/computer_and_number.md#バイト)の符号付き整数データであれば、表現できる範囲は $-128 \\sim 127$ であるが、上限である $127$ を超える結果、あるいは下限である $-128$ を下回る結果となるような演算を行うと、オーバフローが発生する。\n\n"},{"term":"アンダーフロー","link":"./note/ja/./basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md","flagment":"アンダーフロー","content":"\n**アンダーフロー**は、[浮動小数点数](./numeric_representation.md#浮動小数点数)の演算において、演算結果の[指数部](./numeric_representation.md#浮動小数点数)が小さくなりすぎることで数値を表現できなくなるような[誤差](#誤差)。[浮動小数点数](./numeric_representation.md#浮動小数点数)の[指数部](./numeric_representation.md#浮動小数点数)で表現可能な範囲の最小値よりも小さくなった場合に発生する。 $0$ に限りなく近い数値を扱う場合などにアンダーフローが発生することがある。\n\n\n"},{"term":"集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"集合","content":"\n**集合**は、一定の規則に従ってまとめられた[要素](#要素)の集まり。集合は[要素](#要素)の数や種類、順序などには一切意味を持たない。\n\n集合は中括弧を用いて表現される。例えば、 $\\lbrace 1, 2, 3 \\rbrace$ という集合は、[要素](#要素)が $1, 2, 3$ からなっていることを表す。\n\n集合には[和集合](#和集合)や[積集合](#積集合)、[差集合](#差集合)、[補集合](#補集合)などの演算があり、これらを用いてより複雑な集合を作ることができる。\n\n"},{"term":"要素","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"要素","content":"\n**要素**は、[集合](#集合)に属する個々のもののことで、数字や文字、形、色、音などどのようなものでもよい。\n\n"},{"term":"ベン図","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"ベン図","content":"\n**ベン図**は、複数の[集合](#集合)同士の関係や[集合](#集合)の範囲を図として表現したもの。ベン図を用いることで、複数の[集合](#集合)がどのように重なり合い、共通する[要素](#要素)を持つのかといったことを可視化することができる。\n\nベン図は一般的に円や楕円といった閉曲線を用いて表現される。それぞれの円や楕円は1つの[集合](#集合)を表し、[集合](#集合)の[要素](#要素)をその中に表記する。2つ以上の[集合](#集合)が共通する[要素](#要素)を持つ場合、それらの円や楕円は重なり合う図となる。\n\n"},{"term":"部分集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"部分集合","content":"\n2つの[集合](#集合) $A, B$ において、 $A$ の全ての[要素](#要素)が $B$ の[要素](#要素)に含まれているような場合、 $A$ は $B$ の**部分集合**であるという。2つの[集合](#集合)の[要素](#集合)が全て同じであるとき、 $A$ は $B$ の部分集合であると同時に $B$ も $A$ の部分集合となる。\n\n$A$ が $B$ の部分集合で、 $A$ と $B$ が同じ[集合](#集合)ではない時、 $A$ は $B$ の**真部分集合**であるという。\n\n![部分集合のベン図](../assets/images/subset.png)\n\n"},{"term":"真部分集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"部分集合","content":"\n2つの[集合](#集合) $A, B$ において、 $A$ の全ての[要素](#要素)が $B$ の[要素](#要素)に含まれているような場合、 $A$ は $B$ の**部分集合**であるという。2つの[集合](#集合)の[要素](#集合)が全て同じであるとき、 $A$ は $B$ の部分集合であると同時に $B$ も $A$ の部分集合となる。\n\n$A$ が $B$ の部分集合で、 $A$ と $B$ が同じ[集合](#集合)ではない時、 $A$ は $B$ の**真部分集合**であるという。\n\n![部分集合のベン図](../assets/images/subset.png)\n\n"},{"term":"全体集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"補集合","content":"\n[全体集合](#全体集合)の[部分集合](#部分集合) $A$ があったとき、 $A$ に属さない[要素](#要素)の[集合](#集合)を $A$ の**補集合**という。\n\n![補集合のベン図](../assets/images/complementary_set.png)\n\n"},{"term":"補集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"補集合","content":"\n[全体集合](#全体集合)の[部分集合](#部分集合) $A$ があったとき、 $A$ に属さない[要素](#要素)の[集合](#集合)を $A$ の**補集合**という。\n\n![補集合のベン図](../assets/images/complementary_set.png)\n\n"},{"term":"和集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"和集合","content":"\n2つの[集合](#集合) $A, B$ において、少なくともどちらか片方に属している[要素](#要素)の[集合](#集合)を**和集合**という。\n\n![和集合のベン図](../assets/images/union.png)\n\n"},{"term":"積集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"積集合","content":"\n2つの[集合](#集合) $A, B$ において、両方の[集合](#集合)に属している[要素](#要素)の[集合](#集合)を**積集合**という。\n\n![積集合のベン図](../assets/images/intersection.png)\n\n"},{"term":"差集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"差集合","content":"\n2つの[集合](#集合) $A, B$ において、 $A$ から $B$ を除いた[集合](#集合)を $A$ の $B$ に対する**差集合**という。\n\n![差集合のベン図](../assets/images/difference_set.png)\n\n"},{"term":"対称差集合","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"対称差集合","content":"\n2つの[集合](#集合) $A, B$ において、 $A$ と $B$ のどちらか一方にだけ属する[要素](#要素)の[集合](#集合)を $A$ と $B$ の**対称差集合**という。\n\n![対称差集合のベン図](../assets/images/symmetric_difference_set.png)\n\n\n"},{"term":"命題","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"命題","content":"\n**命題**は、正誤が明確にできる文章や条件式のことで、真(true)か偽(false)のどちらかの値をとる。例えば、 $1 + 1 = 2$ という数式は、真である命題。\n\n"},{"term":"真偽値（ブール値）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/set_and_proposition.md","flagment":"真偽値","content":"\n**真偽値**（**ブール値**）は、真(true)または偽(false)のどちらかをとるような値。[2進数](./radix.md#2進数)においては $0$ を真、 $1$ を偽として1[ビット](../../../_/chapters/computer_and_number.md#ビット)で表現することができる。\n\n\n"},{"term":"論理演算","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"論理演算","content":"\n**論理演算**は、[真偽値](./set_and_proposition.md#真偽値)を対象として行う演算。\n\n基本的な論理演算には、[OR演算](#or演算)、[AND演算](#and演算)、[NOT演算](#not演算)があり、これらは[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が行う演算の最小単位となる。[真偽値](./set_and_proposition.md#真偽値)は[2進数](./radix.md#2進数)1桁で表現することができ、これは[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が扱う情報の最小単位であるため、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が行う演算は全てこれらの論理演算の組み合わせにより成り立っている。\n\nまた、基本論理演算を組み合わせた複合的な論理演算として、[NOR演算](#nor演算)、[NAND演算](#nand演算)、[XOR演算](#xor演算)などがある。\n\n論理演算の入出力関係は[真理値表](#真理値表)や[ベン図](./set_and_proposition.md#ベン図)を用いて表されることが多い。\n\n"},{"term":"OR演算（論理和）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"or演算","content":"\n**OR演算**（**論理和**）は、2つの[真偽値](./set_and_proposition.md#真偽値)の入力値のうち、どちらか一方でも真であれば真を出力する。\n\n2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $y$ | $z$ |\n| --- | --- | --- |\n| $0$ | $0$ | $0$ |\n| $0$ | $1$ | $1$ |\n| $1$ | $0$ | $1$ |\n| $1$ | $1$ | $1$ |\n\n![OR演算のベン図](../assets/images/venn_diagram_or.png)\n\n"},{"term":"AND演算（論理積）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"and演算","content":"\n**AND演算**（**論理積**）は、2つの[真偽値](./set_and_proposition.md#真偽値)の入力値のうち、両方が真であるときにだけ真を出力する。\n\n2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $y$ | $z$ |\n| --- | --- | --- |\n| $0$ | $0$ | $0$ |\n| $0$ | $1$ | $0$ |\n| $1$ | $0$ | $0$ |\n| $1$ | $1$ | $1$ |\n\n![AND演算のベン図](../assets/images/venn_diagram_and.png)\n\n"},{"term":"NOT演算（論理否定）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"not演算","content":"\n**NOT演算**（**論理否定**）は、1つの[真偽値](./set_and_proposition.md#真偽値)の入力値を反転した値を出力する。\n\n入力変数を $x$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $z$ |\n| --- | --- |\n| $0$ | $1$ |\n| $1$ | $0$ |\n\n![NOT演算のベン図](../assets/images/venn_diagram_not.png)\n\n"},{"term":"NOR演算（否定論理和）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"nor演算","content":"\n**NOR演算**（**否定論理和**）は、[OR演算](#or演算)と[NOT演算](#not演算)を組み合わせたもので、2つの[真偽値](./set_and_proposition.md#真偽値)の入力値のうち、どちらか一方でも真であれば偽を出力する。\n\n2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $y$ | $z$ |\n| --- | --- | --- |\n| $0$ | $0$ | $1$ |\n| $0$ | $1$ | $0$ |\n| $1$ | $0$ | $0$ |\n| $1$ | $1$ | $0$ |\n\n![NOR演算のベン図](../assets/images/venn_diagram_nor.png)\n\n"},{"term":"NAND演算（否定論理積）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"nand演算","content":"\n**NAND演算**（**否定論理積**）は、[AND演算](#and演算)と[NOT演算](#not演算)を組み合わせたもので、2つの[真偽値](./set_and_proposition.md#真偽値)の入力値のうち、両方が真であるときにだけ偽を出力する。\n\n2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $y$ | $z$ |\n| --- | --- | --- |\n| $0$ | $0$ | $1$ |\n| $0$ | $1$ | $1$ |\n| $1$ | $0$ | $1$ |\n| $1$ | $1$ | $0$ |\n\n![NAND演算のベン図](../assets/images/venn_diagram_nand.png)\n\n"},{"term":"XOR演算（排他的論理和）","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"xor演算","content":"\n**XOR演算**（**排他的論理和**）は、2つの[真偽値](./set_and_proposition.md#真偽値)の入力値の値が異なる場合にのみ真を出力する。\n\n2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、[真理値表](#真理値表)と[ベン図](./set_and_proposition.md#ベン図)は次のようになる。\n\n| $x$ | $y$ | $z$ |\n| --- | --- | --- |\n| $0$ | $0$ | $0$ |\n| $0$ | $1$ | $1$ |\n| $1$ | $0$ | $1$ |\n| $1$ | $1$ | $0$ |\n\n![XOR演算のベン図](../assets/images/venn_diagram_xor.png)\n\n\n"},{"term":"真理値表","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"真理値表","content":"\n**真理値表**は、[論理演算](#論理演算)の入力の組み合わせと出力を表で表現したもの。入力を $x$ 、出力を $z$ とし、 $x$ を反転した値を出力するような[論理演算](#論理演算)の真理値表は以下のように表される。\n\n| $x$ | $z$ |\n| --- | --- |\n| $0$ | $1$ |\n| $1$ | $0$ |\n\n"},{"term":"ド・モルガンの法則","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"ドモルガンの法則","content":""},{"term":"マスクビット","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"マスクビット","content":"\n**マスクビット**は、ある[ビット](../../../_/chapters/computer_and_number.md#ビット)列の特定の[ビット](../../../_/chapters/computer_and_number.md#ビット)にだけ操作を行いたい場合などに用いる[ビット](../../../_/chapters/computer_and_number.md#ビット)列で、操作対象となる[ビット](../../../_/chapters/computer_and_number.md#ビット)に対応する[ビット](../../../_/chapters/computer_and_number.md#ビット)を $1$ 、それ以外を $0$ としたものとなる。\n\n```\n"},{"term":"ビットマスク演算","link":"./note/ja/./basics/discrete_mathematics/_/chapters/logical_operation.md","flagment":"ビットマスク演算","content":"\n**ビットマスク演算**（**ビットマスク**）は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列のうち特定の部分だけを取り出すために使用される演算。取り出したい[ビット](../../../_/chapters/computer_and_number.md#ビット)に対する[マスクビット](#マスクビット)との[AND演算](#and演算)を行うことで得られる。対象としなかった部分は $0$ で埋められる。\n\n次の例では、対象となる[ビット](../../../_/chapters/computer_and_number.md#ビット)列 $10011011$ に対して末尾の4[ビット](../../../_/chapters/computer_and_number.md#ビット)を取り出す操作を行っている。\n\n```math\n\\begin{array}{rr}\n     & 10011011 \\\n\\lor & 00001111 \\\n\\hline\n     & 00001011\n\\end{array}\n```\n\n"},{"term":"順列","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"順列","content":"\n**順列**は、複数の異なる[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を持つ[集合](../../../discrete_mathematics/_/chapters/set_and_proposition.md#集合)から[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を取り出し、それらを並べる場合の数を求める方法。\n\n[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)数が $n$ 個の場合、それを並べる場合の数は以下の式で表される。\n\n```math\n1 \\times 2 \\times \\cdots (n - 1) \\times n = n!\n```\n\nまた、 $n$ 個の[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)の中から $r$ 個の[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を取り出して、それを並べる並べ方は以下の式で表される。\n\n```math\n\\begin{array}{cc}\n{}_n P_r = \\frac{n!}{(n - r)!} & (0 \\leq r \\leq n)\n\\end{array}\n```\n\n\n"},{"term":"組合せ","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"組合せ","content":"\n**組合せ**は、複数の異なる[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を持つ[集合](../../../discrete_mathematics/_/chapters/set_and_proposition.md#集合)からいくつか[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を取り出すときのパターンの総数。[順列](#順列)とは異なり、取り出す順番は意味を持たない。\n\n[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)数が $n$ 個の[集合](../../../discrete_mathematics/_/chapters/set_and_proposition.md#集合)から $r$ 個の[要素](../../../discrete_mathematics/_/chapters/set_and_proposition.md#要素)を取り出す組み合わせの数は、以下の式で表される。\n\n```math\n{}_n C_r = \\frac{{}_n P_r}{r!} = \\frac{n!}{(n - r)!r!}\n```\n\n\n"},{"term":"確率","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"確率","content":"\n**確率**は、ある[試行](#試行)に対して得られる全ての結果に対し、特定の[事象](#事象)が起こる頻度（起こりやすさ）を表したもの。通常は $0$ から $1$ までの実数で表され、 $0$ に近いほどその[事象](#事象)が起こりにくく、 $1$ に近いほど起こりやすい。\n\nある[試行](#試行)によって[事象](#事象) $A$ の起こる確率 $P(A)$ は、[事象](#事象) $A$ の起こりうる場合の数を $n$ 、全事象の数を $m$ とすると以下の式で表される。\n\n```math\nP(A) = \\frac{n}{m}\n```\n\n"},{"term":"試行","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"試行","content":"\n**試行**は、ある[事象](#事象)が起こるかどうかを確かめるために行われる一連の行為。同じ条件で何度も繰り返すことができ、その結果が偶然によって決まる実験や観測のことを指す。\n\n試行の例としては、サイコロを振ることやコインを投げることなどが挙げられる。\n\n"},{"term":"事象","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"事象","content":"\n**事象**は、[試行](#試行)の結果起こりうる事柄。\n\n例えば、コインを1回投げるという[試行](#試行)においては、「表が出る」あるいは「裏が出る」という事象が起こりうる。\n\n"},{"term":"排反","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"排反","content":"\n**排反**は、ある2つの[事象](#事象)について、両方が同時に起こることがないという性質。一方の[事象](#事象)が起こった場合にもう一方の[事象](#事象)は起こり得ない。\n\n例えば、コインを1回投げた場合に、「表が出る」という[事象](#事象)と「裏が出る」という[事象](#事象)は同時に起こり得ないため、これらは排反である。\n\n"},{"term":"独立","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"独立","content":"\n**独立**は、ある2つの[事象](#事象)について、それぞれが無関係に起こったり起こらなかったりするという性質。一方の[事象](#事象)が起こっても、他方の[事象](#事象)に影響を与えず、逆もまた同様であるような[事象](#事象)の組み合わせ。言い換えると、[従属](#従属)ではないこと。\n\n例えば、コインを2回投げた場合、1回目の表裏がどうであろうと、2回目の表裏には影響を与えず、2回目に表が出る[確率](#確率)と裏が出る[確率](#確率)はそれぞれ $\\frac{1}{2}$ であり、これらの事象は独立である。\n\n"},{"term":"従属","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"従属","content":"\n**従属**は、ある2つの[事象](#事象)について、一方の[事象](#事象)が起こる[確率](#確率)がもう一方の[事象](#事象)の発生の有無によって変わるという性質。言い換えると、[独立](#独立)ではないこと。従属な[事象](#事象)の場合、一方の[事象](#事象)が既に発生したことが、もう一方の[事象](#事象)が発生する[確率](#確率)に影響を与えるため、それらの[確率](#確率)を求める際には、同時に考慮する必要がある。\n\n"},{"term":"余事象","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"余事象","content":"\n**余事象**は、ある[事象](#事象)の[補集合](../../../discrete_mathematics/_/chapters/set_and_proposition.md#補集合)を表す言葉で、その[事象](#事象)が起こらないという[事象](#事象)。ある[事象](#事象) $A$ が起こらない[確率](#確率) $P(\\bar{A})$ （余事象の[確率](#確率)）は次のように求められる。\n\n```math\nP(\\bar{A}) = 1 - P(A)\n```\n\n"},{"term":"加法定理","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"加法定理","content":"\n**加法定理**は、ある2つの[事象](#事象) $A, B$ のいずれかが起こるという[事象](#事象)（**和事象**）の[確率](#確率)を求めるための定理。\n\n2つの[事象](#事象)が互いに[排反](#排反)である場合、和事象の確率 $P(A \\cup B)$ は、それぞれの[事象](#事象)の[確率](#確率)の和で求められる。\n\n```math\nP(A \\cup B) = P(A) + P(B)\n```\n\n2つの[事象](#事象)が互いに[排反](#排反)でない場合、和事象の[確率](#確率) $P(A \\cup B)$ は、それぞれの[事象](#事象)の[確率](#確率)の和から重複する部分（両方が同時に起こる[確率](#確率)）の[確率](#確率)を引くことで求められる。\n\n```math\nP(A \\cup B) = P(A) + P(B) - P(A \\cap B)\n```\n\n"},{"term":"乗法定理","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"乗法定理","content":"\n**乗法定理**は、ある2つの[事象](#事象) $A, B$ の両方が同時に起こるという[事象](#事象)（**積事象**）の[確率](#確率)を求めるための定理。\n\n2つの[事象](#事象)が互いに[独立](#独立)である場合、積事象の[確率](#確率) $P(A \\cap B)$ は、それぞれの[事象](#事象)の[確率](#確率)の積で求められる。\n\n```math\nP(A \\cap B) = P(A) \\times P(B)\n```\n\n2つの[事象](#事象)が互いに[従属](#従属)である場合、積事象の[確率](#確率) $P(A \\cap B)$ は、一方の[事象](#事象)の[確率](#確率)ともう一方の[条件付き確率](#条件付き確率)の積で求められる。\n\n```math\nP(A \\cap B) = P(A) \\times P(B|A)\n```\n\n"},{"term":"条件付き確率","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"条件付き確率","content":"\n**条件付き確率**は、ある[事象](#事象) $A$ が起こるという条件の下で別の[事象](#事象) $B$ の起こる[確率](#確率)のことで、 $P(B|A)$ のように表す。条件付き確率は次の式で求められる。\n\n```math\nP(B|A) = \\frac{P(A \\cap B)}{P(A)}\n```\n\n"},{"term":"ベイズの定理（原因の確率）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ベイズの定理","content":"\n**ベイズの定理**（**原因の確率**）は、2つの[事象](#事象) $A, B$ が互いに[排反](#排反)であり、そのいずれかの[事象](#事象)によって[事象](#事象) $E$ が発生したとき、その[事象](#事象) $E$ が発生した原因が[事象](#事象) $A$ または $B$ である[確率](#確率)を求めるための定理。\n\n[事象](#事象) $E$ の発生する[確率](#確率)を $P(E)$ 、[事象](#事象) $A$ の発生する[確率](#確率)を $P(A)$ 、[事象](#事象) $A$ が原因で[事象](#事象) $E$ が起こる[確率](#確率)を $P(E|A)$ 、[事象](#事象) $B$ の発生する[確率](#確率)を $P(B)$ 、[事象](#事象) $B$ が原因で[事象](#事象) $E$ が起こる[確率](#確率)を $P(E|B)$ とすると、[事象](#事象) $E$ が起こる原因が $A$ である[確率](#確率) $P(A|E)$ は以下の式で表される。\n\n```math\nP(A|E) = \\frac{P(A) \\times P(E|A)}{P(E)} = \\frac{P(A) \\times P(E|A)}{P(A) \\times P(E|A) + P(B) \\times P(E|B)}\n```\n\n\n"},{"term":"代表値","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"代表値","content":"\n**代表値**は、集団内のデータを代表する値のことで、主に[平均値](#平均値)や[中央値](#中央値)、[最頻値](#最頻値)などが用いられる。\n\n"},{"term":"平均値（算術平均）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"平均値","content":"\n**平均値**（**算術平均**）は、データの合計をデータの個数で割ることで得られる値。 $n$ 個のデータ $x_1, x_2, \\dots, x_n$ の平均値 $\\bar{x}$ は以下のように求められる。\n\n```math\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i\n```\n\n"},{"term":"中央値（メジアン）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"中央値","content":"\n**中央値**（**メジアン**）は、データを昇順もしくは降順に並べたときに真ん中の順位に位置するデータの値。データの個数が奇数の場合には中央に位置する値、偶数の場合には中央に位置する2つの値の[平均値](#平均値)を中央値とする。極端な外れ値が存在するデータや、分布に偏りのあるデータには、[平均値](#平均値)よりも[代表値](#代表値)として適している場合がある。\n\n"},{"term":"最頻値（モード）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"最頻値","content":"\n**最頻値**（**モード**）は、データ群の中で最も頻繁に出現する値。どの値が出やすいかという傾向を見るのに適した指標。最頻値は常に一意に定まるわけではなく、複数存在する場合や存在しない場合もある。\n\n"},{"term":"範囲（レンジ）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"範囲","content":"\n**範囲**（**レンジ**）は、データの最大値と最小値の差を表す指標。データのばらつきを簡単に表現することができる。極端に大きな値や小さな値が存在する場合には、範囲が大きくなりすぎて、データ全体の特徴を表す指標としては不適切になることがある。\n\n"},{"term":"散布値","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"散布値","content":"\n**散布値**は、データのばらつきを表すような指標となる値のことで、主に[範囲](#範囲)や[分散](#分散)、[標準偏差](#標準偏差)などが用いられる。\n\n"},{"term":"分散","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"分散","content":"\n**分散**は、データのばらつき具合を表す指標のひとつで、[平均値](#平均値)と各データとの差の2乗の[平均値](#平均値)。分散が小さいほどデータは[平均値](#平均値)付近に集中しており、大きいほど散らばっていることを意味する。データ数を $n$ 、分散を $s^2$ 、[平均値](#平均値)を $\\bar{x}$ とすると、以下の式で表される。\n\n```math\ns^2 = \\frac{1}{n} \\sum^{n}_{i=1}{(x_i - \\bar{x})^2}\n```\n\n全てのデータが等しいとき、分散は $0$ となる。なお、各データに対する[平均値](#平均値)との差 $x_i - \\bar{x}$ を**偏差**という。\n\n"},{"term":"偏差","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"分散","content":"\n**分散**は、データのばらつき具合を表す指標のひとつで、[平均値](#平均値)と各データとの差の2乗の[平均値](#平均値)。分散が小さいほどデータは[平均値](#平均値)付近に集中しており、大きいほど散らばっていることを意味する。データ数を $n$ 、分散を $s^2$ 、[平均値](#平均値)を $\\bar{x}$ とすると、以下の式で表される。\n\n```math\ns^2 = \\frac{1}{n} \\sum^{n}_{i=1}{(x_i - \\bar{x})^2}\n```\n\n全てのデータが等しいとき、分散は $0$ となる。なお、各データに対する[平均値](#平均値)との差 $x_i - \\bar{x}$ を**偏差**という。\n\n"},{"term":"標準偏差","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"標準偏差","content":"\n**標準偏差**は、データのばらつき具合を表す指標のひとつで、[分散](#分散)の平方根をとったもの。標準偏差が小さいほどデータは[平均値](#平均値)付近に集中しており、大きいほど散らばっていることを意味する。標準偏差を $s$ 、[分散](#分散)を $s^2$ とすると、以下の式で表される。[分散](#分散)は各データと[平均値](#平均値)との差の二乗をとるため単位が元のデータと異なるが、標準偏差を求めることで単位が元に戻り分析しやすくなる。\n\n```math\ns = \\sqrt{s^2}\n```\n\n\n"},{"term":"確率分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"確率分布","content":"\n**確率分布**は、[確率変数](#確率変数)の取りうる値と、その値をとる[確率](#確率)との関係を示したもの。確率変数が離散的な値を取る場合には**確率関数**、連続的な値を取る場合には**確率密度関数**として表現される。代表的なものには[二項分布](#二項分布)や[ポアソン分布](#ポアソン分布)、[正規分布](#正規分布)、[指数分布](#指数分布)などがある。\n\n"},{"term":"確率変数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"確率変数","content":"\n**確率変数**は、ある[事象](#事象)に対して[確率](#確率)を割り当てる変数で、その値が特定の[確率分布](#確率分布)に従うときに用いられる。確率変数は離散的な場合と連続的な場合がある。\n\n"},{"term":"確率関数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"確率分布","content":"\n**確率分布**は、[確率変数](#確率変数)の取りうる値と、その値をとる[確率](#確率)との関係を示したもの。確率変数が離散的な値を取る場合には**確率関数**、連続的な値を取る場合には**確率密度関数**として表現される。代表的なものには[二項分布](#二項分布)や[ポアソン分布](#ポアソン分布)、[正規分布](#正規分布)、[指数分布](#指数分布)などがある。\n\n"},{"term":"確率密度関数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"確率分布","content":"\n**確率分布**は、[確率変数](#確率変数)の取りうる値と、その値をとる[確率](#確率)との関係を示したもの。確率変数が離散的な値を取る場合には**確率関数**、連続的な値を取る場合には**確率密度関数**として表現される。代表的なものには[二項分布](#二項分布)や[ポアソン分布](#ポアソン分布)、[正規分布](#正規分布)、[指数分布](#指数分布)などがある。\n\n"},{"term":"期待値","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"期待値","content":"\n**期待値**は、[確率変数](#確率変数)の全ての値に[確率](#確率)の重みをつけた加重平均。1回の[試行](#試行)で得られる結果の[平均値](#平均値)を表す。[確率変数](#確率変数) $X$ について、その期待値 $E(X)$ は、[確率変数](#確率変数) $X$ が取り得る値の個数を $n$ 、 $X$ が $i$ 番目の値を取るときの値を $x_i$ 、 $X$ が $i$ 番目の値を取るときの[確率](#確率)を $p_i$ とすると、以下の式で表される。\n\n```math\nE(X) = \\sum_{i=1}^n {x_i \\times p_i}\n```\n\n"},{"term":"ベルヌーイ試行","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ベルヌーイ試行","content":"\n**ベルヌーイ試行**は、とりうる結果が2種類（成功と失敗など）で、繰り返し行った各[試行](#試行)が[独立](#独立)となるような[試行](#試行)。\n\n例えば、コインを投げる[試行](#試行)はベルヌーイ試行である。\n\nベルヌーイ試行では、[確率変数](#確率変数) $X$ がとりうる値の一方を $1$ 、もう一方を $0$ とする。[試行](#試行)が成功となる[確率](#確率)を $p$ とすると、成功と失敗の[確率](#確率)はそれぞれ次のように表される。\n\n```math\n\\begin{eqnarray}\nP(X=1) & = & p \\\nP(X=0) & = & 1 - p\n\\end{eqnarray}\n```\n\n"},{"term":"二項分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"二項分布","content":"\n**二項分布**は、[ベルヌーイ試行](#ベルヌーイ試行)を繰り返し行ったときに、ある[事象](#事象)が起こった回数を[確率変数](#確率変数)とした離散型の[確率分布](#確率分布)。\n\n例えば、ある製品の生産ラインで1個あたりの不良品率を $p$ としたときに、 $n$ 個の製品を生産したときに不良品が $k$ 個含まれている確率を求めることができる。\n\n成功する[確率](#確率)が $p$ のある[ベルヌーイ試行](#ベルヌーイ試行)を $n$ 回行って成功する回数 $X$ は以下の式で表され、 $X$ が二項分布に従うとき $X \\sim B(n, p)$ と表す。\n\n```math\n\\begin{array}{cc}\nP(X = k) = {}_n C_k p^k (1 - p)^{n-k} & (k = 0, 1, 2, \\cdots, n)\n\\end{array}\n```\n\n![二項分布のグラフ](../assets/images/binomial_distribution.png)\n\n"},{"term":"指数分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"指数分布","content":"\n**指数分布**は、ある[事象](#事象)の発生から次の発生までの期間を表す[確率分布](#確率分布)。[事象](#事象)が発生する[確率](#確率)は一定として考える。指数分布は単位時間あたりの平均事象数 $\\lambda$ をパラメータとして持つ。\n\n指数分布は生存関数やハザード関数、密度関数などの様々な関数形を持つ。\n\n生存関数は、ある時間 $t$ までに[事象](#事象)が起こる[確率](#確率)を表し、次の式で与えられる。\n\n```math\nS(t) = \\exp^{- \\lambda t}\n```\n\nハザード関数は、ある時間 $t$ に[事象](#事象)が起こる[条件付き確率](#条件付き確率)を表し、次の式で与えられる。\n\n```math\nh(t) = \\lambda\n```\n\n密度関数は、ある時間 $t$ で[事象](#事象)が起こる確率密度を表し、次の式で与えられる。\n\n```math\nf(t) = \\lambda \\exp^{- \\lambda t}\n```\n\n![指数分布のグラフ](../assets/images/exponential_distribution.png)\n\n指数分布は、[待ち行列](./waiting_queue_theory.md#待ち行列)やシステムの信頼性解析などにおいてよく用いられる。\n\n"},{"term":"ポアソン分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ポアソン分布","content":"\n**ポアソン分布**は、[試行](#試行)回数が十分に大きく、発生[確率](#確率)が低い[ベルヌーイ試行](#ベルヌーイ試行)を繰り返し行ったときに、ある[事象](#事象)が何回起こるかを示した離散型の[確率分布](#確率分布)。\n\n成功する[確率](#確率)が $p$ のある[ベルヌーイ試行](#ベルヌーイ試行)を $n$ 回行ったとき、期待発生回数を $\\lambda = np$ とおく。このとき、成功する回数 $X$ は以下の式で表され、 $X$ がポアソン分布に従うとき $X \\sim Po(\\lambda)$ と表す。\n\n```math\n\\begin{array}{cc}\nP(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!} & (k = 0, 1, 2, \\cdots)\n\\end{array}\n```\n\n![ポアソン分布のグラフ](../assets/images/poisson_distribution.png)\n\n"},{"term":"正規分布（ガウス分布）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"正規分布","content":"\n**正規分布**（**ガウス分布**）は、連続的な[確率分布](#確率分布)の1つであり、[平均値](#平均値)と[標準偏差](#標準偏差)によって特徴づけられる。正規分布は[平均値](#平均値)を中心としたベル型曲線としてグラフ化される。自然現象や社会現象の多くは正規分布に従っており、実験や推定なども正規分布を前提として行うことが多い。\n\n[平均値](#平均値)を $\\mu$ 、[分散](#分散)を $s^2$ とおく。このとき、[確率変数](#確率変数) $X$ は以下の式で表され、 $X$ が正規分布に従うとき $X \\sim N(\\mu, s^2)$ と表す。\n\n```math\nf(x) = \\frac{1}{\\sqrt{2 \\pi s^2}} \\exp \\left( -\\frac{(x - \\mu)^2}{2 s^2} \\right)\n```\n\n![正規分布のグラフ](../assets/images/normal_distribution_1.png)\n![正規分布のグラフ](../assets/images/normal_distribution_2.png)\n\n"},{"term":"標準正規分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"標準正規分布","content":"\n**標準正規分布**は、[平均](#平均値)が $0$ 、[標準偏差](#標準偏差)が $1$ であるような[正規分布](#正規分布)のことで、 $N(0, 1)$ と表す。任意の[正規分布](#正規分布)を標準正規分布に変換することで、[確率変数](#確率変数)の値を**標準正規分布表**から求めることができる。\n\n\n"},{"term":"標準正規分布表","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"標準正規分布","content":"\n**標準正規分布**は、[平均](#平均値)が $0$ 、[標準偏差](#標準偏差)が $1$ であるような[正規分布](#正規分布)のことで、 $N(0, 1)$ と表す。任意の[正規分布](#正規分布)を標準正規分布に変換することで、[確率変数](#確率変数)の値を**標準正規分布表**から求めることができる。\n\n\n"},{"term":"マルコフ過程","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"マルコフ過程","content":"\n**マルコフ過程**は、ある時点での状態にのみ依存して次の状態が決まるような性質を持つ[確率](#確率)過程。マルコフ過程は過去の状態や未来の状態に依存せず、数学的に扱いやすい。さらに、挙動を決定する変数が1つのみであるものを**単純マルコフ過程**と呼ぶ。\n\n"},{"term":"単純マルコフ過程","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"マルコフ過程","content":"\n**マルコフ過程**は、ある時点での状態にのみ依存して次の状態が決まるような性質を持つ[確率](#確率)過程。マルコフ過程は過去の状態や未来の状態に依存せず、数学的に扱いやすい。さらに、挙動を決定する変数が1つのみであるものを**単純マルコフ過程**と呼ぶ。\n\n"},{"term":"マルコフ連鎖","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"マルコフ連鎖","content":"\n**マルコフ連鎖**は、連鎖的な時間軸での[マルコフ過程](#マルコフ過程)。\n\n\n"},{"term":"相関関係","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"相関関係","content":"\n**相関関係**は、2つの変数の関連性の強さを表すための指標。相関関係を数値で表したものを**相関係数**という。\n\n相関係数 $r$ は $-1 \\leq r \\leq +1$ であり、この値が $1$ に近いほど強い正の相関があるといい、 $-1$ に近いほど強い負の相関があるという。\n\n"},{"term":"相関係数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"相関関係","content":"\n**相関関係**は、2つの変数の関連性の強さを表すための指標。相関関係を数値で表したものを**相関係数**という。\n\n相関係数 $r$ は $-1 \\leq r \\leq +1$ であり、この値が $1$ に近いほど強い正の相関があるといい、 $-1$ に近いほど強い負の相関があるという。\n\n"},{"term":"相関図（散布図）","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"相関図","content":"\n**相関図**（**散布図**）は、何らかの[相関関係](#相関関係)があると予想される2つのデータ系列をそれぞれ縦軸と横軸にとってここのデータをプロットしたもの。\n\n![相関図](../assets/images/correlation_diagram.png)\n\n\n"},{"term":"回帰分析","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"回帰分析","content":"\n**回帰分析**は、[相関関係](#相関関係)にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を**説明変数**、その値をもとに予測したい変数を**目的変数**という。説明変数が1つの場合を**単回帰分析**、2つ以上の場合を**重回帰分析**という。\n\n"},{"term":"説明変数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"回帰分析","content":"\n**回帰分析**は、[相関関係](#相関関係)にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を**説明変数**、その値をもとに予測したい変数を**目的変数**という。説明変数が1つの場合を**単回帰分析**、2つ以上の場合を**重回帰分析**という。\n\n"},{"term":"目的変数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"回帰分析","content":"\n**回帰分析**は、[相関関係](#相関関係)にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を**説明変数**、その値をもとに予測したい変数を**目的変数**という。説明変数が1つの場合を**単回帰分析**、2つ以上の場合を**重回帰分析**という。\n\n"},{"term":"単回帰分析","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"回帰分析","content":"\n**回帰分析**は、[相関関係](#相関関係)にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を**説明変数**、その値をもとに予測したい変数を**目的変数**という。説明変数が1つの場合を**単回帰分析**、2つ以上の場合を**重回帰分析**という。\n\n"},{"term":"重回帰分析","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"回帰分析","content":"\n**回帰分析**は、[相関関係](#相関関係)にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を**説明変数**、その値をもとに予測したい変数を**目的変数**という。説明変数が1つの場合を**単回帰分析**、2つ以上の場合を**重回帰分析**という。\n\n"},{"term":"ロジスティック回帰分析","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ロジスティック回帰分析","content":"\n**ロジスティック回帰分析**は、1つの**カテゴリ変数**（2値の変数）の発生[確率](#確率)を、複数の[説明変数](#回帰分析)によって予測する解析手法。\n\n"},{"term":"カテゴリ変数","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ロジスティック回帰分析","content":"\n**ロジスティック回帰分析**は、1つの**カテゴリ変数**（2値の変数）の発生[確率](#確率)を、複数の[説明変数](#回帰分析)によって予測する解析手法。\n\n"},{"term":"最小二乗法","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"最小二乗法","content":"\n**最小二乗法**は、測定値と論理値の差の二乗の合計が最小になるようにパラメータを決定する手法。観測されたデータとモデルの予測値の誤差の平方和を最小化することで、回帰直線を求める。\n\n"},{"term":"主成分","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"主成分分析","content":"\n**主成分分析**(**PCA**: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。\n\n変換後の低次元のデータについて[分散](#分散)が最大となるものを**第一主成分**、次に分散が大きくなるものを**第二主成分**という。\n\n"},{"term":"第一主成分","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"主成分分析","content":"\n**主成分分析**(**PCA**: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。\n\n変換後の低次元のデータについて[分散](#分散)が最大となるものを**第一主成分**、次に分散が大きくなるものを**第二主成分**という。\n\n"},{"term":"第二主成分","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"主成分分析","content":"\n**主成分分析**(**PCA**: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。\n\n変換後の低次元のデータについて[分散](#分散)が最大となるものを**第一主成分**、次に分散が大きくなるものを**第二主成分**という。\n\n"},{"term":"因子分析","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"因子分析","content":"\n**因子分析**は、高次元のデータの背景にある共通因子を探る手法。[主成分分析](#主成分分析)は高次元のデータを合成することを目的としているが、因子分析では高次元データに対して影響を与えている原因を抽出するため、因果関係が逆になっている。\n\n多数の変数から**主因子**（**共通因子**）を抽出し、それぞれの変数が主因子によって説明される割合を求める。そして、この割合をもとに、各変数の特性を主因子によって説明することができる。\n\n\n"},{"term":"推定","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"推定","content":"\n**推定**は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出してそれをもとに全体の[平均](#平均値)・[分散](#分散)などの傾向を算出する方法。全体のデータのことを**母集団**、推定のために取り出したデータのことを**標本**という。\n\n\n"},{"term":"母集団","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"推定","content":"\n**推定**は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出してそれをもとに全体の[平均](#平均値)・[分散](#分散)などの傾向を算出する方法。全体のデータのことを**母集団**、推定のために取り出したデータのことを**標本**という。\n\n\n"},{"term":"標本","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"推定","content":"\n**推定**は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出してそれをもとに全体の[平均](#平均値)・[分散](#分散)などの傾向を算出する方法。全体のデータのことを**母集団**、推定のために取り出したデータのことを**標本**という。\n\n\n"},{"term":"度数分布表","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"度数分布表","content":"\n**度数分布表**は、データの散らばりや分布をわかりやすくするために、データをいくつかの階級に分けてその階級に属するデータの数をまとめた表。\n\n"},{"term":"ヒストグラム","link":"./note/ja/./basics/applied_mathematics/_/chapters/probability_and_statistics.md","flagment":"ヒストグラム","content":"\n**ヒストグラム**は、[度数分布表](#度数分布表)をもとにプロットした棒グラフ。\n\n\n"},{"term":"スカラ","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"スカラ","content":"\n**スカラ**は、大きさのみを持つ量。温度や時間、距離、重さなどはスカラ量である。\n\n\n"},{"term":"ベクトル","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"ベクトル","content":"\n**ベクトル**は、大きさと方向を持つ量。力や速度、加速度などはベクトル量である。\n\n"},{"term":"基底ベクトル","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"基底ベクトル","content":"\n**基底ベクトル**は、大きさが $1$ で、その[ベクトル](#ベクトル)空間上の軸に沿った方向の[ベクトル](#ベクトル)。全ての[ベクトル](#ベクトル)は基底ベクトルの実数倍の和として表現できる。\n\n"},{"term":"1次従属","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"1次従属","content":"\n**1次従属**は、2つの[ベクトル](#ベクトル)において、どちらかがもう一方の実数倍で表現できる状態。\n\n"},{"term":"1次独立","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"1次独立","content":"\n**1次独立**は、[1次従属](#1次従属)ではない状態。\n\n"},{"term":"単位ベクトル","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"単位ベクトル","content":"\n**単位ベクトル**は、大きさが $1$ の[ベクトル](#ベクトル)。\n\n"},{"term":"内積","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"ベクトルの内積","content":"\n[ベクトル](#ベクトル)の**内積**は、2つの[ベクトル](#ベクトル)をかけ合わせて得られる値。2つの[ベクトル](#ベクトル)をそれぞれ $\\vec{a}, \\vec{b}$ 、これらの[ベクトル](#ベクトル)の成す角を $\\theta$ 、2つの[ベクトル](#ベクトル)の大きさ（[スカラ](#スカラ)）をそれぞれ $\\|a\\|, \\|b\\|$ とすると、内積 $\\vec{a} \\cdot \\vec{b}$ は以下の式で表される。\n\n```math\n\\vec{a} \\cdot \\vec{b} = \\|a\\| \\|b\\| \\cos{\\theta}\n```\n\n\n"},{"term":"行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"行列","content":"\n**行列**は、数や記号や式などを縦と横に矩形上に並べたもの。行列内に並べられたもののことを**要素**といい、要素の横の並びを**行**、要素の縦の並びを**列**という。\n\n"},{"term":"要素","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"行列","content":"\n**行列**は、数や記号や式などを縦と横に矩形上に並べたもの。行列内に並べられたもののことを**要素**といい、要素の横の並びを**行**、要素の縦の並びを**列**という。\n\n"},{"term":"行","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"行列","content":"\n**行列**は、数や記号や式などを縦と横に矩形上に並べたもの。行列内に並べられたもののことを**要素**といい、要素の横の並びを**行**、要素の縦の並びを**列**という。\n\n"},{"term":"列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"行列","content":"\n**行列**は、数や記号や式などを縦と横に矩形上に並べたもの。行列内に並べられたもののことを**要素**といい、要素の横の並びを**行**、要素の縦の並びを**列**という。\n\n"},{"term":"正方行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"正方行列","content":"\n**正方行列**は、[行](#行列)の数と[列](#行列)の数が等しい[行列](#行列)。\n\n"},{"term":"単位行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"単位行列","content":"\n**単位行列**は、任意の[正方行列](#正方行列) $A$ に対して $AE = EA = A$ が成り立つような[行列](#行列) $E$ 。\n\n2行2列の[正方行列](#正方行列)の単位行列は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cc}\n1 & 0 \\\\\n0 & 1\n\\end{array}\n\\right]\n```\n\nまた、3行3列の[正方行列](#正方行列)の単位行列は次のようになる。\n\n```math\n\\left[\n\\begin{array}{ccc}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n"},{"term":"逆行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"逆行列","content":"\n**逆行列**は、任意の[正方行列](#正方行列) $A$ に対して $AA^{-1} = A^{-1}A = E$ が成り立つような[行列](#行列) $A^{-1}$ 。ただし、 $E$ は[単位行列](#単位行列)とする。全ての[正方行列](#正方行列)が必ずしも逆行列を持つとは限らないため、注意が必要。\n\n2行2列の[正方行列](#正方行列) $A$ を\n\n```math\nA =\n\\left[\n\\begin{array}{cc}\na & b \\\\\nc & d\n\\end{array}\n\\right]\n```\n\nとすると、 $A$ の逆行列 $A^{-1}$ は\n\n```math\nA^{-1} = \\frac{1}{ad - bc}\n\\left[\n\\begin{array}{cc}\nd  & -b \\\\\n-c & a\n\\end{array}\n\\right]\n```\n\nとなる。\n\n"},{"term":"正則行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"正則行列","content":"\n**正則行列**は、[逆行列](#逆行列)を持つ[行列](#行列)。任意の[正方行列](#正方行列) $A$ に対して $AB = BA = E$ が成り立つような[行列](#行列) $A$ が正則行列となる。ただし、 $E$ は[単位行列](#単位行列)、 $B$ は $A$ の[逆行列](#逆行列)とする。\n\n"},{"term":"転置行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"転置行列","content":"\n**転置行列**は、[行列](#行列)の[行](#行列)と[列](#行列)を入れ替えてできる[行列](#行列)。\n\n2行3列の[行列](#行列) $A$ を\n\n```math\n\\left[\n\\begin{array}{ccc}\na & b & c\\\\\nd & e & f\n\\end{array}\n\\right]\n```\n\nとすると、 $A$ の転置行列 ${}^t A$ は\n\n```math\n\\left[\n\\begin{array}{cc}\na & d \\\\\nb & e \\\\\nc & f\n\\end{array}\n\\right]\n```\n\nとなる。\n\n\n"},{"term":"テンソル","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"テンソル","content":"\n**テンソル**は、数や記号や式などを縦と横と高さの3方向に並べたもの。3次元のデータなどを扱うために利用される。\n\n\n"},{"term":"固有値","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"固有値と固有ベクトル","content":"\n[正方行列](#正方行列) $A$ に対して、[スカラ](#スカラ)値 $\\lambda$ 、[ベクトル](#ベクトル) $x$ が\n\n```math\nA x = \\lambda x\n```\n\nを満たすとき、 $\\lambda$ を $A$ の**固有値**、 $x$ を $A$ の固有値 $\\lambda$ に対する**固有ベクトル**という。\n\n\n"},{"term":"固有ベクトル","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"固有値と固有ベクトル","content":"\n[正方行列](#正方行列) $A$ に対して、[スカラ](#スカラ)値 $\\lambda$ 、[ベクトル](#ベクトル) $x$ が\n\n```math\nA x = \\lambda x\n```\n\nを満たすとき、 $\\lambda$ を $A$ の**固有値**、 $x$ を $A$ の固有値 $\\lambda$ に対する**固有ベクトル**という。\n\n\n"},{"term":"対数","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"対数","content":"\n$a > 0, a \\neq 1$ とするとき、どのような正の数 $R$ に対しても\n\n```math\na^x = R\n```\n\nを満たす実数 $x$ がただ1つに決まる。この $x$ の値を、 $a$ を**底**とする $R$ の**対数**といい、\n\n```math\nx = \\log_a{R}\n```\n\nで表す。また、この時の $R$ をこの対数の**真数**といい、 $R > 0$ である。また、対数と指数の間には\n\n```math\nx = \\log_a{R} \\Leftrightarrow a^x = R \n```\n\nという関係が成り立つ。\n\n\n"},{"term":"底","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"対数","content":"\n$a > 0, a \\neq 1$ とするとき、どのような正の数 $R$ に対しても\n\n```math\na^x = R\n```\n\nを満たす実数 $x$ がただ1つに決まる。この $x$ の値を、 $a$ を**底**とする $R$ の**対数**といい、\n\n```math\nx = \\log_a{R}\n```\n\nで表す。また、この時の $R$ をこの対数の**真数**といい、 $R > 0$ である。また、対数と指数の間には\n\n```math\nx = \\log_a{R} \\Leftrightarrow a^x = R \n```\n\nという関係が成り立つ。\n\n\n"},{"term":"真数","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"対数","content":"\n$a > 0, a \\neq 1$ とするとき、どのような正の数 $R$ に対しても\n\n```math\na^x = R\n```\n\nを満たす実数 $x$ がただ1つに決まる。この $x$ の値を、 $a$ を**底**とする $R$ の**対数**といい、\n\n```math\nx = \\log_a{R}\n```\n\nで表す。また、この時の $R$ をこの対数の**真数**といい、 $R > 0$ である。また、対数と指数の間には\n\n```math\nx = \\log_a{R} \\Leftrightarrow a^x = R \n```\n\nという関係が成り立つ。\n\n\n"},{"term":"数列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"数列","content":"\n**数列**は、一定の法則に従って数を並べたもの。並べられた数のことを**項**、数列の最初の項を**初項**という。\n\n"},{"term":"項","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"数列","content":"\n**数列**は、一定の法則に従って数を並べたもの。並べられた数のことを**項**、数列の最初の項を**初項**という。\n\n"},{"term":"初項","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"数列","content":"\n**数列**は、一定の法則に従って数を並べたもの。並べられた数のことを**項**、数列の最初の項を**初項**という。\n\n"},{"term":"等差数列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"等差数列","content":"\n**等差数列**は、隣り合う2つの[項](#数列)の差が常に一定である[数列](#数列)。また、この時の差のことを**公差**という。\n\n以下に示すのは、[初項](#数列)が $3$ 、公差が $4$ である等差数列の例。\n\n```math\n3, 7, 11, 15, 19, 23, \\cdots\n```\n\n"},{"term":"公差","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"等差数列","content":"\n**等差数列**は、隣り合う2つの[項](#数列)の差が常に一定である[数列](#数列)。また、この時の差のことを**公差**という。\n\n以下に示すのは、[初項](#数列)が $3$ 、公差が $4$ である等差数列の例。\n\n```math\n3, 7, 11, 15, 19, 23, \\cdots\n```\n\n"},{"term":"等比数列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"等比数列","content":"\n**等比数列**は、隣り合う2つの[項](#数列)の比（左隣の[項](#数列)にある定数をかけることで右隣の値となる）が常に一定である[数列](#数列)。この時の定数のことを**公比**という。\n\n以下に示すのは、[初項](#数列)が1、公比が3である等差数列の例。\n\n```math\n1, 3, 9, 27, 81, 243, \\cdots\n```\n\n"},{"term":"公比","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"等比数列","content":"\n**等比数列**は、隣り合う2つの[項](#数列)の比（左隣の[項](#数列)にある定数をかけることで右隣の値となる）が常に一定である[数列](#数列)。この時の定数のことを**公比**という。\n\n以下に示すのは、[初項](#数列)が1、公比が3である等差数列の例。\n\n```math\n1, 3, 9, 27, 81, 243, \\cdots\n```\n\n"},{"term":"フィボナッチ数列","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_calculation.md","flagment":"フィボナッチ数","content":"\n**フィボナッチ数列**は、2つ前の[項](#数列)と1つ前の[項](#数列)を足したものを次の[項](#数列)とする[数列](#数列)。最初の2[項](#数列)は $1, 1$ から始まる。\n\n```math\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\cdots\n```\n\n\n"},{"term":"二分法","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_analysis.md","flagment":"二分法","content":"\n**二分法**とは、ある関数 $f(x)$ について、正の値をとる点と負の値をとる点の2点から $f(x) =  0$ の解を求める方法。\n\n$f(x)$ において符号の異なる2点をそれぞれ $a, b$ とする。二分方では最初にこの2点の中点を求め、その時の値の正負を調べる。最初の2点のうち中点と符号が一致する方を中点と置き換えて、この操作を繰り返し行う。このような反復操作により確実に $f(x) = 0$ となる解を導くことができる。\n\n二分法は計算が遅いものの、確実に解を求めたい場合には有効である。\n\n\n"},{"term":"補間法","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_analysis.md","flagment":"補間法","content":"\n**補間法**とは、ある関数 $f(x)$ について2点以上の値がわかっている場合に、 $f(x)$ がどのような関数であるかを推測するための方法。\n\n**線形補間**とは、既知の2点から直線（1次関数）を求め、任意の $x$ のときの $f(x)$ の値を求める方法。\n\n**ラグランジュ補間**とは、独立した $n + 1$ 個の値から、これらの点をすべて通る $n$ 次の多項式を決定する方法。\n\n\n"},{"term":"線形補間","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_analysis.md","flagment":"補間法","content":"\n**補間法**とは、ある関数 $f(x)$ について2点以上の値がわかっている場合に、 $f(x)$ がどのような関数であるかを推測するための方法。\n\n**線形補間**とは、既知の2点から直線（1次関数）を求め、任意の $x$ のときの $f(x)$ の値を求める方法。\n\n**ラグランジュ補間**とは、独立した $n + 1$ 個の値から、これらの点をすべて通る $n$ 次の多項式を決定する方法。\n\n\n"},{"term":"ラグランジュ補間","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_analysis.md","flagment":"補間法","content":"\n**補間法**とは、ある関数 $f(x)$ について2点以上の値がわかっている場合に、 $f(x)$ がどのような関数であるかを推測するための方法。\n\n**線形補間**とは、既知の2点から直線（1次関数）を求め、任意の $x$ のときの $f(x)$ の値を求める方法。\n\n**ラグランジュ補間**とは、独立した $n + 1$ 個の値から、これらの点をすべて通る $n$ 次の多項式を決定する方法。\n\n\n"},{"term":"ニュートン法","link":"./note/ja/./basics/applied_mathematics/_/chapters/numerical_analysis.md","flagment":"ニュートン法","content":"\n**ニュートン法**とは、方程式の解に近いと思われる予測値を1つ設定しておき、この予測値を基準として徐々に真の解に近づけていく方法。\n\n\n"},{"term":"因数分解","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"因数分解","content":"\n**因数分解**は、未知変数を含む方程式を因数の積として表現することで、複雑な式を簡易化する方法。**因数**は約数のことで、ある数を割り切ることができる数。因数分解では、数式を共通因数でくくりだしたり、[乗法公式](#乗法公式)を用いたりする。\n\n"},{"term":"因数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"因数分解","content":"\n**因数分解**は、未知変数を含む方程式を因数の積として表現することで、複雑な式を簡易化する方法。**因数**は約数のことで、ある数を割り切ることができる数。因数分解では、数式を共通因数でくくりだしたり、[乗法公式](#乗法公式)を用いたりする。\n\n"},{"term":"乗法定理","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"乗法定理","content":""},{"term":"素因数分解","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"素因数分解","content":"\n**素因数分解**は、ある正の整数を[素数](#素数)の積の形で表す方法。対象の数を割り切れる最小の[素数](#素数)で割り、その商をさらに割り切れる最小の[素数](#素数)で割る、といった操作を繰り返す。そして、商が[素数](#素数)になった時点で、対象の数をそれまで割ってきた[素数](#素数)の積で表す。\n\n例えば、 $180$ を素因数分解すると次のようになる。\n\n```math\n180 = 2 \\times 2 \\times 3 \\times 3 \\times 5 = 2^2 \\times 3^2 \\times 5\n```\n\n"},{"term":"素数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"素数","content":"\n**素数**は、 $2$ 以上の自然数のうち、 正の約数が $1$ と自分自身のみのもの。素数でない数のことを**合成数**という。素数は $2$ を初項とした次のような無限数列である。\n\n```math\n2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, \\cdots\n```\n\n\n"},{"term":"合成数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"素数","content":"\n**素数**は、 $2$ 以上の自然数のうち、 正の約数が $1$ と自分自身のみのもの。素数でない数のことを**合成数**という。素数は $2$ を初項とした次のような無限数列である。\n\n```math\n2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, \\cdots\n```\n\n\n"},{"term":"微分","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"微分","content":"\n**微分**は、ある関数 $f(x)$ の[導関数](#導関数) $f'(x)$ を求める演算。関数 $y = f(x)$ を $x$ について微分することを次のように表す。\n\n```math\nf'(x) = \\frac{dy}{dx} = \\frac{d}{dx}f(x)\n```\n\n"},{"term":"導関数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"導関数","content":"\n**導関数**は、関数 $y = f(x)$ のある点における瞬間の変化率（接線の傾き）を求められる関数。導関数は次のような定義で表される。\n\n```math\nf'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}\n```\n\n"},{"term":"微分係数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"微分係数","content":"\n**微分係数**は、関数 $y = f(x)$ の[導関数](#導関数) $f'(x)$ の、 $x = a$ における値。\n\n```math\nf'(a) = \\lim_{b \\to a} \\frac{f(b) - f(a)}{b - a}\n```\n\n\n"},{"term":"積分","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"積分","content":"\n**積分**は、[微分](#微分)と対をなす演算のことで、[微分](#微分)するとある関数 $f'(x)$ となるような関数 $f(x)$ を求める。積分を用いることで、ある関数が描く面積を求めることができる。ある関数 $f(x)$ を $x$ で積分することを次のように表す。\n\n```math\n\\int f(x) dx\n```\n\n"},{"term":"不定積分","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"不定積分","content":"\n**不定積分**は、[微分](#微分)したら $f(x)$ となるような関数 $F(x) = \\int f(x) dx$ を求める演算。定数項は[微分](#微分)されると $0$ になるため、どのような値となるかが定まらないため、 **積分定数** $C$ として記す。\n\n"},{"term":"積分定数","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"不定積分","content":"\n**不定積分**は、[微分](#微分)したら $f(x)$ となるような関数 $F(x) = \\int f(x) dx$ を求める演算。定数項は[微分](#微分)されると $0$ になるため、どのような値となるかが定まらないため、 **積分定数** $C$ として記す。\n\n"},{"term":"定積分","link":"./note/ja/./basics/applied_mathematics/_/chapters/formal_processing.md","flagment":"定積分","content":"\n**定積分**は、ある範囲 $[a, b]$ における[積分](#積分)値（関数 $f(x)$ の描く面積）を求める演算。 $F(x) = \\int f(x) dx$ において、 $x$ に定数 $a, b$ を代入して得られた値の差、 $F(b) - F(a)$ のこと。\n\n```math\n\\int_{a}^{b} f(x) dx = \\bigl[ F(x) \\bigr]_{a}^{b} = F(b) - F(a)\n```\n"},{"term":"グラフ","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"グラフ","content":"\n**グラフ**は、有限個の点（**ノード**）から構成され、これらの点が線（**エッジ**）で結ばれたもの。通信網やリンク、電子回路といったものの関係を抽象化するために用いられる。\n\n"},{"term":"ノード","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"グラフ","content":"\n**グラフ**は、有限個の点（**ノード**）から構成され、これらの点が線（**エッジ**）で結ばれたもの。通信網やリンク、電子回路といったものの関係を抽象化するために用いられる。\n\n"},{"term":"エッジ","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"グラフ","content":"\n**グラフ**は、有限個の点（**ノード**）から構成され、これらの点が線（**エッジ**）で結ばれたもの。通信網やリンク、電子回路といったものの関係を抽象化するために用いられる。\n\n"},{"term":"有向グラフ","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"有向グラフ","content":"\n**有向グラフ**は、[エッジ](#グラフ)がどちらからどちらに向かっているかという方向を持っている[グラフ](#グラフ)。[エッジ](#グラフ)は矢印によって表される。\n\n"},{"term":"無向グラフ","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"無向グラフ","content":"\n**無向グラフ**は、[エッジ](#グラフ)が向きを持たない[グラフ](#グラフ)。[エッジ](#グラフ)は単純な線によって表される。\n\n\n"},{"term":"隣接行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"隣接行列","content":"\n**隣接行列**は、[グラフ](#グラフ)を表現するために用いられる[行列](./numerical_calculation.md#行列)。[行列](./numerical_calculation.md#行列)の各[行](./numerical_calculation.md#行列)と[列](./numerical_calculation.md#行列)はそれぞれ[グラフ](#グラフ)の[ノード](#グラフ)に対応しており、[ノード](#グラフ)同士が[エッジ](#グラフ)で接続されている部分を $1$ に、それ以外を $0$ にしたものとなっている。また、[エッジ](#グラフ)が重みを持つような[グラフ](#グラフ)の場合は、 $1$ の代わりに重みを入れた[行列](./numerical_calculation.md#行列)とする。\n\n\n"},{"term":"木","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"木","content":"\n**木**は、[無向グラフ](#無向グラフ)のうち循環するような関係を持たないもの。\n\n木の中にある1つの[ノード](#グラフ)を基準とすると、他の[ノード](#グラフ)との親子関係を明確にすることができる。この時、最上位の階層となる（親を持たない）[ノード](#グラフ)のことを**ルート**（**根**）、一番下の階層となる（子を持たない）[ノード](#グラフ)のことを**リーフ**（**葉**）という。\n\n"},{"term":"ルート（根）","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"木","content":"\n**木**は、[無向グラフ](#無向グラフ)のうち循環するような関係を持たないもの。\n\n木の中にある1つの[ノード](#グラフ)を基準とすると、他の[ノード](#グラフ)との親子関係を明確にすることができる。この時、最上位の階層となる（親を持たない）[ノード](#グラフ)のことを**ルート**（**根**）、一番下の階層となる（子を持たない）[ノード](#グラフ)のことを**リーフ**（**葉**）という。\n\n"},{"term":"リーフ（葉）","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"木","content":"\n**木**は、[無向グラフ](#無向グラフ)のうち循環するような関係を持たないもの。\n\n木の中にある1つの[ノード](#グラフ)を基準とすると、他の[ノード](#グラフ)との親子関係を明確にすることができる。この時、最上位の階層となる（親を持たない）[ノード](#グラフ)のことを**ルート**（**根**）、一番下の階層となる（子を持たない）[ノード](#グラフ)のことを**リーフ**（**葉**）という。\n\n"},{"term":"走査","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"走査","content":"\n**走査**は、[木](#木)の持つ各[ノード](#グラフ)を順番に読んでいく操作。\n\n"},{"term":"深さ優先探索","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"深さ優先探索","content":"\n**深さ優先探索**は、現在の[ノード](#グラフ)について調査した後にその子[ノード](#グラフ)に対して同じことを繰り返す[走査](#走査)方法。再帰呼出しによって容易に表現でき、先行順、中間順、後行順の3つの方法がある。**先行順**では根[ノード](#グラフ)を調査してから子[ノード](#グラフ)を探索し、**中間順**では子[ノード](#グラフ)左側を探索してから根[ノード](#グラフ)を調査して子[ノード](#グラフ)右側を探索し、**後行順**では子[ノード](#グラフ)を探索してから根[ノード](#グラフ)を調査する。\n\n下のような[木](#木)をそれぞれの方法で走査した場合、結果は次のようになる。\n\n![深さ優先探索](../assets/images/depth_first_search.png)\n\n- 先行順 : F, B, A, D, C, E, G, I, H\n- 中間順 : A, B, C, D, E, F, G, H, I\n- 後行順 : A, C, E, D, B, H, I, G, F\n\n"},{"term":"先行順","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"深さ優先探索","content":"\n**深さ優先探索**は、現在の[ノード](#グラフ)について調査した後にその子[ノード](#グラフ)に対して同じことを繰り返す[走査](#走査)方法。再帰呼出しによって容易に表現でき、先行順、中間順、後行順の3つの方法がある。**先行順**では根[ノード](#グラフ)を調査してから子[ノード](#グラフ)を探索し、**中間順**では子[ノード](#グラフ)左側を探索してから根[ノード](#グラフ)を調査して子[ノード](#グラフ)右側を探索し、**後行順**では子[ノード](#グラフ)を探索してから根[ノード](#グラフ)を調査する。\n\n下のような[木](#木)をそれぞれの方法で走査した場合、結果は次のようになる。\n\n![深さ優先探索](../assets/images/depth_first_search.png)\n\n- 先行順 : F, B, A, D, C, E, G, I, H\n- 中間順 : A, B, C, D, E, F, G, H, I\n- 後行順 : A, C, E, D, B, H, I, G, F\n\n"},{"term":"中間順","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"深さ優先探索","content":"\n**深さ優先探索**は、現在の[ノード](#グラフ)について調査した後にその子[ノード](#グラフ)に対して同じことを繰り返す[走査](#走査)方法。再帰呼出しによって容易に表現でき、先行順、中間順、後行順の3つの方法がある。**先行順**では根[ノード](#グラフ)を調査してから子[ノード](#グラフ)を探索し、**中間順**では子[ノード](#グラフ)左側を探索してから根[ノード](#グラフ)を調査して子[ノード](#グラフ)右側を探索し、**後行順**では子[ノード](#グラフ)を探索してから根[ノード](#グラフ)を調査する。\n\n下のような[木](#木)をそれぞれの方法で走査した場合、結果は次のようになる。\n\n![深さ優先探索](../assets/images/depth_first_search.png)\n\n- 先行順 : F, B, A, D, C, E, G, I, H\n- 中間順 : A, B, C, D, E, F, G, H, I\n- 後行順 : A, C, E, D, B, H, I, G, F\n\n"},{"term":"後行順","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"深さ優先探索","content":"\n**深さ優先探索**は、現在の[ノード](#グラフ)について調査した後にその子[ノード](#グラフ)に対して同じことを繰り返す[走査](#走査)方法。再帰呼出しによって容易に表現でき、先行順、中間順、後行順の3つの方法がある。**先行順**では根[ノード](#グラフ)を調査してから子[ノード](#グラフ)を探索し、**中間順**では子[ノード](#グラフ)左側を探索してから根[ノード](#グラフ)を調査して子[ノード](#グラフ)右側を探索し、**後行順**では子[ノード](#グラフ)を探索してから根[ノード](#グラフ)を調査する。\n\n下のような[木](#木)をそれぞれの方法で走査した場合、結果は次のようになる。\n\n![深さ優先探索](../assets/images/depth_first_search.png)\n\n- 先行順 : F, B, A, D, C, E, G, I, H\n- 中間順 : A, B, C, D, E, F, G, H, I\n- 後行順 : A, C, E, D, B, H, I, G, F\n\n"},{"term":"幅優先探索","link":"./note/ja/./basics/applied_mathematics/_/chapters/graph_theory.md","flagment":"幅優先探索","content":"\n**幅優先探索**は、深さが同じ[ノード](#グラフ)を浅い方から順に[走査](#走査)する方法。\n\n下のような[木](#木)を幅優先探索で走査した場合、結果は次のようになる。\n\n![幅優先探索](../assets/images/breadth_first_search.png)\n\n- 幅優先探索 : F, B, G, A, D, I, C, E, H\n\n\n"},{"term":"待ち行列","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"待ち行列","content":"\n**待ち行列**は、ユーザがサービスを受ける際の混雑状況を数理的に表現したもの。待つことなくサービスを受けられる[[確率](./probability_and_statistics.md#確率)や、サービスの平均待ち時間などを考えるために用いられる。\n\n"},{"term":"ケンドール記法","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"ケンドール記法","content":"\n**ケンドール記法**は、[待ち行列](#待ち行列)を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。\n\n- **到着分布** : [待ち行列](#待ち行列)に並びに来る人の到着間隔\n- **サービス時間分布** : サービスを行う時間\n- **窓口数** : サービスを行う窓口の数\n\n[M/M/1モデル](#mm1モデル)やM/M/mモデル、M/D/1モデルなどがある。\n\n"},{"term":"到着分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"ケンドール記法","content":"\n**ケンドール記法**は、[待ち行列](#待ち行列)を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。\n\n- **到着分布** : [待ち行列](#待ち行列)に並びに来る人の到着間隔\n- **サービス時間分布** : サービスを行う時間\n- **窓口数** : サービスを行う窓口の数\n\n[M/M/1モデル](#mm1モデル)やM/M/mモデル、M/D/1モデルなどがある。\n\n"},{"term":"サービス時間分布","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"ケンドール記法","content":"\n**ケンドール記法**は、[待ち行列](#待ち行列)を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。\n\n- **到着分布** : [待ち行列](#待ち行列)に並びに来る人の到着間隔\n- **サービス時間分布** : サービスを行う時間\n- **窓口数** : サービスを行う窓口の数\n\n[M/M/1モデル](#mm1モデル)やM/M/mモデル、M/D/1モデルなどがある。\n\n"},{"term":"窓口数","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"ケンドール記法","content":"\n**ケンドール記法**は、[待ち行列](#待ち行列)を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。\n\n- **到着分布** : [待ち行列](#待ち行列)に並びに来る人の到着間隔\n- **サービス時間分布** : サービスを行う時間\n- **窓口数** : サービスを行う窓口の数\n\n[M/M/1モデル](#mm1モデル)やM/M/mモデル、M/D/1モデルなどがある。\n\n"},{"term":"M/M/1モデル","link":"./note/ja/./basics/applied_mathematics/_/chapters/waiting_queue_theory.md","flagment":"mm1モデル","content":""},{"term":"最短経路問題","link":"./note/ja/./basics/applied_mathematics/_/chapters/optimization_problem.md","flagment":"最短経路問題","content":"\n**最短経路問題**は、[グラフ](./graph_theory.md#グラフ)において、2つの[ノード](./graph_theory.md#グラフ)を結ぶ最短となる経路を求めるための最適化問題。\n\n\n"},{"term":"動的計画法","link":"./note/ja/./basics/applied_mathematics/_/chapters/optimization_problem.md","flagment":"動的計画法","content":"\n**動的計画法**は、問題解決のための過程を何段回かに分け、各段階における最適解を求める方法。\n\n\n"},{"term":"情報量","link":"./note/ja/./basics/information_theory/_/chapters/information_theory.md","flagment":"情報量","content":"\n**情報量**は、ある[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)がどれほど起こりにくいかを表す尺度。起こりやすい[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)であるほど持っている情報は少ないと考えられ、一方で起こりにくい[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)は多くの情報を持っていると考えられる。\n\n"},{"term":"生起確率","link":"./note/ja/./basics/information_theory/_/chapters/information_theory.md","flagment":"生起確率","content":"\n**生起確率**は、ある[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)が発生する[確率](../../../applied_mathematics/_/chapters/probability_and_statistics.md#確率)。\n\n"},{"term":"自己エントロピー（選択情報量）","link":"./note/ja/./basics/information_theory/_/chapters/information_theory.md","flagment":"自己エントロピー","content":"\n**自己エントロピー**（**選択情報量**）は、ある[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)が起こるときの[情報量](#情報量)。[対数](../../../applied_mathematics/_/chapters/numerical_calculation.md#対数)の底を $2$ とする（[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)で情報を表現することを考えた場合）と、自己エントロピーとはその情報を何[ビット](../../../_/chapters/computer_and_number.md#ビット)で表現できるのかを表す。\n\nある[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象) $E$ の[生起確率](#生起確率)を $P(E)$ とすると、自己エントロピー $I(E)$ は以下の式で求められる。\n\n```math\nI(E) = \\log_2{\\frac{1}{P(E)}} = - \\log_2{P(E)}\n```\n\n"},{"term":"エントロピー（平均情報量）","link":"./note/ja/./basics/information_theory/_/chapters/information_theory.md","flagment":"エントロピー","content":"\n**エントロピー**（**平均情報量**）は、系全体で考えた場合の[情報量](#情報量)の平均。平均情報量は、その系の情報を[圧縮](./coding_theory.md#圧縮)するときの限界となる。\n\n\n"},{"term":"圧縮","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"圧縮","content":"\n**圧縮**は、データの意味を変えずにデータの容量を小さくする処理。圧縮を行うことで、記憶容量の節減や、伝送時間の短縮ができる。\n\n"},{"term":"圧縮率","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"圧縮率","content":"\n**圧縮率**は、[圧縮](#圧縮)によってデータの容量をどれだけ小さくできるかという指標。\n\n"},{"term":"可逆圧縮","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"可逆圧縮","content":"\n**可逆圧縮**は、[圧縮](#圧縮)したデータを[解凍](#解凍)したときに完全に元の状態に戻せるような[圧縮](#圧縮)。ただし、[圧縮](#圧縮)には限界があるため、[非可逆圧縮](#非可逆圧縮)に比べて[圧縮率](#圧縮率)は小さくなる。\n\n"},{"term":"非可逆圧縮","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"非可逆圧縮","content":"\n**非可逆圧縮**は、[圧縮](#圧縮)したデータを[解凍](#解凍)したときにデータが品質劣化を起こすような[圧縮](#圧縮)。[圧縮率](#圧縮率)は[可逆圧縮](#可逆圧縮)に比べて高いものの、完全に元のデータに戻すことはできない。\n\n\n"},{"term":"解凍（伸張、展開）","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"解凍","content":"\n**解凍**（**伸張**、**展開**）は、[圧縮](#圧縮)したデータを元の状態に復元する処理。\n\n"},{"term":"自己解凍形式","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"自己解凍形式","content":"\n**自己解凍形式**は、[圧縮](#圧縮)したデータの[解凍](#解凍)をそのデータの情報自身でできるような形式。\n\n\n"},{"term":"情報源符号","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"情報源符号","content":"\n**情報源符号**は、情報源で転送前にデータを効率的に[圧縮](#圧縮)することを目的とする符号化。\n\n"},{"term":"ハフマン符号化","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"ハフマン符号化","content":"\n**ハフマン符号化**は、ファイル[圧縮](#圧縮)の技術のひとつで、[可逆圧縮](#可逆圧縮)。出現回数の多い文字を短い[ビット](../../../_/chapters/computer_and_number.md#ビット)列に、出現回数の少ない文字を長い[ビット](../../../_/chapters/computer_and_number.md#ビット)列に置き換えることでファイルサイズを小さくする。\n\n"},{"term":"ランレングス符号化","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"ランレングス符号化","content":"\n**ランレングス符号化**は、主に画像ファイルに用いられる[圧縮](#圧縮)技術のひとつで、[可逆圧縮](#可逆圧縮)。連続する同一の値を、 $\\rm{値} \\times \\rm{回数}$ という情報に置き換える。単純な画像データほど[圧縮率](#圧縮率)が高い。\n\n\n"},{"term":"伝送路符号（通信路符号）","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"伝送路符号","content":"\n**伝送路符号**（**通信路符号**）とは、データ伝送時に通信路上のノイズに対応するために冗長[ビット](../../../discrete_mathematics/_/chapters/computer_and_number.md#ビット)を付加する符号化。\n\n- [通信理論 - 伝送理論 - 誤り検出と訂正](../../../communication_theory/_/chapters/transmission_theory.md#誤り検出と訂正)\n\n\n"},{"term":"アナログ","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"アナログ","content":"\n"},{"term":"デジタル","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"デジタル","content":"\n**デジタル**とは、データを一定の間隔で区切った値（離散値）で表したもの。デジタルデータは、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)による処理がしやすく、通信時のノイズによる情報の劣化にも強い。ただし値を近似値として記録しているため、正確な値をデータにすることはできない。\n\n自然界に存在するほとんどの情報は、人間が観測するスケールにおいてはアナログであるが、アナログデータは[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)では扱いにくいのでデジタルデータへの変換（[A/D変換](../../../measurement_and_control/_/chapters/signal_processing.md#ad変換)）がよく行われる。\n\n![アナログとデジタル](../assets/images/analog_and_digital.jpg)\n\n\n"},{"term":"エンディアン（バイトオーダ）","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"エンディアン","content":"\n**エンディアン**（**バイトオーダ**）は、複数の[バイト](../../../_/chapters/computer_and_number.md#バイト)などを並べる際の方式。エンディアンは[CPU](../../../../computer/hardware/_/chapters/processor.md#cpu)によって決まっており、異なる機器間でデータをやり取りする際はエンディアンに留意する必要がある。\n\n"},{"term":"ビッグエンディアン","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"ビッグエンディアン","content":"\n**ビッグエンディアン**は、複数の[バイト](../../../_/chapters/computer_and_number.md#バイト)で構成されるデータを上位[バイト](../../../_/chapters/computer_and_number.md#バイト)から下位[バイト](../../../_/chapters/computer_and_number.md#バイト)の順に取り扱う手法。\n\n"},{"term":"リトルエンディアン","link":"./note/ja/./basics/information_theory/_/chapters/coding_theory.md","flagment":"リトルエンディアン","content":"\n**リトルエンディアン**は、複数の[バイト](../../../_/chapters/computer_and_number.md#バイト)で構成されるデータを下位[バイト](../../../_/chapters/computer_and_number.md#バイト)から上位[バイト](../../../_/chapters/computer_and_number.md#バイト)の順に取り扱う手法。\n\n\n"},{"term":"文字コード","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"文字コード","content":"\n**文字コード**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内部で文字を[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)の[ビット](../../../_/chapters/computer_and_number.md#ビット)パターンに割り当てたもの。文字コードには複数の体系が存在しており、情報をやり取りするためにはコード体系が合致している必要がある。\n\n"},{"term":"マルチバイト文字","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"マルチバイト文字","content":"\n**マルチバイト文字**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上で1文字を複数[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現するような体系。アルファベットや数字、一部の記号は、[ASCIIコード](#asciiコード)により1[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現することができるが、全角カナや漢字などは1[バイト](../../../_/chapters/computer_and_number.md#バイト)では表現しきれないためマルチバイト文字を用いる。\n\n"},{"term":"ASCIIコード","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"asciiコード","content":"\n**ASCIIコード**は、1文字を7[ビット](../../../_/chapters/computer_and_number.md#ビット)の符号と誤り検出用の[パリティ](../../../communication_theory/_/chapters/transmission_theory.md#パリティ)[ビット](../../../_/chapters/computer_and_number.md#ビット)1[ビット](../../../_/chapters/computer_and_number.md#ビット)で表現した[文字コード](#文字コード)。基本的にはアルファベットと数字、記号に用いられており、日本語などは文字種が多いため7[ビット](../../../_/chapters/computer_and_number.md#ビット)では多くの文字は表現しきれない。\n\n"},{"term":"EUCコード","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"eucコード","content":"\n**EUCコード**は、[UNIX](../../../../computer/software/_/chapters/operating_system.md#unix)上で2[バイト](../../../_/chapters/computer_and_number.md#バイト)文字と1[バイト](../../../_/chapters/computer_and_number.md#バイト)文字を混在して用いる[文字コード](#文字コード)。\n\n"},{"term":"JISコード","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"jisコード","content":"\n**JISコード**は、漢字やひらがなを含む[文字コード](#文字コード)で、漢字やひらがなは2[バイト](../../../_/chapters/computer_and_number.md#バイト)、英数字や記号は1[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現される。\n\n"},{"term":"Unicode","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"unicode","content":"\n**Unicode**は、世界各国の文字体系全てに対応するための[文字コード](#文字コード)。すべての文字を2[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する。\n\n**UTF-8**、**UTF-16**、**UTF-32**の3つのエンコーディング方式により符号化される。\n\n\n"},{"term":"UTF-8","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"unicode","content":"\n**Unicode**は、世界各国の文字体系全てに対応するための[文字コード](#文字コード)。すべての文字を2[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する。\n\n**UTF-8**、**UTF-16**、**UTF-32**の3つのエンコーディング方式により符号化される。\n\n\n"},{"term":"UTF-16","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"unicode","content":"\n**Unicode**は、世界各国の文字体系全てに対応するための[文字コード](#文字コード)。すべての文字を2[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する。\n\n**UTF-8**、**UTF-16**、**UTF-32**の3つのエンコーディング方式により符号化される。\n\n\n"},{"term":"UTF-32","link":"./note/ja/./basics/information_theory/_/chapters/character_representation.md","flagment":"unicode","content":"\n**Unicode**は、世界各国の文字体系全てに対応するための[文字コード](#文字コード)。すべての文字を2[バイト](../../../_/chapters/computer_and_number.md#バイト)で表現する。\n\n**UTF-8**、**UTF-16**、**UTF-32**の3つのエンコーディング方式により符号化される。\n\n\n"},{"term":"述語理論","link":"./note/ja/./basics/information_theory/_/chapters/predicate_theory.md","flagment":"述語理論","content":"\n**述語理論**は、[命題](../../../discrete_mathematics/_/chapters/set_and_proposition.md#命題)を組み合わせて別の[事象](../../../applied_mathematics/_/chapters/probability_and_statistics.md#事象)の真偽を証明する方法。\n\n\n"},{"term":"演繹推論","link":"./note/ja/./basics/information_theory/_/chapters/predicate_theory.md","flagment":"演繹推論","content":"\n**演繹推論**は、既存の知識からある結論を導く手法。論理を数珠つなぎにしていって結論を引き出す。前提が正しければ結論も必ず正しいものとする。\n\n\n"},{"term":"帰納推論","link":"./note/ja/./basics/information_theory/_/chapters/predicate_theory.md","flagment":"帰納推論","content":"\n**帰納推論**は、観測事実の因果関係から一般論を導く手法。多くの事実から類似点をまとめて結論を出す。\n\n\n"},{"term":"形式言語","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"形式言語","content":"\n**形式言語**は、人間が使用する自然言語に対して、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)などで情報として扱うために曖昧さを排除した言語。\n\n"},{"term":"逆ポーランド記法（後置記法）","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"逆ポーランド記法","content":"\n**逆ポーランド記法**（**後置記法**）は、数式を表現するための記法で、演算子を被演算子の後ろに記述する[形式言語](#形式言語)。括弧を使わずに記述することができる。\n\n例えば、 $A - (B + (C \\times D))$ を逆ポーランド記法で表すと、 $ABCD \\times +-$ となる。\n\n逆ポーランド記法は、計算式の演算子と被演算子を[木](../../../applied_mathematics/_/chapters/graph_theory.md#木)の各[ノード](../../../applied_mathematics/_/chapters/graph_theory.md#グラフ)としたものを[後行順](../../../applied_mathematics/_/chapters/graph_theory.md#深さ優先探索)で[走査](../../../applied_mathematics/_/chapters/graph_theory.md#走査)したものとなる。\n\n\n"},{"term":"BNF（バッカス・ナウア記法）","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"bnf","content":"\n**BNF**（**バッカス・ナウア記法**）は、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の文法を厳密に表現するための[形式言語](#形式言語)。表現方法には、順次、選択、反復がある。\n\n- **順次**<br> `<x>::=<a><b>` : ここで、 `x` という構文は `a` と `b` という文字の並びであるという意味\n- **選択**<br> `<x>::=<a | b>` : ここで、 `x` という構文は `a` もしくは `b` のどちらかという意味<br> `<x>::=[<a>]` : ここで、 `x` という構文は `a` もしくは空という意味\n- **反復**<br> `<x>::=<a>...` : ここで、 `x` という構文は `a` という文字の繰り返しという意味\n\n例えば、数字と数字列はBNFでそれぞれ次のように表すことができる。\n\n```ebnf\n<数字>::=\"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n<数字列>::=<数字>|<数字列><数字>\n```\n\n\n"},{"term":"順次","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"bnf","content":"\n**BNF**（**バッカス・ナウア記法**）は、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の文法を厳密に表現するための[形式言語](#形式言語)。表現方法には、順次、選択、反復がある。\n\n- **順次**<br> `<x>::=<a><b>` : ここで、 `x` という構文は `a` と `b` という文字の並びであるという意味\n- **選択**<br> `<x>::=<a | b>` : ここで、 `x` という構文は `a` もしくは `b` のどちらかという意味<br> `<x>::=[<a>]` : ここで、 `x` という構文は `a` もしくは空という意味\n- **反復**<br> `<x>::=<a>...` : ここで、 `x` という構文は `a` という文字の繰り返しという意味\n\n例えば、数字と数字列はBNFでそれぞれ次のように表すことができる。\n\n```ebnf\n<数字>::=\"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n<数字列>::=<数字>|<数字列><数字>\n```\n\n\n"},{"term":"選択","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"bnf","content":"\n**BNF**（**バッカス・ナウア記法**）は、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の文法を厳密に表現するための[形式言語](#形式言語)。表現方法には、順次、選択、反復がある。\n\n- **順次**<br> `<x>::=<a><b>` : ここで、 `x` という構文は `a` と `b` という文字の並びであるという意味\n- **選択**<br> `<x>::=<a | b>` : ここで、 `x` という構文は `a` もしくは `b` のどちらかという意味<br> `<x>::=[<a>]` : ここで、 `x` という構文は `a` もしくは空という意味\n- **反復**<br> `<x>::=<a>...` : ここで、 `x` という構文は `a` という文字の繰り返しという意味\n\n例えば、数字と数字列はBNFでそれぞれ次のように表すことができる。\n\n```ebnf\n<数字>::=\"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n<数字列>::=<数字>|<数字列><数字>\n```\n\n\n"},{"term":"反復","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"bnf","content":"\n**BNF**（**バッカス・ナウア記法**）は、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の文法を厳密に表現するための[形式言語](#形式言語)。表現方法には、順次、選択、反復がある。\n\n- **順次**<br> `<x>::=<a><b>` : ここで、 `x` という構文は `a` と `b` という文字の並びであるという意味\n- **選択**<br> `<x>::=<a | b>` : ここで、 `x` という構文は `a` もしくは `b` のどちらかという意味<br> `<x>::=[<a>]` : ここで、 `x` という構文は `a` もしくは空という意味\n- **反復**<br> `<x>::=<a>...` : ここで、 `x` という構文は `a` という文字の繰り返しという意味\n\n例えば、数字と数字列はBNFでそれぞれ次のように表すことができる。\n\n```ebnf\n<数字>::=\"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n<数字列>::=<数字>|<数字列><数字>\n```\n\n\n"},{"term":"正規表現","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"正規表現","content":"\n**正規表現**は、文字列のパターンを示すための表現方法。パターンを表現するために特別な**メタ文字**が使用される。\n\n| メタ文字 | 意味                                         |\n| -------- | :------------------------------------------- |\n| `.`      | 任意の1文字                                  |\n| `()`     | ()内の文字列を1つのパターンとして扱う        |\n| `+`      | 直前の文字やパターンの1回以上の繰り返し      |\n| `*`      | 直前の文字やパターンの0回以上の繰り返し      |\n| `?`      | 直前の文字やパターンの0回または1回の繰り返し |\n| `\\`      | 次に続くメタ文字を通常の文字として扱う       |\n| `\\|`     | 文字やパターンの選択                         |\n| `[]`     | []内の文字のどれか1文字                      |\n| `^`      | 行頭のマッチ                                 |\n| `$`      | 行末のマッチ                                 |\n\n\n"},{"term":"メタ文字","link":"./note/ja/./basics/information_theory/_/chapters/formal_language.md","flagment":"正規表現","content":"\n**正規表現**は、文字列のパターンを示すための表現方法。パターンを表現するために特別な**メタ文字**が使用される。\n\n| メタ文字 | 意味                                         |\n| -------- | :------------------------------------------- |\n| `.`      | 任意の1文字                                  |\n| `()`     | ()内の文字列を1つのパターンとして扱う        |\n| `+`      | 直前の文字やパターンの1回以上の繰り返し      |\n| `*`      | 直前の文字やパターンの0回以上の繰り返し      |\n| `?`      | 直前の文字やパターンの0回または1回の繰り返し |\n| `\\`      | 次に続くメタ文字を通常の文字として扱う       |\n| `\\|`     | 文字やパターンの選択                         |\n| `[]`     | []内の文字のどれか1文字                      |\n| `^`      | 行頭のマッチ                                 |\n| `$`      | 行末のマッチ                                 |\n\n\n"},{"term":"オートマオン","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"オートマトン","content":"\n**オートマトン**は、入力とその時の状態によって出力が決定される機会をモデル化したもの。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、**初期状態**からいくつかの状態を遷移して**受理状態**で終了するものを**有限オートマトン**という。\n\n"},{"term":"初期状態","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"オートマトン","content":"\n**オートマトン**は、入力とその時の状態によって出力が決定される機会をモデル化したもの。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、**初期状態**からいくつかの状態を遷移して**受理状態**で終了するものを**有限オートマトン**という。\n\n"},{"term":"受理状態","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"オートマトン","content":"\n**オートマトン**は、入力とその時の状態によって出力が決定される機会をモデル化したもの。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、**初期状態**からいくつかの状態を遷移して**受理状態**で終了するものを**有限オートマトン**という。\n\n"},{"term":"有限オートマトン","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"オートマトン","content":"\n**オートマトン**は、入力とその時の状態によって出力が決定される機会をモデル化したもの。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、**初期状態**からいくつかの状態を遷移して**受理状態**で終了するものを**有限オートマトン**という。\n\n"},{"term":"状態遷移表","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"状態遷移表","content":"\n**状態遷移表**は、[オートマトン](#オートマトン)の状態遷移を表で表したもの。\n\n以下は、A～Eまでの状態をとり得る[オートマトン](#オートマトン)の状態遷移表の例である。\n\n| 遷移元 \\ 遷移先 |  A     |  B  |  C  |  D  |  E  |\n| --------------- | ------ | --- | --- | --- | --- |\n| A               | $0$    | $1$ |     |     |     |\n| B               | $0$    |     |     | $1$ |     |\n| C               | $0$    |     |     |     | $1$ |\n| D               | $0$    |     | $1$ |     |     |\n| E               | $0, 1$ |     |     |     |     |\n\n"},{"term":"状態遷移図","link":"./note/ja/./basics/information_theory/_/chapters/automaton.md","flagment":"状態遷移図","content":"\n**状態遷移図**は、[オートマトン](#オートマトン)の状態遷移を図で表したもの。矢印と丸のセットで表したものが初期状態で、二重丸で表したものが受理状態。\n\n以下は、A～Eまでの状態をとり得る[オートマトン](#オートマトン)の状態遷移図の例である。\n\n![オートマトンの状態遷移図](../assets/images/automaton.png)\n\n\n"},{"term":"計算量（オーダ）","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"計算量","content":"\n**計算量**（**オーダ**）は、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の性能を評価するための指標。計算量は、扱うデータの件数が増えるにつれてどのような割合で計算回数が増加するかを評価する。\n\n単に計算量というと、[時間計算量](#時間計算量)のことを指す場合が多い。\n\n"},{"term":"時間計算量","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"時間計算量","content":"\n**時間計算量**は、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の計算回数を基に[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の性能を評価するための指標。\n\n"},{"term":"空間計算量","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"空間計算量","content":"\n**空間計算量**（**領域計算量**）は、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)使用量を基に[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の性能を評価するための指標。\n\n"},{"term":"最悪計算量","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"最悪計算量","content":"\n**最悪計算量**は、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)が扱うデータ数が同じであってもケースによって計算回数が変動する場合や、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)が乱数を使う場合において、最も悪いケースの[計算量](#計算量)。一般的には計算時間を最悪計算量によって見積もることが多い。\n\n"},{"term":"平均計算量","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"平均計算量","content":"\n**平均計算量**は、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)が扱うデータ数が同じであってもケースによって計算回数が変動する場合や、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)が乱数を使う場合において、平均となる[計算量](#計算量)。大半の[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)では、[最悪計算量](#最悪計算量)と一致する。\n\n"},{"term":"オーダ記法","link":"./note/ja/./basics/information_theory/_/chapters/computational_complexity.md","flagment":"オーダ記法","content":"\n**オーダ記法**は、[計算量](#計算量)を表記するための記法で、 $O(n \\rm{に関する式})$ で表現する。ここで、 $n$ は扱うデータ数。\n\n"},{"term":"機械語","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"機械語","content":"\n**機械語**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が直接処理することができる、[バイナリ](../../../_/chapters/computer_and_number.md#バイナリ)で記述された命令の集まり。機械語の命令パターン1つのことを**オペコード**という。\n\n[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)は人間にとっては直接記述するのに向いていないので、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング)の[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を作成し、それを[言語プロセッサ](#言語プロセッサ)によって機械語に変換するのが一般的。\n\n\n"},{"term":"オペコード","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"機械語","content":"\n**機械語**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が直接処理することができる、[バイナリ](../../../_/chapters/computer_and_number.md#バイナリ)で記述された命令の集まり。機械語の命令パターン1つのことを**オペコード**という。\n\n[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)は人間にとっては直接記述するのに向いていないので、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング)の[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を作成し、それを[言語プロセッサ](#言語プロセッサ)によって機械語に変換するのが一般的。\n\n\n"},{"term":"アセンブリ言語","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"アセンブリ言語","content":"\n**アセンブリ言語**は、[機械語](#機械語)の[オペコード](#機械語)に1対1で対応する、英単語や記号によって命令を記述した言語。[オペコード](#機械語)に対応したアセンブリ言語の各命令のことを**ニーモニック**という。\n\n\n"},{"term":"ニーモニック","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"アセンブリ言語","content":"\n**アセンブリ言語**は、[機械語](#機械語)の[オペコード](#機械語)に1対1で対応する、英単語や記号によって命令を記述した言語。[オペコード](#機械語)に対応したアセンブリ言語の各命令のことを**ニーモニック**という。\n\n\n"},{"term":"言語プロセッサ","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"言語プロセッサ","content":"\n**言語プロセッサ**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。言語プロセッサには、[アセンブラ](#アセンブラ)や[コンパイラ](#コンパイラ)、[インタプリタ](#インタプリタ)などがある。\n\n\n"},{"term":"アセンブラ","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"アセンブラ","content":"\n**アセンブラ**は、[アセンブリ言語](#アセンブリ言語)を[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。[アセンブリ言語](#アセンブリ言語)を[機械語](#機械語)に変換することを**アセンブル**という。\n\n\n"},{"term":"アセンブル","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"アセンブラ","content":"\n**アセンブラ**は、[アセンブリ言語](#アセンブリ言語)を[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。[アセンブリ言語](#アセンブリ言語)を[機械語](#機械語)に変換することを**アセンブル**という。\n\n\n"},{"term":"コンパイラ","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"コンパイラ","content":"\n**コンパイラ**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を解析して[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。コンパイラによって[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)単位で生成された[機械語](#機械語)[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)のことを**オブジェクトコード**という。\n\n[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング)で書かれた[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を[機械語](#機械語)に変換することを**コンパイル**という。\n\n"},{"term":"コンパイル","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"コンパイラ","content":"\n**コンパイラ**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を解析して[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。コンパイラによって[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)単位で生成された[機械語](#機械語)[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)のことを**オブジェクトコード**という。\n\n[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング)で書かれた[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を[機械語](#機械語)に変換することを**コンパイル**という。\n\n"},{"term":"オブジェクトコード","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"コンパイラ","content":"\n**コンパイラ**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を解析して[機械語](#機械語)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)。コンパイラによって[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)単位で生成された[機械語](#機械語)[プログラム](../../../../programming/_/chapters/programming.md#プログラミング)のことを**オブジェクトコード**という。\n\n[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング)で書かれた[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を[機械語](#機械語)に変換することを**コンパイル**という。\n\n"},{"term":"字句解析","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"字句解析","content":"\n**字句解析**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を最小の単位の語句である**トークン**に分解する処理。\n\n"},{"term":"トークン","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"字句解析","content":"\n**字句解析**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を最小の単位の語句である**トークン**に分解する処理。\n\n"},{"term":"構文解析","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"構文解析","content":"\n**構文解析**は、[トークン](#字句解析)の並びを定められた文法によって解析する処理。\n\n"},{"term":"意味解析","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"意味解析","content":"\n**意味解析**は、[トークン](#字句解析)の並びを意味を考慮して解析する処理。\n\n"},{"term":"最適化","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"最適化","content":"\n**最適化**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の高速化やサイズの縮小のための処理。\n\n\n"},{"term":"リンカ","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"リンカ","content":"\n**リンカ**は、[コンパイラ](#コンパイラ)が生成した[オブジェクトコード](#コンパイラ)をつなぎ合わせて[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が実行できるようにするための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\nリンカによって[オブジェクトコード](#コンパイラ)をつなぎ合わせる処理を**リンク**という。\n\n\n"},{"term":"リンク","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"リンカ","content":"\n**リンカ**は、[コンパイラ](#コンパイラ)が生成した[オブジェクトコード](#コンパイラ)をつなぎ合わせて[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が実行できるようにするための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\nリンカによって[オブジェクトコード](#コンパイラ)をつなぎ合わせる処理を**リンク**という。\n\n\n"},{"term":"インタプリタ","link":"./note/ja/./basics/information_theory/_/chapters/compiler_theory.md","flagment":"インタプリタ","content":"\n**インタプリタ**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を部分的に解釈しながら並行して実行するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n\n"},{"term":"伝送路","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"伝送路","content":"\n**伝送路**は、電気信号により情報を伝送するための媒体を指す用語。\n\n"},{"term":"単方向","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"単方向","content":"\n**単方向**の[伝送路](#伝送路)は、決まった方向にしか通信できない。\n\n"},{"term":"半二重","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"半二重","content":"\n**半二重**の[伝送路](#伝送路)は、双方向の通信が可能であるが、送信と受信が同時に行えない。\n\n"},{"term":"全二重","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"全二重","content":"\n**全二重**の[伝送路](#伝送路)は、双方向の通信が可能であり、送信と受信を同時に行うことができる。\n\n\n"},{"term":"送信誤り","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"送信誤り","content":"\n**送信誤り**は、機器同士が通信を行う際に、回線状況などにより伝送データ起こる誤り。\n\n"},{"term":"誤り検出","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"誤り検出","content":"\n**誤り検出**は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を通じたデータ伝送などにおいて、[送信誤り](#送信誤り)を検出する方法。\n\n"},{"term":"誤り訂正","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"誤り訂正","content":"\n**誤り訂正**は、[送信誤り](#送信誤り)を検出し、その誤りを受信側で訂正する方法。\n\n"},{"term":"バースト誤り","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"バースト誤り","content":"\n**バースト誤り**は、通信回線の混線やケーブルの不具合などにより、一度にまとめて起こる誤り。\n\n"},{"term":"パリティ","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"パリティビット","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"偶数パリティ","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"奇数パリティ","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"垂直パリティ","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"水平パリティ","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"パリティ","content":"\n**パリティ**は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に**パリティビット**を付加する。[ビット](../../../_/chapters/computer_and_number.md#ビット)列の $1$ の数が偶数になるように付加されたものを**偶数パリティ**、奇数になるように付加されたものを**奇数パリティ**という。\n\nパリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（**垂直パリティ**）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（**水平パリティ**）を伝送する。垂直パリティと水平パリティの組み合わせにより、どの[ビット](../../../_/chapters/computer_and_number.md#ビット)で誤りがあるかを判断することができ、その[ビット](../../../_/chapters/computer_and_number.md#ビット)を反転することで誤りを訂正する。\n\n"},{"term":"ハミング符号","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"符号語","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"検査行列","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"生成行列","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"受信語","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"誤りベクトル","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"ハミング符号","content":"\n**ハミング符号**は、データにいくつかの冗長[ビット](../../../_/chapters/computer_and_number.md#ビット)を付加することで、1[ビット](../../../_/chapters/computer_and_number.md#ビット)の誤りを検出し、それを訂正する方法。\n\nハミング符号では、ある整数 $m$ に対して、符号化するデータの[ビット](../../../_/chapters/computer_and_number.md#ビット)数 $k$ と、**符号語**の長さ $n$ は次のようになる。\n\n```math\n\\begin{eqnarray}\nk & = & n - m \\\nn & = & 2^m - 1\n\\end{eqnarray}\n```\n\nハミング符号では最初に、 $m$ [行](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列) $n$ [列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の**検査行列** $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。\n\n```math\nH =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]\n```\n\n検査行列は、全ての[列要素](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)がゼロではなく、それぞれが相違となるような[ビット](../../../_/chapters/computer_and_number.md#ビット)列を並べたものとなる。[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)の並べ方は任意で、上記の例に限らない。\n\n次に、 $HG^{T} = GH^{T} = 0$ を満たすような**生成行列** $G$ を求める。前述の検査行列に対する生成行列は次のようになる。\n\n```math\nG =\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n```\n\nそして、送信したい情報と生成行列の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを `1011` とすると、符号語は次のようになる。\n\n```math\n\\left[\n\\begin{array}{cccc}\n1 & 0 & 1 & 1\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n\n=\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n```\n\n受信側では、**受信語** $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\\nYH^T & = & xGH^T \\\nYH^T & = & 0\n\\end{eqnarray}\n```\n\n送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は**誤りベクトル**とする。\n\n```math\n\\begin{eqnarray}\nY    & = & xG \\oplus e_i \\\nYH^T & = & (xG \\oplus e_i)H^T \\\nYH^T & = & xGH^T \\oplus e_i H^T \\\nYH^T & = & e_i H^T\n\\end{eqnarray}\n```\n\nこれらの関係より、受信語 $Y$ と検査行列の[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)の[積](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列の積)が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)が誤っているということがわかる。例えば、受信語が `1111100` であった場合は次のような誤りベクトルが得られる。\n\n```math\n\\left[\n\\begin{array}{ccccccc}\n1 & 1 & 1 & 1 & 1 & 0 & 0\n\\end{array}\n\\right]\n\n\\cdot\n\n\\left[\n\\begin{array}{ccccccc}\n1 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\right]^T\n\n=\n\n\\left[\n\\begin{array}{ccc}\n0 & 1 & 1\n\\end{array}\n\\right]\n```\n\nこの場合、誤りベクトルの[転置行列](../../../applied_mathematics/_/chapters/numerical_calculation.md#転置行列)は検査行列の2[列](../../../applied_mathematics/_/chapters/numerical_calculation.md#行列)目と一致するので、受信語の2[ビット](../../../_/chapters/computer_and_number.md#ビット)目が誤っている、すなわち正しい受信語は `1011100` であることがわかる。\n\n"},{"term":"CRC","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"crc","content":"\n**CRC**(Cyclic Redundancy Check)は、連続する誤り（[バースト誤り](#バースト誤り)）を検出するための誤り制御の仕組み。誤り訂正の機能はない。\n\n送信側では、**生成多項式**を基にした定数[ビット](../../../_/chapters/computer_and_number.md#ビット)列でデータを除算した剰余をデータの末尾に付与する。受信側では、同様の生成多項式を用いて剰余を求め、データの末尾に付与された値と一致するかを確認する。剰余が一致すれば誤りがないということがわかる。\n\n[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)における除算は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列をずらしながら[XOR演算](../../../discrete_mathematics/_/chapters/logical_operation.md#xor演算)を繰り返し行っていく。このような様子からCRCという名前となっている。\n\n\n"},{"term":"生成多項式","link":"./note/ja/./basics/communication_theory/_/chapters/transmission_theory.md","flagment":"crc","content":"\n**CRC**(Cyclic Redundancy Check)は、連続する誤り（[バースト誤り](#バースト誤り)）を検出するための誤り制御の仕組み。誤り訂正の機能はない。\n\n送信側では、**生成多項式**を基にした定数[ビット](../../../_/chapters/computer_and_number.md#ビット)列でデータを除算した剰余をデータの末尾に付与する。受信側では、同様の生成多項式を用いて剰余を求め、データの末尾に付与された値と一致するかを確認する。剰余が一致すれば誤りがないということがわかる。\n\n[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)における除算は、[ビット](../../../_/chapters/computer_and_number.md#ビット)列をずらしながら[XOR演算](../../../discrete_mathematics/_/chapters/logical_operation.md#xor演算)を繰り返し行っていく。このような様子からCRCという名前となっている。\n\n\n"},{"term":"A/D変換","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"ad変換","content":""},{"term":"標本化","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"標本化","content":"\n**標本化**は、連続する[アナログ](../../../information_theory/_/chapters/coding_theory.md#アナログ)情報を一定の間隔でサンプリングする処理。\n\n"},{"term":"量子化","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"量子化","content":"\n**量子化**は、[標本化](#標本化)したデータを[デジタル](../../../information_theory/_/chapters/coding_theory.md#デジタル)値に変換する処理。\n\n"},{"term":"符号化","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"符号化","content":"\n**符号化**は、[量子化](#量子化)したデータを[2進数](../../../discrete_mathematics/_/chapters/radix.md#2進数)に変換する処理。\n\n\n"},{"term":"D/A変換","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"da変換","content":""},{"term":"サンプリング定理（標本化定理）","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"サンプリング定理","content":"\n**サンプリング定理**（**標本化定理**）は、ある周波数の[アナログ](../../../information_theory/_/chapters/coding_theory.md#アナログ)信号を[デジタル](../../../information_theory/_/chapters/coding_theory.md#デジタル)データに変換するときに、それを[アナログ](../../../information_theory/_/chapters/coding_theory.md#アナログ)信号に復元するためには、その周波数の2倍のサンプリング周波数が必要であるという定理。\n\n\n"},{"term":"PCM","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"pcm","content":"\n**PCM**(Pulse Code Modulation)は、音を[標本化](#標本化)し、[量子化](#量子化)、[符号化](#符号化)したデータを格納するために用いられている方式。\n\n単純なPCMでは、[標本化](#標本化)ごとのデータの変化が小さいことが多いので、データの差分を用いて動的にデータを作成することで[圧縮](../../../information_theory/_/chapters/coding_theory.md#圧縮)を行う**ADPCM**(Adaptive Differential PCM)という方式もある。\n\n\n"},{"term":"ADPCM","link":"./note/ja/./basics/measurement_and_control/_/chapters/signal_processing.md","flagment":"pcm","content":"\n**PCM**(Pulse Code Modulation)は、音を[標本化](#標本化)し、[量子化](#量子化)、[符号化](#符号化)したデータを格納するために用いられている方式。\n\n単純なPCMでは、[標本化](#標本化)ごとのデータの変化が小さいことが多いので、データの差分を用いて動的にデータを作成することで[圧縮](../../../information_theory/_/chapters/coding_theory.md#圧縮)を行う**ADPCM**(Adaptive Differential PCM)という方式もある。\n\n\n"},{"term":"制御システム","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"制御システム","content":"\n**制御システム**は、ロボットや機械などの他の機械を制御するためのシステム。\n\n"},{"term":"センサ","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"サーミスタ","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"フォトダイオード","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"ジャイロセンサ","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"距離画像センサ","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"TOF方式","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"センサ","content":"\n**センサ**は、[制御システム](#制御システム)を構成する要素のひとつで、動きや温度などを観測するための機械。\n\n- **サーミスタ** : 温度を測定するためのセンサ\n- **フォトダイオード** : 光を測定するためのセンサ\n- **ジャイロセンサ** : 物体の角度や角速度を測定するためのセンサ\n- **距離画像センサ** : 目的物までの距離を計測するためのセンサで、**TOF方式**(Time of Flight)（照射した光線が物体にあたって反射し、センサまで戻ってくるまでの時間を基に計算する方式）を用いる場合が多い\n\n"},{"term":"アクチュエータ","link":"./note/ja/./basics/measurement_and_control/_/chapters/control_theory.md","flagment":"アクチュエータ","content":"\n**アクチュエータ**は、[制御システム](#制御システム)を構成する要素のひとつで、機械や機構を物理的に動かすための装置。\n\n\n"},{"term":"プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミング","content":"\n**プログラミング**は、[プログラム](#プログラム)を記述して[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)へ命令を行い、目的とするタスクを解決すること。\n\n[プログラマ](#プログラマ)には、世の中の様々なタスクや問題をプログラミングによって解決するという役割がある。毎日の単純作業のくり返しを減らしたり（表計算[ソフト](../../../computer/software/_/chapters/software.md#ソフトウェア)など）、ミスが許されない場面で正確に動作することが保証されたシステムを利用したり（銀行のシステムや信号機など）、さらに人間には難しいタスクの解決を行ったり（[AI](../../../artificial_intelligence/_/chapters/artificial_intelligence.md#人工知能)による異常検知など）と、プログラミングスキルの応用範囲は多岐にわたる。\n\n"},{"term":"プログラム","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラム","content":"\n**プログラム**は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が処理を行う手順や内容を示したもの。\n\n"},{"term":"プログラマ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラマ","content":"\n**プログラマ**は、[プログラム](#プログラム)を記述する職業。\n\n"},{"term":"プログラミング言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミング言語","content":"\n**プログラミング言語**は、[プログラム](#プログラム)を記述する際に用いられる言語。プログラミング言語に対して、人間が日常生活で用いる言語のことを**自然言語**という。\n\n"},{"term":"自然言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミング言語","content":"\n**プログラミング言語**は、[プログラム](#プログラム)を記述する際に用いられる言語。プログラミング言語に対して、人間が日常生活で用いる言語のことを**自然言語**という。\n\n"},{"term":"ソースコード（ソース、コード）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"ソースコード","content":"\n**ソースコード**（**ソース**、**コード**）は、[プログラミング言語](#プログラミング言語)で書かれた[プログラム](#プログラム)。\n\n\n"},{"term":"機械語（マシン語、オブジェクトコード、ネイティブコード）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"機械語","content":"\n**機械語**（**マシン語**、**オブジェクトコード**、**ネイティブコード**）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が直接解釈できる[プログラム](#プログラム)で、[2進数](../../../basics/discrete_mathematics/_/chapters/radix.md#2進数)の羅列からなる。機械語は次の例のような[プログラム](#プログラム)となっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいように[プログラミング言語](#プログラミング言語)を用いて[ソースコード](#ソースコード)を作成し、専用の[プログラム](#プログラム)によって[ソースコード](#ソースコード)を機械語に変換するのが一般的。[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)ごとに対応する機械語も異なるので注意が必要。\n\n```\n0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000\n0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n...(以下略)\n```\n\n"},{"term":"オペコード","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"オペコード","content":"\n**オペコード**は、[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)に与える[機械語](#機械語)の命令の識別番号。\n\n\n"},{"term":"低水準言語（低級言語）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"低水準言語","content":"\n**低水準言語**（**低級言語**）は、[プログラミング言語](#プログラミング言語)の中でも[機械語](#機械語)に近い言語。低水準言語は[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)資源を効率よく使うことができ、高速に動作するという利点があるが、[プログラム](#プログラム)が長くなりやすく柔軟性に乏しいことから、組込みや[ファームウェア](../../../computer/_/chapters/computer.md#ファームウェア)といった分野など、限られた[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)資源で性能を最大限引き出すという目的がない限りは[高水準言語](#高水準言語)が用いられることがほとんどとなる。\n\n"},{"term":"アセンブリ言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"アセンブリ言語","content":"\n**アセンブリ言語**は、ニーモニックという命令を組み合わせて記述する[プログラミング言語](#プログラミング言語)。**ニーモニック**は、[機械語](#機械語)の命令に1対1で対応する、英単語や記号で表記した命令。[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)ごとに対応するアセンブリ言語も異なるので注意が必要。\n\nアセンブリ言語の一種である**Netwide Assembler**を用いて `Hello, world` を出力する[プログラム](#プログラム)を以下に示す。\n\n```asm\nsection .data\n    msg db      \"Hello, world\"      ; データセクションで文字列を宣言\n\nsection .text\n    global _start                   ; プログラムのエントリポイントとして_startを呼び出し\n\n_start:\n    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット\n    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット\n    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット\n    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット\n    syscall                         ; システムコールを発行\n    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット\n    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット\n    syscall                         ; システムコールを発行\n```\n\n"},{"term":"ニーモニック","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"アセンブリ言語","content":"\n**アセンブリ言語**は、ニーモニックという命令を組み合わせて記述する[プログラミング言語](#プログラミング言語)。**ニーモニック**は、[機械語](#機械語)の命令に1対1で対応する、英単語や記号で表記した命令。[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)ごとに対応するアセンブリ言語も異なるので注意が必要。\n\nアセンブリ言語の一種である**Netwide Assembler**を用いて `Hello, world` を出力する[プログラム](#プログラム)を以下に示す。\n\n```asm\nsection .data\n    msg db      \"Hello, world\"      ; データセクションで文字列を宣言\n\nsection .text\n    global _start                   ; プログラムのエントリポイントとして_startを呼び出し\n\n_start:\n    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット\n    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット\n    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット\n    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット\n    syscall                         ; システムコールを発行\n    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット\n    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット\n    syscall                         ; システムコールを発行\n```\n\n"},{"term":"アセンブル","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"アセンブル","content":"\n**アセンブル**は、[アセンブリ言語](#アセンブリ言語)で書かれた[プログラム](#プログラム)を[機械語](#機械語)に変換する操作。\n\n"},{"term":"アセンブラ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"アセンブラ","content":"\n**アセンブラ**は、[アセンブル](#アセンブル)を行うための[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。\n\n\n"},{"term":"高水準言語（高級言語）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"高水準言語","content":"\n**高水準言語**（**高級言語**）は、[低水準言語](#低水準言語)に比べて抽象度が高く、人間にとってわかりやすい[プログラミング言語](#プログラミング言語)。[機械語](#機械語)を意識することなく記述することができ、[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)に依存しない[プログラム](#プログラム)を作ることができる（[機械語](#機械語)への変換の段階で様々な[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)に対応させることができるため）。\n\n代表的な高水準言語としては、C系言語（[C](./programming_language.md#c言語), [C#](./programming_language.md#c-1), [C++](./programming_language.md#c)等）や[Java](./programming_language.md#java)、[Python](./programming_language.md#python)、[PHP](./programming_language.md#php)、[JavaScript](./programming_language.md#javascript)などがある。それぞれの言語には得手不得手があり、[C言語](./programming_language.md#c言語)であれば処理速度が高速であることから[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)や[サーバ](../../../computer/_/chapters/computer.md#サーバ)などの低レイヤの実装に向いており、[JavaScript](./programming_language.md#javascript)であれば一般的な[Webブラウザ](../../../network/_/chapters/web.md#webブラウザ)で動作することから[Web](../../../network/_/chapters/web.md#web)フロントエンド向けとなっている。\n\n高水準言語は種類が多く、[ソースコード](#ソースコード)の[コンパイル・](#コンパイル)実行方式や、[データ型](./data_type.md#型)の決定方式などによって分類することができる。\n\n"},{"term":"コンパイル","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"コンパイル","content":"\n**コンパイル**は、[高水準言語](#高水準言語)で書かれた[ソースコード](#ソースコード)を[機械語](#機械語)に変換する操作。\n\n"},{"term":"コンパイラ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"コンパイラ","content":"\n**コンパイラ**は、[コンパイル](#コンパイル)を行うための[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。\n\n"},{"term":"コンパイラ言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"コンパイラ言語","content":"\n**コンパイラ言語**は、[プログラム](#プログラム)を実行する前に、あらかじめ[ソースコード](#ソースコード)全体の[コンパイル](#コンパイル)を行う方式の言語。[プログラム](#プログラム)を利用する際には、[機械語](#機械語)に変換された[実行ファイル](../../../computer/software/_/chapters/file_system.md#実行ファイル)を実行する。\n\n事前に[コンパイル](#コンパイル)を済ませているため、実行前に不具合を発見できたり、実行時の[コンパイル](#コンパイル)コストがないため実行速度が速いといった利点がある。一方で、実行時に起こりうる様々なパターンに対応できるように[プログラミング](#プログラミング)する必要があり、[インタプリタ言語](#インタプリタ言語)と比較しても難易度が高い言語が多い。また、[コンパイル](#コンパイル)済みの[実行ファイル](../../../computer/software/_/chapters/file_system.md#実行ファイル)は[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)に依存するため、[マルチプラットフォーム](../../../computer/software/_/chapters/software.md#マルチプラットフォーム)に対応できないという欠点もある（それぞれの[プラットフォーム](../../../computer/software/_/chapters/software.md#プラットフォーム)用に[コンパイル](#コンパイル)する必要がある）。\n\n代表的なコンパイラ言語には、[C言語](./programming_language.md#c言語)や[Swift](./programming_language.md#swift)、[Go](./programming_language.md#go)、[Rust](./programming_language.md#rust)といったものがある。\n\n"},{"term":"インタプリタ言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"インタプリタ言語","content":"\n**インタプリタ言語**は、[プログラム](#プログラム)の実行時に[ソースコード](#ソースコード)を1行ずつ[コンパイル](#コンパイル)しながら処理を進める方式の言語。実行時に毎回[コンパイル](#コンパイル)を行うコストが発生するため、実行速度は[コンパイラ言語](#コンパイラ言語)に劣る。しかし、[コンパイル](#コンパイル)を行わずに実行結果をすぐに確認できるため、[デバッグ](#デバッグ)が容易で、開発にかかるコストは小さくなる。\n\n代表的なインタプリタ言語には、[Python](./programming_language.md#python)や[PHP](./programming_language.md#php)、[JavaScript](./programming_language.md#javascript)、Rubyなどがある。\n\n"},{"term":"JITコンパイラ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"jitコンパイラ","content":"\n**JITコンパイラ**(Just-In Time Compiler)は、[ソースコード](#ソースコード)を環境に依存しない**中間コード**（**バイトコード**）に変換しておき、実行時にバイトコードを[コンパイル](#コンパイル)して実行する方式をとる。実行時に[コンパイル](#コンパイル)する点では[インタプリタ言語](#インタプリタ言語)と似ているが、[字句解析](../../../basics/information_theory/_/chapters/compiler_theory.md#字句解析)などのコストを省けるため、[インタプリタ言語](#インタプリタ言語)より高速に動作する。また、[コンパイラ言語](#コンパイラ言語)では直接[機械語](#機械語)のコードを生成するため、[プログラム](#プログラム)が実行環境（[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)など）に依存してしまうが、この方式では[プログラム](#プログラム)の実行機である[ランタイム](../../../computer/software/_/chapters/software.md#ランタイム)（[フレームワーク](../../../computer/software/_/chapters/package.md#フレームワーク)）が利用できる環境であればひとつの中間コードで実行できるというメリットもある。\n\nJITコンパイラを用いる代表的な言語には、[Java](./programming_language.md#java)や[C#](./programming_language.md#c-1)などがある。\n\n"},{"term":"中間コード（バイトコード）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"jitコンパイラ","content":"\n**JITコンパイラ**(Just-In Time Compiler)は、[ソースコード](#ソースコード)を環境に依存しない**中間コード**（**バイトコード**）に変換しておき、実行時にバイトコードを[コンパイル](#コンパイル)して実行する方式をとる。実行時に[コンパイル](#コンパイル)する点では[インタプリタ言語](#インタプリタ言語)と似ているが、[字句解析](../../../basics/information_theory/_/chapters/compiler_theory.md#字句解析)などのコストを省けるため、[インタプリタ言語](#インタプリタ言語)より高速に動作する。また、[コンパイラ言語](#コンパイラ言語)では直接[機械語](#機械語)のコードを生成するため、[プログラム](#プログラム)が実行環境（[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)など）に依存してしまうが、この方式では[プログラム](#プログラム)の実行機である[ランタイム](../../../computer/software/_/chapters/software.md#ランタイム)（[フレームワーク](../../../computer/software/_/chapters/package.md#フレームワーク)）が利用できる環境であればひとつの中間コードで実行できるというメリットもある。\n\nJITコンパイラを用いる代表的な言語には、[Java](./programming_language.md#java)や[C#](./programming_language.md#c-1)などがある。\n\n"},{"term":"スクリプト言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"スクリプト言語","content":"\n**スクリプト言語**は、[プログラミング言語](#プログラミング言語)のうち比較的容易に記述・実行ができる言語。定義は曖昧であるが、[プログラミング](#プログラミング)の初学者にとっても学びやすく、開発スピードが早いため小規模な開発に向いている。[インタプリタ言語](#インタプリタ言語)はスクリプト言語に分類されることが多く、[Python](./programming_language.md#python)や[PHP](./programming_language.md#php)、[JavaScript](./programming_language.md#javascript)、Rubyなどがスクリプト言語に含まれる。\n\n"},{"term":"静的型付け言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"静的型付け言語","content":"\n**静的型付け言語**は、実行前にデータの[型](./data_type.md#型)を決定する方式の言語。[コンパイラ言語](#コンパイラ言語)の多くは静的型付け言語となっており、[プログラム](#プログラム)中で使用するデータに対して、そのデータをどの[型](./data_type.md#型)として扱うかを明示（**型注釈**）する必要がある。事前にデータの[型](./data_type.md#型)を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、[プログラム](#プログラム)の信頼性が向上する。\n\nまた、[Rust](./programming_language.md#rust)や[Go](./programming_language.md#go)のような新しい静的型付け言語では、[ソースコード](#ソースコード)中に[型](./data_type.md#型)を明示せずとも、[コンパイラ](#コンパイラ)が文脈から自動的に[型](./data_type.md#型)を判断する**型推論**の機能が搭載されているものもあり、[ソースコード](#ソースコード)の記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。\n\n"},{"term":"型注釈","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"静的型付け言語","content":"\n**静的型付け言語**は、実行前にデータの[型](./data_type.md#型)を決定する方式の言語。[コンパイラ言語](#コンパイラ言語)の多くは静的型付け言語となっており、[プログラム](#プログラム)中で使用するデータに対して、そのデータをどの[型](./data_type.md#型)として扱うかを明示（**型注釈**）する必要がある。事前にデータの[型](./data_type.md#型)を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、[プログラム](#プログラム)の信頼性が向上する。\n\nまた、[Rust](./programming_language.md#rust)や[Go](./programming_language.md#go)のような新しい静的型付け言語では、[ソースコード](#ソースコード)中に[型](./data_type.md#型)を明示せずとも、[コンパイラ](#コンパイラ)が文脈から自動的に[型](./data_type.md#型)を判断する**型推論**の機能が搭載されているものもあり、[ソースコード](#ソースコード)の記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。\n\n"},{"term":"型推論","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"静的型付け言語","content":"\n**静的型付け言語**は、実行前にデータの[型](./data_type.md#型)を決定する方式の言語。[コンパイラ言語](#コンパイラ言語)の多くは静的型付け言語となっており、[プログラム](#プログラム)中で使用するデータに対して、そのデータをどの[型](./data_type.md#型)として扱うかを明示（**型注釈**）する必要がある。事前にデータの[型](./data_type.md#型)を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、[プログラム](#プログラム)の信頼性が向上する。\n\nまた、[Rust](./programming_language.md#rust)や[Go](./programming_language.md#go)のような新しい静的型付け言語では、[ソースコード](#ソースコード)中に[型](./data_type.md#型)を明示せずとも、[コンパイラ](#コンパイラ)が文脈から自動的に[型](./data_type.md#型)を判断する**型推論**の機能が搭載されているものもあり、[ソースコード](#ソースコード)の記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。\n\n"},{"term":"動的付け言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"動的型付け言語","content":"\n**動的型付け言語**は、実行時にデータの[型](./data_type.md#型)を決定する方式の言語。[ソースコード](#ソースコード)中で[型](./data_type.md#型)を明示する必要はなく、[コンパイラ](#コンパイラ)が文脈から全てのデータの[型](./data_type.md#型)を自動的に判断する。[ソースコード](#ソースコード)がシンプルになり読みやすくなる一方で、データが読み込まれるたびにそのデータの[型](./data_type.md#型)を推測する必要があるため、実行速度は[静的型付け言語](#静的型付け言語)に劣る。また、データが想定していない[型](./data_type.md#型)として扱われる可能性もあるため注意する必要がある。\n\n実行時に[型](./data_type.md#型)を決定するという抽象化の性質から、[関数](./function.md#関数)がとる[引数](./function.md#引数)の[型](./data_type.md#型)も柔軟に判断することができるため、同じインタフェースを持つ異なる[オブジェクト](./object_oriented.md#オブジェクト)をひとつの[関数](./function.md#関数)で扱える。これを利用したプログラミングスタイルとして[ダックタイピング](./object_oriented.md#ダックタイピング)がある。\n\n"},{"term":"汎用プログラミング言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"汎用プログラミング言語","content":"\n**汎用プログラミング言語**は、広い用途で利用される[高水準言語](#高水準言語)。\n\n"},{"term":"専用プログラミング言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"専用プログラミング言語","content":"\n**専用プログラミング言語**は、限られた分野で活躍する[高水準言語](#高水準言語)。\n\n"},{"term":"トランスコンパイル","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"トランスコンパイル","content":"\n**トランスコンパイル**は、ある[プログラミング言語](#プログラミング言語)で書かれた[ソースコード](#ソースコード)を、別の[プログラミング言語](#プログラミング言語)の[コード](#ソースコード)に変換する処理。\n\n\n"},{"term":"プログラミングパラダイム","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミングパラダイム","content":"\n**プログラミングパラダイム**は、[プログラミング](#プログラミング)の考え方や記述方法の枠組み。ひとつの[プログラミング言語](#プログラミング言語)は、複数のプログラミングパラダイムを組み合わせている場合（[マルチパラダイム言語](#マルチパラダイム言語)）が多い。\n\n"},{"term":"命令型プログラミング（手続き型プログラミング）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"命令型プログラミング","content":"\n**命令型プログラミング**（**手続き型プログラミング**）は、[識別子](#識別子)をつけた命令ブロック（[関数](./function.md#関数)）の定義と呼び出しを組み合わせることで[プログラム](#プログラム)全体を組み立てることを土台とした[プログラミングパラダイム](#プログラミングパラダイム)。[手続き](./function.md#関数)は、[プログラム](#プログラム)内のあらゆるポイントから呼び出すことができ、[手続き](./function.md#関数)内の命令コード行の終端に到達すると、その[手続き](./function.md#関数)を呼び出したポイントの次の命令に制御が移される（**復帰**）。[C言語](./programming_language.md#c言語)や[C++](./programming_language.md#c)、[PHP](./programming_language.md#php)、[Python](./programming_language.md#python)など、多くの[プログラミン言語](#プログラミング言語)は命令型プログラミングをサポートしている。\n\n"},{"term":"命令型プログラミング（手続き型プログラミング）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"命令型プログラミング","content":"\n**命令型プログラミング**（**手続き型プログラミング**）は、[識別子](#識別子)をつけた命令ブロック（[関数](./function.md#関数)）の定義と呼び出しを組み合わせることで[プログラム](#プログラム)全体を組み立てることを土台とした[プログラミングパラダイム](#プログラミングパラダイム)。[手続き](./function.md#関数)は、[プログラム](#プログラム)内のあらゆるポイントから呼び出すことができ、[手続き](./function.md#関数)内の命令コード行の終端に到達すると、その[手続き](./function.md#関数)を呼び出したポイントの次の命令に制御が移される（**復帰**）。[C言語](./programming_language.md#c言語)や[C++](./programming_language.md#c)、[PHP](./programming_language.md#php)、[Python](./programming_language.md#python)など、多くの[プログラミン言語](#プログラミング言語)は命令型プログラミングをサポートしている。\n\n"},{"term":"復帰","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"命令型プログラミング","content":"\n**命令型プログラミング**（**手続き型プログラミング**）は、[識別子](#識別子)をつけた命令ブロック（[関数](./function.md#関数)）の定義と呼び出しを組み合わせることで[プログラム](#プログラム)全体を組み立てることを土台とした[プログラミングパラダイム](#プログラミングパラダイム)。[手続き](./function.md#関数)は、[プログラム](#プログラム)内のあらゆるポイントから呼び出すことができ、[手続き](./function.md#関数)内の命令コード行の終端に到達すると、その[手続き](./function.md#関数)を呼び出したポイントの次の命令に制御が移される（**復帰**）。[C言語](./programming_language.md#c言語)や[C++](./programming_language.md#c)、[PHP](./programming_language.md#php)、[Python](./programming_language.md#python)など、多くの[プログラミン言語](#プログラミング言語)は命令型プログラミングをサポートしている。\n\n"},{"term":"宣言型プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"宣言型プログラミング","content":"\n**宣言型プログラミング**は、達成したい目的を記述し、その命令の実行手順については[コンパイラ](#コンパイラ)に任せるような言語。[プログラム](#プログラム)の本質がわかりやすく、記述がシンプルになるものの、複雑な処理を行うことはできない。[データベース](../../../development/database/_/chapters/database.md#データベース)に対する[クエリ](../../../development/database/_/chapters/sql.md#クエリ)を記述する[SQL](../../../development/database/_/chapters/sql.md#sql)は宣言型に準拠した言語である。\n\nまたは、数学論理学に根ざした流れをくむ、[関数型プログラミング](#関数型プログラミング)や[論理プログラミング](#論理プログラミング)、[制約プログラミング](#制約プログラミング)を総称して宣言型プログラミングと呼ぶこともある。\n\n"},{"term":"構造化プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"構造化プログラミング","content":"\n**構造化プログラミング**は、[プログラム](#プログラム)の処理手順を明確にし、判読性を向上させることを目的とした[プログラミングパラダイム](#プログラミングパラダイム)。一般的には、順次、[分岐](./control_flow.md#条件分岐)、[反復](./control_flow.md#反復)といった3つの[制御構文](./control_flow.md#制御フロー)によって処理の流れを記述する。また、[プログラム](#プログラム)を任意に分割した部分[プログラム](#プログラム)（[サブルーチン](./function.md#関数)とコードブロック）の階層的な組み合わせによる構造化も指している。[C言語](./programming_language.md#c言語)や[C++](./programming_language.md#c)、[Java](./programming_language.md#java)、[PHP](./programming_language.md#php)といった多くの言語は構造化プログラミングをサポートしている。\n\n"},{"term":"オブジェクト指向プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"オブジェクト指向プログラミング","content":"\n**オブジェクト指向プログラミング**は、あらゆるものを[オブジェクト](./object_oriented.md#オブジェクト)として表現する[プログラミングパラダイム](#プログラミングパラダイム)。[プログラム](#プログラム)を手順ではなく、モノの作成と操作として見る考え方。[C++](./programming_language.md#c)や[Java](./programming_language.md#java)、[PHP](./programming_language.md#php)、[Python](./programming_language.md#python)などは[オブジェクト指向](./object_oriented.md#オブジェクト指向)を取り入れた[プログラミング言語](#プログラミング言語)に分類される。[オブジェクト指向](./object_oriented.md#オブジェクト指向)をサポートする[プログラミング言語](#プログラミング言語)は大抵の場合、[命令型プログラミング](#命令型プログラミング)との組み合わせで用いられる。\n\n"},{"term":"関数型プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"関数型プログラミング","content":"\n**関数型プログラミング**は、数学的な関数を主軸として[プログラミング](#プログラミング)を行う[プログラミングパラダイム](#プログラミングパラダイム)。関数型プログラミングでは、**参照透過性**（入力が決まると出力が一意に決まり、他のデータへの[副作用](./function.md#副作用)がない）を満たした[関数](./function.md#関数)を使って組み立てた式が主役となる。[オブジェクト指向プログラミング](#オブジェクト指向プログラミング)では[状態](./object_oriented.md#プロパティ)と[振る舞い](./object_oriented.md#メソッド)を[オブジェクト](./object_oriented.md#オブジェクト)によって管理していたが、関数型プログラミングでは状態と振る舞いを切り離している。ClojureやElang、Haskell、Scala、[Rust](./programming_language.md#rust)などは関数型プログラミングに分類される。\n\n"},{"term":"参照透過性","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"関数型プログラミング","content":"\n**関数型プログラミング**は、数学的な関数を主軸として[プログラミング](#プログラミング)を行う[プログラミングパラダイム](#プログラミングパラダイム)。関数型プログラミングでは、**参照透過性**（入力が決まると出力が一意に決まり、他のデータへの[副作用](./function.md#副作用)がない）を満たした[関数](./function.md#関数)を使って組み立てた式が主役となる。[オブジェクト指向プログラミング](#オブジェクト指向プログラミング)では[状態](./object_oriented.md#プロパティ)と[振る舞い](./object_oriented.md#メソッド)を[オブジェクト](./object_oriented.md#オブジェクト)によって管理していたが、関数型プログラミングでは状態と振る舞いを切り離している。ClojureやElang、Haskell、Scala、[Rust](./programming_language.md#rust)などは関数型プログラミングに分類される。\n\n"},{"term":"論理プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"論理プログラミング","content":"\n**論理プログラミング**は、あらかじめ事実やルールを定義しておき、最終的に問い合わせを行うことで解を得る[プログラミングパラダイム](#プログラミングパラダイム)。既知の理論を基にして、新たな仮説を説明できるかといったことが[プログラム](#プログラム)的に証明できる。代表的な論理プログラミング言語には、Prologがある。\n\n"},{"term":"制約プログラミング","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"制約プログラミング","content":"\n**制約プログラミング**は、[変数](./variable.md#変数)間の関係を制約という形で記述し、**制約ソルバー**により与えた制約を満たす解を探索する[プログラミングパラダイム](#プログラミングパラダイム)。ツールキットのような形で[ライブラリ](../../../computer/software/_/chapters/package.md#ライブラリ)として各[プログラミング言語](#プログラミング言語)に提供されている場合が多く、代表的な[プログラミング言語](#プログラミング言語)と言えるものは少ない。\n\n"},{"term":"制約ソルバー","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"制約プログラミング","content":"\n**制約プログラミング**は、[変数](./variable.md#変数)間の関係を制約という形で記述し、**制約ソルバー**により与えた制約を満たす解を探索する[プログラミングパラダイム](#プログラミングパラダイム)。ツールキットのような形で[ライブラリ](../../../computer/software/_/chapters/package.md#ライブラリ)として各[プログラミング言語](#プログラミング言語)に提供されている場合が多く、代表的な[プログラミング言語](#プログラミング言語)と言えるものは少ない。\n\n"},{"term":"マルチパラダイム言語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"マルチパラダイム言語","content":"\n**マルチパラダイム言語**は、複数の[プログラミングパラダイム](#プログラミングパラダイム)に対応する[プログラミング言語](#プログラミング言語)の総称。[命令型プログラミング](#命令型プログラミング)や[構造化プログラミング](#構造化プログラミング)といった[パラダイム](#プログラミングパラダイム)は、他の[パラダイム](#プログラミングパラダイム)と組み合わせて用いられることが多い。\n\n\n"},{"term":"文法（シンタックス）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"文法","content":"\n**文法**（**シンタックス**）は、各[プログラミング言語](#プログラミング言語)が規定している[プログラム](#プログラム)の書き方。文法が誤っていると、[コンパイラ](#コンパイラ)が[ソースコード](#ソースコード)を正しく解析できず、[エラー](#エラー)となる。[プログラミング言語](#プログラミング言語)の文法は、[自然言語](#プログラミング言語)の文法に比べて非常に厳密であるため、[プログラミング](#プログラミング)を行うときには常に正しい文法を心掛けなくてはならない。\n\n文法は[プログラミング言語](#プログラミング言語)ごとに様々であるが、例として次のようなものがある。\n\n- [プログラム](#プログラム)は半角アルファベットと数字、各種記号によって記述する\n- `{` と `}` は対応しており、 `{}` で囲まれた部分は処理のひとつのまとまりを表す\n- ひとつの文は `;` で終わらなければならない\n- [プログラム](#プログラム)は上から下へと順次実行される\n\n"},{"term":"コメント（注釈）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"コメント","content":"\n**コメント**（注釈）は、[ソースコード](#ソースコード)中で[コンパイル](#コンパイル)時に無視される部分。[プログラム](#プログラム)の内容や補足を記述したり、一時的に無効化したい[プログラム](#プログラム)を**コメントアウト**したりといった使い方がある。\n\n一般的な[プログラミング言語](#プログラミング言語)におけるコメントの書き方は次のようになっている。\n\n```\n; アセンブリ言語などで用いられる1行のコメント\n\n// 高水準言語でよく用いられる1行のコメント\n\n/*\n\n    高水準言語でよく用いられる\n    複数行に対応したコメント\n\n*/\n```\n\n"},{"term":"コメントアウト","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"コメント","content":"\n**コメント**（注釈）は、[ソースコード](#ソースコード)中で[コンパイル](#コンパイル)時に無視される部分。[プログラム](#プログラム)の内容や補足を記述したり、一時的に無効化したい[プログラム](#プログラム)を**コメントアウト**したりといった使い方がある。\n\n一般的な[プログラミング言語](#プログラミング言語)におけるコメントの書き方は次のようになっている。\n\n```\n; アセンブリ言語などで用いられる1行のコメント\n\n// 高水準言語でよく用いられる1行のコメント\n\n/*\n\n    高水準言語でよく用いられる\n    複数行に対応したコメント\n\n*/\n```\n\n"},{"term":"エラー","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"エラー","content":"\n**エラー**は、[コンパイル](#コンパイル)時・実行時に[プログラム](#プログラム)が正常に処理を続行できなくなるような致命的な問題の発生により中断・終了されることを指す。[シンタックス](#文法)の誤りや、[アルゴリズム](./algorithm.md#アルゴリズム)の[バグ](#バグ)等により発生する。\n\n代表的なエラーには次のようなものがある。\n\n- **ゼロ除算**（整数を0で割るような[演算](./operation.md#演算)を試みた）\n- [配列](./data_type.md#配列)の要素数より大きい[インデックス](./data_type.md#配列)にアクセスを試みた\n- 存在しない[ファイル](../../../computer/software/_/chapters/file_system.md#ファイル)を参照しようとした\n- ユーザが想定外の入力を行った\n- [データベース](../../../development/database/_/chapters/database.md#データベース)や[サーバ](../../../computer/_/chapters/computer.md#サーバ)への接続に失敗した\n\n"},{"term":"例外","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"例外","content":"\n**例外**は、[プログラミング言語](#プログラミング言語)が想定可能な[エラー](#エラー)のことで、例外発生時の処理を[ソースコード](#ソースコード)中に記述しておき、[プログラム](#プログラム)が止まらないようにすることができる。[プログラムが](#プログラム)想定できない[エラー](#エラー)が発生した場合は、[プログラム](#プログラム)が[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)によって強制的に終了される。\n\n"},{"term":"バグ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"バグ","content":"\n**バグ**は、[プログラム](#プログラム)上の誤りや不具合。[文法](#文法)上の[エラー](#エラー)や、[エラー](#エラー)ではないものの[プログラム](#プログラム)が仕様通りに動作しないような欠陥のことをいう。\n\n"},{"term":"デバッグ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"デバッグ","content":"\n**デバッグ**は、[プログラム](#プログラム)の[バグ](#バグ)を見つけて修正すること。\n\n"},{"term":"未定義動作","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"未定義動作","content":"\n**未定義動作**は、[プログラミング言語](#プログラミング言語)の仕様において動作が予測できないと規定されている[プログラム](#プログラム)を実行した結果のことで、[C言語](./programming_language.md#c言語)や[C++](./programming_language.md#c)といった言語ではいくつかの未定義動作が定められている。未定義動作を設けることにより、パフォーマンスの高い[コンパイラ](#コンパイラ)を作成することが容易になる。一方で、未定義動作は[プログラム](#プログラム)の[バグ](#バグ)となる可能性が高く、実行環境によって結果が変わることもあるため発見が難しい。\n\n"},{"term":"識別子（シンボル）","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"識別子","content":"\n**識別子**（**シンボル**）は、[ソースコード](#ソースコード)中でデータや処理のまとまりに対して[プログラマ](#プログラマ)がつける名前。識別子には、そのデータの性質や状態、役割を表す名前をつけるのが一般的。\n\n識別子の命名に関しては、各[プログラミング言語](#プログラミング言語)ごとにルールが存在する。次に示すのは、多くの[プログラミング言語](#プログラミング言語)に共通しているルールの一部。\n\n- [変数](./variable.md#変数)名にはアルファベット、数字、アンダースコアが使用できる\n- アルファベットの大文字と小文字は区別される\n- 1文字目はアルファベットかアンダースコアが使用できる（数字から始まる[変数](./variable.md#変数)名は使用できない）\n- [予約語](#予約語)は使用できない（[予約語](#予約語)を含む[変数](./variable.md#変数)名は使用できる）\n- 識別子中にスペースを含むことはできない（複数の単語からなる識別子において、単語間にスペースを用いるなど）\n\n[プログラミング](#プログラミング)において良い識別子を命名することは、[ソースコード](#ソースコード)の可読性やメンテナンス性を向上させるために非常に重要である。言語ごとのコミュニティや開発チームごとのルール・文化に従い、一般的な単語を用いた、誰が見てもわかりやすい識別子を心掛けるべきである。\n\n"},{"term":"予約語","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"予約語","content":"\n**予約語**は、各[プログラミング言語](#プログラミング言語)において規定されている、[識別子](#識別子)として利用できない文字列。データの[型](./data_type.md#型)や[制御構文](./control_flow.md#制御フロー)に用いられる単語などがこれにあたり、[プログラム](#プログラム)の[構文解析](../../../basics/information_theory/_/chapters/compiler_theory.md#構文解析)の妨げになるなどの理由から使用できなくなっている。また、将来的に[プログラミング言語](#プログラミング言語)に取り入れられる予定の機能に関するキーワードも予約語となっている場合もある。\n\n予約語ではなくとも、他の[プログラミング言語](#プログラミング言語)で予約語になっているものや、将来的に使用できなくなる可能性のある文字列は[識別子](#識別子)としてふさわしくないので、避けた方がよい。\n\n以下に示すのは、[C言語](./programming_language.md#c言語)の予約語の一部。\n\n```c\nauto, break, case, char, const, continue, default, do, double, else, enum,\nextern, float, for, goto, if, int, long, register, return, signed, sizeof,\n...\n```\n\n\n"},{"term":"実行環境","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミングを始める","content":"\n[プログラミング](#プログラミング)を始めるために必要なものは、各種[プログラミング言語](#プログラミング言語)の実行環境と、[プログラム](#プログラム)を記述するためのテキストエディタのみで、基本的には特別なものは必要としない。**実行環境**は、[プログラム](#プログラム)を[コンパイル](#コンパイル)して実行するための環境。**テキストエディタ**には、[プログラミング](#プログラミング)を便利に行うための補助機能を提供するものや、実行環境が搭載された**統合開発環境**など様々なものがあるが、PCにデフォルトでインストールされているようなもの（[Windows](../../../computer/software/_/chapters/operating_system.md#windows)のメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。\n\n- [サクラエディタ](https://sakura-editor.github.io/)\n- [秀丸エディタ（有料）](https://hide.maruo.co.jp/software/hidemaru.html)\n- [Visual Studio Code](https://code.visualstudio.com/)\n- [Neovim](https://neovim.io/)\n"},{"term":"テキストエディタ","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミングを始める","content":"\n[プログラミング](#プログラミング)を始めるために必要なものは、各種[プログラミング言語](#プログラミング言語)の実行環境と、[プログラム](#プログラム)を記述するためのテキストエディタのみで、基本的には特別なものは必要としない。**実行環境**は、[プログラム](#プログラム)を[コンパイル](#コンパイル)して実行するための環境。**テキストエディタ**には、[プログラミング](#プログラミング)を便利に行うための補助機能を提供するものや、実行環境が搭載された**統合開発環境**など様々なものがあるが、PCにデフォルトでインストールされているようなもの（[Windows](../../../computer/software/_/chapters/operating_system.md#windows)のメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。\n\n- [サクラエディタ](https://sakura-editor.github.io/)\n- [秀丸エディタ（有料）](https://hide.maruo.co.jp/software/hidemaru.html)\n- [Visual Studio Code](https://code.visualstudio.com/)\n- [Neovim](https://neovim.io/)\n"},{"term":"統合開発環境","link":"./note/ja/./programming/_/chapters/programming.md","flagment":"プログラミングを始める","content":"\n[プログラミング](#プログラミング)を始めるために必要なものは、各種[プログラミング言語](#プログラミング言語)の実行環境と、[プログラム](#プログラム)を記述するためのテキストエディタのみで、基本的には特別なものは必要としない。**実行環境**は、[プログラム](#プログラム)を[コンパイル](#コンパイル)して実行するための環境。**テキストエディタ**には、[プログラミング](#プログラミング)を便利に行うための補助機能を提供するものや、実行環境が搭載された**統合開発環境**など様々なものがあるが、PCにデフォルトでインストールされているようなもの（[Windows](../../../computer/software/_/chapters/operating_system.md#windows)のメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。\n\n- [サクラエディタ](https://sakura-editor.github.io/)\n- [秀丸エディタ（有料）](https://hide.maruo.co.jp/software/hidemaru.html)\n- [Visual Studio Code](https://code.visualstudio.com/)\n- [Neovim](https://neovim.io/)\n"},{"term":"変数","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"変数","content":"\n**変数**は、[プログラム](./programming.md#プログラム)中で用いるデータに固有の名前をつけたもの。物理的にはデータは[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に格納されており、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上のデータには[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を使ってアクセスすることができる。しかし、[メモリアドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)はただの数値の羅列であり、人間にはわかりずらいため、[ソースコード](./programming.md#ソースコード)中では格納しているデータの性質や役割を表す[識別子](./programming.md#識別子)をつけた変数を用いる。\n\n"},{"term":"グローバル変数","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"グローバル変数","content":"\n**グローバル変数**は、[グローバルスコープ](./control_flow.md#グローバル)に宣言された[変数](#変数)。\n\n"},{"term":"ローカル変数（自動変数、局所変数）","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"ローカル変数","content":"\n**ローカル変数**（**自動変数**、**局所変数**）は、[ローカルスコープ](./control_flow.md#ローカル)に宣言された[変数](#変数)。\n\n同じ[識別子](./programming.md#識別子)の[変数](#変数)を複数回宣言できない[プログラミング言語](./programming.md#プログラミング言語)においても、[スコープ](./control_flow.md#スコープ)が異なれば同じ[識別子](./programming.md#識別子)を用いることができる。\n\n\n"},{"term":"宣言","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"宣言","content":"\n**宣言**は、[プログラム](./programming.md#プログラム)中で用いる[変数](#変数)の名前を明示する操作。[静的型付け言語](./programming.md#静的型付け言語)の多くは、宣言時に[変数](#変数)の[型](./data_type.md#型)も指定する必要がある。\n\n[プログラミング言語](./programming.md#プログラミング言語)によっては、同じ[変数](#変数)名を複数回宣言しようとすると[エラー](./programming.md#エラー)となる。一方で、新しい[変数](#変数)で前の[変数](#変数)を上書きする（**シャドーイング**）仕様の[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n"},{"term":"シャドーイング","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"宣言","content":"\n**宣言**は、[プログラム](./programming.md#プログラム)中で用いる[変数](#変数)の名前を明示する操作。[静的型付け言語](./programming.md#静的型付け言語)の多くは、宣言時に[変数](#変数)の[型](./data_type.md#型)も指定する必要がある。\n\n[プログラミング言語](./programming.md#プログラミング言語)によっては、同じ[変数](#変数)名を複数回宣言しようとすると[エラー](./programming.md#エラー)となる。一方で、新しい[変数](#変数)で前の[変数](#変数)を上書きする（**シャドーイング**）仕様の[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n"},{"term":"代入","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"代入","content":"\n**代入**は、[宣言](#宣言)した[変数](#変数)に対してデータを関連付ける操作。既にデータが紐づけられている[変数](#変数)に対して別のデータを紐づけることもでき、これを**再代入**という。代入のための[演算子](./operation.md#代入演算子)としては `=` が用いられる場合が多い（数学的な意味では `=` は「等価」であるが、多くの[プログラミング言語](./programming.md#プログラミング言語)では等価は `==` で表される）。\n\n[変数](#変数)名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、[プログラミング](./programming.md#プログラミング)では**束縛**（**バインド**）という。\n\n"},{"term":"再代入","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"代入","content":"\n**代入**は、[宣言](#宣言)した[変数](#変数)に対してデータを関連付ける操作。既にデータが紐づけられている[変数](#変数)に対して別のデータを紐づけることもでき、これを**再代入**という。代入のための[演算子](./operation.md#代入演算子)としては `=` が用いられる場合が多い（数学的な意味では `=` は「等価」であるが、多くの[プログラミング言語](./programming.md#プログラミング言語)では等価は `==` で表される）。\n\n[変数](#変数)名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、[プログラミング](./programming.md#プログラミング)では**束縛**（**バインド**）という。\n\n"},{"term":"束縛（バインド）","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"代入","content":"\n**代入**は、[宣言](#宣言)した[変数](#変数)に対してデータを関連付ける操作。既にデータが紐づけられている[変数](#変数)に対して別のデータを紐づけることもでき、これを**再代入**という。代入のための[演算子](./operation.md#代入演算子)としては `=` が用いられる場合が多い（数学的な意味では `=` は「等価」であるが、多くの[プログラミング言語](./programming.md#プログラミング言語)では等価は `==` で表される）。\n\n[変数](#変数)名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、[プログラミング](./programming.md#プログラミング)では**束縛**（**バインド**）という。\n\n"},{"term":"初期化","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"初期化","content":"\n**初期化**は、[変数](#変数)の[宣言](#宣言)と同時に[代入](#代入)を行う操作。[定数](#定数)のような、後から変更することを許可しない[変数](#変数)を[宣言](#宣言)したい場合は、初期化が必須となる。\n\n"},{"term":"参照","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"参照","content":"\n**参照**は、[変数](#変数)名に紐づくデータを取り出す操作。データが[代入](#代入)されていない[変数](#変数)（**未初期化状態**の[変数](#変数)）を参照することは不正な操作となり、[プログラミング言語](./programming.md#プログラミング言語)によっては[未定義動作](./programming.md#未定義動作)となる。これを防ぐため、[宣言](#宣言)時や実行時に自動的に初期値（[整数型](./data_type.md#整数型)であれば `0` 、[文字列型](./data_type.md#文字列型)であれば空文字など）を割り当てる[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n\n"},{"term":"未初期化状態の変数","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"参照","content":"\n**参照**は、[変数](#変数)名に紐づくデータを取り出す操作。データが[代入](#代入)されていない[変数](#変数)（**未初期化状態**の[変数](#変数)）を参照することは不正な操作となり、[プログラミング言語](./programming.md#プログラミング言語)によっては[未定義動作](./programming.md#未定義動作)となる。これを防ぐため、[宣言](#宣言)時や実行時に自動的に初期値（[整数型](./data_type.md#整数型)であれば `0` 、[文字列型](./data_type.md#文字列型)であれば空文字など）を割り当てる[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n\n"},{"term":"定数","link":"./note/ja/./programming/_/chapters/variable.md","flagment":"定数","content":"\n**定数**は、[初期化](#初期化)した後に別のデータを[再代入](#代入)できない[変数](#変数)。[変数](#変数)は後からデータを紐づけることができるが、定数はできないので、必ず[初期化](#初期化)する必要がある。定数の[初期化](#初期化)には `const` キーワードが用いられる場合が多い。[プログラム](./programming.md#プログラム)中で変更されてはいけないデータや、数学的・物理的な定数に用いられるのが一般的。\n\n```c\n// C言語\n\n// 変数の初期化時にconstキーワードをつけることで定数にすることができる\nconst int max_num = 1000;\nconst float pi = 3.14159;\n```\n\n```javascript\n// JavaScript\n\n// letの代わりにconstを用いることで定数を初期化する\nconst max_num = 1000;\nconst pi = 3.14159;\n```\n\n定数は紐づくデータは変わらないが、[ポインタ](./data_type.md#ポインタ型)経由などでデータ自体を書き換えることができてしまうため、必ずしも[参照](#参照)した中身が一致するとは限らない点に注意が必要である。\n\nまた `const` 定数と似たような使われ方をする機能として、 `define` を利用できる[プログラミング言語](./programming.md#プログラミング言語)もある。これは一般的には、[ソースコード](./programming.md#ソースコード)中の[文字列](./data_type.md#文字列型)を[コンパイル](./programming.md#コンパイル)時に別の値に置き替える機能のことを指す。\n\n```c\n// C言語\n\n// defineマクロを用いて値を定義する\n"},{"term":"型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"型","content":"\n**型**は、[プログラム](./programming.md#プログラム)で扱うデータを性質や属性によって分類してもの。[静的型付け言語](./programming.md#静的型付け言語)においては、[プログラマ](./programming.md#プログラマ)が[ソースコード](./programming.md#ソースコード)中に型を明示することによって[コンパイル](./programming.md#コンパイル)時にデータの型が決まる。[静的型付け言語](./programming.md#静的型付け言語)においては、実行時に自動的に型が判断される。\n\n\n"},{"term":"プリミティブ型（基本データ型、原始型）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"プリミティブ型","content":"\n**プリミティブ型**（**基本データ型**、**原始型**）は、[プログラミング言語](./programming.md#プログラミング言語)で標準的に用意されている最も基本的な[型](#型)。プリミティブ型に属する[型](#型)は、[プログラミング言語](./programming.md#プログラミング言語)においてそれ以上分解することができないシンプルな[型](#型)として定義されており、[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)が高速に[演算](./operation.md#演算)できるという特徴がある。\n\n"},{"term":"文字型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"文字型","content":"\n**文字型**( `char` )は、[自然言語](./programming.md#プログラミング言語)の1文字を格納するための[型](#型)。1[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)で表現できる[ASCII文字](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)や、[マルチバイト文字](../../../basics/information_theory/_/chapters/character_representation.md#マルチバイト文字)で様々な文字種に対応している[JISコード](../../../basics/information_theory/_/chapters/character_representation.md#jisコード)や[Unicode](../../../basics/information_theory/_/chapters/character_representation.md#unicode)などのサポートが一般的。\n\n[ソースコード](./programming.md#ソースコード)中で `'` で囲まれた部分は文字型のデータとして扱われる（ `'` と `\"` を使い分けない[プログラミング言語](./programming.md#プログラミング言語)もある）。このようにクォーテーションで囲まれた、[ソースコード](./programming.md#ソースコード)中に直接記述された文字のことを**文字リテラル**という。\n\n```c\n// C言語\n\nint main()\n{\n    // 文字リテラル\n    char charcter = 'a';\n    printf(\"character: %c\\n\", character);\n\n    return 0;\n}\n```\n\n"},{"term":"文字リテラル","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"文字型","content":"\n**文字型**( `char` )は、[自然言語](./programming.md#プログラミング言語)の1文字を格納するための[型](#型)。1[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)で表現できる[ASCII文字](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)や、[マルチバイト文字](../../../basics/information_theory/_/chapters/character_representation.md#マルチバイト文字)で様々な文字種に対応している[JISコード](../../../basics/information_theory/_/chapters/character_representation.md#jisコード)や[Unicode](../../../basics/information_theory/_/chapters/character_representation.md#unicode)などのサポートが一般的。\n\n[ソースコード](./programming.md#ソースコード)中で `'` で囲まれた部分は文字型のデータとして扱われる（ `'` と `\"` を使い分けない[プログラミング言語](./programming.md#プログラミング言語)もある）。このようにクォーテーションで囲まれた、[ソースコード](./programming.md#ソースコード)中に直接記述された文字のことを**文字リテラル**という。\n\n```c\n// C言語\n\nint main()\n{\n    // 文字リテラル\n    char charcter = 'a';\n    printf(\"character: %c\\n\", character);\n\n    return 0;\n}\n```\n\n"},{"term":"整数型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"整数型","content":"\n**整数型**( `int, short, long' )は、整数値を格納するための[型](#型)。1[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)が表現できる範囲は $0 \\sim 255 (2^8)$ であるため、より大きい数値を扱えるように2[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)や4[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)、8[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)の整数型などを用意している[プログラミング言語](./programming.md#プログラミングン言語)もある。**符号付き整数**と**符号なし整数**をサポートしている[プログラミング言語](./programming.md#プログラミング言語)もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。\n\n"},{"term":"符号付き整数","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"整数型","content":"\n**整数型**( `int, short, long' )は、整数値を格納するための[型](#型)。1[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)が表現できる範囲は $0 \\sim 255 (2^8)$ であるため、より大きい数値を扱えるように2[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)や4[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)、8[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)の整数型などを用意している[プログラミング言語](./programming.md#プログラミングン言語)もある。**符号付き整数**と**符号なし整数**をサポートしている[プログラミング言語](./programming.md#プログラミング言語)もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。\n\n"},{"term":"符号なし整数","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"整数型","content":"\n**整数型**( `int, short, long' )は、整数値を格納するための[型](#型)。1[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)が表現できる範囲は $0 \\sim 255 (2^8)$ であるため、より大きい数値を扱えるように2[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)や4[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)、8[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)の整数型などを用意している[プログラミング言語](./programming.md#プログラミングン言語)もある。**符号付き整数**と**符号なし整数**をサポートしている[プログラミング言語](./programming.md#プログラミング言語)もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。\n\n"},{"term":"固定長小数点数型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"固定長小数点数型","content":"\n**固定長小数点数型**( `fixed` )は、小数を扱うための[型](#型)で、どの[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を小数点とするかをあらかじめ決めておく。固定小数点数を扱うため、データの解析が容易である一方で、表せる数の範囲は[浮動小数点数](#浮動小数点数型)に比べて狭い。\n\n"},{"term":"浮動小数点数型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"浮動小数点数型","content":"\n**浮動小数点数型**( `float, double` )は、小数を扱うための[型](#型)で、浮動小数点方式の小数を扱う。[単精度](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#浮動小数点数)と[倍精度](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#浮動小数点数)で別の[型](#型)として用意している[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n"},{"term":"ブーリアン型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ブーリアン型","content":"\n**ブーリアン型**( `bool, boolean` )は、[真偽値](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#真偽値)を扱うための[型](#型)で、 `true` か `false` のどちらかの値が格納される。この[型](#型)に対しては、[論理積](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)( `AND` )、[論理和](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)( `OR` )、[排他的論理和](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)( `XOR` )、同値、非同値、[否定](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)といった[論理演算](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)が可能。[条件分岐](./control_flow.md#条件分岐)において評価結果としても用いられる。\n\n"},{"term":"ポインタ型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ポインタ型","content":"\n**ポインタ型**は、[変数](./variable.md#変数)や[関数](./function.md#関数)の実体が格納された、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を保持しておくための[型](#型)。[配列](#配列)や[オブジェクト](#オブジェクト型)といった[複合型](#複合型)は[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納されており、実体にアクセスするためには[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)のポインタを経由する必要がある。また、[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に格納されたデータに対してもポインタをつくることができる。\n\n[プログラム](./programming.md#プログラム)中で利用される[変数](./variable.md#変数)や[関数](./function.md#関数)などのリソースは[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上で固有の[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)に割り当てられており、[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を知っていればそのデータにアクセスすることができる。また、[メモリアドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)の足し引きによって隣のデータにアクセスすることもできる。一方で、予期しない[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)のデータを変更してしまうと深刻な[バグ](./programming.md#バグ)に繋がるため、注意が必要である。\n\nポインタのポインタや、さらにそのポインタを作るといったこともできる。\n\n"},{"term":"参照型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"参照型","content":"\n**参照型**は[ポインタ型](#ポインタ型)と同様、[変数](./variable.md#変数)や[関数](./function.md#関数)が置かれた[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を指す[型](#型)。[ポインタ型](#ポインタ型)とは異なり、[参照](./variable.md#参照)先に書き込むことはできない、読み込み専用の[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)。また、[参照](./variable.md#参照)先にデータが存在しないことを禁止しており、[ポインタ](#ポインタ型)に比べて安全に利用できるという利点がある。\n\n\n"},{"term":"Null","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"null","content":"\n**Null**は、何もないことを表すデータで、[プログラミング言語](./programming.md#プログラミング言語)によって実装や扱いが異なる。[型](#型)として定義されている言語もあれば、特別な値として扱う言語もある。空文字や `0` とは区別され、[変数](./variable.md#変数)に値が[代入](./variable.md#代入)されていない状態などを表す。\n\n\n"},{"term":"複合型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"複合型","content":"\n**複合型**は、[プリミティブ型](#プリミティブ型)を組み合わせた構造を持つ[型](#型)。あらかじめ定義された汎用的な[型](#型)もあるが、多くの[プログラミング言語](./programming.md#プログラミング言語)では開発者が独自に定義することもできる。\n\n各[プログラミング言語](./programming.md#プログラミング)ごとに用意されている複合型や、内部的なデータ構造が異なる場合があるので注意。\n\n\n"},{"term":"コンテナ型（コレクション型）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"コンテナ型","content":"\n**コンテナ型**（**コレクション型**）は、同じ[型](#型)のデータを複数まとめるための抽象データ[型](#型)。それぞれに特性や得意とする操作が異なるため、用途に応じて適切に使い分けることで[プログラム](./programming.md#プログラム)の質が向上する。\n\n"},{"term":"イテレータ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"イテレータ","content":"\n**イテレータ**は、[コンテナ型](#コンテナ型)が持つ各要素に対する繰り返し処理の抽象化構造。[繰り返し処理](./control_flow.md#反復)の[for文](./control_flow.md#ofr文)などにおいて利用される。イテレータは[コンテナ](#コンテナ型)内の要素の[ポインタ](#ポインタ型)を指し示しており、[ループ](./control_flow.md#反復)が進むにつれて次の要素の[ポインタ](#ポインタ型)を返す。\n\n"},{"term":"配列","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"配列","content":"\n**配列**は、同じ[型](#型)のデータの集合を格納するためのデータ[型](#型)で、要素が[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上で隣り合うように並べられる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を `0` とした整数値となっている。\n\n```c\n// C言語\n\nchar str[] = \"Hello, world\";\n\nstr[5] = \"!\";\nprintf(\"%s\\n\", str);     // \"Hello! world\"が出力される\n```\n\n配列には、[コンパイル](./programming.md#コンパイル)時に要素数が決まる**固定長配列**と、実行時に要素数を動的に追加したり削除したりできる**可変長配列**がある。通常、固定長配列は[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に、可変長配列は[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納される。可変長配列において、[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に確保したサイズが不足した場合、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域の再確保（[アロケート](./programming.md#アロケート)）が発生するため、あらかじめ十分な領域を用意しておくとよい。\n\n可変長配列の末尾に対するデータの追加・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は常に $O(1)$ で高速である。データの探索にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は基本的に $O(N)$ であるが、配列がソート済みである場合は[二分探索](./algorithm.md#二分探索)を用いて $O(\\log{N})$ に抑えることもできる。\n\n基本的には使い勝手の良い[コンテナ型](#コンテナ型)の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対しては[リスト](#リスト)を用いた方が良い場合もある。\n\n"},{"term":"インデックス（添え字）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"配列","content":"\n**配列**は、同じ[型](#型)のデータの集合を格納するためのデータ[型](#型)で、要素が[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上で隣り合うように並べられる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を `0` とした整数値となっている。\n\n```c\n// C言語\n\nchar str[] = \"Hello, world\";\n\nstr[5] = \"!\";\nprintf(\"%s\\n\", str);     // \"Hello! world\"が出力される\n```\n\n配列には、[コンパイル](./programming.md#コンパイル)時に要素数が決まる**固定長配列**と、実行時に要素数を動的に追加したり削除したりできる**可変長配列**がある。通常、固定長配列は[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に、可変長配列は[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納される。可変長配列において、[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に確保したサイズが不足した場合、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域の再確保（[アロケート](./programming.md#アロケート)）が発生するため、あらかじめ十分な領域を用意しておくとよい。\n\n可変長配列の末尾に対するデータの追加・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は常に $O(1)$ で高速である。データの探索にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は基本的に $O(N)$ であるが、配列がソート済みである場合は[二分探索](./algorithm.md#二分探索)を用いて $O(\\log{N})$ に抑えることもできる。\n\n基本的には使い勝手の良い[コンテナ型](#コンテナ型)の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対しては[リスト](#リスト)を用いた方が良い場合もある。\n\n"},{"term":"固定長配列","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"配列","content":"\n**配列**は、同じ[型](#型)のデータの集合を格納するためのデータ[型](#型)で、要素が[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上で隣り合うように並べられる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を `0` とした整数値となっている。\n\n```c\n// C言語\n\nchar str[] = \"Hello, world\";\n\nstr[5] = \"!\";\nprintf(\"%s\\n\", str);     // \"Hello! world\"が出力される\n```\n\n配列には、[コンパイル](./programming.md#コンパイル)時に要素数が決まる**固定長配列**と、実行時に要素数を動的に追加したり削除したりできる**可変長配列**がある。通常、固定長配列は[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に、可変長配列は[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納される。可変長配列において、[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に確保したサイズが不足した場合、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域の再確保（[アロケート](./programming.md#アロケート)）が発生するため、あらかじめ十分な領域を用意しておくとよい。\n\n可変長配列の末尾に対するデータの追加・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は常に $O(1)$ で高速である。データの探索にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は基本的に $O(N)$ であるが、配列がソート済みである場合は[二分探索](./algorithm.md#二分探索)を用いて $O(\\log{N})$ に抑えることもできる。\n\n基本的には使い勝手の良い[コンテナ型](#コンテナ型)の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対しては[リスト](#リスト)を用いた方が良い場合もある。\n\n"},{"term":"可変長配列","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"配列","content":"\n**配列**は、同じ[型](#型)のデータの集合を格納するためのデータ[型](#型)で、要素が[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上で隣り合うように並べられる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を `0` とした整数値となっている。\n\n```c\n// C言語\n\nchar str[] = \"Hello, world\";\n\nstr[5] = \"!\";\nprintf(\"%s\\n\", str);     // \"Hello! world\"が出力される\n```\n\n配列には、[コンパイル](./programming.md#コンパイル)時に要素数が決まる**固定長配列**と、実行時に要素数を動的に追加したり削除したりできる**可変長配列**がある。通常、固定長配列は[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上の[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に、可変長配列は[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納される。可変長配列において、[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に確保したサイズが不足した場合、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域の再確保（[アロケート](./programming.md#アロケート)）が発生するため、あらかじめ十分な領域を用意しておくとよい。\n\n可変長配列の末尾に対するデータの追加・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は常に $O(1)$ で高速である。データの探索にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は基本的に $O(N)$ であるが、配列がソート済みである場合は[二分探索](./algorithm.md#二分探索)を用いて $O(\\log{N})$ に抑えることもできる。\n\n基本的には使い勝手の良い[コンテナ型](#コンテナ型)の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対しては[リスト](#リスト)を用いた方が良い場合もある。\n\n"},{"term":"リスト（連結リスト、リンクリスト）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"リスト","content":"\n**リスト**（**連結リスト**、**リンクリスト**）は、各ノードが任意のデータと他のノードへの[ポインタ](#ポインタ型)を持つようなデータ構造。ノードが別のノードの[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)情報を持つことによって、データの集まりを表現している。\n\n- **単方向リスト** : 各ノードが次のノードへのポインタを持つリスト\n- **双方向リスト** : 各ノードが次のノードと前のノードへのポインタを持つリスト\n- **循環リスト** : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）\n\nリストは、前後のノードと[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)上で隣り合っている必要がないため、データ数が増えても[アロケート](./programming.md#アロケート)が発生しないという利点がある。\n\nリストの任意の場所へのデータの挿入・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と高速である。一方で、要素へのアクセスにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(N)$ であり、[配列](#配列)に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番に[ポインタ](#ポインタ型)をたどっていく必要があるためである（[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上での配置が隣り合っているとは限らないため）。\n\n"},{"term":"単方向リスト","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"リスト","content":"\n**リスト**（**連結リスト**、**リンクリスト**）は、各ノードが任意のデータと他のノードへの[ポインタ](#ポインタ型)を持つようなデータ構造。ノードが別のノードの[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)情報を持つことによって、データの集まりを表現している。\n\n- **単方向リスト** : 各ノードが次のノードへのポインタを持つリスト\n- **双方向リスト** : 各ノードが次のノードと前のノードへのポインタを持つリスト\n- **循環リスト** : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）\n\nリストは、前後のノードと[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)上で隣り合っている必要がないため、データ数が増えても[アロケート](./programming.md#アロケート)が発生しないという利点がある。\n\nリストの任意の場所へのデータの挿入・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と高速である。一方で、要素へのアクセスにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(N)$ であり、[配列](#配列)に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番に[ポインタ](#ポインタ型)をたどっていく必要があるためである（[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上での配置が隣り合っているとは限らないため）。\n\n"},{"term":"双方向リスト","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"リスト","content":"\n**リスト**（**連結リスト**、**リンクリスト**）は、各ノードが任意のデータと他のノードへの[ポインタ](#ポインタ型)を持つようなデータ構造。ノードが別のノードの[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)情報を持つことによって、データの集まりを表現している。\n\n- **単方向リスト** : 各ノードが次のノードへのポインタを持つリスト\n- **双方向リスト** : 各ノードが次のノードと前のノードへのポインタを持つリスト\n- **循環リスト** : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）\n\nリストは、前後のノードと[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)上で隣り合っている必要がないため、データ数が増えても[アロケート](./programming.md#アロケート)が発生しないという利点がある。\n\nリストの任意の場所へのデータの挿入・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と高速である。一方で、要素へのアクセスにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(N)$ であり、[配列](#配列)に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番に[ポインタ](#ポインタ型)をたどっていく必要があるためである（[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上での配置が隣り合っているとは限らないため）。\n\n"},{"term":"循環リスト","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"リスト","content":"\n**リスト**（**連結リスト**、**リンクリスト**）は、各ノードが任意のデータと他のノードへの[ポインタ](#ポインタ型)を持つようなデータ構造。ノードが別のノードの[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)情報を持つことによって、データの集まりを表現している。\n\n- **単方向リスト** : 各ノードが次のノードへのポインタを持つリスト\n- **双方向リスト** : 各ノードが次のノードと前のノードへのポインタを持つリスト\n- **循環リスト** : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）\n\nリストは、前後のノードと[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)上で隣り合っている必要がないため、データ数が増えても[アロケート](./programming.md#アロケート)が発生しないという利点がある。\n\nリストの任意の場所へのデータの挿入・削除にかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(1)$ と高速である。一方で、要素へのアクセスにかかる[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)は $O(N)$ であり、[配列](#配列)に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番に[ポインタ](#ポインタ型)をたどっていく必要があるためである（[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上での配置が隣り合っているとは限らないため）。\n\n"},{"term":"スタック","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"スタック","content":"\n**スタック**は、データを**FILO**（First In Last Out: 先入れ後出し）の構造で保持する[コンテナ](#コンテナ型)。スタックに対してデータを追加する操作を**プッシュ**、スタックからデータを取り出す操作を**ポップ**といい、これを基本操作とするデータ[型](#型)となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。\n\n"},{"term":"FILO","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"スタック","content":"\n**スタック**は、データを**FILO**（First In Last Out: 先入れ後出し）の構造で保持する[コンテナ](#コンテナ型)。スタックに対してデータを追加する操作を**プッシュ**、スタックからデータを取り出す操作を**ポップ**といい、これを基本操作とするデータ[型](#型)となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。\n\n"},{"term":"プッシュ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"スタック","content":"\n**スタック**は、データを**FILO**（First In Last Out: 先入れ後出し）の構造で保持する[コンテナ](#コンテナ型)。スタックに対してデータを追加する操作を**プッシュ**、スタックからデータを取り出す操作を**ポップ**といい、これを基本操作とするデータ[型](#型)となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。\n\n"},{"term":"ポップ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"スタック","content":"\n**スタック**は、データを**FILO**（First In Last Out: 先入れ後出し）の構造で保持する[コンテナ](#コンテナ型)。スタックに対してデータを追加する操作を**プッシュ**、スタックからデータを取り出す操作を**ポップ**といい、これを基本操作とするデータ[型](#型)となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。\n\n"},{"term":"キュー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"FIFO","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"エンキュー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"デキュー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"優先度付きキュー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"両端キュー（デック）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"キュー","content":"\n**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持する[コンテナ](#コンテナ型)。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ[型](#型)となる。最初にエンキューしたデータから取り出したいような場合に用いる（[待ち行列](../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)）。\n\nキューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。\n\n先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。\n\n"},{"term":"ハッシュテーブル","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"エントリ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"ハッシュ値","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"ハッシュ関数","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"衝突","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"連鎖法","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"開番地法","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ハッシュテーブル","content":"\n**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ[型](#型)。キーを基に生成された**ハッシュ値**を[インデックス](#配列)として値を管理することで、検索や要素の追加を $O(1)$ の[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。\n\nハッシュ値を[インデックス](#配列)とした[配列](#配列)であり、[インデックス](#配列)が飛び飛びとなるため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)効率は悪い。\n\n複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータを[リンクリスト](#リスト)で管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となる[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を算出する。\n\n"},{"term":"連想配列（連想リスト、連想コンテナ、辞書）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"連想配列","content":"\n**連想配列**（**連想リスト**、**連想コンテナ**、**辞書**）は、[インデックス](#配列)として文字列などの整数値以外のデータ[型](#型)を用いることができるような[コンテナ](#コンテナ型)。連想配列の実装には、[ハッシュテーブル](#ハッシュテーブル)や[平衡二分探索木](#木)などが用いられる。\n\n"},{"term":"セット（集合）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"セット","content":"\n**セット**（**集合**）は、順序のないデータの集まりを表現するデータ[型](#型)で、重複するデータが存在しないことを保証する。\n\n"},{"term":"木","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"ノード","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"エッジ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"ルートノード（根ノード）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"ブランチノード（枝ノード）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"リーフノード（葉ノード）","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"二分木","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"平衡木","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"木","content":"\n**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。\n\n各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。\n\n"},{"term":"グラフ","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"グラフ","content":"\n**グラフ**は、[木](#木)と同様に[ノード](#木)と[エッジ](#木)からなるデータ構造であるが、[木](#木)とは異なり[ノード](#木)同士が親子関係を持たない。\n\n"},{"term":"文字列型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"文字列型","content":"\n**文字列型**( `string` )は、複数の文字からなる文字列を表現するための[型](#型)。[文字型](#文字型)には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合は[プログラミング言語](./programming.md#プログラミング言語)ごとに用意されている文字列型を用いる。文字列型の[オブジェクト](#オブジェクト型)を用意している場合もあれば、[文字型](#文字型)の[配列](#配列)を文字列として扱う言語もある。\n\n[ソースコード](./programming.md#ソースコード)中で `\"` で囲まれた部分は文字列型のデータとして扱われる（ `'` と `\"` を使い分けない[プログラミング言語](./programming.md#プログラミング言語)もある）。このようにクォーテーションで囲まれた、[ソースコード](./programming.md#ソースコード)中に直接記述された文字のことを**文字列リテラル**という。\n\n文字列の終端を判別するための特別な文字としては、**NULL文字**が用いられる（[Null](#null)とは異なる）。[配列](#配列)により文字列を表現する[プログラミング言語](./programming.md#プログラミング言語)では、文字列の長さにNULL文字の分の1を加えたサイズの[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が必要となる。\n\n```c\n// C言語\n\nint main()\n{\n    // 文字列リテラル\n    char str[] = \"All roads lead to Rome.\";\n    printf(\"str: %s\\n\", str);\n\n    return 0;\n}\n```\n\n\n"},{"term":"文字列リテラル","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"文字列型","content":"\n**文字列型**( `string` )は、複数の文字からなる文字列を表現するための[型](#型)。[文字型](#文字型)には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合は[プログラミング言語](./programming.md#プログラミング言語)ごとに用意されている文字列型を用いる。文字列型の[オブジェクト](#オブジェクト型)を用意している場合もあれば、[文字型](#文字型)の[配列](#配列)を文字列として扱う言語もある。\n\n[ソースコード](./programming.md#ソースコード)中で `\"` で囲まれた部分は文字列型のデータとして扱われる（ `'` と `\"` を使い分けない[プログラミング言語](./programming.md#プログラミング言語)もある）。このようにクォーテーションで囲まれた、[ソースコード](./programming.md#ソースコード)中に直接記述された文字のことを**文字列リテラル**という。\n\n文字列の終端を判別するための特別な文字としては、**NULL文字**が用いられる（[Null](#null)とは異なる）。[配列](#配列)により文字列を表現する[プログラミング言語](./programming.md#プログラミング言語)では、文字列の長さにNULL文字の分の1を加えたサイズの[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が必要となる。\n\n```c\n// C言語\n\nint main()\n{\n    // 文字列リテラル\n    char str[] = \"All roads lead to Rome.\";\n    printf(\"str: %s\\n\", str);\n\n    return 0;\n}\n```\n\n\n"},{"term":"NULL文字","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"文字列型","content":"\n**文字列型**( `string` )は、複数の文字からなる文字列を表現するための[型](#型)。[文字型](#文字型)には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合は[プログラミング言語](./programming.md#プログラミング言語)ごとに用意されている文字列型を用いる。文字列型の[オブジェクト](#オブジェクト型)を用意している場合もあれば、[文字型](#文字型)の[配列](#配列)を文字列として扱う言語もある。\n\n[ソースコード](./programming.md#ソースコード)中で `\"` で囲まれた部分は文字列型のデータとして扱われる（ `'` と `\"` を使い分けない[プログラミング言語](./programming.md#プログラミング言語)もある）。このようにクォーテーションで囲まれた、[ソースコード](./programming.md#ソースコード)中に直接記述された文字のことを**文字列リテラル**という。\n\n文字列の終端を判別するための特別な文字としては、**NULL文字**が用いられる（[Null](#null)とは異なる）。[配列](#配列)により文字列を表現する[プログラミング言語](./programming.md#プログラミング言語)では、文字列の長さにNULL文字の分の1を加えたサイズの[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が必要となる。\n\n```c\n// C言語\n\nint main()\n{\n    // 文字列リテラル\n    char str[] = \"All roads lead to Rome.\";\n    printf(\"str: %s\\n\", str);\n\n    return 0;\n}\n```\n\n\n"},{"term":"オブジェクト型","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"オブジェクト型","content":"\n**オブジェクト型**は、[オブジェクト指向](./object_oriented.md#オブジェクト指向)の[プログラミング言語](./programming.md#プログラミング言語)において、[クラス](./object_oriented.md#クラス)から生成された[オブジェクト](./object_oriented.md#オブジェクト)を指すデータ[型](#型)。\n\n\n"},{"term":"ディープコピー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ディープコピー","content":"\n**ディープコピー**は、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上のデータの実体を別の[メモリアドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)にそのまま複製する方法。多くの[プログラミング言語](./programming.md#プログラミング言語)では、[プリミティブ型](#プリミティブ型)のデータの複製はディープコピーによって行われる。\n\n[コンテナ型](#コンテナ型)や[オブジェクト型](#オブジェクト型)のデータは多くの[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域を必要とするため、ディープコピーのコストが大きくなる。そのため、明示しない限りは[シャローコピー](#シャローコピー)となる[プログラミング言語](./programming.md#プログラミング言語)が多い。このような特徴から、ディープコピーは**高価なコピー**であるとされ、無駄なディープコピーは避けるべきである。\n\n[可変長配列](#配列)のデータを追加するときに、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)不足が発生した場合、より広い[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が[アロケート](./programming.md#アロケート)され、確保した領域に元のデータがディープコピーされる。\n\n"},{"term":"高価なコピー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"ディープコピー","content":"\n**ディープコピー**は、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上のデータの実体を別の[メモリアドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)にそのまま複製する方法。多くの[プログラミング言語](./programming.md#プログラミング言語)では、[プリミティブ型](#プリミティブ型)のデータの複製はディープコピーによって行われる。\n\n[コンテナ型](#コンテナ型)や[オブジェクト型](#オブジェクト型)のデータは多くの[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域を必要とするため、ディープコピーのコストが大きくなる。そのため、明示しない限りは[シャローコピー](#シャローコピー)となる[プログラミング言語](./programming.md#プログラミング言語)が多い。このような特徴から、ディープコピーは**高価なコピー**であるとされ、無駄なディープコピーは避けるべきである。\n\n[可変長配列](#配列)のデータを追加するときに、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)不足が発生した場合、より広い[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が[アロケート](./programming.md#アロケート)され、確保した領域に元のデータがディープコピーされる。\n\n"},{"term":"シャローコピー","link":"./note/ja/./programming/_/chapters/data_type.md","flagment":"シャローコピー","content":"\n**シャローコピー**は、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上のデータ[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を指す[ポインタ](#ポインタ型)を取得する方式。コピー元と同じデータを指し示す[ポインタ](#ポインタ型)を取得する見かけ上のコピーであるため、データの実体が書き換えられると、コピー元もコピー先もデータが置き換わったように見える。そのため、コピー元かコピー先のどちらかのデータだけを変更したいような場合には[ディープコピー](#ディープコピー)を用いる必要がある。\n\n[コンテナ型](#コンテナ型)や[オブジェクト型](#オブジェクト型)のデータは[ディープコピー](#ディープコピー)にかかるコストが大きいため、シャローコピーを用いることで複製のコストが抑えられる。\n"},{"term":"演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"演算","content":"\n**演算**は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを**演算子**（**オペレータ**）、演算対象となるデータのことを**被演算子**（**オペランド**）という。各[プログラミング言語](./programming.md#プログラミング言語)で用いられる演算子は基本的に共通しているものが多い。\n\n\n"},{"term":"演算子（オペレータ）","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"演算","content":"\n**演算**は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを**演算子**（**オペレータ**）、演算対象となるデータのことを**被演算子**（**オペランド**）という。各[プログラミング言語](./programming.md#プログラミング言語)で用いられる演算子は基本的に共通しているものが多い。\n\n\n"},{"term":"被演算子（オペランド）","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"演算","content":"\n**演算**は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを**演算子**（**オペレータ**）、演算対象となるデータのことを**被演算子**（**オペランド**）という。各[プログラミング言語](./programming.md#プログラミング言語)で用いられる演算子は基本的に共通しているものが多い。\n\n\n"},{"term":"算術演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"算術演算","content":"\n**算術演算**は、加算や減算、乗算、除算、剰余（モジュロ演算）といった数学的な[演算](#演算)処理。算術演算の優先度に関するルールについては、通常の数学で用いられるものと同様である場合が多い。\n\n| 演算                 | 演算子 |\n|----------------------|--------|\n| 加算                 | `+`    |\n| 減算                 | `-`    |\n| 乗算                 | `*`    |\n| 除算                 | `/`    |\n| 剰余（モジュロ演算） | `%`    |\n\n\n"},{"term":"比較演算（関係演算）","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"比較演算","content":"\n**比較演算**（**関係演算**）は、左右の[オペランド](#演算)を比較して、結果として[真偽値](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#真偽値)を返却するような[演算](#演算)。[プログラミング言語](./programming.md#プログラミング言語)によっては、等価・非等価の[演算](#演算)は[型](./data_type.md#型)の比較を行わず、曖昧な結果を返却する場合もある（[文字型](./data_type.md#文字型)の `'1'` と[整数型](./data_type.md#整数型)の `1` を同値として扱うなど）。このような言語では、[型](./data_type.md#型)の比較も同時に行う厳密な等価・非等価の[演算子](#演算)として、 `===` および `!==` を用いることが一般的である。\n\n| 演算                     | 演算子 |\n|--------------------------|--------|\n| 大なり                   | `>`    |\n| 大なりイコール           | `>=`   |\n| 小なり                   | `<`    |\n| 小なりイコール           | `<=`   |\n| イコール（同値）         | `==`   |\n| ノットイコール（非同値） | `!=`   |\n\n\n"},{"term":"代入演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"代入演算","content":"\n**代入演算**は、左側の[オペランド](#演算)に対して右側の[オペランド](#演算)の値を代入する[演算](#演算)。また[代入](./variable.md#代入)の際に、左側の[オペランド](#演算)の元の値と右側の[オペランド](#演算)の[算術演算](#算術演算)を行った結果の[再代入](./variable.md#代入)を行う、**複合代入演算**をサポートする[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n| 演算         | 演算子 |\n|--------------|--------|\n| 代入         | `=`    |\n| 加算して代入 | `+=`   |\n| 減算して代入 | `-=`   |\n| 乗算して代入 | `*=`   |\n| 除算して代入 | `/=`   |\n| 剰余を代入   | `%=`   |\n\n\n"},{"term":"複合代入演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"代入演算","content":"\n**代入演算**は、左側の[オペランド](#演算)に対して右側の[オペランド](#演算)の値を代入する[演算](#演算)。また[代入](./variable.md#代入)の際に、左側の[オペランド](#演算)の元の値と右側の[オペランド](#演算)の[算術演算](#算術演算)を行った結果の[再代入](./variable.md#代入)を行う、**複合代入演算**をサポートする[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n| 演算         | 演算子 |\n|--------------|--------|\n| 代入         | `=`    |\n| 加算して代入 | `+=`   |\n| 減算して代入 | `-=`   |\n| 乗算して代入 | `*=`   |\n| 除算して代入 | `/=`   |\n| 剰余を代入   | `%=`   |\n\n\n"},{"term":"論理演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"論理演算","content":"\n**論理演算**は、[オペランド](#演算)に[真偽値](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#真偽値)をとり、複数の条件を組み合わせた新しい条件を評価する[演算](#演算)。論理演算子を組み合わせることで、複雑な条件を表現することができる。\n\n| 演算        | 演算子 | 概要                                                            |\n|-------------|--------|-----------------------------------------------------------------|\n| 論理積(AND) | `&&`   | 左右のオペランドが両方 `true` であれば `true`                   |\n| 論理和(OR)  | `||`   | 左右のオペランドの一方でも `true` であれば `true`               |\n| 否定(NOT)   | `!`    | オペランドが `true` であれば `false` 、 `false` であれば `true` |\n\n\n"},{"term":"ビット演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"ビット演算","content":"\n**ビット演算**は、[オペランド](#演算)を[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列とみなして、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)単位での[演算](#演算)を行う。\n\n| 演算           | 演算子 | 概要                                                                                        |\n|----------------|--------|---------------------------------------------------------------------------------------------|\n| ビットAND      | `&`    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           |\n| ビットOR       | `|`    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す |\n| ビットXOR      | `^`    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  |\n| ビットNOT      | `~`    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   |\n| 右ビットシフト | `>>`   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          |\n| 左ビットシフト | `<<`   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |\n\n**右ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $1/2$ 倍になり、**左ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $2$ 倍になる。\n\n**論理ビットシフト**では、[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)演算後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を常に `0` で初期化する。**算術ビットシフト**では、右[シフト](../../../basics/_/chapters/computer_and_number.md#ビット)を行った後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を[符号ビット](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#符号ビット)で初期化する。\n\n"},{"term":"右ビットシフト","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"ビット演算","content":"\n**ビット演算**は、[オペランド](#演算)を[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列とみなして、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)単位での[演算](#演算)を行う。\n\n| 演算           | 演算子 | 概要                                                                                        |\n|----------------|--------|---------------------------------------------------------------------------------------------|\n| ビットAND      | `&`    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           |\n| ビットOR       | `|`    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す |\n| ビットXOR      | `^`    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  |\n| ビットNOT      | `~`    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   |\n| 右ビットシフト | `>>`   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          |\n| 左ビットシフト | `<<`   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |\n\n**右ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $1/2$ 倍になり、**左ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $2$ 倍になる。\n\n**論理ビットシフト**では、[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)演算後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を常に `0` で初期化する。**算術ビットシフト**では、右[シフト](../../../basics/_/chapters/computer_and_number.md#ビット)を行った後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を[符号ビット](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#符号ビット)で初期化する。\n\n"},{"term":"左ビットシフト","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"ビット演算","content":"\n**ビット演算**は、[オペランド](#演算)を[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列とみなして、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)単位での[演算](#演算)を行う。\n\n| 演算           | 演算子 | 概要                                                                                        |\n|----------------|--------|---------------------------------------------------------------------------------------------|\n| ビットAND      | `&`    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           |\n| ビットOR       | `|`    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す |\n| ビットXOR      | `^`    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  |\n| ビットNOT      | `~`    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   |\n| 右ビットシフト | `>>`   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          |\n| 左ビットシフト | `<<`   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |\n\n**右ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $1/2$ 倍になり、**左ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $2$ 倍になる。\n\n**論理ビットシフト**では、[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)演算後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を常に `0` で初期化する。**算術ビットシフト**では、右[シフト](../../../basics/_/chapters/computer_and_number.md#ビット)を行った後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を[符号ビット](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#符号ビット)で初期化する。\n\n"},{"term":"論理ビットシフト","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"ビット演算","content":"\n**ビット演算**は、[オペランド](#演算)を[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列とみなして、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)単位での[演算](#演算)を行う。\n\n| 演算           | 演算子 | 概要                                                                                        |\n|----------------|--------|---------------------------------------------------------------------------------------------|\n| ビットAND      | `&`    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           |\n| ビットOR       | `|`    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す |\n| ビットXOR      | `^`    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  |\n| ビットNOT      | `~`    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   |\n| 右ビットシフト | `>>`   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          |\n| 左ビットシフト | `<<`   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |\n\n**右ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $1/2$ 倍になり、**左ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $2$ 倍になる。\n\n**論理ビットシフト**では、[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)演算後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を常に `0` で初期化する。**算術ビットシフト**では、右[シフト](../../../basics/_/chapters/computer_and_number.md#ビット)を行った後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を[符号ビット](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#符号ビット)で初期化する。\n\n"},{"term":"算術ビットシフト","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"ビット演算","content":"\n**ビット演算**は、[オペランド](#演算)を[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列とみなして、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)単位での[演算](#演算)を行う。\n\n| 演算           | 演算子 | 概要                                                                                        |\n|----------------|--------|---------------------------------------------------------------------------------------------|\n| ビットAND      | `&`    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           |\n| ビットOR       | `|`    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す |\n| ビットXOR      | `^`    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  |\n| ビットNOT      | `~`    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   |\n| 右ビットシフト | `>>`   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          |\n| 左ビットシフト | `<<`   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |\n\n**右ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $1/2$ 倍になり、**左ビットシフト**は1[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)するごとに値が元の $2$ 倍になる。\n\n**論理ビットシフト**では、[シフト](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#シフト演算)演算後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を常に `0` で初期化する。**算術ビットシフト**では、右[シフト](../../../basics/_/chapters/computer_and_number.md#ビット)を行った後の空き[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)を[符号ビット](../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#符号ビット)で初期化する。\n\n"},{"term":"インクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"インクリメント","content":"\n**インクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1増加させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。インクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミングン言語)もある。\n\n**前置インクリメント**は、データをインクリメントしてからその値を返却する。**後置インクリメント**は、データを返却してからインクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置インクリメント\n++x;\n\n// 後置インクリメント\nx++;\n```\n\n\n"},{"term":"前置インクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"インクリメント","content":"\n**インクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1増加させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。インクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミングン言語)もある。\n\n**前置インクリメント**は、データをインクリメントしてからその値を返却する。**後置インクリメント**は、データを返却してからインクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置インクリメント\n++x;\n\n// 後置インクリメント\nx++;\n```\n\n\n"},{"term":"後置インクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"インクリメント","content":"\n**インクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1増加させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。インクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミングン言語)もある。\n\n**前置インクリメント**は、データをインクリメントしてからその値を返却する。**後置インクリメント**は、データを返却してからインクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置インクリメント\n++x;\n\n// 後置インクリメント\nx++;\n```\n\n\n"},{"term":"デクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"デクリメント","content":"\n**デクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1減少させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。デクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n**前置デクリメント**は、データをデクリメントしてからその値を返却する。**後置デクリメント**は、データを返却してからデクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置デクリメント\n--x;\n\n// 後置デクリメント\nx--;\n```\n\n\n"},{"term":"前置デクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"デクリメント","content":"\n**デクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1減少させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。デクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n**前置デクリメント**は、データをデクリメントしてからその値を返却する。**後置デクリメント**は、データを返却してからデクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置デクリメント\n--x;\n\n// 後置デクリメント\nx--;\n```\n\n\n"},{"term":"後置デクリメント","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"デクリメント","content":"\n**デクリメント**は、[整数型](./data_type.md#整数型)の[オペランド](#演算)の値を1減少させる[演算](#演算)。カウンタ[変数](./variable.md#変数)のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。デクリメント演算子をサポートしていない[プログラミング言語](./programming.md#プログラミング言語)もある。\n\n**前置デクリメント**は、データをデクリメントしてからその値を返却する。**後置デクリメント**は、データを返却してからデクリメントする。微妙な動作のずれに繋がるため注意が必要。\n\n```c\n// C言語\n\n// 前置デクリメント\n--x;\n\n// 後置デクリメント\nx--;\n```\n\n\n"},{"term":"三項演算","link":"./note/ja/./programming/_/chapters/operation.md","flagment":"三項演算","content":"\n**三項演算**は、条件式に応じて返却する値を切り替えるような[演算](#演算)。通常の[演算](#演算)が[オペランド](#演算)を1つあるいは2つしかとらないのに対して、三項演算では3つの[オペランド](#演算)をとるのが特徴。\n\n一般的には次のような記法を用いる。\n\n```\n<条件式> ? <真式> : <偽式>\n```\n\n```php\n<?php\n\n// PHP\n\n// 代入演算子の右側のオペランドが三項演算で構成されているパターン\n// $yが20以下なら$y + 5の結果が、20より大きければ20が$xに代入される\n$y = $_POST[\"input_num\"];\n$x = $y <= 20 ? $y + 5 : 20;\n\n?>\n```\n\n三項演算子をサポートしていない[プログラミング言語](./programming.md#プログラミング言語)もある。\n"},{"term":"制御フロー","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"制御フロー","content":"\n**制御フロー**は、[プログラム](./programming.md#プログラム)の処理の流れ。制御フローを記述するための[プログラミング言語](./programming.md#プログラミング言語)の[文法](./programming.md#文法)を、**制御構文**という。\n\n[プログラム](./programming.md#プログラム)は通常、上から下へと順次実行されていくが、制御構文を用いることで、処理の流れを[分岐](#条件分岐)させたり、[繰り返し](#反復)同じ処理をさせたりすることができる。\n\n"},{"term":"制御構文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"制御フロー","content":"\n**制御フロー**は、[プログラム](./programming.md#プログラム)の処理の流れ。制御フローを記述するための[プログラミング言語](./programming.md#プログラミング言語)の[文法](./programming.md#文法)を、**制御構文**という。\n\n[プログラム](./programming.md#プログラム)は通常、上から下へと順次実行されていくが、制御構文を用いることで、処理の流れを[分岐](#条件分岐)させたり、[繰り返し](#反復)同じ処理をさせたりすることができる。\n\n"},{"term":"ネスト（入れ子）","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"ネスト","content":"\n**ネスト**（**入れ子**）は、[制御構文](#制御フロー)中でさらに別の[制御構文](#制御フロー)を記述する構造。\n\n\n"},{"term":"ブロック","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"ブロック","content":"\n**ブロック**は、[ソースコード](./programming.md#ソースコード)中で処理をまとめたもの。多くの[プログラミング言語](./programming.md#プログラミング言語)ではブロックは `{}` で囲まれた範囲となる。[Python](./programming_language.md#python)のようにインデントにより処理ブロックを表現するものもある。\n\nブロックは入れ子にすることもできる。\n\n"},{"term":"スコープ","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"スコープ","content":"\n**スコープ**は、[変数](./variable.md#変数)や[関数](./function.md#関数)などの[識別子](./programming.md#識別子)を参照できる範囲。[変数](./variable.md#変数)などが[宣言](./variable.md#宣言)される位置などによって決定される。スコープは、[宣言](./variable.md#宣言)された場所から[宣言](./variable.md#宣言)された[ブロック](#ブロック)の終わりまでとなる。\n\n```javascript\n// JavaScript\n\n{\n    // 変数xを初期化\n    let x = 1;\n\n    {\n        // 変数yを初期化\n        let y = 3;\n\n        // 変数x, yのスコープ内なので、問題ない\n        console.log(x);\n        console.log(y);\n\n        x = x + y;\n    }\n\n    // 変数xのスコープ内なので問題ない\n    console.log(x);\n\n    // 変数yのスコープ外なのでエラーとなる\n    console.log(y);\n}\n```\n\n"},{"term":"グローバル","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"グローバル","content":"\n**グローバル**とは、[ソースコード](./programming.md#ソースコード)全体が[スコープ](#スコープ)となっているデータ（[変数](./variable.md#変数)）。グローバルなデータには、全ての[関数](./function.md#関数)から直接アクセスすることができる。更新されるタイミングがわかりにくかったり、予想外のデータとなってしまうことから[バグ](./programming.md#バグ)を生みやすいため、扱いには注意が必要。\n\n"},{"term":"ローカル","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"ローカル","content":"\n**ローカル**とは、そのデータが[宣言](./variable.md#宣言)された[関数](./function.md#関数)内でしか[参照](./variable.md#参照)できないデータ（[スコープ](#スコープ)が[関数](./function.md#関数)内に閉じられている[変数](./variable.md#変数)）。\n\n"},{"term":"条件分岐","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"条件分岐","content":"\n**条件分岐**は、与えられた条件式の結果によって実行する処理[ブロック](#ブロック)を切り替えるような構文。\n\n"},{"term":"if文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"if文","content":"\n`if` 文は、与えられた条件式を評価し、それが `true` （言語によっては `true` に類するもの（[整数型](./data_type.md#整数型)の `0` 以外や[文字列型](./data_type.md#文字列型)で空文字でない場合等）が含まれる場合もある）であれば、直後の処理[ブロック](#ブロック)を実行する。\n\n```c\n// C言語\n\n"},{"term":"else文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"if文","content":"\n`if` 文は、与えられた条件式を評価し、それが `true` （言語によっては `true` に類するもの（[整数型](./data_type.md#整数型)の `0` 以外や[文字列型](./data_type.md#文字列型)で空文字でない場合等）が含まれる場合もある）であれば、直後の処理[ブロック](#ブロック)を実行する。\n\n```c\n// C言語\n\n"},{"term":"switch文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"switch文","content":"\n`switch` 文は、与えられた式を評価した結果に応じて処理を分岐する構文。与えられた式を `case` 節にある値と比較し、等価であればその節の処理[ブロック](#ブロック)を実行する。また、 `default` 節が用意されている場合は、全ての条件に対してその処理[ブロック](#ブロック)が実行される。\n\n`case` の処理[ブロック](#ブロック)の最後に `break` 文を記述した場合は、その処理[ブロック](#ブロック)の実行後に即座に `switch` 文を抜ける。一方で `break` 文を省略した場合には、条件に合致した処理[ブロック](#ブロック)を実行した後に、次に条件に合致するものがあればその処理[ブロック](#ブロック)を続けて実行する。 `default` 節がある `swtich` 文においては、意図しない処理[ブロック](#ブロック)が実行されてしまわないように適切に `break` 文を用いる必要がある。\n\n```c\n// C言語\n\n"},{"term":"case節","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"switch文","content":"\n`switch` 文は、与えられた式を評価した結果に応じて処理を分岐する構文。与えられた式を `case` 節にある値と比較し、等価であればその節の処理[ブロック](#ブロック)を実行する。また、 `default` 節が用意されている場合は、全ての条件に対してその処理[ブロック](#ブロック)が実行される。\n\n`case` の処理[ブロック](#ブロック)の最後に `break` 文を記述した場合は、その処理[ブロック](#ブロック)の実行後に即座に `switch` 文を抜ける。一方で `break` 文を省略した場合には、条件に合致した処理[ブロック](#ブロック)を実行した後に、次に条件に合致するものがあればその処理[ブロック](#ブロック)を続けて実行する。 `default` 節がある `swtich` 文においては、意図しない処理[ブロック](#ブロック)が実行されてしまわないように適切に `break` 文を用いる必要がある。\n\n```c\n// C言語\n\n"},{"term":"default節","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"switch文","content":"\n`switch` 文は、与えられた式を評価した結果に応じて処理を分岐する構文。与えられた式を `case` 節にある値と比較し、等価であればその節の処理[ブロック](#ブロック)を実行する。また、 `default` 節が用意されている場合は、全ての条件に対してその処理[ブロック](#ブロック)が実行される。\n\n`case` の処理[ブロック](#ブロック)の最後に `break` 文を記述した場合は、その処理[ブロック](#ブロック)の実行後に即座に `switch` 文を抜ける。一方で `break` 文を省略した場合には、条件に合致した処理[ブロック](#ブロック)を実行した後に、次に条件に合致するものがあればその処理[ブロック](#ブロック)を続けて実行する。 `default` 節がある `swtich` 文においては、意図しない処理[ブロック](#ブロック)が実行されてしまわないように適切に `break` 文を用いる必要がある。\n\n```c\n// C言語\n\n"},{"term":"反復（ループ）","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"反復","content":"\n**反復**（**ループ**）は、条件に応じて特定の処理[ブロック](#ブロック)を複数回実行するための構文。\n\n"},{"term":"break文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"break文","content":"\n`break` 文は、現在実行中の[ループ](#反復)処理[ブロック](#ブロック)の[反復](#反復)処理を中断し、処理を次に進める[制御構文](#制御フロー)。 `swtich` 文でも利用される。[ループ](#反復)文を[ネスト](#ネスト)した多重[ループ](#反復)においては、 `break` 文から見て最も内側の（近い）[ループ](#反復)から抜け出す。\n\n"},{"term":"continue文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"continue文","content":"\n`continue` 文は、現在実行中の[ループ](#反復)処理[ブロック](#ブロック)を中断して、次の[ループ](#反復)を実行する（[ループ](#反復)処理[ブロック](#ブロック)の先頭に戻る）ための[制御構文](#制御フロー)。[ループ](#反復)文を[ネスト](#ネスト)した多重[ループ](#反復)においては、 `continue` 文から見て最も内側の（近い）[ループ](#反復)の処理を継続する。\n\n"},{"term":"while文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"while文","content":"\n`while` 文は、与えられた条件式を評価して、それが `true` （言語によっては `true` に類するもの（[整数型](./data_type.md#整数型)の `0` 以外や[文字列型](./data_type.md#文字列型)で空文字でない場合等）が含まれる場合もある）である間、直後の処理[ブロック](#ブロック)を実行する。\n\n```c\n// C言語\n\n"},{"term":"do while文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"do-while文","content":""},{"term":"for文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for文","content":"\n`for` 文は、[ループ](#反復)の回数を数える**カウンタ変数**を用いて、カウンタ変数に関する条件式を評価しながら[反復](#反復)処理を行う。[ループ](#反復)開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 `while` 文を用いても同様の処理は実現できるが、 `for` 文を用いるとより簡潔に記述することができる。一般的な `for` 文の書式は以下の通り。\n\n```\nfor( 初期化式; 条件式; 更新式 )\n{\n    // 実行する処理ブロック\n}\n```\n\n**初期化式**には、カウンタ変数の初期化を行う処理を記述する。**条件式**には、 [ループ](#反復)を[反復](#反復)する条件を記述し、結果が `true` となる間処理を繰り返す。**更新式**には、[ループ](#反復)が1回終わったときの更新処理を記述する。\n\n```c\n// C言語\n\nint main()\n{\n    for( int i=0; i<20; i++ )\n    {\n        printf(\"%d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n```php\n<?php\n\n// PHP\n\nfor( $i=0; $i<20; $i++ )\n{\n    echo($i);\n}\n\n?>\n```\n\n"},{"term":"カウンタ変数","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for文","content":"\n`for` 文は、[ループ](#反復)の回数を数える**カウンタ変数**を用いて、カウンタ変数に関する条件式を評価しながら[反復](#反復)処理を行う。[ループ](#反復)開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 `while` 文を用いても同様の処理は実現できるが、 `for` 文を用いるとより簡潔に記述することができる。一般的な `for` 文の書式は以下の通り。\n\n```\nfor( 初期化式; 条件式; 更新式 )\n{\n    // 実行する処理ブロック\n}\n```\n\n**初期化式**には、カウンタ変数の初期化を行う処理を記述する。**条件式**には、 [ループ](#反復)を[反復](#反復)する条件を記述し、結果が `true` となる間処理を繰り返す。**更新式**には、[ループ](#反復)が1回終わったときの更新処理を記述する。\n\n```c\n// C言語\n\nint main()\n{\n    for( int i=0; i<20; i++ )\n    {\n        printf(\"%d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n```php\n<?php\n\n// PHP\n\nfor( $i=0; $i<20; $i++ )\n{\n    echo($i);\n}\n\n?>\n```\n\n"},{"term":"初期化式","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for文","content":"\n`for` 文は、[ループ](#反復)の回数を数える**カウンタ変数**を用いて、カウンタ変数に関する条件式を評価しながら[反復](#反復)処理を行う。[ループ](#反復)開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 `while` 文を用いても同様の処理は実現できるが、 `for` 文を用いるとより簡潔に記述することができる。一般的な `for` 文の書式は以下の通り。\n\n```\nfor( 初期化式; 条件式; 更新式 )\n{\n    // 実行する処理ブロック\n}\n```\n\n**初期化式**には、カウンタ変数の初期化を行う処理を記述する。**条件式**には、 [ループ](#反復)を[反復](#反復)する条件を記述し、結果が `true` となる間処理を繰り返す。**更新式**には、[ループ](#反復)が1回終わったときの更新処理を記述する。\n\n```c\n// C言語\n\nint main()\n{\n    for( int i=0; i<20; i++ )\n    {\n        printf(\"%d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n```php\n<?php\n\n// PHP\n\nfor( $i=0; $i<20; $i++ )\n{\n    echo($i);\n}\n\n?>\n```\n\n"},{"term":"条件式","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for文","content":"\n`for` 文は、[ループ](#反復)の回数を数える**カウンタ変数**を用いて、カウンタ変数に関する条件式を評価しながら[反復](#反復)処理を行う。[ループ](#反復)開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 `while` 文を用いても同様の処理は実現できるが、 `for` 文を用いるとより簡潔に記述することができる。一般的な `for` 文の書式は以下の通り。\n\n```\nfor( 初期化式; 条件式; 更新式 )\n{\n    // 実行する処理ブロック\n}\n```\n\n**初期化式**には、カウンタ変数の初期化を行う処理を記述する。**条件式**には、 [ループ](#反復)を[反復](#反復)する条件を記述し、結果が `true` となる間処理を繰り返す。**更新式**には、[ループ](#反復)が1回終わったときの更新処理を記述する。\n\n```c\n// C言語\n\nint main()\n{\n    for( int i=0; i<20; i++ )\n    {\n        printf(\"%d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n```php\n<?php\n\n// PHP\n\nfor( $i=0; $i<20; $i++ )\n{\n    echo($i);\n}\n\n?>\n```\n\n"},{"term":"更新式","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for文","content":"\n`for` 文は、[ループ](#反復)の回数を数える**カウンタ変数**を用いて、カウンタ変数に関する条件式を評価しながら[反復](#反復)処理を行う。[ループ](#反復)開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 `while` 文を用いても同様の処理は実現できるが、 `for` 文を用いるとより簡潔に記述することができる。一般的な `for` 文の書式は以下の通り。\n\n```\nfor( 初期化式; 条件式; 更新式 )\n{\n    // 実行する処理ブロック\n}\n```\n\n**初期化式**には、カウンタ変数の初期化を行う処理を記述する。**条件式**には、 [ループ](#反復)を[反復](#反復)する条件を記述し、結果が `true` となる間処理を繰り返す。**更新式**には、[ループ](#反復)が1回終わったときの更新処理を記述する。\n\n```c\n// C言語\n\nint main()\n{\n    for( int i=0; i<20; i++ )\n    {\n        printf(\"%d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n```php\n<?php\n\n// PHP\n\nfor( $i=0; $i<20; $i++ )\n{\n    echo($i);\n}\n\n?>\n```\n\n"},{"term":"for in文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for-in文","content":""},{"term":"loop文","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for-in文","content":""},{"term":"無限ループ","link":"./note/ja/./programming/_/chapters/control_flow.md","flagment":"for-in文","content":""},{"term":"関数（サブルーチン、手続き、プロシージャ）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"関数","content":"\n**関数**（**サブルーチン**、**手続き**、**プロシージャ**）は、データを受け取り、定められた特定の処理を実行して、その結果を返す命令[ブロック](./control_flow.md#ブロック)。関数には[プログラマ](./programming.md#プログラマ)が任意の[識別子](./programming.md#識別子)をつけることができる（ `main` 関数のような特別な意味を持つ関数については除く）。関数につけられた[識別子](./programming.md#識別子)を[ソースコード](./programming.md#ソースコード)中に記すことで、その命令[ブロック](./control_flow.md#ブロック)を呼び出すことができる。\n\n関数を用いることで、[プログラム](./programming.md#プログラム)の再利用性やメンテナンス性が向上するという利点がある。\n\n"},{"term":"引数（パラメータ）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"引数","content":"\n**引数**（**パラメータ**）は、[関数](#関数)が呼び出されるときに、[関数](#関数)の呼び出し元から受け取るデータ。[関数](#関数)を定義する際には、受け取る情報に任意の[識別子](./programming.md#識別子)を用いた**仮引数**を用いて処理を記述する。[関数呼び出し](#関数呼び出し)の際に実際に処理したい情報を**実引数**として[関数](#関数)に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。\n\n引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、[関数呼び出し](#関数呼び出し)の際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を**オプション引数**（**デフォルト引数**、**任意引数**）という。[関数定義](#関数定義)の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、**可変長引数**をサポートしている言語もある（文字列のフォーマットなどによく利用される）。\n\n"},{"term":"仮引数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"引数","content":"\n**引数**（**パラメータ**）は、[関数](#関数)が呼び出されるときに、[関数](#関数)の呼び出し元から受け取るデータ。[関数](#関数)を定義する際には、受け取る情報に任意の[識別子](./programming.md#識別子)を用いた**仮引数**を用いて処理を記述する。[関数呼び出し](#関数呼び出し)の際に実際に処理したい情報を**実引数**として[関数](#関数)に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。\n\n引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、[関数呼び出し](#関数呼び出し)の際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を**オプション引数**（**デフォルト引数**、**任意引数**）という。[関数定義](#関数定義)の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、**可変長引数**をサポートしている言語もある（文字列のフォーマットなどによく利用される）。\n\n"},{"term":"実引数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"引数","content":"\n**引数**（**パラメータ**）は、[関数](#関数)が呼び出されるときに、[関数](#関数)の呼び出し元から受け取るデータ。[関数](#関数)を定義する際には、受け取る情報に任意の[識別子](./programming.md#識別子)を用いた**仮引数**を用いて処理を記述する。[関数呼び出し](#関数呼び出し)の際に実際に処理したい情報を**実引数**として[関数](#関数)に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。\n\n引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、[関数呼び出し](#関数呼び出し)の際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を**オプション引数**（**デフォルト引数**、**任意引数**）という。[関数定義](#関数定義)の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、**可変長引数**をサポートしている言語もある（文字列のフォーマットなどによく利用される）。\n\n"},{"term":"オプション引数（デフォルト引数、任意引数）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"引数","content":"\n**引数**（**パラメータ**）は、[関数](#関数)が呼び出されるときに、[関数](#関数)の呼び出し元から受け取るデータ。[関数](#関数)を定義する際には、受け取る情報に任意の[識別子](./programming.md#識別子)を用いた**仮引数**を用いて処理を記述する。[関数呼び出し](#関数呼び出し)の際に実際に処理したい情報を**実引数**として[関数](#関数)に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。\n\n引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、[関数呼び出し](#関数呼び出し)の際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を**オプション引数**（**デフォルト引数**、**任意引数**）という。[関数定義](#関数定義)の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、**可変長引数**をサポートしている言語もある（文字列のフォーマットなどによく利用される）。\n\n"},{"term":"可変長引数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"引数","content":"\n**引数**（**パラメータ**）は、[関数](#関数)が呼び出されるときに、[関数](#関数)の呼び出し元から受け取るデータ。[関数](#関数)を定義する際には、受け取る情報に任意の[識別子](./programming.md#識別子)を用いた**仮引数**を用いて処理を記述する。[関数呼び出し](#関数呼び出し)の際に実際に処理したい情報を**実引数**として[関数](#関数)に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。\n\n引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、[関数呼び出し](#関数呼び出し)の際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を**オプション引数**（**デフォルト引数**、**任意引数**）という。[関数定義](#関数定義)の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、**可変長引数**をサポートしている言語もある（文字列のフォーマットなどによく利用される）。\n\n"},{"term":"戻り値","link":"./note/ja/./programming/_/chapters/function.md","flagment":"戻り値","content":"\n**戻り値**は、[関数](#関数)の命令[ブロック](./control_flow.md#ブロック)が実行された結果として、[関数](#関数)の呼び出し元に返されるデータ。[関数](#関数)の戻り値は `return` キーワードを用いて記述する。戻り値は通常1つしか返すことができないため、複数の値を返したいような場合には、値を[オブジェクト](./object_oriented.md#オブジェクト)として返却したり、[引数](#引数)として受け取った[ポインタ](./data_type.md#ポインタ型)に直接結果を書き込んだりする。\n\n[関数](#関数)内部で[宣言](./variable.md#宣言)された[ローカル変数](./variable.md#ローカル変数)は、[関数](#関数)の処理[ブロック](./control_flow.md#ブロック)内部のみで有効な[変数](./variable.md#変数)であり、戻り値として使用するには注意が必要となる。戻り値として返却されるデータが[プリミティブ型](./data_type.md#プリミティブ型)の場合はデータが[ディープコピー](./data_type.md#ディープコピー)されるが、[複合型](./variable.md#複合型)の値を返却しようとした場合に[シャローコピー](./data_type.md#シャローコピー)が発生する可能性がある。このような場合、[ローカル変数](./variable.md#ローカル変数)は[関数](#関数)の実行が終了されると破棄されるため、戻り値が[ダングリングポインタ](./programming_language.md#ダンリングポインタ)となってしまう場合がある。そのため、明示的に確保した[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に格納したデータの[ポインタ](./data_type.md#ポインタ型)を返却したり、[引数](#引数)として受け取った[ポインタ](./data_type.md#ポインタ型)に直接データを格納したりといった工夫が必要となる。\n\n"},{"term":"return","link":"./note/ja/./programming/_/chapters/function.md","flagment":"戻り値","content":"\n**戻り値**は、[関数](#関数)の命令[ブロック](./control_flow.md#ブロック)が実行された結果として、[関数](#関数)の呼び出し元に返されるデータ。[関数](#関数)の戻り値は `return` キーワードを用いて記述する。戻り値は通常1つしか返すことができないため、複数の値を返したいような場合には、値を[オブジェクト](./object_oriented.md#オブジェクト)として返却したり、[引数](#引数)として受け取った[ポインタ](./data_type.md#ポインタ型)に直接結果を書き込んだりする。\n\n[関数](#関数)内部で[宣言](./variable.md#宣言)された[ローカル変数](./variable.md#ローカル変数)は、[関数](#関数)の処理[ブロック](./control_flow.md#ブロック)内部のみで有効な[変数](./variable.md#変数)であり、戻り値として使用するには注意が必要となる。戻り値として返却されるデータが[プリミティブ型](./data_type.md#プリミティブ型)の場合はデータが[ディープコピー](./data_type.md#ディープコピー)されるが、[複合型](./variable.md#複合型)の値を返却しようとした場合に[シャローコピー](./data_type.md#シャローコピー)が発生する可能性がある。このような場合、[ローカル変数](./variable.md#ローカル変数)は[関数](#関数)の実行が終了されると破棄されるため、戻り値が[ダングリングポインタ](./programming_language.md#ダンリングポインタ)となってしまう場合がある。そのため、明示的に確保した[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に格納したデータの[ポインタ](./data_type.md#ポインタ型)を返却したり、[引数](#引数)として受け取った[ポインタ](./data_type.md#ポインタ型)に直接データを格納したりといった工夫が必要となる。\n\n"},{"term":"関数定義","link":"./note/ja/./programming/_/chapters/function.md","flagment":"関数定義","content":"\n**関数定義**には、[関数](#関数)につけられた[識別子](./programming_language.md#識別子)、処理内容、[仮引数](#引数)リスト、[戻り値](#戻り値)を記述する。\n\n```c\n// C言語\n\n// 関数定義\nint add( int a_, int b_ )\n{\n    int result = a_ + b_;\n    return result;\n}\n```\n\n```php\n<?php\n\n// PHP\n\n// 関数定義\nfunction add( $a_, $b_ )\n{\n    $result = $a_ + $b_;\n    return $result;\n}\n\n?>\n```\n\n```javascript\n// JavaScript\n\nfunction add( a_, b_ )\n{\n    let result = a_ + b_;\n    return result;\n}\n```\n\n"},{"term":"関数呼び出し（コール、キック）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"関数呼び出し","content":"\n**関数呼び出し**（**コール**、**キック**）では、[関数](#関数)の[識別子](./programming.md#識別子)を記述して処理を引用し、[仮引数](#引数)リストに対応した[実引数](#引数)を渡す。\n\n```c\n// C言語\n\n// 関数プロトタイプ宣言\nint add( int, int );\n\n// メイン関数\nint main()\n{\n    int a = 5;\n    int b = 10;\n\n    // 関数呼び出し\n    int result = add(a, b);\n    printf(\"Result: %d\\n\", result);\n\n    return 0;\n}\n\n// 関数定義\nint add( int a_, int b_ )\n{\n    int result = a_ + b_;\n    return result;\n}\n```\n\n```php\n<?php\n\n// PHP\n\n// 関数定義\nfunction add( $a_, $b_ )\n{\n    $result = $a_ + $b_;\n    return $result;\n}\n\n$a = 5;\n$b = 10;\n\n// 関数呼び出し\n$result = add($a, $b);\necho(\"Result: \" . $result);\n\n?>\n```\n\n```javascript\n// JavaScript\n\n// 関数定義\nfunction add( a_, b_ )\n{\n    let result = a_ + b_;\n    return result;\n}\n\nlet a = 5;\nlet b = 10;\n\n// 関数呼び出し\nlet result = add(a, b);\nconsole.log(\"Result: \" + result);\n```\n\n"},{"term":"関数プロトタイプ宣言","link":"./note/ja/./programming/_/chapters/function.md","flagment":"関数プロトタイプ宣言","content":"\n**関数プロトタイプ宣言**は、[関数](#関数)を[ソースコード](./programming.md#ソースコード)の冒頭で宣言しておき、後から具体的な[関数定義](#関数定義)を行う記法。[C言語](./programming_language.md#c言語)などにおいては、[関数呼び出し](#関数呼び出し)よりも前に[関数](#関数)の存在が明示されている必要があるため、[関数呼び出し](#関数呼び出し)を含む部分を[関数定義](#関数定義)よりも前に記述したい場合に用いる。\n\n"},{"term":"副作用","link":"./note/ja/./programming/_/chapters/function.md","flagment":"副作用","content":"\n**副作用**は、[関数](#関数)が[関数](#関数)外の[プログラム](./programming.md#プログラム)上のデータを変化させる性質。\n\n"},{"term":"冪等性","link":"./note/ja/./programming/_/chapters/function.md","flagment":"冪等性","content":"\n**冪等性**は、同じ[関数](#関数)を繰り返し呼び出しても同じ結果が得られるという性質。\n\n\n"},{"term":"シグネチャ","link":"./note/ja/./programming/_/chapters/function.md","flagment":"シグネチャ","content":"\n**シグネチャ**は、[関数](#関数)や[メソッド](./object_oriented.md#メソッド)の名前、[引数](#引数)の数やデータ[型](./data_type.md#型)、[戻り値](#戻り値)の[型](./data_type.md#型)などの組み合わせ。[オブジェクト指向](./object_oriented.md#オブジェクト指向)の[プログラミング言語](./programming.md#プログラミング言語)において[クラス](./object_oriented.md#クラス)のインタフェースを定義する際などに用いられる。\n\n\n"},{"term":"標準関数（組み込み関数）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"標準関数","content":"\n**標準関数**（**組込み関数**）は、各[プログラミング言語](./programming.md#プログラミング言語)の仕様としてあらかじめ用意されている[関数](#関数)。使い方は通常の[関数](#関数)と同様で、仕様として定義されているため、[プログラマ](./programming.md#プログラマ)が定義し実装する必要はない。用意されている[関数](#関数)の詳細については、各[プログラミング言語](./programming.md#プログラミング言語)のドキュメントなどを参照する必要がある。\n\n\n"},{"term":"無名関数（クロージャ）","link":"./note/ja/./programming/_/chapters/function.md","flagment":"無名関数","content":"\n**無名関数**（**クロージャ**）は、[識別子](./programming.md#識別子)を持たない[関数](#関数)。**ラムダ式**を用いて、[関数](#関数)を[変数](./variable.md#変数)に格納したり、[高階関数](#高階関数)の[引数](#引数)として渡したりすることができる。\n\n\n"},{"term":"ラムダ式","link":"./note/ja/./programming/_/chapters/function.md","flagment":"無名関数","content":"\n**無名関数**（**クロージャ**）は、[識別子](./programming.md#識別子)を持たない[関数](#関数)。**ラムダ式**を用いて、[関数](#関数)を[変数](./variable.md#変数)に格納したり、[高階関数](#高階関数)の[引数](#引数)として渡したりすることができる。\n\n\n"},{"term":"高階関数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"高階関数","content":"\n**高階関数**は、[関数](#関数)の[引数](#引数)や[戻り値](#戻り値)として[関数](#関数)を用いるような[関数](#関数)。\n\n"},{"term":"コールバック関数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"コールバック関数","content":"\n**コールバック関数**は、[高階関数](#高階関数)の[引数](#引数)としてとられる[関数](#関数)。[高階関数](#高階関数)の呼び出し元が定義した[関数](#関数)を、[高階関数](#高階関数)の処理の中から呼び出し返すことからコールバックと呼ばれる。\n\n例えば、非同期処理を扱う[高階関数](#高階関数)に、非同期操作が完了した後に行いたい処理をコールバックとして渡しておくといった使い方がある（**非同期コールバック**）。\n\n\n"},{"term":"非同期コールバック","link":"./note/ja/./programming/_/chapters/function.md","flagment":"コールバック関数","content":"\n**コールバック関数**は、[高階関数](#高階関数)の[引数](#引数)としてとられる[関数](#関数)。[高階関数](#高階関数)の呼び出し元が定義した[関数](#関数)を、[高階関数](#高階関数)の処理の中から呼び出し返すことからコールバックと呼ばれる。\n\n例えば、非同期処理を扱う[高階関数](#高階関数)に、非同期操作が完了した後に行いたい処理をコールバックとして渡しておくといった使い方がある（**非同期コールバック**）。\n\n\n"},{"term":"再帰関数","link":"./note/ja/./programming/_/chapters/function.md","flagment":"再帰関数","content":"\n**再帰関数**は、ある[関数](#関数)の内部でその[関数](#関数)自身を呼び出す（再帰呼び出し）ような[関数](#関数)。例えば、 `0` から[引数](#引数)として受け取った整数までの総和を求める[関数](#関数)などに用いられる。呼び出される側でどれほど処理を繰り返せばいいかわからない場合や、[引数](#引数)として受け取るデータの階層が不明な場合などに再帰関数を用いることで、実装がシンプルになったりする。\n\n再帰関数を実装する場合には、再帰呼び出しを停止する条件を考慮する必要がある。再帰呼び出しを打ち切る条件が満たされないような実装になると、無限ループが発生してしまう。また、無限ループでなくとも、再帰呼び出しされる回数が多いとスタックオーバフローが発生してしまう可能性がある。\n\nよくある再帰関数の実装は次のような形式となっている。[関数](#関数)内部で再帰呼び出しを行っており、**ベースケース**の条件に合致した段階で再帰呼び出しが停止する。ベースケースに達すると、再帰的に呼び出された[関数](#関数)に結果を返却していき、最終的な結果が呼び出し元に返される。\n\n```javascript\nfunction example_func( 引数 )\n{\n    if( ベースケース )\n    {\n        return ベースケースに対する値;\n    }\n\n    // 再帰呼び出し\n    example_func();\n    return 結果;\n}\n```\n\n\n"},{"term":"再帰呼び出し","link":"./note/ja/./programming/_/chapters/function.md","flagment":"再帰関数","content":"\n**再帰関数**は、ある[関数](#関数)の内部でその[関数](#関数)自身を呼び出す（再帰呼び出し）ような[関数](#関数)。例えば、 `0` から[引数](#引数)として受け取った整数までの総和を求める[関数](#関数)などに用いられる。呼び出される側でどれほど処理を繰り返せばいいかわからない場合や、[引数](#引数)として受け取るデータの階層が不明な場合などに再帰関数を用いることで、実装がシンプルになったりする。\n\n再帰関数を実装する場合には、再帰呼び出しを停止する条件を考慮する必要がある。再帰呼び出しを打ち切る条件が満たされないような実装になると、無限ループが発生してしまう。また、無限ループでなくとも、再帰呼び出しされる回数が多いとスタックオーバフローが発生してしまう可能性がある。\n\nよくある再帰関数の実装は次のような形式となっている。[関数](#関数)内部で再帰呼び出しを行っており、**ベースケース**の条件に合致した段階で再帰呼び出しが停止する。ベースケースに達すると、再帰的に呼び出された[関数](#関数)に結果を返却していき、最終的な結果が呼び出し元に返される。\n\n```javascript\nfunction example_func( 引数 )\n{\n    if( ベースケース )\n    {\n        return ベースケースに対する値;\n    }\n\n    // 再帰呼び出し\n    example_func();\n    return 結果;\n}\n```\n\n\n"},{"term":"ベースケース","link":"./note/ja/./programming/_/chapters/function.md","flagment":"再帰関数","content":"\n**再帰関数**は、ある[関数](#関数)の内部でその[関数](#関数)自身を呼び出す（再帰呼び出し）ような[関数](#関数)。例えば、 `0` から[引数](#引数)として受け取った整数までの総和を求める[関数](#関数)などに用いられる。呼び出される側でどれほど処理を繰り返せばいいかわからない場合や、[引数](#引数)として受け取るデータの階層が不明な場合などに再帰関数を用いることで、実装がシンプルになったりする。\n\n再帰関数を実装する場合には、再帰呼び出しを停止する条件を考慮する必要がある。再帰呼び出しを打ち切る条件が満たされないような実装になると、無限ループが発生してしまう。また、無限ループでなくとも、再帰呼び出しされる回数が多いとスタックオーバフローが発生してしまう可能性がある。\n\nよくある再帰関数の実装は次のような形式となっている。[関数](#関数)内部で再帰呼び出しを行っており、**ベースケース**の条件に合致した段階で再帰呼び出しが停止する。ベースケースに達すると、再帰的に呼び出された[関数](#関数)に結果を返却していき、最終的な結果が呼び出し元に返される。\n\n```javascript\nfunction example_func( 引数 )\n{\n    if( ベースケース )\n    {\n        return ベースケースに対する値;\n    }\n\n    // 再帰呼び出し\n    example_func();\n    return 結果;\n}\n```\n\n\n"},{"term":"カリー化","link":"./note/ja/./programming/_/chapters/function.md","flagment":"カリー化","content":"\n**カリー化**は、複数の[引数](#引数)をとる[関数](#関数)があったときに、いくつかの[引数](#引数)を共通化して、内部で元の[関数](#関数)を呼び出すような新しい[関数](#関数)をつくること。カリー化した[関数](#関数)を用いることで、元の[関数](#関数)に渡す[引数](#引数)の一部を省略することができ、[ソースコード](./programming.md#ソースコード)をシンプルに保つことができる。\n"},{"term":"オブジェクト指向","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"オブジェクト指向","content":"\n**オブジェクト指向**は、[プログラミングパラダイム](./programming.md#プログラミングパラダイム)のひとつで、非常に多くの[プログラミング言語](./programming.md#プログラミング言語)に取り入れられている概念である。相互に作用する[オブジェクト](#オブジェクト)を組み合わせることで[プログラム](./programming.md#プログラム)を設計する手法で、[クラス](#クラス)ベースのオブジェクト指向に則った[プログラミング言語](./programming.md#プログラミング言語)が多い（[JavaScript](./programming_language.md#javascript)のように、[プロトタイプ](#プロトタイプ)ベースのオブジェクト指向もある）。\n\n```cpp\n// C++\n\n"},{"term":"オブジェクト","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"オブジェクト","content":"\n**オブジェクト指向**は、[プログラミングパラダイム](./programming.md#プログラミングパラダイム)のひとつで、非常に多くの[プログラミング言語](./programming.md#プログラミング言語)に取り入れられている概念である。相互に作用する[オブジェクト](#オブジェクト)を組み合わせることで[プログラム](./programming.md#プログラム)を設計する手法で、[クラス](#クラス)ベースのオブジェクト指向に則った[プログラミング言語](./programming.md#プログラミング言語)が多い（[JavaScript](./programming_language.md#javascript)のように、[プロトタイプ](#プロトタイプ)ベースのオブジェクト指向もある）。\n\n```cpp\n// C++\n\n"},{"term":"メンバ","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"メンバ","content":"\n**メンバ**は、[オブジェクト](#オブジェクト)が持つ[プロパティ](#プロパティ)や[メソッド](#メソッド)。\n\n"},{"term":"プロパティ（属性、メンバ変数、フィールド変数）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"プロパティ","content":"\n**プロパティ**（**属性**、**メンバ変数**、**フィールド変数**）は、[オブジェクト](#オブジェクト)が持つデータや情報。\n\n"},{"term":"メソッド（操作、メンバ関数）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"メソッド","content":"\n**メソッド**（**操作**、**メンバ関数**）は、[オブジェクト](#オブジェクト)の機能や振る舞い。\n\n"},{"term":"クラス","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"クラス","content":"\n**クラス**は、[オブジェクト](#オブジェクト)を生成するための設計図のようなもの。[オブジェクト](#オブジェクト)の実体はクラスを元にして生成される。同じクラスから生成された[オブジェクト](#オブジェクト)は、共通の[プロパティ](#プロパティ)と[メソッド](#メソッド)を持つ（ただし、それぞれの[オブジェクト](#オブジェクト)が持つ[プロパティ](#プロパティ)は独立しており、[オブジェクト](#オブジェクト)ごとに固有）。クラスは実体を持たない設計図であるため、そのままでは[プロパティ](#プロパティ)や[メソッド](#メソッド)を利用することはできない。\n\n"},{"term":"インスタンス","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"インスタンス","content":"\n**インスタンス**は、[クラス](#クラス)から生成された[オブジェクト](#オブジェクト)の実体。[クラス](#クラス)という概念から[オブジェクト](#オブジェクト)という実体を生成することを、**インスタンス化**という。\n\n"},{"term":"インスタンス化","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"インスタンス","content":"\n**インスタンス**は、[クラス](#クラス)から生成された[オブジェクト](#オブジェクト)の実体。[クラス](#クラス)という概念から[オブジェクト](#オブジェクト)という実体を生成することを、**インスタンス化**という。\n\n"},{"term":"プロトタイプ","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"プロトタイプ","content":"\n**プロトタイプ**は、プロトタイプベースの[オブジェクト指向](#オブジェクト指向)において用いられる概念。[オブジェクト](#オブジェクト)を生成する際に、その元となる**プロトタイプオブジェクト**を指定することで、プロトタイプオブジェクトの共通の機能を利用することができる。このようにして、ある[オブジェクト](#オブジェクト)からプロトタイプオブジェクトの機能を参照することを**プロトタイプチェーン**と呼ぶ。\n\nプロトタイプベースの[オブジェクト指向](#オブジェクト指向)には[クラス](#クラス)の概念はなく、全てが実体（[オブジェクト](#オブジェクト)、プロトタイプオブジェクト）から成る。[クラス](#クラス)ベースにおける設計図である[クラス](#クラス)は静的なものであり、一度定義された[クラス](#クラス)は[プログラム](./programming.md#プログラム)中で変更されることはない。一方でプロトタイプは、設計図自体を[プログラム](./programming.md#プログラム)中で拡張したり変更したりすることができる。\n\n\n"},{"term":"プロトタイプオブジェクト","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"プロトタイプ","content":"\n**プロトタイプ**は、プロトタイプベースの[オブジェクト指向](#オブジェクト指向)において用いられる概念。[オブジェクト](#オブジェクト)を生成する際に、その元となる**プロトタイプオブジェクト**を指定することで、プロトタイプオブジェクトの共通の機能を利用することができる。このようにして、ある[オブジェクト](#オブジェクト)からプロトタイプオブジェクトの機能を参照することを**プロトタイプチェーン**と呼ぶ。\n\nプロトタイプベースの[オブジェクト指向](#オブジェクト指向)には[クラス](#クラス)の概念はなく、全てが実体（[オブジェクト](#オブジェクト)、プロトタイプオブジェクト）から成る。[クラス](#クラス)ベースにおける設計図である[クラス](#クラス)は静的なものであり、一度定義された[クラス](#クラス)は[プログラム](./programming.md#プログラム)中で変更されることはない。一方でプロトタイプは、設計図自体を[プログラム](./programming.md#プログラム)中で拡張したり変更したりすることができる。\n\n\n"},{"term":"プロトタイプチェーン","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"プロトタイプ","content":"\n**プロトタイプ**は、プロトタイプベースの[オブジェクト指向](#オブジェクト指向)において用いられる概念。[オブジェクト](#オブジェクト)を生成する際に、その元となる**プロトタイプオブジェクト**を指定することで、プロトタイプオブジェクトの共通の機能を利用することができる。このようにして、ある[オブジェクト](#オブジェクト)からプロトタイプオブジェクトの機能を参照することを**プロトタイプチェーン**と呼ぶ。\n\nプロトタイプベースの[オブジェクト指向](#オブジェクト指向)には[クラス](#クラス)の概念はなく、全てが実体（[オブジェクト](#オブジェクト)、プロトタイプオブジェクト）から成る。[クラス](#クラス)ベースにおける設計図である[クラス](#クラス)は静的なものであり、一度定義された[クラス](#クラス)は[プログラム](./programming.md#プログラム)中で変更されることはない。一方でプロトタイプは、設計図自体を[プログラム](./programming.md#プログラム)中で拡張したり変更したりすることができる。\n\n\n"},{"term":"カプセル化","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"カプセル化","content":"\n**カプセル化**は、[オブジェクト](#オブジェクト)が持つ情報を隠蔽することによって、不正な操作ができないようにする仕組み。[オブジェクト](#オブジェクト)が持つ[メソッド](#メソッド)や[プロパティ](#プロパティ)は、[アクセス指定子](#アクセス指定子)によってアクセスできる範囲を制限できる。\n\nカプセル化には、[オブジェクト](#オブジェクト)の外部からのアクセスを制限することで、[オブジェクト](#オブジェクト)内部のデータを保護して、直接書き換えられないようにする目的がある。[オブジェクト](#オブジェクト)内部のデータに直接アクセスできないようにする代わりに、保護されたデータを間接的に操作できるインタフェースとなるような[メソッド](#メソッド)を用意しておくという使い方が多い。\n\n```cpp\n// C++\n\n"},{"term":"アクセス指定子","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"アクセス指定子","content":"\n**アクセス指定子**は、[オブジェクト](#オブジェクト)が持つ[プロパティ](#プロパティ)や[メソッド](#メソッド)の公開範囲を指定するためのキーワード。これにより、[オブジェクト](#オブジェクト)の内部からしかアクセスできないデータと、[オブジェクト](#オブジェクト)の外側からでもアクセスできるデータを切り分けることができる。\n\n```cpp\n// C++\n\nclass Monster\n{\n    // 外部にも公開されるメンバ\n    public:\n\n        int level_up( int diff_ )\n        {\n            return this->level_up_inner(diff_);\n        }\n\n    // 外部からは見えないが、子クラスからは見えるメンバ\n    protected:\n\n        int level_up_inner( int idff_ )\n        {\n            this->m_level += diff_;\n            return this->m_level;\n        }\n\n        int m_level = 1;\n\n    // 外部からも子クラスからも見えないメンバ\n    private:\n\n        int m_index = 0;\n};\n\nclass Dragon : public Monster\n{\n    public:\n\n        void power_up()\n        {\n            // level_up_innerは子クラスからもアクセス可能\n            this->level_up_inner(1);\n        }\n};\n\nint main()\n{\n    Dragon dragon;\n\n    // level_upは外部からもアクセス可能\n    int level = dragon.level_up(10);\n\n    return 0;\n}\n```\n\n"},{"term":"public","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"public","content":"\n`public` は、[アクセス指定子](#アクセス指定子)のひとつで、[オブジェクト](#オブジェクト)の[スコープ](./control_flow.md#スコープ)範囲であれば、内部からでも外部からでもアクセスすることができる[メンバ](#メンバ)となる。\n\n"},{"term":"private","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"private","content":"\n`private` は、[アクセス指定子](#アクセス指定子)のひとつで、[オブジェクト](#オブジェクト)の外部からの[メンバ](#メンバ)へのアクセスを制限することができる。[子クラス](子クラス)から[親クラス](#親クラス)の[メンバ](#メンバ)へアクセスすることもできない。\n\n"},{"term":"protected","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"protected","content":"\n`protected` は、[アクセス指定子](#アクセス指定子)のひとつで、[オブジェクト](#オブジェクト)の外部からの[メンバ](#メンバ)へのアクセスを制限することができる。[子クラス](#子クラス)から[親クラス](#親クラス)の[メンバ](#メンバ)へアクセスすることはできる。\n\n\n"},{"term":"継承（インヘリタンス）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"継承","content":"\n**継承**（**インヘリタンス**）は、継承元（親）となる[クラス](#クラス)の持つ[プロパティ](#プロパティ)や[メソッド](#メソッド)を引き継いだ、別の[クラス](#クラス)を定義できる仕組み。複数の類似した[クラス](#クラス)において、共通部分をまとめた[親クラス](#親クラス)を定義することで、コードの再利用が高まる。\n\n```cpp\n// C++\n\n"},{"term":"親クラス（スーパークラス、基底クラス）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"親クラス","content":"\n**親クラス**（**スーパークラス**、**基底クラス**）は、ある[クラス](#クラス)の[継承](#継承)元となった[クラス](#クラス)。\n\n"},{"term":"子クラス（サブクラス、派生クラス）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"子クラス","content":"\n**子クラス**（**サブクラス**、**派生クラス**）は、別の[クラス](#クラス)を[継承](#継承)した[クラス](#クラス)。\n\n"},{"term":"メソッドオーバライド","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"メソッドオーバライド","content":"\n**メソッドオーバライド**は、[親クラス](#親クラス)で定義された[メソッド](#メソッド)と同じ[識別子](./programming.md#識別子)を持つ[メソッド](#メソッド)を[子クラス](#子クラス)側でも定義することで、動作が上書きできる機能。\n\n\n"},{"term":"ポリモーフィズム（ポリモルフィズム、多相性）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"ポリモーフィズム","content":"\n**ポリモーフィズム**（**ポリモルフィズム**、**多相性**）は、同じ[識別子](./programming.md#識別子)の[メソッド](#メソッド)で複数の異なる振る舞いを定義することができる性質。\n\n例えば、異なる[クラス](#クラス)が同じ名前の[メソッド](#メソッド)を共通して持つことによって、その[メソッド](#メソッド)を通して、暗黙的に複数の[オブジェクト](#オブジェクト)を切り替えることができる。この性質を利用することで、[オブジェクト](#オブジェクト)を利用している側の[ソースコード](./programming.md#ソースコード)を変更することなく[クラス](#クラス)を切り替えることが可能となり、メンテナンス性の向上に繋がる。[インタフェース](#インタフェース)や[仮想関数](#抽象クラス)の機能を用いることで、[クラス](#クラス)の[メソッド](#メソッド)の[シグネチャ](./function.md#シグネチャ)を共通化することができ、ポリモーフィズムの性質を利用しやすくなる。\n\n```cpp\n// C++\n\n"},{"term":"ダックタイピング","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"ダックタイピング","content":"\n**ダックタイピング**は、[関数](./function.md#関数)や[メソッド](#メソッド)が、特定のインタフェース（[プロパティ](#プロパティ)や[メソッド](#メソッド)）を持つ全ての[オブジェクト](#オブジェクト)を[引数](./function.md#引数)として受け取ることができる性質。[ポリモーフィズム](#ポリモーフィズム)の恩恵のひとつで、呼び出される[関数](./function.md#関数)（[メソッド](#メソッド)）は、[引数](./function.md#引数)として渡されたデータがどの[クラス](#クラス)の[オブジェクト](#オブジェクト)であるかを意識する必要がない。\n\n"},{"term":"DI（依存性の注入）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"di","content":"\n**DI**（Dependency Injection: **依存性の注入**）は、[引数](./function.md#引数)として受け取る[オブジェクト](#オブジェクト)がどの[クラス](#クラス)のものかに依存せずに、[関数](./function.md#関数)や[メソッド](#メソッド)を実行するという考え方。[ダックタイピング](#ダックタイピング)により、共通のインタフェースを持つ[オブジェクト](#オブジェクト)全てを[引数](./function.md#引数)として受け取れるようになり、[オブジェクト](#オブジェクト)への依存性を[関数](./function.md#関数)側から縛るのではなく、外部から指定できるようになる。\n\n\n"},{"term":"抽象クラス","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"抽象クラス","content":"\n**抽象クラス**は、具体的な実装を持たず、[継承](#継承)されることを前提とした[クラス](#クラス)。[具象クラス](#具象クラス)からは直接[インスタンス](#インスタンス)を生成することはできない。[オーバライド](#メソッドオーバライド)されることが前提となる[メソッド](#メソッド)を**抽象メソッド**（C++では**仮想関数**）といい、[関数](./function.md#関数)の[シグネチャ](./function.md#シグネチャ)のみを記述する。\n\n"},{"term":"抽象メソッド","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"抽象クラス","content":"\n**抽象クラス**は、具体的な実装を持たず、[継承](#継承)されることを前提とした[クラス](#クラス)。[具象クラス](#具象クラス)からは直接[インスタンス](#インスタンス)を生成することはできない。[オーバライド](#メソッドオーバライド)されることが前提となる[メソッド](#メソッド)を**抽象メソッド**（C++では**仮想関数**）といい、[関数](./function.md#関数)の[シグネチャ](./function.md#シグネチャ)のみを記述する。\n\n"},{"term":"仮想関数","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"抽象クラス","content":"\n**抽象クラス**は、具体的な実装を持たず、[継承](#継承)されることを前提とした[クラス](#クラス)。[具象クラス](#具象クラス)からは直接[インスタンス](#インスタンス)を生成することはできない。[オーバライド](#メソッドオーバライド)されることが前提となる[メソッド](#メソッド)を**抽象メソッド**（C++では**仮想関数**）といい、[関数](./function.md#関数)の[シグネチャ](./function.md#シグネチャ)のみを記述する。\n\n"},{"term":"具象クラス","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"具象クラス","content":"\n**具象クラス**は、[抽象クラス](#抽象クラス)を[継承](#継承)して[抽象メソッド](#抽象クラス)を[オーバライド](#メソッドオーバライド)し、具体的な実装を施した[クラス](#クラス)。\n\n"},{"term":"インタフェース","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"インタフェース","content":"\n**インタフェース**は、[クラス](#クラス)が定義するべき[メソッド](#メソッド)の[シグネチャ](./function.md#シグネチャ)を示したもので、具体的な実装は持たない。インタフェースを実装する[クラス](#クラス)は、インタフェースに定義されている[メソッド](#メソッド)を全て実装している必要がある（ `default` キーワードにより、インタフェースにデフォルトの実装を定義することができる[プログラミング言語](./programming.md#プログラミング言語)もある）。[継承](#継承)では1つの[親クラス](#親クラス)からしか性質を引き継げないが、1つの[クラス](#クラス)が複数のインタフェースを実装することは可能。\n\n```java\n// Java\n\n// インタフェース\ninterface RaceMonster\n{\n    public int level_up( int diff_ );\n}\n\ninterface RaceDragon\n{\n    public void powerup();\n\n    default public void bark()\n    {\n        System.out.println(\"Growl!!\");\n    }\n}\n \n// インタフェースを実装したクラス\nclass Slime implements RaceMonster\n{\n    public void level_up( int diff_ )\n    {\n        System.out.println(\"Level up!\");\n        this.m_level += diff_;\n        return this.m_level;\n    }\n\n    private int m_level = 1;\n}\n\n// 複数のインタフェースを実装したクラス\nclass Dragon implements RaceMonster, RaceDragon\n{\n    public void level_up( int diff_ )\n    {\n        System.out.println(\"Level up!\");\n        this.m_level += diff_;\n        return this.m_level;\n    }\n\n    public void powerup()\n    {\n        System.out.println(\"Power up!\");\n        this.m_power += 100;\n    }\n\n    private int m_level = 1;\n    private int m_power = 100;\n}\n```\n\n```php\n<?php\n\n// PHP\n\n// インタフェース\ninterface RaceMonster\n{\n    public function level_up( $diff_ );\n}\n\ninterface RaceDragon\n{\n    public function powerup();\n}\n\n// インタフェースを実装したクラス\nclass Slime implements RaceMonster\n{\n    public function level_up( $diff_ )\n    {\n        echo(\"Level up!\");\n        $this->m_level += $diff_;\n        return $this->m_level;\n    }\n\n    private $m_level = 1;\n}\n\n// 複数のインタフェースを実装したクラス\nclass Dragon implements RaceMonster, RaceDragon\n{\n    public function level_up( $diff_ )\n    {\n        echo(\"Level up!\");\n        $this->m_level += $diff_;\n        return $this->m_level;\n    }\n\n    public function powerup()\n    {\n        echo(\"Power up!\");\n        $this->m_power += 100;\n    }\n\n    private $m_level = 1;\n    private $m_power = 100;\n}\n\n?>\n```\n\n\n"},{"term":"this","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"this","content":"\n`this` は、[クラス](#クラス)の[メソッド](#メソッド)内で用いることができ、[クラス](#クラス)の[インスタンス](#インスタンス)自身を指すキーワード（多くの[プログラミング言語](./programming.md#プログラミング言語)では `this` が用いられているが、 `self` など別のキーワードを用いる場合もある）。[インスタンス](#インスタンス)内の[プロパティ](#プロパティ)や[メソッド](#メソッド)を参照する際に利用する。\n\n```cpp\n// C++\n\n"},{"term":"コンストラクタ","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"コンストラクタ","content":"\n**コンストラクタ**は、[オブジェクト](#オブジェクト)の初期化を行うための特別な[メソッド](#メソッド)で、[インスタンス](#インスタンス)の生成時に自動的に実行される。[プロパティ](#プロパティ)の初期化や、[オブジェクト](#オブジェクト)ごとの特別な初期化処理が必要な場合などに用いる。\n\n```cpp\n// C++\n\n"},{"term":"デストラクタ","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"デストラクタ","content":"\n**デストラクタ**は、[オブジェクト](#オブジェクト)の終了処理を行うための特別な[メソッド](#メソッド)で、[インスタンス](#インスタンス)が破棄されるときに自動的に実行される。[ガベージコレクション](./programming.md#ガベージコレクション)を用いる[プログラミング言語](./programming.md#プログラミング言語)では、デストラクタが実行されるタイミングが予測できないため、複雑な処理を行おうとすると[バグ](./programming.md#バグ)の発生原因となってしまう場合がある。一方で、[C言語](./programming_language.md#c言語)のように[プログラマ](./programming.md#プログラマ)が[変数](./variable.md#変数)の生存期間を管理する言語においては、[インスタンス](#インスタンス)が管理する[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)の解放を行うなど重要な役割を持っている。\n\n```cpp\n// C++\n\n"},{"term":"静的メンバ","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"静的メンバ","content":"\n**静的メンバ**は、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上に静的に配置され、[インスタンス](#インスタンス)との直接的な関連を持たない[メンバ](#メンバ)。多くの[プログラミング言語](./programming.md#プログラミングン言語)では、 `static` キーワードをつけることで[メンバ](#メンバ)を静的メンバにすることができる。\n\n"},{"term":"staticプロパティ（静的プロパティ）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"staticプロパティ","content":"\n**staticプロパティ**は、[オブジェクト](#オブジェクト)に依存せずに独立した[変数](./variable.md#変数)のように扱える[プロパティ](#プロパティ)。[クラス](#クラス)に属する[グローバル変数](./variable.md#グローバル変数)のようなものとして扱われる。\n\n```cpp\n// C++\n\n"},{"term":"staticメソッド（静的メソッド）","link":"./note/ja/./programming/_/chapters/object_oriented.md","flagment":"staticメソッド","content":"\n**staticメソッド**（**静的メソッド**）は、[オブジェクト](#オブジェクト)の[メンバ](#メンバ)として定義されているものの、[インスタンス](#インスタンス)を必要としない[メソッド](#メソッド)。全ての[インスタンス](#インスタンス)で共通する処理や、[クラス](#クラス)に関連するような[関数](./function.md#関数)を使用したい場合に用いる。静的メソッドは[インスタンス](#インスタンス)に依存しないため、 `this` による[メンバ](#メンバ)へのアクセスができない。\n\n```cpp\n// C++\n\n"},{"term":"コーディングルール","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"コーディングルール","content":"\n**コーディングルール**は、[変数](./variable.md#変数)名のつけ方や[コメント](./programming.md#コメント)の書き方、[制御構文](./control_flow.md#制御フロー)の書き方といった、[ソースコード](./programming.md#ソースコード)をつくる際に[プログラマ](./programming.md#プログラマ)が守るように定められたルール。[プログラミング言語](./programming.md#プログラミング言語)の仕様として定められていたり、構文上の[エラー](./programming.md#エラー)となることはないが、チーム内で[ソースコード](./programming.md#ソースコード)の一貫性を持たせるために設けることが多い。どのコーディングルールが正しいといった正解はなく、[プログラミング言語](./programming.md#プログラミング言語)ごとのコミュニティや開発チームの文化によって、コーディングルールも異なる。\n\n\n"},{"term":"命名規則","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"命名規則","content":"\n**命名規則**は、[識別子](./programming.md#識別子)の命名に関する[コーディングルール](#コーディングルール)。1つの[プログラム](./programming.md#プログラム)の中で複数の命名規則を組み合わせることも多い（[変数](./variable.md#変数)は[スネークケース](#スネークケース)、[関数](#関数)は[キャメルケース](#キャメルケース)を用いるといった具合）。\n\n特に、複数の単語からなる[識別子](./programming.md#識別子)を使用する場合には、それらの単語の区切りをどのように表現するかによって様々な命名規則が存在する（[識別子](./programming.md#識別子)にスペースは使用できないため）。\n\n"},{"term":"パスカルケース","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"パスカルケース","content":"\n**パスカルケース**は、[命名規則](#命名規則)の一種で、全ての単語の1文字目を大文字で始め、複数の単語からなる[識別子](./programming.md#識別子)については単語同士をそのままつなげるスタイル。[C#](./programming_language.md#c-1)などの一部の[プログラミング言語](./programming.md#プログラミング言語)で使われることがある。\n\n```js\nUser\nUserName\nSetUserName\n```\n\n"},{"term":"キャメルケース","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"キャメルケース","content":"\n**キャメルケース**は、[命名規則](#命名規則)の一種で、複数の単語からなる[識別子](./programming.md#識別子)において、2つ目以降の単語の1文字目を大文字で始め、単語同士をそのままつなげるスタイル。[スネークケース](#スネークケース)と並んで、様々な[プログラミング言語](./programming.md#プログラミング言語)で広く使われている。\n\n```js\nuser\nuserName\nsetUserName\n```\n\n"},{"term":"スネークケース","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"スネークケース","content":"\n**スネークケース**は、[命名規則](#命名規則)の一種で、複数の単語からなる[識別子](./programming.md#識別子)において、全ての単語を小文字にし、単語同士をアンダースコアでつなげるというスタイル。[キャメルケース](#キャメルケース)と並んで、様々な[プログラミング言語](./programming.md#プログラミング言語)で広く使われている。\n\n```js\nuser\nuser_name\nset_user_name\n```\n\n"},{"term":"アッパーケース","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"アッパーケース","content":"\n**アッパーケース**は、[命名規則](#命名規則)の一種で、全ての単語を大文字にし、単語同士をアンダースコアでつなげるというスタイル。[定数](./variable.md#定数)名として用いられることが多い。\n\n```js\nUSER\nUSER_NAME\nSET_USER_NAME\n```\n\n"},{"term":"ケバブケース","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"ケバブケース","content":"\n**ケバブケース**は、[命名規則](#命名規則)の一種で、全ての単語を小文字にし、単語同士をハイフンでつなげるというスタイル。[プログラミング言語](./programming.md#プログラミング言語)で採用されることは少なく、HTMLのclass名や属性、CSSのプロパティなどに用いられる。\n\n```js\nuser\nuser-name\nset-user-name\n```\n\n"},{"term":"ハンガリアン記法","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"ハンガリアン記法","content":"\n**ハンガリアン記法**は、[命名規則](#命名規則)の一種で、[識別子](./programming.md#識別子)の先頭や末尾に決まった意味のプレフィックス（接頭辞）やサフィックス（接尾辞）を付与するスタイル。流行していた時代もあったが、現代ではアンチパターンとされることもある。ただし、全ての[識別子](./programming.md#識別子)に対してではなく、一部の決まった[識別子](./programming.md#識別子)に対してハンガリアン記法を適用するのが有効な場合もあるため、適切に利用するとよい。\n\n```js\n// メンバ変数にプレフィックスとしてm_をつける\nm_name\nm_type\n\n// グローバル変数にプレフィックスとしてg_をつける\ng_counter\ng_error_code\n\n// 変数の型を表すプレフィックスをつける\ni_number    // int型\nc_alphabet  // char型\n```\n\n\n"},{"term":"コーディングスタイル","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"コーディングスタイル","content":"\n**コーディングスタイル**は、[ソースコード](./programming.md#ソースコード)の記述に関する細かい決まりごと。\n\n"},{"term":"インデント","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"インデント","content":"\n**インデント**（字下げ）は、[ソースコード](./programming.md#ソースコード)中で[ブロック](./control_flow.md#ブロック)の構造が分かりやすくなるように、先頭に挿入する空白。インデントにスペースを用いるか、タブを用いるか、またインデントはスペースいくつ分がよいかといったスタイルの違いがある。よく用いられるのは、スペース2つやスペース4つ、タブなど。基本的にはインデントの付け方によって[プログラム](./programming.md#プログラム)の動作に影響はないが、[Python](./programming_language.md#python)のようにインデントが構造を記述する意味を持っている場合もある。\n\n"},{"term":"オールマン","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"中括弧","content":"\n[ブロック](./control_flow.md#ブロック)の始まりと終わりを示す中括弧の書き方に関するスタイルの違いがある。代表的なものは次の2つ。\n\n```js\n// オールマン\nwhile( true )\n{\n    something();\n}\n\n// K&R\nwhile( true ) {\n    something();\n}\n```\n\n"},{"term":"K&R","link":"./note/ja/./programming/_/chapters/coding_rule.md","flagment":"中括弧","content":"\n[ブロック](./control_flow.md#ブロック)の始まりと終わりを示す中括弧の書き方に関するスタイルの違いがある。代表的なものは次の2つ。\n\n```js\n// オールマン\nwhile( true )\n{\n    something();\n}\n\n// K&R\nwhile( true ) {\n    something();\n}\n```\n\n"},{"term":"C言語","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"c言語","content":"\n**C言語**は、1972年に開発された[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[高水準言語](./programming.md#高水準言語)ではあるが[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)寄りの記述が可能な[低水準言語](./programming.md#低水準言語)のような特徴も持っている。[コンパイラ言語](./programming.md#コンパイラ言語)・[静的型付け言語](./programming.md#静的型付け言語)に分類される。[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)や[デバイスドライバ](../../../computer/hardware/_/chapters/io_unit.md#デバイスドライバ)など、低レイヤを中心にあらゆる分野で利用されており、[プログラミング言語](./programming.md#プログラミング言語)の中でも実行速度は最速の部類となる。また、習得難易度は[スクリプト言語](./programming.md#スクリプト言語)に比べて高く、限られた[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資産で効率的に実行できる[プログラム](./programming.md#プログラム)を要するケースに適している。\n\n[メモリ管理](./programming.md#プログラムのメモリ管理)に[ガベージコレクション](./programming.md#ガベージコレクション)を用いず、[プログラマ](./programming.md#プログラマ)が[メモリ管理](./programming.md#プログラムのメモリ管理)の責務を負うため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に関する様々な[エラー](./programming.md#エラー)を回避して[プログラム](./programming.md#プログラム)を記述する必要がある。\n\n```c\n"},{"term":"C++","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"c","content":"\n**C言語**は、1972年に開発された[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[高水準言語](./programming.md#高水準言語)ではあるが[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)寄りの記述が可能な[低水準言語](./programming.md#低水準言語)のような特徴も持っている。[コンパイラ言語](./programming.md#コンパイラ言語)・[静的型付け言語](./programming.md#静的型付け言語)に分類される。[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)や[デバイスドライバ](../../../computer/hardware/_/chapters/io_unit.md#デバイスドライバ)など、低レイヤを中心にあらゆる分野で利用されており、[プログラミング言語](./programming.md#プログラミング言語)の中でも実行速度は最速の部類となる。また、習得難易度は[スクリプト言語](./programming.md#スクリプト言語)に比べて高く、限られた[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資産で効率的に実行できる[プログラム](./programming.md#プログラム)を要するケースに適している。\n\n[メモリ管理](./programming.md#プログラムのメモリ管理)に[ガベージコレクション](./programming.md#ガベージコレクション)を用いず、[プログラマ](./programming.md#プログラマ)が[メモリ管理](./programming.md#プログラムのメモリ管理)の責務を負うため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に関する様々な[エラー](./programming.md#エラー)を回避して[プログラム](./programming.md#プログラム)を記述する必要がある。\n\n```c\n"},{"term":"C#","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"c-1","content":""},{"term":".NET Framework","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"c","content":"\n**C言語**は、1972年に開発された[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[高水準言語](./programming.md#高水準言語)ではあるが[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)寄りの記述が可能な[低水準言語](./programming.md#低水準言語)のような特徴も持っている。[コンパイラ言語](./programming.md#コンパイラ言語)・[静的型付け言語](./programming.md#静的型付け言語)に分類される。[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)や[デバイスドライバ](../../../computer/hardware/_/chapters/io_unit.md#デバイスドライバ)など、低レイヤを中心にあらゆる分野で利用されており、[プログラミング言語](./programming.md#プログラミング言語)の中でも実行速度は最速の部類となる。また、習得難易度は[スクリプト言語](./programming.md#スクリプト言語)に比べて高く、限られた[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資産で効率的に実行できる[プログラム](./programming.md#プログラム)を要するケースに適している。\n\n[メモリ管理](./programming.md#プログラムのメモリ管理)に[ガベージコレクション](./programming.md#ガベージコレクション)を用いず、[プログラマ](./programming.md#プログラマ)が[メモリ管理](./programming.md#プログラムのメモリ管理)の責務を負うため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に関する様々な[エラー](./programming.md#エラー)を回避して[プログラム](./programming.md#プログラム)を記述する必要がある。\n\n```c\n"},{"term":"Unity","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"c","content":"\n**C言語**は、1972年に開発された[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[高水準言語](./programming.md#高水準言語)ではあるが[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)寄りの記述が可能な[低水準言語](./programming.md#低水準言語)のような特徴も持っている。[コンパイラ言語](./programming.md#コンパイラ言語)・[静的型付け言語](./programming.md#静的型付け言語)に分類される。[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)や[デバイスドライバ](../../../computer/hardware/_/chapters/io_unit.md#デバイスドライバ)など、低レイヤを中心にあらゆる分野で利用されており、[プログラミング言語](./programming.md#プログラミング言語)の中でも実行速度は最速の部類となる。また、習得難易度は[スクリプト言語](./programming.md#スクリプト言語)に比べて高く、限られた[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資産で効率的に実行できる[プログラム](./programming.md#プログラム)を要するケースに適している。\n\n[メモリ管理](./programming.md#プログラムのメモリ管理)に[ガベージコレクション](./programming.md#ガベージコレクション)を用いず、[プログラマ](./programming.md#プログラマ)が[メモリ管理](./programming.md#プログラムのメモリ管理)の責務を負うため、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)に関する様々な[エラー](./programming.md#エラー)を回避して[プログラム](./programming.md#プログラム)を記述する必要がある。\n\n```c\n"},{"term":"Objective-C","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"objective-c","content":"\n**Objective-C**は、[C言語](#c言語)をベースにして**Smalltalk**（[オブジェクト指向](./object_oriented.md#オブジェクト指向)の起源ともいえる[プログラミング言語](./programming.md#プログラミング言語)）の機能を取り込んだ[プログラミング言語](./programming.md#プログラミング言語)。Appple社の[macOS](../../../computer/software/_/chapters/operating_system.md#macos)や[iOS](../../../computer/software/_/chapters/operating_system.md#ios)向けの[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)開発における標準言語。近年では[MacOS](../../../computer/software/_/chapters/operating_system.md#macos)、[iOS](../../../computer/software/_/chapters/operating_system.md#ios)[アプリ](../../../computer/software/_/chapters/software.md#応用ソフトウェア)の開発用言語は[Swift](#swift)に置き換えられつつある。\n\n\n"},{"term":"Smalltalk","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"objective-c","content":"\n**Objective-C**は、[C言語](#c言語)をベースにして**Smalltalk**（[オブジェクト指向](./object_oriented.md#オブジェクト指向)の起源ともいえる[プログラミング言語](./programming.md#プログラミング言語)）の機能を取り込んだ[プログラミング言語](./programming.md#プログラミング言語)。Appple社の[macOS](../../../computer/software/_/chapters/operating_system.md#macos)や[iOS](../../../computer/software/_/chapters/operating_system.md#ios)向けの[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)開発における標準言語。近年では[MacOS](../../../computer/software/_/chapters/operating_system.md#macos)、[iOS](../../../computer/software/_/chapters/operating_system.md#ios)[アプリ](../../../computer/software/_/chapters/software.md#応用ソフトウェア)の開発用言語は[Swift](#swift)に置き換えられつつある。\n\n\n"},{"term":"Java","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"java","content":"\n**Java**は、[C言語](#c言語)に影響を受けた[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[静的型付け言語](./programming.md#静的型付け言語)に分類され、[メモリ管理](./programming.md#プログラムのメモリ管理)には[ガベージコレクション](./programming.md#ガベージコレクション)を用いる。様々な[プラットフォーム](../../../computer/software/_/chapters/software.md#プラットフォーム)で実行できるように[JITコンパイラ](./programming.md#jitコンパイラ)方式を用いており、Java[プログラム](./programming.md#プログラム)を実行するためのソフトウェアを**JVM**（Java仮想マシン）という。また、[オブジェクト指向](./object_oriented.md#オブジェクト指向)を取り入れた言語でもある。非常に人気が高く、世界で最も使用されている[プログラミング言語](./programming.md#プログラミング言語)のひとつとなっている。\n\n```java\nimport java.util.Scanner;\n\npublic class Oddeven\n{\n    public static void main( String[] args )\n    {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"> \");\n        int input_num = scanner.nextInt();\n\n        if( input_num % 2 == 0 )\n        {\n            System.out.println(\"It is an even number : \" + input_num);\n        }\n        else\n        {\n            System.out.println(\"It is an odd number : \" + input_num);\n        }\n\n        scanner.close();\n    }\n}\n```\n\n"},{"term":"JVM（Java仮想マシン）","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"java","content":"\n**Java**は、[C言語](#c言語)に影響を受けた[汎用プログラミング言語](./programming.md#汎用プログラミング言語)で、[静的型付け言語](./programming.md#静的型付け言語)に分類され、[メモリ管理](./programming.md#プログラムのメモリ管理)には[ガベージコレクション](./programming.md#ガベージコレクション)を用いる。様々な[プラットフォーム](../../../computer/software/_/chapters/software.md#プラットフォーム)で実行できるように[JITコンパイラ](./programming.md#jitコンパイラ)方式を用いており、Java[プログラム](./programming.md#プログラム)を実行するためのソフトウェアを**JVM**（Java仮想マシン）という。また、[オブジェクト指向](./object_oriented.md#オブジェクト指向)を取り入れた言語でもある。非常に人気が高く、世界で最も使用されている[プログラミング言語](./programming.md#プログラミング言語)のひとつとなっている。\n\n```java\nimport java.util.Scanner;\n\npublic class Oddeven\n{\n    public static void main( String[] args )\n    {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"> \");\n        int input_num = scanner.nextInt();\n\n        if( input_num % 2 == 0 )\n        {\n            System.out.println(\"It is an even number : \" + input_num);\n        }\n        else\n        {\n            System.out.println(\"It is an odd number : \" + input_num);\n        }\n\n        scanner.close();\n    }\n}\n```\n\n"},{"term":"Kotlin","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"kotlin","content":"\n**Kotlin**は、[Android](../../../computer/software/_/chapters/operating_system.md#android)[アプリ](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を開発するための比較的新しい[プログラミング言語](./programming.md#プログラミング言語)。[Java](#java)を簡潔に安全に記述できるように改良されており、[JVM](#java)上で動作する。\n\n\n"},{"term":"Swift","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"swift","content":"\n**Swift**は、Apple製品の[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を開発するためにつくられた[プログラミング言語](./programming.md#プログラミング言語)。[Objective-C](#objective-c)に代わる新たな言語として設計されており、シンプルで直感的に[プログラミング](./programming.md#プログラミング)ができるとして人気が高い。\n\n\n"},{"term":"Python","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"python","content":"\n**Python**は、[インタプリタ](./programming.md#インタプリタ言語)方式の[汎用プログラミング言語](./programming.md#汎用プログラミング言語)。[動的型付け言語](./programming.md#動的型付け言語)に分類され、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)の管理には[ガベージコレクション](./programming.md#ガベージコレクション)を用いる。可読性が高く記述が用意であるため、[プログラミング](./programming.md#プログラミング)の入門やスピード感のある開発に適している。[機械学習](../../../artificial_intelligence/_/chapters/machine_learning.md#機械学習)分野の[ライブラリ](../../../computer/software/_/chapters/package.md#ライブラリ)が充実しているほか、[Web](../../../network/_/chapters/web.md#web)開発にも用いられる。\n\n```python\ninput_num = int(input(\"> \"))\n\nif ( input_num % 2 ) == 0:\n    print(\"It is an even number : {0}\".format(input_num))\nelse:\n    print(\"It is an even number : {0}\".format(input_num))\n```\n\n\n"},{"term":"PHP","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"php","content":"\n**PHP**は、動的な[Web](../../../network/_/chapters/web.md#web)サイトを作成するためのツールから派生した[スクリプト言語](./programming.md#スクリプト言語)。[Web](../../../network/_/chapters/web.md#web)開発に特化しており、HTMLに埋め込むような記法を用いることができるという特徴がある。そのほかにも、学習コストが低い点や[データベース](../../../development/database/_/chapters/database.md#データベース)アクセスを容易に行えるという強みもある。\n\n```php\n<?php\n\n$input_num = $_POST[\"input_num\"];\n\nif( $input_num % 2 === 0 )\n{\n    echo(\"It is an even number : \" . $input_num);\n}\nelse\n{\n    echo(\"It is an odd number : \" . $input_num);\n}\n\n?>\n```\n\n\n"},{"term":"JavaScript","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"javascript","content":"\n**JavaScript**は、一般的な[Webブラウザ](../../../network/_/chapters/web.md#webブラウザ)上で実行される[プログラミング言語](./programming.md#プログラミング言語)。[インタプリタ言語](./programming.md#インタプリタ言語)・[動的型付け言語](./programming.md#動的型付け言語)に分類される。[Web](../../../network/_/chapters/web.md#web)ページ上のコンテンツに動きを与える目的でよく用いられており、近年では[サーバ](../../../network/_/chapters/web.md#webサーバ)サイドにおける実行環境の登場や、**SPA**(Single Page Application)の普及により活躍の幅が広がっている。習得難易度は比較的低く、[ブラウザ](../../../network/_/chapters/web.md#webブラウザ)さえあれば実行環境が整うという手軽さもメリットのひとつである。\n\n```javascript\nlet input_num = document.getElementById('#input_num').value;\n\nif( input_num % 2 === 0 )\n{\n    console.log(\"It is an even number : \" + input_num);\n}\nelse\n{\n    console.log(\"It is an even number : \" + input_num);\n}\n```\n\n"},{"term":"TypeScript","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"typescript","content":"\n**TypeScript**は、Microsoftによって開発された[JavaScript](#javascript)のスーパーセット。大規模[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)開発のために設計されており、[静的型付け言語](./programming.md#静的型付け言語)のような[型](./data_type.md#型)宣言などの機能が搭載されている。実行時は、[JavaScript](#javascript)に[トランスコンパイル](./programming.md#トランスコンパイル)したものを[ブラウザ](../../../network/_/chapters/web.md#webブラウザ)上で動作させる。\n\n\n"},{"term":"Rust","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"rust","content":"\n**Rust**は、[C言語](#c言語)や[C++](#c)に代わるシステム[プログラミング言語](./programming.md#プログラミング言語)を目指す[プログラミング言語](./programming.md#プログラミング言語)。[静的型付け言語](./programming.md#静的型付け言語)・[コンパイラ言語](./programming.md#コンパイラ言語)に分類される。また、[ガベージコレクション](./programming.md#ガベージコレクション)を用いない独特の[メモリ管理](./programming.md#プログラムのメモリ管理)（**ボローチェッカー**による[参照](./data_type.md#参照型)の有効性の検証）によって、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)安全性を確保している。パフォーマンスや信頼性の高さから[Linux](../../../computer/software/_/chapters/operating_system.md#linux)の[カーネル](../../../computer/software/_/chapters/operating_system.md#カーネル)[プログラム](./programming.md#プログラム)にも採用されたり、GoogleやFacebookといった企業でも一部取り入れられたりと、注目の集まる言語となっている。開発者に最も愛されている[プログラミング言語](./programming.md#プログラミング言語)としても知られるが、習得難易度は[C言語](#c言語)や[C++](#c)と同程度かそれ以上に高い。\n\n\n"},{"term":"ボローチェッカー","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"rust","content":"\n**Rust**は、[C言語](#c言語)や[C++](#c)に代わるシステム[プログラミング言語](./programming.md#プログラミング言語)を目指す[プログラミング言語](./programming.md#プログラミング言語)。[静的型付け言語](./programming.md#静的型付け言語)・[コンパイラ言語](./programming.md#コンパイラ言語)に分類される。また、[ガベージコレクション](./programming.md#ガベージコレクション)を用いない独特の[メモリ管理](./programming.md#プログラムのメモリ管理)（**ボローチェッカー**による[参照](./data_type.md#参照型)の有効性の検証）によって、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)安全性を確保している。パフォーマンスや信頼性の高さから[Linux](../../../computer/software/_/chapters/operating_system.md#linux)の[カーネル](../../../computer/software/_/chapters/operating_system.md#カーネル)[プログラム](./programming.md#プログラム)にも採用されたり、GoogleやFacebookといった企業でも一部取り入れられたりと、注目の集まる言語となっている。開発者に最も愛されている[プログラミング言語](./programming.md#プログラミング言語)としても知られるが、習得難易度は[C言語](#c言語)や[C++](#c)と同程度かそれ以上に高い。\n\n\n"},{"term":"Go","link":"./note/ja/./programming/_/chapters/programming_language.md","flagment":"go","content":"\n**Go**は、高負荷がかかるシステムなどには必須の並行プログラミングがシンプルに記述できるように、Googleが開発した[プログラミング言語](./programming.md#プログラミング言語)。[静的型付け言語](./programming.md#静的型付け言語)・[コンパイラ言語](./programming.md#コンパイラ言語)に分類され、[メモリ管理](./programming.md#プログラムのメモリ管理)には[ガベージコレクション](./programming.md#ガベージコレクション)を用いる。[Web](../../../network/_/chapters/web.md#web)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)やモバイル[アプリ](../../../computer/software/_/chapters/software.md#応用ソフトウェア)などの開発に適しており、[標準ライブラリ](../../../computer/software/_/chapters/package.md#標準ライブラリ)が豊富であるという特徴がある。実行速度は[C言語](#c言語)や[Rust](#rust)には劣るものの、同じ分野で活躍する[PHP](#php)などの言語に比べると圧倒的に高速である。\n"},{"term":"アルゴリズム","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"アルゴリズム","content":"\n**アルゴリズム**は、問題を解くための手順のことで、特に[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)[プログラム](./programming.md#プログラム)について使われることが多い。適切なアルゴリズムを用いると、処理時間（[時間計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#時間計算量)）が大幅に短縮できたり、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)などの処理に必要となる資源（[空間計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#空間計算量)）を削減できたりする。アルゴリズムを学ぶことで、良い[プログラム](./programming.md#プログラム)を作ることができるようになる。\n\n\n"},{"term":"背理法","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"背理法","content":"\n**背理法**は、真であると証明したい[命題](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#命題)を偽であると仮定し、その矛盾を導くことによって、[命題](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#命題)が偽であるという仮定が誤り（=[命題](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#命題)が真）であることを論理付ける方法。\n\n\n"},{"term":"探索アルゴリズム","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"探索アルゴリズム","content":"\n"},{"term":"全探索","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"全探索","content":"\n**全探索**は、あり得るすべてのパターンをしらみつぶしに調べる[アルゴリズム](#アルゴリズム)。最もシンプルな[アルゴリズム](#アルゴリズム)のひとつで、問題を考える際にはまず全探索をしても現実的な時間で実行が終わるのかどうかを検討することが大切。\n\n"},{"term":"ビット全探索","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"ビット全探索","content":"\n**ビット全探索**は、[ビット演算](./operation.md#ビット演算)を利用することで[全探索](#全探索)を行う方法。ビット全探索では、[部分集合](../../../basics/discrete_mathematics/_/chapters/set_and_proposition.md#部分集合)を全パターン列挙することができるため、組み合わせを[全探索](#全探索)する際のテクニックとして使える。\n\n"},{"term":"線形探索","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"線形探索","content":"\n**線形探索**は、[配列](./data_type.md#配列)から検索したい値を見つけ出すための[アルゴリズム](#アルゴリズム)のひとつで、全ての要素を順番に検索したい値と比較する。\n\n"},{"term":"二分探索","link":"./note/ja/./programming/_/chapters/algorithm.md","flagment":"二分探索","content":"\n**二分探索**は、昇順あるいは降順に並べられた[配列](./data_type.md#配列)から検索したい値を見つけ出すための[アルゴリズム](#アルゴリズム)のひとつで、中央の要素と検索したい値との大小比較を行い、検索したい値が中央の要素よりも前にあるか後ろにあるかを判断しながら絞り込んでいく。ソートされていない[配列](./data_type.md#配列)や、大小関係の定義されていない要素には使用できない。\n"},{"term":"メモリ管理","link":"./note/ja/./programming/_/chapters/memory_management.md","flagment":"プログラムのメモリ管理","content":"\n[プログラム](./programming.md#プログラム)中で用いられる[変数](./variable.md#変数)や[関数](./function.md#関数)は、[プログラム](./programming.md#プログラム)に割り当てられた[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域内に格納される。[グローバル変数](./variable.md#グローバル変数)は[静的領域](../../../computer/hardware/_/chapters/memory.md#静的領域)に、[関数](./function.md#関数)内で使用される[ローカル変数](./variable.md#ローカル変数)は[スタック領域](../../../computer/hardware/_/chapters/memory.md#スタック領域)に、[配列](./data_type.md#配列)や[オブジェクト](./object_oriented.md#オブジェクト)といった可変長のデータの実体は[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納される。\n\n[プログラミング言語](./programming.md#プログラミング言語)の[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)管理においては、次の2つの特徴を持つことが望ましい。\n\n- [メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)が[プラグラマ](./programming.md#プログラマ)が選んだタイミングで適切に解放されること。これにより[プログラム](./programming.md#プログラム)が無駄な[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)を消費しないようにする。\n- 解放済みの[オブジェクト](./object_oriented.md#オブジェクト)への[ポインタ](./data_type.md#ポインタ型)（[ダングリングポインタ](#ダングリングポインタ)）を使ってしまうことがないこと。これは[未定義動作](./programming.md#未定義動作)となり、クラッシュやセキュリティホールにつながる。\n\nこれらの特徴は相反しており、これら2つを両立することは難しい。[プログラマ](./programming.md#プログラマ)が任意のタイミングで値の[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)を解放できる言語については、[ポインタ](./data_type.md#ポインタ型)が存在するうちに値を解放してしまうと、その[ポインタ](./data_type.md#ポインタ型)の参照する先がなくなってしまう（[ダングリングポインタ](#ダングリングポインタ)）。多くの[プログラミング言語](./programming.md#プログラミング言語)はこれらのうちどちらかを諦めており、トレードオフを選択している。\n\n- 安全第一の[プログラミング言語](./programming.md#プログラミング言語)では、[ガベージコレクション](#ガベージコレクション)を用いて[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)管理を行う。[オブジェクト](./object_oriented.md#オブジェクト)へ到達できる[ポインタ](./data_type.md#ポインタ型)がすべてなくなったところで自動的にその[オブジェクト](./object_oriented.md#オブジェクト)を解放する。[Python](./programming_language.md#python)、[JavaScript](./programming_language.md#javascript)、[Java](./programming_language.md#java)、[C#](./programming_language.md#c-1)、Haskellなどのほとんどの近代的な言語はこれに属する。ただし、[ガベージコレクション](#ガベージコレクション)を用いると望んだタイミングで[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)が解放されない可能性がある。\n- 制御優先の[プログラミング言語](./programming.md#プログラミング言語)では、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)解放の責任を[プログラマ](./programming.md#プログラマ)に委ねる。[ダングリングポインタ](#ダングリングポインタ)を避ける責任も[プログラマ](./programming.md#プログラマ)に課せられ、[プログラマ](./programming.md#プログラマ)がミスを侵さなければ[ガベージコレクション](#ガベージコレクション)を用いるよりも良い方法である（ただし人はミスをするため、危険な言語であるとも言える）。これに属する代表的な言語は[C](./programming_language.md#c言語)と[C++](./programming_language.md#c)だけである。\n\n[ポインタ](./data_type.md#ポインタ型)の扱いに成約を加えたことでこれら2つを両立した言語として、[Rust](./programming_language.md#rust)がある。\n\n"},{"term":"メモリリーク","link":"./note/ja/./programming/_/chapters/memory_management.md","flagment":"メモリリーク","content":"\n**メモリリーク**は、[プログラム](./programming.md#プログラム)が使い終わった[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)の解放を忘れることで、使用できなくなる[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域ができてしまうこと。[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)管理に関する[バグ](./programming.md#バグ)の一種。\n\n"},{"term":"ダブルフリー（多重フリー）","link":"./note/ja/./programming/_/chapters/memory_management.md","flagment":"ダブルフリー","content":"\n**ダブルフリー**（[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)の二重解放、多重フリー）は、既に解放された[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)の[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)を、再度解放しようとすること。[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)管理に関する[バグ](./programming.md#バグ)の一種。\n\n"},{"term":"ダングリングポインタ","link":"./note/ja/./programming/_/chapters/memory_management.md","flagment":"ダングリングポインタ","content":"\n**ダングリングポインタ**は、[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)に格納されたデータの[アドレス](../../../computer/hardware/_/chapters/memory.md#アドレス)を格納した[スタック領域](../../../computer/hardware/_/chapters/memory.md#アドレス)の[ポインタ](./data_type.md#ポインタ型)において、既に解放された[ヒープ領域](../../../computer/hardware/_/chapters/memory.md#ヒープ領域)を指し示す[ポインタ](./data_type.md#ポインタ型)。[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)管理に関する[バグ](./programming.md#バグ)の一種。\n\n"},{"term":"アロケート（アロケーション）","link":"./note/ja/./programming/_/chapters/memory_management.md","flagment":"アロケート","content":"\n**アロケート**（**アロケーション**）は、データを配置するために必要な[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域を確保すること。可変長データを拡張しようとしたときに、あらかじめ確保した[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)領域が不足した場合、改めて十分な空き領域をアロケートする必要がある。基本的にアロケートは低速な操作であるため、アロケートが発生する回数が少なくなるようにすることで[プログラム](./programming.md#プログラム)を高速化することができる場合がある。\n"},{"term":"Rust","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"rust","content":"\n**Rust**は、システムプログラミングのための言語であり、[C](../../../_/chapters/programming_language.md#c言語)や[C++](../../../_/chapters/programming_language.md#c)といった言語を置き替える次世代の[プログラミング言語](../../../_/chapters/programming.md#プログラミング言語)となることを目指している。\n\n"},{"term":"ゼロオーバヘッド原則","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"実行速度","content":"\n[C++](../../../_/chapters/programming_language.md#c)には**ゼロオーバヘッド原則**という、実行することに対して余計なコード（ガベージコレクションなど）でCPUを消費しない、という考え方がある。\n\n[Rust](#rust)には**ゼロコスト抽象化**という、抽象化の処理に最小限のコストしか払わないという考え方がある。例えば、[Rust](#rust)の抽象型であるtraitは[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイル)時に静的ディスパッチ（具体的な型に変換）されるため、実行時の[オーバヘッド](../../../../system/_/chapters/system_performance_evaluation.md#オーバヘッド)がない。\n\n[Rust](#rust)は[C++](../../../_/chapters/programming_language.md#c)と同様に、[プログラマ](../../../_/chapters/programming.md#プログラマ)が[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の能力を最大限活用できるような[コード](../../../_/chapters/programming.md#ソースコード)を書くことをサポートする言語である。\n\n"},{"term":"ゼロコスト抽象化","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"実行速度","content":"\n[C++](../../../_/chapters/programming_language.md#c)には**ゼロオーバヘッド原則**という、実行することに対して余計なコード（ガベージコレクションなど）でCPUを消費しない、という考え方がある。\n\n[Rust](#rust)には**ゼロコスト抽象化**という、抽象化の処理に最小限のコストしか払わないという考え方がある。例えば、[Rust](#rust)の抽象型であるtraitは[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイル)時に静的ディスパッチ（具体的な型に変換）されるため、実行時の[オーバヘッド](../../../../system/_/chapters/system_performance_evaluation.md#オーバヘッド)がない。\n\n[Rust](#rust)は[C++](../../../_/chapters/programming_language.md#c)と同様に、[プログラマ](../../../_/chapters/programming.md#プログラマ)が[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の能力を最大限活用できるような[コード](../../../_/chapters/programming.md#ソースコード)を書くことをサポートする言語である。\n\n"},{"term":"rustup","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"rustup","content":"\n**rustup**は、[Rust](#rust)のインストールやアップデートを行うためのツール。 `rustup` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)で、[Rust](#rust)の[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイル)に必要なツールチェーンやクロスコンパイル環境を構築することができる。\n\n- [rustupのインストール](https://rustup.rs/)\n\n`rustup install` は、Rustのツールチェーンをインストールする[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。配布用チャネルとして、安定リリース版の `stable` 、次期バージョンに向けたベータ版の `beta` 、開発版の `nightly` を指定できる。\n\n```sh\n"},{"term":"Cargo","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"cargo","content":"\n**Cargo**は、[Rust](#rust)のビルドシステムと[パッケージマネージャ](../../../../computer/software/_/chapters/package.md#パッケージマネージャ)を兼ね備えたツール。Cargoを用いることで、[ソースコード](../../../_/chapters/programming.md#ソースコード)のビルドや、依存している[パッケージ](../../../../computer/software/_/chapters/package.md#パッケージ)のダウンロードなどが[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)ひとつで完結するようになる。\n\n`cargo new` および `cargo init` は、[Rust](#rust)のプロジェクトを作成するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。 `cargo new` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)は引数にプロジェクト名を指定することで、新しいプロジェクトの[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)内に開発のための環境が作成される。一方、 `cargo init` は[カレントディレクトリ](../../../../computer/software/_/chapters/file_system.md#カレントディレクトリ)を[Rust](#rust)プロジェクトとするための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。 `--bin` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)をつけることで[バイナリ](../../../../basics/_/chapters/computer_and_number.md#バイナリ)向けのプロジェクト、 `--lib` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)をつけることで[ライブラリ](../../../../computer/software/_/chapters/package.md#ライブラリ)向けのプロジェクトとして初期化される（デフォルトは `--bin` ）。\n\n```sh\n"},{"term":"rustc","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"rustc","content":"\n**rustc**は、[Rust](#rust)の[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)。ビルドツールとして[Cargo](#cargo)を利用しているプロジェクトでは、内部で自動的にrustcが実行されている。クロスコンパイルが可能で、[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)、[Linux](../../../../computer/software/_/chapters/operating_system.md#linux)、[macOS](../../../../computer/software/_/chapters/operating_system.md#macos)向けの[実行ファイル](../../../../computer/software/_/chapters/file_system.md#実行ファイル)他、[Android](../../../../computer/software/_/chapters/operating_system.md#android)や[iOS](../../../../computer/software/_/chapters/operating_system.md#ios)で動作する[ライブラリ](../../../../computer/software/_/chapters/package.md#ライブラリ)をホストマシンで出力することができる。\n\n[Rust](#rust)で書かれた[プログラム](../../../_/chapters/programming.md#プログラム)を指定することで、それを[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイル)することができる。\n\n```sh\n$ rustc <path>\n```\n\n"},{"term":"rustdoc","link":"./note/ja/./programming/rust/_/chapters/rust.md","flagment":"rustdoc","content":"\n**rustdoc**は、[Rust](#rust)のドキュメンテーションツールで、[ソースコード](../../../_/chapters/programming.md#ソースコード)中のドキュメンテーションコメントを整形してHTMLを生成する。また、ドキュメンテーションコメント中に書かれた[Rust](#rust)[プログラム](../../../_/chapters/programming.md#プログラム)が正常に動作するかをテストすることができる。\n\n[Rust](#rust)で書かれた[プログラム](../../../_/chapters/programming.md#プログラム)を指定することで、その[ソースコード](../../../_/chapters/programming.md#ソースコード)に対するHTMLドキュメントを生成することができる。\n\n```sh\n$ rustdoc <path>\n```\n\n[Cargo](#cargo)を用いたプロジェクトでは、次の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)でrustdocを使用することができる。\n\n```sh\n$ cargo doc\n```\n"},{"term":"型推論","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"型推論","content":"\n**型推論**は、[プログラム](../../../_/chapters/programming.md#プログラム)中に[型](../../../_/chapters/data_type.md#型)を明示せずとも、いくつかの[型](../../../_/chapters/data_type.md#型)情報から自動で[変数](../../../_/chapters/variable.md#変数)の[型](../../../_/chapters/data_type.md#型)を推論する[Rust](./rust.md#rust)[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)の機能。これにより、[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイル)時の[エラー](../../../_/chapters/programming.md#エラー)検出というメリットを残したまま、[動的型付け言語](../../../_/chapters/programming.md#動的型付け言語)の可読性の高さという恩恵を受けることができる。\n\n"},{"term":"ジェネリック","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"ジェネリック","content":"\n**ジェネリック**は、反復的な[コード](../../../_/chapters/programming.md#ソースコード)を記述する必要性を減らすための機能で、[引数](../../../_/chapters/function.md#引数)や[戻り値](../../../_/chapters/function.md#戻り値)として複数の種類の[型](../../../_/chapters/data_type.md#型)を取りうるような[関数](../../../_/chapters/function.md#関数)を1つの定義で表現することができるようになる。\n\n[JavaScript](../../../_/chapters/programming_language.md#javascript)や[Python](../../../_/chapters/programming_language.md#python)といった[動的型付け言語](../../../_/chapters/programming.md#動的型付け言語)では、すべての[関数](../../../_/chapters/function.md#関数)が自然とこのよう動作となる。[関数](../../../_/chapters/function.md#関数)は、その[関数](../../../_/chapters/function.md#関数)が必要とする[プロパティ](../../../_/chapters/object_oriented.md#プロパティ)や[メソッド](../../../_/chapters/object_oriented.md#メソッド)を持つすべての[オブジェクト](../../../_/chapters/object_oriented.md#オブジェクト)を[引数](../../../_/chapters/function.md#引数)として取ることができる（[引数](../../../_/chapters/function.md#引数)として取りうる[オブジェクト](../../../_/chapters/object_oriented.md#オブジェクト)を明示的に制限しない）。このような性質を[ダックタイピング](../../../_/chapters/object_oriented.md#ダックタイピング)といい、これにより[プログラム](../../../_/chapters/programming.md#プログラム)が効率的になる一方で、[エラー](../../../_/chapters/programming.md#エラー)や[バグ](../../../_/chapters/programming.md#バグ)の原因ともなりうる。\n\n[Rust](#rust)ではジェネリック機構を利用することで、厳密な[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)時の[型](../../../_/chapters/data_type.md#型)チェックと柔軟性を両立している。\n\n\n"},{"term":"整数型","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"整数型","content":"\n[Rust](./rust.md#rust)の整数型に関する特徴は以下の通り。\n\n- [Rust](./rust.md#rust)の符号付き整数は[2の補数](../../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#2の補数)表現となっている。\n- [Rust](./rust.md#rust)では、[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)値に対して `u8` 型を用いる。[バイナリファイル](../../../../computer/software/_/chapters/file_system.md#バイナリファイル)や[ソケット](../../../../computer/linux/_/chapters/process_and_job.md#ソケット)からデータを読み取ると、 `u8` の値のストリームが得られる。\n- [C](../../../_/chapters/programming_language.md#c言語)や[C++](../../../_/chapters/programming_language.md#c)では数値と文字の[型](../../../_/chapters/data_type.md#型)を区別しない（ `u8` と `char` は同じ）が、[Rust](./rust.md#rust)ではこれらを区別する。ただし、[バイトリテラル](#バイトリテラル)の機能が用意されており、例えば `b'X'` は、文字\"X\"に対する[ASCII](../../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)コードの `u8` 値になる。\n- `usize` と `isize` は、実行対象の計算機のアドレス空間サイズに依存しており、32[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)アーキテクチャでは32[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)、64[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)アーキテクチャでは64[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)となる。\n- `0x` 、 `0o` 、 `0b` を接頭辞としてつけると、それぞれ[16進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#16進数)、[8進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#8進数)、[2進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#2進数)のリテラルになる。\n- 整数型から別の整数型への変換は `as` 演算子を用いて行う。[Rust](./rust.md#rust)は[C](../../../_/chapters/programming_language.md#c言語)や[C++](../../../_/chapters/programming_language.md#c)とは異なり、数値型の**暗黙の型変換**をほとんど行わないので、[プログラマ](../../../_/chapters/programming.md#プログラム)自身が明示する必要がある。\n\n"},{"term":"暗黙の型変換","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"整数型","content":"\n[Rust](./rust.md#rust)の整数型に関する特徴は以下の通り。\n\n- [Rust](./rust.md#rust)の符号付き整数は[2の補数](../../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#2の補数)表現となっている。\n- [Rust](./rust.md#rust)では、[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)値に対して `u8` 型を用いる。[バイナリファイル](../../../../computer/software/_/chapters/file_system.md#バイナリファイル)や[ソケット](../../../../computer/linux/_/chapters/process_and_job.md#ソケット)からデータを読み取ると、 `u8` の値のストリームが得られる。\n- [C](../../../_/chapters/programming_language.md#c言語)や[C++](../../../_/chapters/programming_language.md#c)では数値と文字の[型](../../../_/chapters/data_type.md#型)を区別しない（ `u8` と `char` は同じ）が、[Rust](./rust.md#rust)ではこれらを区別する。ただし、[バイトリテラル](#バイトリテラル)の機能が用意されており、例えば `b'X'` は、文字\"X\"に対する[ASCII](../../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)コードの `u8` 値になる。\n- `usize` と `isize` は、実行対象の計算機のアドレス空間サイズに依存しており、32[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)アーキテクチャでは32[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)、64[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)アーキテクチャでは64[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)となる。\n- `0x` 、 `0o` 、 `0b` を接頭辞としてつけると、それぞれ[16進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#16進数)、[8進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#8進数)、[2進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#2進数)のリテラルになる。\n- 整数型から別の整数型への変換は `as` 演算子を用いて行う。[Rust](./rust.md#rust)は[C](../../../_/chapters/programming_language.md#c言語)や[C++](../../../_/chapters/programming_language.md#c)とは異なり、数値型の**暗黙の型変換**をほとんど行わないので、[プログラマ](../../../_/chapters/programming.md#プログラム)自身が明示する必要がある。\n\n"},{"term":"チェック付き演算","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"チェック付き演算","content":"\n**チェック付き演算**は、演算結果を `Option` 型で返却する。数学的に正しい答えが得られた場合には `Some(v)` を、そうでない場合は `None` を返す。これによって、計算結果が[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)した場合などの挙動を制御することができる。\n\n[演算子](../../../_/chapters/operation.md#演算)名に接頭辞 `check_` をつけることで利用できる。\n\n"},{"term":"ラップ演算","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"ラップ演算","content":"\n**ラップ演算**は、[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が発生した場合に、溢れた桁を無視した結果を返却する。\n\n[演算子](../../../_/chapters/operation.md#演算)名に接頭辞 `wrapping_` をつけることで利用できる。\n\n"},{"term":"飽和演算","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"飽和演算","content":"\n**飽和演算**は、[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が発生した場合に、計算結果としてその[型](../../../_/chapters/data_type.md#型)の最大値（もしくは最小値）を返却する。\n\n[演算子](../../../_/chapters/operation.md#演算)名に接頭辞 `saturating_` をつけることで利用できる。\n\n"},{"term":"オーバフロー演算","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"オーバフロー演算","content":"\n**オーバフロー演算**は、[ラップ演算](#ラップ演算)の結果（ `result` ）と、[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が発生したか否かの[真偽値](#真偽値型)（ `overflowed` ）を、 `(result, overflowed)` という形式の[タプル](#タプル型)で返却する。\n\n[演算子](../../../_/chapters/operation.md#演算)名に接頭辞 `overflowing_` をつけることで利用できる。\n\n\n"},{"term":"タプル型","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"タプル型","content":"\n**タプル型**は、様々な[型](../../../_/chapters/data_type.md#型)の組み合わせを表現するための[型](../../../_/chapters/data_type.md#型)。要素へのアクセスには定数のインデックスを用いる。\n\n```rust\nlet profile: (&str, usize, usize, usize) = (\"ichigo\", 2001, 8, 21);\nprintln!(\"Birth year: {}\", profile.1);\n```\n\nタプルは[配列](#配列)とよく似ているが、[配列](#配列)は同じ型の要素を複数格納する[コンテナ](../../../_/chapters/data_type.md#コンテナ型)であるのに対し、タプルは異なる[型](../../../_/chapters/data_type.md#型)の要素をまとめることができる。また、[配列](#配列)は[変数](../../../_/chapters/variable.md#変数)インデックスによる要素へのアクセス( `array[i]` )ができるのに対して、タプルは定数インデックスしか用いることができない。\n\nタプルは[関数](../../../_/chapters/function.md#関数)の[返り値](../../../_/chapters/function.md#返り値)などに頻繁に用いられる。[関数](../../../_/chapters/function.md#関数)は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。\n\nまた、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 `(height, width)` や `(latitude, longitude)` などである。\n\n0要素のタプルもタプルの典型的な活用例で、 `()` のように記述され、**ユニット型**と呼ばれる。\n\n\n"},{"term":"ユニット型","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"タプル型","content":"\n**タプル型**は、様々な[型](../../../_/chapters/data_type.md#型)の組み合わせを表現するための[型](../../../_/chapters/data_type.md#型)。要素へのアクセスには定数のインデックスを用いる。\n\n```rust\nlet profile: (&str, usize, usize, usize) = (\"ichigo\", 2001, 8, 21);\nprintln!(\"Birth year: {}\", profile.1);\n```\n\nタプルは[配列](#配列)とよく似ているが、[配列](#配列)は同じ型の要素を複数格納する[コンテナ](../../../_/chapters/data_type.md#コンテナ型)であるのに対し、タプルは異なる[型](../../../_/chapters/data_type.md#型)の要素をまとめることができる。また、[配列](#配列)は[変数](../../../_/chapters/variable.md#変数)インデックスによる要素へのアクセス( `array[i]` )ができるのに対して、タプルは定数インデックスしか用いることができない。\n\nタプルは[関数](../../../_/chapters/function.md#関数)の[返り値](../../../_/chapters/function.md#返り値)などに頻繁に用いられる。[関数](../../../_/chapters/function.md#関数)は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。\n\nまた、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 `(height, width)` や `(latitude, longitude)` などである。\n\n0要素のタプルもタプルの典型的な活用例で、 `()` のように記述され、**ユニット型**と呼ばれる。\n\n\n"},{"term":"ポインタ型","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"ポインタ型","content":"\n[Rust](./rust.md#rust)には、ポインタ[アドレス](../../../../computer/hardware/_/chapters/memory.md#アドレス)を表す[型](../../../_/chapters/data_type.md#型)がいくつかある。\n\n"},{"term":"参照","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"参照","content":"\n**参照**は、[Rust](./rust.md#rust)の最も基本的な[ポインタ型](#ポインタ型)。\n\n`String` 型の値への参照は `&String` であり、これは `String` のアドレスを保持した1[ワード](../../../../basics/_/chapters/computer_and_number.md#ワード)長のデータとなる。\n\n[Rust](./rust.md#rust)のポインタは[C](../../../_/chapters/programming_language.md#c言語)とは異なり、決して `null` になることはない。また、値の[所有権](./ownership_and_move.md#所有権)と[ライフタイム](./reference_and_lifetime.md#ライフタイム)の管理により、[ダングリングポインタ](../../../_/chapters/memory_management.md#ダングリングポインタ)や[多重開放（多重フリー）](../../../_/chapters/memory_management.md#二重フリー)、[ポインタ](#ポインタ型)の無効化（nullポインタ）といった[バグ](../../../_/chapters/programming.md#バグ)を[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)時に取り除くことができる。\n\n参照には、[共有参照](./reference_and_lifetime.md#共有参照)と[可変参照](./reference_and_lifetime.md#可変参照)がある。\n\n"},{"term":"Box","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"box","content":"\n`Box` は、[ヒープ](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)上に値を確保するための[型](../../../_/chapters/data_type.md#型)。 `Box<T>` の値は、事前に[移動](./ownership_and_move.md#移動)されていない限りは[スコープ](../../../_/chapters/control_flow.md#スコープ)を抜けると自動的に[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)が解放される。\n\n"},{"term":"rawポインタ","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"rawポインタ","content":"\n**rawポインタ**は、[C++](../../../_/chapters/programming_language.md#c)が扱う[ポインタ](#ポインタ型)とよく似ており、[Rust](./rust.md#rust)が管理する[ポインタ](#ポインタ型)とは異なって[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)安全ではない(unsafe Rust)。\n\n\n"},{"term":"スライス","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"スライス","content":"\n**スライス**は、[配列](#配列)や[ベクタ](#ベクタ)のうちの特定の領域を指す[参照](#参照)。スライスはファットポインタであり、スライスが指す最初の要素への[ポインタ](#ポインタ型)とスライスに含まれる要素数という2[ワード](../../../../basics/_/chapters/computer_and_number.md#ワード)長で表される。\n\n```rust\nlet even: [i32; 5] = [2, 4, 6, 8, 10];\nlet evel_slice: &[i32] = &even;\n```\n\n通常の[参照](#参照)は[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)上の独立の値に対する[所有権](./ownership_and_move.md#所有権)のない[ポインタ](#ポインタ型)であるのに対し、スライスの[参照](#参照)（あるいは単にスライス）は[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)上の独立した値の領域に対する[参照](#参照)であると考えることができる。\n\n同じ[型](../../../_/chapters/data_type.md#型)のデータ列に対する[関数](../../../_/chapters/function.md#関数)を実装する際には、[引数](../../../_/chapters/function.md#引数)としてスライスをとるように設計すると、[配列](#配列)に対しても[ベクタ](#ベクタ)に対しても適用できるようになる。\n\n```rust\nfn print_num( n: &[i32] )\n{\n    for elm in n\n    {\n        println!(\"{}\", elm);\n    }\n}\n```\n\n\n"},{"term":"文字列リテラル","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"文字列リテラル","content":"\n**文字列リテラル**は、[プログラム](../../../_/chapters/programming.md#プログラム)中でダブルクォーテーションで囲まれた文字列。文字列リテラルには改行を含めることができ、文字列の行の最後にバックスラッシュをつけた場合は、改行文字と次の行の空白文字が無視される。\n\n```rust\n\"Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAenean commodo ligula eget dolor.\nAenean massa.\nCum sociis natoque penatibus et magnis dis parturient montes, \\\nnascetur ridiculus mus.\"\n```\n\n文字列中の意味のある文字をエスケープするのが面倒なケース（[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)のパスを記述するときなど）は、**生文字列**(raw string)を用いることができる。\n\n```rust\nr\"C:\\Program Files\\App\"\n```\n\nさらに、ダブルクォーテーションのエスケープすらも省略したい場合には、開始と終了のダブルクォーテーションを任意の数のハッシュ文字で挟む（ハッシュ文字の数は、わかりやすいように決めればよい）。\n\n```rust\nr###\"She said \"Hello\".\"###\n```\n\n"},{"term":"型エイリアス","link":"./note/ja/./programming/rust/_/chapters/data_type.md","flagment":"型エイリアス","content":"\n**型エイリアス**は、ある型に対して別名をつける機能。 `type` キーワードを用いると、既存の[型](../../../_/chapters/data_type.md#型)に対して別名をつけることができる。\n\n```rust\ntype Bytes = Vec<u8>;\n```\n"},{"term":"所有権","link":"./note/ja/./programming/rust/_/chapters/ownership_and_move.md","flagment":"所有権","content":"\n**所有権**は、[Rust](./rust.md#rust)が持つ[メモリ管理](../../../_/chapters/memory_management.md#プログラムのメモリ管理)のための機能で、確保した[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)を使用が終わった時点で自動的に破棄する機能。[C++](../../../_/chapters/programming_language.md#c)においても、[オブジェクト](../../../_/chapters/object_oriented.md#オブジェクト)に所有されている[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)に対して[ポインタ](../../../_/chapters/data_type.md#ポインタ型)を作った場合に、[オブジェクト](../../../_/chapters/object_oriented.md#オブジェクト)が[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)領域を破棄する前に、[ポインタ](../../../_/chapters/data_type.md#ポインタ型)を破棄する義務がある、という考え方のことを所有権という。このような考え方をもとに実装された[C++](../../../_/chapters/programming_language.md#c)の機能をスマートポインタという。[Rust](./rust.md#rust)では所有権の考え方が言語そのものに組み込まれており、すべてのデータに対して[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)が所有権をチェックすることによって[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)のクリーンアップを強制する。[Rust](./rust.md#rust)におけるすべての値は、その[ライフタイム](./reference_and_lifetime.md#ライフタイム)を決定する唯一の所有者を持ち、所有者が解放（ドロップ）されたときに所有されていた値もドロップされる。\n\n[ベクタ](./data_type.md#ベクタ)や文字列などの可変長の[変数](../../../_/chapters/variable.md#変数)を扱う際には、その[変数](../../../_/chapters/variable.md#変数)のファットポインタが[スタックフレーム](../../../_/chapters/data_type.md#スタック)上に保持され、その[ポインタ](../../../_/chapters/data_type.md#ポインタ型)の先のバッファだけが[ヒープ](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)上に取られる。このような状態を、バッファが[スタックフレーム](../../../../computer/hardware/_/chapters/memory.md#スタック領域)上の[ポインタ](../../../_/chapters/data_type.md#ポインタ型)に所有されているという。\n\n複雑な所有関係にある要素（[ベクタ](./data_type.md#ベクタ)の中に文字列が格納されている場合など）では、所有者と所有される値はツリー構造をなす。[変数](../../../_/chapters/variable.md#変数)が[スコープ](../../../_/chapters/control_flow.md#スコープ)から外れると、それより下のツリー全体が順次ドロップされる。\n\n[Rust](./rust.md#rust)の所有権には他にも以下のような特徴がある。\n\n- 値を1つの所有者から別の所有者へmove（移動）することができる\n- 整数、浮動小数点数、文字などの[プリミティブ型](../../../_/chapters/data_type.md#プリミティブ型)（[ヒープ](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)上に領域を確保する必要のない固定長変数）については、所有権のルールが適用されない\n- [標準ライブラリ](../../../../computer/software/_/chapters/package.md#標準ライブラリ)の `Rc` や `Arc` を利用することで、参照カウントが利用できる\n- 値への参照の[借用](./reference_and_lifetime.md#参照と借用)（[参照](./data_type.md#参照)を[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として渡す操作）ができる\n\n\n"},{"term":"コピー型","link":"./note/ja/./programming/rust/_/chapters/ownership_and_move.md","flagment":"コピー型","content":"\n**コピー型**は、[Rust](./rust.md#rust)において、[移動](#移動)の代わりに[ディープコピー](../../../_/chapters/data_type.md#ディープコピー)が行われるような[型](../../../_/chapters/data_type.md#型)。[ヒープ領域](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)のリソースを伴う値は、[ディープコピー](../../../_/chapters/data_type.md#ディープコピー)するのに大きなコストが必要になるが、[プリミティブ型](../../../_/chapters/data_type.md#プリミティブ型)のように[移動](#移動)を意識するメリットが少ない[型](../../../_/chapters/data_type.md#型)については、[移動](#移動)のルールを適用しないためにコピー型とする場合がある。\n\n[変数](../../../_/chapters/variable.md#変数)がコピー型であるかを判断する簡単な指標として、値をドロップする際になにか特別なことをしなければいけない[型](../../../_/chapters/data_type.md#型)はコピー型ではない、と考えるとよい。\n\n独自定義の[型](../../../_/chapters/data_type.md#型)については、デフォルトでコピー型ではないものの、[フィールド](../../../_/chapters/object_oriented.md#プロパティ)がすべてコピー型である場合には次のように属性を付与することでコピー型にすることができる。\n\n```rust\n"},{"term":"Rc","link":"./note/ja/./programming/rust/_/chapters/ownership_and_move.md","flagment":"rcとarc","content":"\n[Rust](./rust.md#rust)では値が唯一の所有者を持っているが、複数の所有者のすべてがその値を使い終わるまで生存してほしいような値に対しては、 `Rc` や `Arc` といった参照カウントの[ポインタ型](./data_type.md#ポインタ型)を利用することができる。\n\n`Arc` はアトミックな参照カウンタであり、複数の[スレッド](../../../../computer/software/_/chapters/operating_system.md#スレッド)間で値を直接共有しても安全なようにできている。だたし、そのような必要がない場合については、 `Rc` の方が高速である。\n\n```rust\nuse std::rc::Rc;\n\nlet s: Rc<String> = Rc::new(\"Hello, world\".to_string());\nlet t: Rc<String> = s.clone();\nlet u: Rc<String> = s.clone();\n```\n\nこのような[コード](../../../_/chapters/programming.md#ソースコード)を書いた場合、[スタックフレーム](../../../../computer/hardware/_/chapters/memory.md#スタック領域)上では[ヒープ領域](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)の `Rc` の参照カウントを指す[ポインタ](../../../_/chapters/data_type.md#ポインタ型)だけが保持される。 `Rc` は強い参照カウントを持ち、 `Rc<T>` がクローンされると参照カウントが[インクリメント](../../../_/chapters/operation.md#インクリメント)される。 `Rc` 自身は `String` 型と同様に、値への[ポインタ](../../../_/chapters/data_type.md#ポインタ型)とバッファの容量、長さからなるワード列でできている。\n\n`Rc` [ポインタ](../../../_/chapters/data_type.md#ポインタ型)に所有される値は不変である必要があるため、注意が必要。\n"},{"term":"Arc","link":"./note/ja/./programming/rust/_/chapters/ownership_and_move.md","flagment":"rcとarc","content":"\n[Rust](./rust.md#rust)では値が唯一の所有者を持っているが、複数の所有者のすべてがその値を使い終わるまで生存してほしいような値に対しては、 `Rc` や `Arc` といった参照カウントの[ポインタ型](./data_type.md#ポインタ型)を利用することができる。\n\n`Arc` はアトミックな参照カウンタであり、複数の[スレッド](../../../../computer/software/_/chapters/operating_system.md#スレッド)間で値を直接共有しても安全なようにできている。だたし、そのような必要がない場合については、 `Rc` の方が高速である。\n\n```rust\nuse std::rc::Rc;\n\nlet s: Rc<String> = Rc::new(\"Hello, world\".to_string());\nlet t: Rc<String> = s.clone();\nlet u: Rc<String> = s.clone();\n```\n\nこのような[コード](../../../_/chapters/programming.md#ソースコード)を書いた場合、[スタックフレーム](../../../../computer/hardware/_/chapters/memory.md#スタック領域)上では[ヒープ領域](../../../../computer/hardware/_/chapters/memory.md#ヒープ領域)の `Rc` の参照カウントを指す[ポインタ](../../../_/chapters/data_type.md#ポインタ型)だけが保持される。 `Rc` は強い参照カウントを持ち、 `Rc<T>` がクローンされると参照カウントが[インクリメント](../../../_/chapters/operation.md#インクリメント)される。 `Rc` 自身は `String` 型と同様に、値への[ポインタ](../../../_/chapters/data_type.md#ポインタ型)とバッファの容量、長さからなるワード列でできている。\n\n`Rc` [ポインタ](../../../_/chapters/data_type.md#ポインタ型)に所有される値は不変である必要があるため、注意が必要。\n"},{"term":"借用","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"参照と借用","content":"\n[参照](./data_type.md#参照)は、[Rust](./rust.md#rust)が[所有権](./ownership_and_move.md#所有権)を持たない[ポインタ型](../../../_/chapters/data_type.md#ポインタ型)。[参照](./data_type.md#参照)は[参照](./data_type.md#参照)先よりも長生きしてはいけないので、これを強調するために[Rust](./rust.md#rust)ではある[参照](./data_type.md#参照)を作ることを**借用**と呼ぶ。\n\n[関数](../../../_/chapters/function.md#関数)に[引数](../../../_/chapters/function.md#引数)を渡す時に[所有権](./ownership_and_move.md#所有権)を[移動](./ownership_and_move.md#移動)してしまうと、それ以降は[引数](../../../_/chapters/function.md#引数)に使った値が使えなくなってしまう（**値渡し**）。そのため、[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として[参照](./data_type.md#参照)を用いるのが適切な場合も多い（**参照渡し**）。\n\n"},{"term":"値渡し","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"参照と借用","content":"\n[参照](./data_type.md#参照)は、[Rust](./rust.md#rust)が[所有権](./ownership_and_move.md#所有権)を持たない[ポインタ型](../../../_/chapters/data_type.md#ポインタ型)。[参照](./data_type.md#参照)は[参照](./data_type.md#参照)先よりも長生きしてはいけないので、これを強調するために[Rust](./rust.md#rust)ではある[参照](./data_type.md#参照)を作ることを**借用**と呼ぶ。\n\n[関数](../../../_/chapters/function.md#関数)に[引数](../../../_/chapters/function.md#引数)を渡す時に[所有権](./ownership_and_move.md#所有権)を[移動](./ownership_and_move.md#移動)してしまうと、それ以降は[引数](../../../_/chapters/function.md#引数)に使った値が使えなくなってしまう（**値渡し**）。そのため、[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として[参照](./data_type.md#参照)を用いるのが適切な場合も多い（**参照渡し**）。\n\n"},{"term":"参照渡し","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"参照と借用","content":"\n[参照](./data_type.md#参照)は、[Rust](./rust.md#rust)が[所有権](./ownership_and_move.md#所有権)を持たない[ポインタ型](../../../_/chapters/data_type.md#ポインタ型)。[参照](./data_type.md#参照)は[参照](./data_type.md#参照)先よりも長生きしてはいけないので、これを強調するために[Rust](./rust.md#rust)ではある[参照](./data_type.md#参照)を作ることを**借用**と呼ぶ。\n\n[関数](../../../_/chapters/function.md#関数)に[引数](../../../_/chapters/function.md#引数)を渡す時に[所有権](./ownership_and_move.md#所有権)を[移動](./ownership_and_move.md#移動)してしまうと、それ以降は[引数](../../../_/chapters/function.md#引数)に使った値が使えなくなってしまう（**値渡し**）。そのため、[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として[参照](./data_type.md#参照)を用いるのが適切な場合も多い（**参照渡し**）。\n\n"},{"term":"共有参照","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"共有参照","content":"\n**共有参照**は、読み取り専用の[参照](./data_type.md#参照)で、[参照](./data_type.md#参照)先の値を書き換えることはできない。ある値に対する共有参照は同時に複数取ることができる。共有参照は、 `&T` のようにして記述する。\n\n"},{"term":"可変参照","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"可変参照","content":"\n**可変参照**は、読み書き可能な[参照](./data_type.md#参照)で、[参照](./data_type.md#参照)先の値を読み書きできる。可変参照は排他的であり、ある値に対して可変参照をとったときには他のあらゆる参照（[共有参照](#共有参照)も可変参照も）とることができない。可変参照は、 `&mut T` のようにして記述する。\n\n```rust\n// show()は値を読んでいるだけなので、共有参照を取るようにすれば十分\nfn show_table( table: &Table )\n{\n    // コレクション型に対して繰り返し実行すると、普通は所有権が移動されて値が消費されてしまう\n    // 共有参照に対して繰り返し実行すると、個々のエントリのキーと値に対する共有参照が作られる\n    for (key, values) in table\n    {\n        println!(\"key = {}:\", key);\n\n        for value in values\n        {\n            println!(\" {}\", value);\n        }\n    }\n}\n\n// sort()は値を書き換えるので、可変参照を取る必要がある\nfn sort_table( table: &mut Table )\n{\n    for (_key, values) in table\n    {\n        values.sort();\n    }\n}\n```\n\n\n"},{"term":"ライフタイム（生存期間）","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"ライフタイム","content":"\n**ライフタイム**（**生存期間**）は、[Rust](./rust.md#rust)[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)が[参照型](./data_type.md#参照)に対して割り当てるもので、[プログラム](../../../_/chapters/programming.md#プログラム)実行中にその[参照](./data_type.md#参照)が安全に利用できる期間を指す。\n\n[ローカル変数](../../../_/chapters/variable.md#ローカル変数)の[参照](./data_type.md#参照)を借用して、その[変数](../../../_/chapters/variable.md#変数)を[スコープ](../../../_/chapters/control_flow.md#スコープ)の外に持ち出すと、[ダングリングポインタ](../../../_/chapters/memory_management.md#ダングリングポインタ)となる。ライフライムの成約により、このような[参照](./data_type.md#参照)が作られることがなくなっている。\n\n```rust\n{\n    let r;\n    {\n        let x = 1;\n        r = &x;\n    }\n    assert_eq!(*r, 1);       // スコープの外ではxにアクセスできない\n}\n```\n\nライフタイムのルールは以下のとおり。\n\n- ある[変数](../../../_/chapters/variable.md#変数)の[参照](./data_type.md#参照)は、その[変数](../../../_/chapters/variable.md#変数)よりも長生きしてはならない\n- ある[変数](../../../_/chapters/variable.md#変数)に格納した[参照](./data_type.md#参照)は、少なくともその[変数](../../../_/chapters/variable.md#変数)と同じだけ生きていなければならない（[変数](../../../_/chapters/variable.md#変数)のライフタイムは、その[変数](../../../_/chapters/variable.md#変数)から[借用](#参照と借用)した[参照](./data_type.md#参照)のライフタイムを包含していなければならない）\n\nまた、[Rust](./rust.md#rust)は[変数](../../../_/chapters/variable.md#変数)のライフタイムとして可能な限り短い期間を想定する。\n\n"},{"term":"ボローチェッカー","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"ボローチェッカー","content":"\n**ボローチェッカー**は、[Rust](./rust.md#rust)[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)が[ライフタイム](#ライフタイム)を利用して[参照](./data_type.md#参照)の安全性を保証する機能。\n\n"},{"term":"'staticライフタイム","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"staticライフタイム","content":"\n**'staticライフタイム**は、[プログラム](../../../_/chapters/programming.md#プログラム)の開始から終了まで存在する[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)リソースに割り当てられる[ライフタイム](#ライフタイム)。\n\nある `static` な[変数](../../../_/chapters/variable.md#変数)を更新する以下のような[関数](../../../_/chapters/function.md#関数)を考える。\n\n```rust\nstatic mut STASH: &i32 = &128;\n\nfn update( p: &i32 )\n{\n    unsafe\n    {\n        STASH = p;\n    }\n}\n```\n\nこのとき、[関数](../../../_/chapters/function.md#関数)の[シグネチャ](../../../_/chapters/function.md#シグネチャ)は**ライフタイムパラメータ**を省略している（実際は[Rust](./rust.md#rust)の[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)が自動的に補完してくれるので省略可能）。これを明示的に記述すると以下のようになる。\n\n```rust\nfn update<'a>( p: &'a i32 ) { /* ... */ }\n```\n\n`'a` は任意の[ライフタイム](#ライフタイム)であり、[引数](../../../_/chapters/function.md#引数) `p` が任意のライフタイムパラメータを持っていることを示す。しかし、static変数である `STASH` に対して任意の[ライフタイム](#ライフタイム)を持つ[変数](../../../_/chapters/variable.md#変数) `p` を[代入](../../../_/chapters/variable.md#代入)するのは、[ライフタイム](#ライフタイム)のルールに反している（[変数](../../../_/chapters/variable.md#変数) `p` は少なくとも `STASH` と同じだけの[ライフタイム](#ライフタイム)を持たなければならない）。そこで、[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として取りうる値の[ライフタイム](#ライフタイム)を'staticライフタイムにすることでこの問題を解決できる。\n\n```rust\nfn update( p: &'static i32 ) { /* ... */ }\n```\n\n"},{"term":"ライフタイムパラメータ","link":"./note/ja/./programming/rust/_/chapters/reference_and_lifetime.md","flagment":"staticライフタイム","content":"\n**'staticライフタイム**は、[プログラム](../../../_/chapters/programming.md#プログラム)の開始から終了まで存在する[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)リソースに割り当てられる[ライフタイム](#ライフタイム)。\n\nある `static` な[変数](../../../_/chapters/variable.md#変数)を更新する以下のような[関数](../../../_/chapters/function.md#関数)を考える。\n\n```rust\nstatic mut STASH: &i32 = &128;\n\nfn update( p: &i32 )\n{\n    unsafe\n    {\n        STASH = p;\n    }\n}\n```\n\nこのとき、[関数](../../../_/chapters/function.md#関数)の[シグネチャ](../../../_/chapters/function.md#シグネチャ)は**ライフタイムパラメータ**を省略している（実際は[Rust](./rust.md#rust)の[コンパイラ](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)が自動的に補完してくれるので省略可能）。これを明示的に記述すると以下のようになる。\n\n```rust\nfn update<'a>( p: &'a i32 ) { /* ... */ }\n```\n\n`'a` は任意の[ライフタイム](#ライフタイム)であり、[引数](../../../_/chapters/function.md#引数) `p` が任意のライフタイムパラメータを持っていることを示す。しかし、static変数である `STASH` に対して任意の[ライフタイム](#ライフタイム)を持つ[変数](../../../_/chapters/variable.md#変数) `p` を[代入](../../../_/chapters/variable.md#代入)するのは、[ライフタイム](#ライフタイム)のルールに反している（[変数](../../../_/chapters/variable.md#変数) `p` は少なくとも `STASH` と同じだけの[ライフタイム](#ライフタイム)を持たなければならない）。そこで、[関数](../../../_/chapters/function.md#関数)の[引数](../../../_/chapters/function.md#引数)として取りうる値の[ライフタイム](#ライフタイム)を'staticライフタイムにすることでこの問題を解決できる。\n\n```rust\nfn update( p: &'static i32 ) { /* ... */ }\n```\n\n"},{"term":"コンピュータ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"コンピュータ","content":"\n**コンピュータ**は、与えられた手順に従って計算やデータ処理を自動的に行う装置全般のことで、特に電子回路を用いて[デジタル](../../../basics/information_theory/_/chapters/coding_theory.md#デジタル)データの入出力や演算、変換などを連続的に行うことができる電気機械を指す。\n\n[パソコン](#パーソナルコンピュータ)やゲーム機、スマートフォンやタブレットといった機器は全てコンピュータであり、最近では家電製品や自動車などにコンピュータが組み込まれることも珍しくない。\n\nコンピュータについて正しく理解して使いこなす能力を持っていることを**コンピュータリテラシ**と呼ぶ。\n\n\n"},{"term":"コンピュータリテラシ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"コンピュータ","content":"\n**コンピュータ**は、与えられた手順に従って計算やデータ処理を自動的に行う装置全般のことで、特に電子回路を用いて[デジタル](../../../basics/information_theory/_/chapters/coding_theory.md#デジタル)データの入出力や演算、変換などを連続的に行うことができる電気機械を指す。\n\n[パソコン](#パーソナルコンピュータ)やゲーム機、スマートフォンやタブレットといった機器は全てコンピュータであり、最近では家電製品や自動車などにコンピュータが組み込まれることも珍しくない。\n\nコンピュータについて正しく理解して使いこなす能力を持っていることを**コンピュータリテラシ**と呼ぶ。\n\n\n"},{"term":"第1世代","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第1世代","content":"\n第1世代の[コンピュータ](#コンピュータ)は、主に真空管を使用している。**真空管**は真空の容器中に電極を設けたもので、その間の電子流を制御することによって増幅や整流、発振などを行うことができる。\n\n1942年に世界初の[コンピュータ](#コンピュータ)（電子計算機）としてアメリカ・アイオワ州立大学で開発された**ABC**(Atanasoff-Berry Computer)は、現在の[コンピュータ](#コンピュータ)につながる様々な発明が詰め込まれていたが、実用機ではなかった。\n\n1946年にアメリカ・ペンシルバニア大学で開発された**ENIAC**(Electronic Numerical Integrator and Computer)は世界初の実用[コンピュータ](#コンピュータ)で、大砲の弾道計算を行うことを目的としていた。ENIACは世界初の[プログラム](../../../programming/_/chapters/programming.md#プログラム)可能な[コンピュータ](#コンピュータ)であったが、計算手順を変更するために配線を繋ぎ直さなければならないという欠点があった。\n\n1949年にイギリス・ケンブリッジ大学で開発された**EDSAC**(Electronic Delay Storage Automatic Calculator)は世界初の[プログラム内蔵方式](#プログラム内蔵方式)の[コンピュータ](#コンピュータ)。EDVACに関するレポートに刺激を受けて開発が進められ、結果としてEDVACよりも先に完成することとなった。\n\n1950年にアメリカ・レミントンランド社で開発された**UNIVAC-I**(UNIVersal Automatic Computer)は[プログラム内蔵方式](#プログラム内蔵方式)で世界初の商用[コンピュータ](#コンピュータ)。\n\n1952年にENIACを改良して開発された**EDVAC**(Electronic Discrete Variable Automatic Computer)は2進数と[プログラム内蔵方式](#プログラム内蔵方式)を採用した[コンピュータ](#コンピュータ)。「コンピュータの父」とも呼ばれる**ジョン・フォン・ノイマン**が携わっていることでも有名。\n\n"},{"term":"真空管","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第1世代","content":"\n第1世代の[コンピュータ](#コンピュータ)は、主に真空管を使用している。**真空管**は真空の容器中に電極を設けたもので、その間の電子流を制御することによって増幅や整流、発振などを行うことができる。\n\n1942年に世界初の[コンピュータ](#コンピュータ)（電子計算機）としてアメリカ・アイオワ州立大学で開発された**ABC**(Atanasoff-Berry Computer)は、現在の[コンピュータ](#コンピュータ)につながる様々な発明が詰め込まれていたが、実用機ではなかった。\n\n1946年にアメリカ・ペンシルバニア大学で開発された**ENIAC**(Electronic Numerical Integrator and Computer)は世界初の実用[コンピュータ](#コンピュータ)で、大砲の弾道計算を行うことを目的としていた。ENIACは世界初の[プログラム](../../../programming/_/chapters/programming.md#プログラム)可能な[コンピュータ](#コンピュータ)であったが、計算手順を変更するために配線を繋ぎ直さなければならないという欠点があった。\n\n1949年にイギリス・ケンブリッジ大学で開発された**EDSAC**(Electronic Delay Storage Automatic Calculator)は世界初の[プログラム内蔵方式](#プログラム内蔵方式)の[コンピュータ](#コンピュータ)。EDVACに関するレポートに刺激を受けて開発が進められ、結果としてEDVACよりも先に完成することとなった。\n\n1950年にアメリカ・レミントンランド社で開発された**UNIVAC-I**(UNIVersal Automatic Computer)は[プログラム内蔵方式](#プログラム内蔵方式)で世界初の商用[コンピュータ](#コンピュータ)。\n\n1952年にENIACを改良して開発された**EDVAC**(Electronic Discrete Variable Automatic Computer)は2進数と[プログラム内蔵方式](#プログラム内蔵方式)を採用した[コンピュータ](#コンピュータ)。「コンピュータの父」とも呼ばれる**ジョン・フォン・ノイマン**が携わっていることでも有名。\n\n"},{"term":"ジョン・フォン・ノイマン","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第1世代","content":"\n第1世代の[コンピュータ](#コンピュータ)は、主に真空管を使用している。**真空管**は真空の容器中に電極を設けたもので、その間の電子流を制御することによって増幅や整流、発振などを行うことができる。\n\n1942年に世界初の[コンピュータ](#コンピュータ)（電子計算機）としてアメリカ・アイオワ州立大学で開発された**ABC**(Atanasoff-Berry Computer)は、現在の[コンピュータ](#コンピュータ)につながる様々な発明が詰め込まれていたが、実用機ではなかった。\n\n1946年にアメリカ・ペンシルバニア大学で開発された**ENIAC**(Electronic Numerical Integrator and Computer)は世界初の実用[コンピュータ](#コンピュータ)で、大砲の弾道計算を行うことを目的としていた。ENIACは世界初の[プログラム](../../../programming/_/chapters/programming.md#プログラム)可能な[コンピュータ](#コンピュータ)であったが、計算手順を変更するために配線を繋ぎ直さなければならないという欠点があった。\n\n1949年にイギリス・ケンブリッジ大学で開発された**EDSAC**(Electronic Delay Storage Automatic Calculator)は世界初の[プログラム内蔵方式](#プログラム内蔵方式)の[コンピュータ](#コンピュータ)。EDVACに関するレポートに刺激を受けて開発が進められ、結果としてEDVACよりも先に完成することとなった。\n\n1950年にアメリカ・レミントンランド社で開発された**UNIVAC-I**(UNIVersal Automatic Computer)は[プログラム内蔵方式](#プログラム内蔵方式)で世界初の商用[コンピュータ](#コンピュータ)。\n\n1952年にENIACを改良して開発された**EDVAC**(Electronic Discrete Variable Automatic Computer)は2進数と[プログラム内蔵方式](#プログラム内蔵方式)を採用した[コンピュータ](#コンピュータ)。「コンピュータの父」とも呼ばれる**ジョン・フォン・ノイマン**が携わっていることでも有名。\n\n"},{"term":"第2世代","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第2世代","content":"\n第2世代の[コンピュータ](#コンピュータ)は、主にトランジスタなどの半導体を使用している。**トランジスタ**は電子回路中で信号を増幅したりスイッチングしたりすることができる半導体素子。トランジスタの登場により[コンピュータ](#コンピュータ)の小型化（**ダウンサイジング**）、低価格化が進んだ。また[真空管](#第1世代)と比べても信頼性が高く、発熱量も少ないため寿命が長いという利点があった。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM1400シリーズ**が世界的に人気が高かった。\n\n"},{"term":"トランジスタ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第2世代","content":"\n第2世代の[コンピュータ](#コンピュータ)は、主にトランジスタなどの半導体を使用している。**トランジスタ**は電子回路中で信号を増幅したりスイッチングしたりすることができる半導体素子。トランジスタの登場により[コンピュータ](#コンピュータ)の小型化（**ダウンサイジング**）、低価格化が進んだ。また[真空管](#第1世代)と比べても信頼性が高く、発熱量も少ないため寿命が長いという利点があった。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM1400シリーズ**が世界的に人気が高かった。\n\n"},{"term":"ダウンサイジング","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第2世代","content":"\n第2世代の[コンピュータ](#コンピュータ)は、主にトランジスタなどの半導体を使用している。**トランジスタ**は電子回路中で信号を増幅したりスイッチングしたりすることができる半導体素子。トランジスタの登場により[コンピュータ](#コンピュータ)の小型化（**ダウンサイジング**）、低価格化が進んだ。また[真空管](#第1世代)と比べても信頼性が高く、発熱量も少ないため寿命が長いという利点があった。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM1400シリーズ**が世界的に人気が高かった。\n\n"},{"term":"IBM1400シリーズ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第2世代","content":"\n第2世代の[コンピュータ](#コンピュータ)は、主にトランジスタなどの半導体を使用している。**トランジスタ**は電子回路中で信号を増幅したりスイッチングしたりすることができる半導体素子。トランジスタの登場により[コンピュータ](#コンピュータ)の小型化（**ダウンサイジング**）、低価格化が進んだ。また[真空管](#第1世代)と比べても信頼性が高く、発熱量も少ないため寿命が長いという利点があった。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM1400シリーズ**が世界的に人気が高かった。\n\n"},{"term":"第3世代","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第3世代","content":"\n第3世代の[コンピュータ](#コンピュータ)は主に集積回路を使用している。[集積回路](../../hardware/_/chapters/ic.md#ic)は半導体基板上に様々な回路素子を連結したもので、大変サイズが小さいことから**チップ**と呼ばれる。[IC](../../hardware/_/chapters/ic.md#ic)の登場により[コンピュータ](#コンピュータ)の小型化、高速化が一気に進んだ。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM 360シリーズ**が有名。\n\n"},{"term":"チップ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第3世代","content":"\n第3世代の[コンピュータ](#コンピュータ)は主に集積回路を使用している。[集積回路](../../hardware/_/chapters/ic.md#ic)は半導体基板上に様々な回路素子を連結したもので、大変サイズが小さいことから**チップ**と呼ばれる。[IC](../../hardware/_/chapters/ic.md#ic)の登場により[コンピュータ](#コンピュータ)の小型化、高速化が一気に進んだ。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM 360シリーズ**が有名。\n\n"},{"term":"IBM 360シリーズ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第3世代","content":"\n第3世代の[コンピュータ](#コンピュータ)は主に集積回路を使用している。[集積回路](../../hardware/_/chapters/ic.md#ic)は半導体基板上に様々な回路素子を連結したもので、大変サイズが小さいことから**チップ**と呼ばれる。[IC](../../hardware/_/chapters/ic.md#ic)の登場により[コンピュータ](#コンピュータ)の小型化、高速化が一気に進んだ。\n\nこの世代の[コンピュータ](#コンピュータ)としては、IBMが開発した**IBM 360シリーズ**が有名。\n\n"},{"term":"第3.5世代","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第35世代","content":""},{"term":"LIS","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第35世代","content":""},{"term":"マイクロプロセッサ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第35世代","content":""},{"term":"第4世代","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第4世代","content":"\n第4世代の[コンピュータ](#コンピュータ)は、主に[VLSI](../../hardware/_/chapters/ic.md#vlsi)を使用している。[VLSI](../../hardware/_/chapters/ic.md#vlsi)は[LSI](../../hardware/_/chapters/ic.md#lsi)よりもさらに集積度を高めた素子で、[VLSI](../../hardware/_/chapters/ic.md#vlsi)の登場により個人向けの[パーソナルコンピュータ](#パーソナルコンピュータ)が普及した。\n\n\n"},{"term":"VLIS","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"第4世代","content":"\n第4世代の[コンピュータ](#コンピュータ)は、主に[VLSI](../../hardware/_/chapters/ic.md#vlsi)を使用している。[VLSI](../../hardware/_/chapters/ic.md#vlsi)は[LSI](../../hardware/_/chapters/ic.md#lsi)よりもさらに集積度を高めた素子で、[VLSI](../../hardware/_/chapters/ic.md#vlsi)の登場により個人向けの[パーソナルコンピュータ](#パーソナルコンピュータ)が普及した。\n\n\n"},{"term":"パーソナルコンピュータ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"パーソナルコンピュータ","content":"\n**パーソナルコンピュータ**（パソコン、PC）は、個人が使用するのに適した小型で低価格の[コンピュータ](#コンピュータ)。形状やサイズに焦点を当てるとノートPC（ラップトップPC）、デスクトップPC、タブレットPCなどに分類できる。\n\n"},{"term":"ワークステーション","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"ワークステーション","content":"\n**ワークステーション**は、3次元の設計やCG、科学計算などに用いられる、一般の[PC](#パーソナルコンピュータ)よりも高速な処理が可能な[PC](#パーソナルコンピュータ)。[CPU](../../hardware/_/chapters/processor.md#cpu)を複数台搭載していたり、高速なグラフィックボードを搭載していたりと、[PC](#パーソナルコンピュータ)の中でも高額な部類。\n\n"},{"term":"サーバ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"サーバ","content":"\n**サーバ**は、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)と呼ばれる他の[コンピュータ](#コンピュータ)や[ソフトウェア](../../software/_/chapters/software.md#ソフトウェア)からの要求に応じてデータやサービスを提供するための[コンピュータ](#コンピュータ)。ホームページを配信する[Web](../../../network/_/chapters/web.md#web)サーバやメールを配信するメールサーバ、ファイルを管理するためのファイルサーバなどに分類できる。\n\n"},{"term":"メインフレーム","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"メインフレーム","content":"\n**メインフレーム**は、企業などの巨大な組織の根幹情報システムなどに使用される[コンピュータ](#コンピュータ)。多数の利用者や業務で共有し、大量の重要なデータや処理を扱うため、高い性能や信頼性を求められる。\n\n"},{"term":"スーパーコンピュータ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"スーパーコンピュータ","content":"\n**スーパーコンピュータ**は、科学的な研究目的で用いられる、大量の数値演算を高速で行うことができる[コンピュータ](#コンピュータ)。気象の予測や宇宙産業の領域で活躍している。\n\n"},{"term":"量子コンピュータ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"量子コンピュータ","content":"\n**量子コンピュータ**は、量子力学の原理を計算に応用した[コンピュータ](#コンピュータ)。素粒子の世界にみられる状態である**重ね合わせ**を利用して、従来の電子回路では不可能な超並列的な処理を行うことができる。\n\n\n"},{"term":"重ね合わせ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"量子コンピュータ","content":"\n**量子コンピュータ**は、量子力学の原理を計算に応用した[コンピュータ](#コンピュータ)。素粒子の世界にみられる状態である**重ね合わせ**を利用して、従来の電子回路では不可能な超並列的な処理を行うことができる。\n\n\n"},{"term":"コンピュータ構成要素","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"コンピュータ構成要素","content":"\n[コンピュータ](#コンピュータ)を構成する要素は、大きく[ハードウェア](#ハードウェア)と[ソフトウェア](#ソフトウェア)に分類できる。\n\n![コンピュータ構成要素](../assets/images/computer_system.jpg)\n\n"},{"term":"ハードウェア","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"ハードウェア","content":"\n**ハードウェア**は、[コンピュータ](#コンピュータ)を構成する要素のうち、回路や装置、設備などの物理的な実体を伴うもの。ディスプレイやキーボード、マウス、プリンタ等はハードウェアに分類される。\n\n- [ハードウェア](../../hardware/_/chapters/hardware.md#ハードウェア)\n\n"},{"term":"ソフトウェア","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"ソフトウェア","content":"\n**ソフトウェア**は、[コンピュータ](#コンピュータ)を動作させるための[プログラム](../../../programming/_/chapters/programming.md#プログラミング)。[コンピュータ](#コンピュータ)の根幹的な制御に関わる[基本ソフトウェア](../../software/_/chapters/software.md#基本ソフトウェア)と、特定の機能や目的のためにつくられた[応用ソフトウェア](../../software/_/chapters/software.md#応用ソフトウェア)がある。\n\n- [ソフトウェア](../../software/_/chapters/software.md#ソフトウェア)\n\n"},{"term":"ファームウェア","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"ファームウェア","content":"\n**ファームウェア**は、[コンピュータ](#コンピュータ)に内蔵される[ソフトウェア](#ソフトウェア)の一種で、本体内部の回路や装置などの基本的な制御を行う機能を持ったもの。機械の内部に固定的に組み込まれ内容の変更が少ないことから、[ハードウェア](#ハードウェア)と[ソフトウェア](#ソフトウェア)の中間的な存在として扱われる。\n\n"},{"term":"ミドルウェア","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"ミドルウェア","content":"\n**ミドルウェア**は、[ソフトウェア](#ソフトウェア)の一種で、[基本ソフトウェア](../../software/_/chapters/software.md#基本ソフトウェア)と[応用ソフトウェア](../../software/_/chapters/software.md#応用ソフトウェア)の中間に位置し、様々な[ソフトウェア](#ソフトウェア)から共通して利用される機能を提供するもの。[基本ソフトウェア](../../software/_/chapters/software.md#基本ソフトウェア)よりも分野や用途が限定された具体的な機能を提供する場合が多い。\n\n\n"},{"term":"コンピュータアーキテクチャ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"コンピュータアーキテクチャ","content":"\n**コンピュータアーキテクチャ**は、[コンピュータ](#コンピュータ)における[ハードウェア](#ハードウェア)や[ソフトウェア](#ソフトウェア)、[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)などの設計思想。\n\n"},{"term":"プログラム内蔵方式","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"プログラム内蔵方式","content":"\n**プログラム内蔵方式**（**ストアドプログラム方式**）は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)に格納しておき、これを読み込みながら実行する[コンピュータアーキテクチャ](#コンピュータアーキテクチャ)。プログラム内蔵方式ではない最初期の[コンピュータ](#コンピュータ)は、計算手順を変えるために配線をつなぎなおす必要があったため、汎用性に乏しかった。プログラム内蔵方式では[プログラム](../../../programming/_/chapters/programming.md#プログラム)を外部から与えることで、ひとつの[コンピュータ](#コンピュータ)で様々な処理を行えるようになっている。現在使われているほとんどの[コンピュータ](#コンピュータ)はプログラム内蔵方式を採用している。\n\nプログラム内蔵方式を採用した[コンピュータ](#コンピュータ)は、**ノイマン型コンピュータ**と呼ばれている。これはプログラム内蔵方式を採用した初期の[コンピュータ](#コンピュータ)である[EDVAC](#第1世代)に関する論文の著者、[ジョン・フォン・ノイマン](#第1世代)に由来している。\n\nノイマン型コンピュータでは、[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)から[演算装置](../../hardware/_/chapters/hardware.md#演算装置)に[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして伝送する際の速度がボトルネックとなりやすい。これを**フォンノイマンボトルネック**という。\n\n"},{"term":"ノイマン型コンピュータ","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"プログラム内蔵方式","content":"\n**プログラム内蔵方式**（**ストアドプログラム方式**）は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)に格納しておき、これを読み込みながら実行する[コンピュータアーキテクチャ](#コンピュータアーキテクチャ)。プログラム内蔵方式ではない最初期の[コンピュータ](#コンピュータ)は、計算手順を変えるために配線をつなぎなおす必要があったため、汎用性に乏しかった。プログラム内蔵方式では[プログラム](../../../programming/_/chapters/programming.md#プログラム)を外部から与えることで、ひとつの[コンピュータ](#コンピュータ)で様々な処理を行えるようになっている。現在使われているほとんどの[コンピュータ](#コンピュータ)はプログラム内蔵方式を採用している。\n\nプログラム内蔵方式を採用した[コンピュータ](#コンピュータ)は、**ノイマン型コンピュータ**と呼ばれている。これはプログラム内蔵方式を採用した初期の[コンピュータ](#コンピュータ)である[EDVAC](#第1世代)に関する論文の著者、[ジョン・フォン・ノイマン](#第1世代)に由来している。\n\nノイマン型コンピュータでは、[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)から[演算装置](../../hardware/_/chapters/hardware.md#演算装置)に[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして伝送する際の速度がボトルネックとなりやすい。これを**フォンノイマンボトルネック**という。\n\n"},{"term":"フォンノイマンボトルネック","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"プログラム内蔵方式","content":"\n**プログラム内蔵方式**（**ストアドプログラム方式**）は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)に格納しておき、これを読み込みながら実行する[コンピュータアーキテクチャ](#コンピュータアーキテクチャ)。プログラム内蔵方式ではない最初期の[コンピュータ](#コンピュータ)は、計算手順を変えるために配線をつなぎなおす必要があったため、汎用性に乏しかった。プログラム内蔵方式では[プログラム](../../../programming/_/chapters/programming.md#プログラム)を外部から与えることで、ひとつの[コンピュータ](#コンピュータ)で様々な処理を行えるようになっている。現在使われているほとんどの[コンピュータ](#コンピュータ)はプログラム内蔵方式を採用している。\n\nプログラム内蔵方式を採用した[コンピュータ](#コンピュータ)は、**ノイマン型コンピュータ**と呼ばれている。これはプログラム内蔵方式を採用した初期の[コンピュータ](#コンピュータ)である[EDVAC](#第1世代)に関する論文の著者、[ジョン・フォン・ノイマン](#第1世代)に由来している。\n\nノイマン型コンピュータでは、[記憶装置](../../hardware/_/chapters/hardware.md#記憶装置)から[演算装置](../../hardware/_/chapters/hardware.md#演算装置)に[プログラム](../../../programming/_/chapters/programming.md#プログラム)をデータとして伝送する際の速度がボトルネックとなりやすい。これを**フォンノイマンボトルネック**という。\n\n"},{"term":"逐次制御方式","link":"./note/ja/./computer/_/chapters/computer.md","flagment":"逐次制御方式","content":"\n**逐次制御方式**は、命令を[主記憶装置](../../hardware/_/chapters/hardware.md#主記憶装置)から取り出して解読し、その内容によってデータを取り出し、処理を実行するという一連の流れを繰り返すことで[プログラム](../../../programming/_/chapters/programming.md#プログラム)を実行する方式。\n"},{"term":"ハードウェア","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"ハードウェア","content":"\n**ハードウェア**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)を構成する要素のうち、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)そのものや[ディスプレイ](./io_unit.md#ディスプレイ装置)、[キーボード](./io_unit.md#キーボード)といった物理的な機器全般。\n\n\n"},{"term":"ハードウェア5大要素","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"ハードウェア5大要素","content":"\n**ハードウェア5大装置**は、一般的な[コンピュータ](../../../_/chapters/computer.md#コンピュータ)が備える5つの装置の総称。[制御装置](#制御装置)、[演算装置](#演算装置)、[記憶装置](#記憶装置)、[入力装置](#入力装置)、[出力装置](#出力装置)からなる。\n\n"},{"term":"制御装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"制御装置","content":"\n**制御装置**は、[演算装置](#演算装置)、[記憶装置](#記憶装置)、[入力装置](#入力装置)、[出力装置](#出力装置)の各々の動作を制御するための装置。\n\n"},{"term":"記憶装置（ストレージ）","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"記憶装置","content":"\n**記憶装置**（**ストレージ**）は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)内部で情報を保持しておくための装置。\n\n"},{"term":"主記憶装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"主記憶装置","content":"\n**主記憶装置**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)やデータを一時的に保持しておくための装置で、データを高速で読み書きすることができるが、**揮発性**であるため[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の電源を落とすと保持していたデータを失ってしまう。\n\n"},{"term":"揮発性","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"主記憶装置","content":"\n**主記憶装置**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)やデータを一時的に保持しておくための装置で、データを高速で読み書きすることができるが、**揮発性**であるため[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の電源を落とすと保持していたデータを失ってしまう。\n\n"},{"term":"補助記憶装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"補助記憶装置","content":"\n**補助記憶装置**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)やデータを長期的に保持しておくための装置で、データの読み書きは遅いが、**不揮発性**であるため[コンピュータ](../../../_/chapters/computer.md#コンピュータ)が故障しない限りは永続的にデータを保持しておくことができる。\n\n"},{"term":"不揮発性","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"補助記憶装置","content":"\n**補助記憶装置**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)やデータを長期的に保持しておくための装置で、データの読み書きは遅いが、**不揮発性**であるため[コンピュータ](../../../_/chapters/computer.md#コンピュータ)が故障しない限りは永続的にデータを保持しておくことができる。\n\n"},{"term":"入力装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"入力装置","content":"\n**入力装置**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に対して命令やデータを与えるための装置。[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[スキャナ](./io_unit.md#図形入力装置)、[タッチパネル](./io_unit.md#ポインティングデバイス)、[センサ](../../../../basics/measurement_and_control/_/chapters/control_theory.md#センサ)類などが入力装置にあたる。\n\n"},{"term":"出力装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"出力装置","content":"\n**出力装置**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)内のデータや、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)が行った処理の結果を出力するための装置。[ディスプレイ](./io_unit.md#ディスプレイ装置)や[プリンタ](./io_unit.md#プリンタ)、スピーカなどが出力装置にあたる。\n\n\n"},{"term":"処理装置","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"処理装置","content":"\n**処理装置**は、[制御装置](#制御装置)と[演算装置](#演算装置)を備えた装置のことで、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の中核を担う重要な要素。[プロセッサ](./processor.md#プロセッサ)とも呼ばれ、一般的な[コンピュータ](../../../_/chapters/computer.md#コンピュータ)は[プロセッサ](./processor.md#プロセッサ)のひとつであるCPUを備えている。\n\n\n"},{"term":"マザーボード","link":"./note/ja/./computer/hardware/_/chapters/hardware.md","flagment":"マザーボード","content":"\n**マザーボード**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)における主要な電子基板のことで、[CPU](./processor.md#cpu)や[メモリ](./memory.md#メモリ)などが取り付けられている。\n\n\n"},{"term":"プロセッサ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"プロセッサ","content":"\n**プロセッサ**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)を動作させるための[ハードウェア](./hardware.md#ハードウェア)で、[処理装置](./hardware.md#処理装置)にあたる。プロセッサは[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)の命令を実行するための[ハードウェア](./hardware.md#ハードウェア)であり、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)がプロセッサに対応していないと実行することができない。また、プロセッサの性能は[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の処理性能に直結するため、プロセッサが[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の実行要件を満たしていない場合は[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が利用できない場合がある。\n\n"},{"term":"CPU（中央演算処理装置: Central Processing Unit）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"cpu","content":"\n**CPU**（**中央演算処理装置**、Central Processing Unit）は、一般的な[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に含まれている[プロセッサ](#プロセッサ)。\n\n"},{"term":"CPUアーキテクチャ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"cpuアーキテクチャ","content":"\n"},{"term":"ワイヤードロジック方式（結線論理）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"ワイヤードロジック方式","content":"\n**ワイヤードロジック方式**（**結線論理**）は、[プロセッサ](#プロセッサ)における命令の実行方式のひとつで、[ハードウェア](./hardware.md#ハードウェア)による物理的な結線により命令を実行する。\n\n[マイクロプログラム方式](#マイクロプログラム方式)に比べて高速である一方、複雑な命令の実行や拡張には不利。\n\n"},{"term":"マイクロプログラム方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"マイクロプログラム方式","content":"\n**マイクロプログラム方式**は、[プロセッサ](#プロセッサ)における命令の実行方式のひとつで、[CPU](#cpu)内の**マイクロプログラム**（**マイクロコード**）を使用して複雑な命令を実装する。マイクロプログラムは**制御記憶**(CS: Control Storage)と呼ばれる[記憶装置](./hardware.md#記憶装置)に格納される。\n\n[ワイヤードロジック方式](#ワイヤードロジック方式)に比べて低速であるが、命令の追加や拡張が容易である。\n\n"},{"term":"マイクロプログラム（マイクロコード）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"マイクロプログラム方式","content":"\n**マイクロプログラム方式**は、[プロセッサ](#プロセッサ)における命令の実行方式のひとつで、[CPU](#cpu)内の**マイクロプログラム**（**マイクロコード**）を使用して複雑な命令を実装する。マイクロプログラムは**制御記憶**(CS: Control Storage)と呼ばれる[記憶装置](./hardware.md#記憶装置)に格納される。\n\n[ワイヤードロジック方式](#ワイヤードロジック方式)に比べて低速であるが、命令の追加や拡張が容易である。\n\n"},{"term":"レジスタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"レジスタ","content":"\n**レジスタ**は、[CPU](#cpu)に内蔵されている[記憶装置](./hardware.md#記憶装置)で、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)内部の[記憶装置](./hardware.md#記憶装置)の中でも最も高速で操作する。ただし、記憶できる容量は少ない。\n\n"},{"term":"命令レジスタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令レジスタ","content":"\n**命令レジスタ**は、取り出した命令を一時的に格納しておくための[レジスタ](#レジスタ)。\n\n"},{"term":"プログラムカウンタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"プログラムカウンタ","content":"\n**プログラムカウンタ**は、次に実行する命令が格納されている[メモリ](./memory.md#メモリ)の[アドレス](./memory.md#アドレス)を格納しておくための[レジスタ](#レジスタ)。\n\n"},{"term":"ベースレジスタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"ベースレジスタ","content":"\n**ベースレジスタ**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を[メモリ](./memory.md#メモリ)上にロードしたときの先頭[アドレス](./memory.md#アドレス)を格納しておくための[レジスタ](#レジスタ)。\n\n"},{"term":"インデックスレジスタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"インデックスレジスタ","content":"\n**インデックスレジスタ**は、連続したデータの取り出しに用いるための[レジスタ](#レジスタ)で、先頭からの相対位置を格納している。[配列](../../../../programming/_/chapters/data_type.md#配列)などのデータ構造を扱う際に利用される。\n\n"},{"term":"アキュムレータ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"アキュムレータ","content":"\n**アキュムレータ**は、[演算](../../../../programming/_/chapters/operation.md#演算)の結果を一時的に格納しておくための[レジスタ](#レジスタ)。\n\n"},{"term":"汎用レジスタ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"汎用レジスタ","content":"\n**汎用レジスタ**は、役割を限定せずに状況に応じて様々な使い方ができる[レジスタ](#レジスタ)。\n\n\n"},{"term":"マシンサイクル","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"マシンサイクル","content":"\n**マシンサイクル**は、[プロセッサ](#プロセッサ)が1つの命令を取り出してから実行するまでの流れのことで、[プロセッサ](#プロセッサ)はマシンサイクルを繰り返すことで[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行している。\n\nマシンサイクルは大きく分けて[命令サイクル](#命令サイクル)と[実行サイクル](#実行サイクル)に分けることができる。さらに、サイクルの中で行われる処理を**ステージ**と呼ばれるいくつかの段階に分けて考える。\n\n"},{"term":"ステージ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"マシンサイクル","content":"\n**マシンサイクル**は、[プロセッサ](#プロセッサ)が1つの命令を取り出してから実行するまでの流れのことで、[プロセッサ](#プロセッサ)はマシンサイクルを繰り返すことで[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行している。\n\nマシンサイクルは大きく分けて[命令サイクル](#命令サイクル)と[実行サイクル](#実行サイクル)に分けることができる。さらに、サイクルの中で行われる処理を**ステージ**と呼ばれるいくつかの段階に分けて考える。\n\n"},{"term":"命令サイクル（Iサイクル: Instruction fetch cycle）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令サイクル","content":"\n**命令サイクル**（**Iサイクル**: Instruction fetch cycle）は、[マシンサイクル](#マシンサイクル)のうち、実行する命令を[主記憶装置](./hardware.md#主記憶装置)から取り出す段階。命令サイクルは大きく2つの[ステージ](#マシンサイクル)に分けることができる。\n\n- **フェッチ** : [プログラムカウンタ](#プログラムカウンタ)の指す[アドレス](./memory.md#アドレス)をもとに、[主記憶装置](./hardware.md#主記憶装置)に格納された命令1つを[命令レジスタ](#命令レジスタ)に取り出す\n- [プログラムカウンタ](#プログラムカウンタ)の更新 : 次の命令の実行に備えて、[プログラムカウンタ](#プログラムカウンタ)の値をカウントアップする\n\n"},{"term":"フェッチ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令サイクル","content":"\n**命令サイクル**（**Iサイクル**: Instruction fetch cycle）は、[マシンサイクル](#マシンサイクル)のうち、実行する命令を[主記憶装置](./hardware.md#主記憶装置)から取り出す段階。命令サイクルは大きく2つの[ステージ](#マシンサイクル)に分けることができる。\n\n- **フェッチ** : [プログラムカウンタ](#プログラムカウンタ)の指す[アドレス](./memory.md#アドレス)をもとに、[主記憶装置](./hardware.md#主記憶装置)に格納された命令1つを[命令レジスタ](#命令レジスタ)に取り出す\n- [プログラムカウンタ](#プログラムカウンタ)の更新 : 次の命令の実行に備えて、[プログラムカウンタ](#プログラムカウンタ)の値をカウントアップする\n\n"},{"term":"プログラムカウンタの更新","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令サイクル","content":"\n**命令サイクル**（**Iサイクル**: Instruction fetch cycle）は、[マシンサイクル](#マシンサイクル)のうち、実行する命令を[主記憶装置](./hardware.md#主記憶装置)から取り出す段階。命令サイクルは大きく2つの[ステージ](#マシンサイクル)に分けることができる。\n\n- **フェッチ** : [プログラムカウンタ](#プログラムカウンタ)の指す[アドレス](./memory.md#アドレス)をもとに、[主記憶装置](./hardware.md#主記憶装置)に格納された命令1つを[命令レジスタ](#命令レジスタ)に取り出す\n- [プログラムカウンタ](#プログラムカウンタ)の更新 : 次の命令の実行に備えて、[プログラムカウンタ](#プログラムカウンタ)の値をカウントアップする\n\n"},{"term":"実行サイクル（Eサイクル: Execution cycle）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"実行サイクル","content":"\n**実行サイクル**（**Eサイクル**、Execution cycle）は、[マシンサイクル](#マシンサイクル)のうち、命令を実行する段階。実行サイクルは大きく4つの[ステージ](#ステージ)に分けることができる。\n\n- **デコード** : 取り出した命令を解読する\n- 実行[アドレス](./memory.md#アドレス)の計算 : [オペランド](#オペランド部)部分の[アドレス](./memory.md#アドレス)を計算して、[メモリ](./memory.md#メモリ)内のデータの場所を求める\n- [オペランド](#オペランド部)の読み出し : 計算した実行[アドレス](./memory.md#アドレス)から対象となるデータを[汎用レジスタ](#汎用レジスタ)に読み出す\n- 命令の実行 : [汎用レジスタ](#汎用レジスタ)からデータを取り出して、[演算装置](./hardware.md#演算装置)で[演算](../../../../programming/_/chapters/operation.md#演算)を行い、結果を[汎用レジスタ](#汎用レジスタ)または[主記憶装置](./hardware.md#記憶装置)に書き出す\n\n\n"},{"term":"デコード","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"実行サイクル","content":"\n**実行サイクル**（**Eサイクル**、Execution cycle）は、[マシンサイクル](#マシンサイクル)のうち、命令を実行する段階。実行サイクルは大きく4つの[ステージ](#ステージ)に分けることができる。\n\n- **デコード** : 取り出した命令を解読する\n- 実行[アドレス](./memory.md#アドレス)の計算 : [オペランド](#オペランド部)部分の[アドレス](./memory.md#アドレス)を計算して、[メモリ](./memory.md#メモリ)内のデータの場所を求める\n- [オペランド](#オペランド部)の読み出し : 計算した実行[アドレス](./memory.md#アドレス)から対象となるデータを[汎用レジスタ](#汎用レジスタ)に読み出す\n- 命令の実行 : [汎用レジスタ](#汎用レジスタ)からデータを取り出して、[演算装置](./hardware.md#演算装置)で[演算](../../../../programming/_/chapters/operation.md#演算)を行い、結果を[汎用レジスタ](#汎用レジスタ)または[主記憶装置](./hardware.md#記憶装置)に書き出す\n\n\n"},{"term":"実行アドレスの計算","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"実行サイクル","content":"\n**実行サイクル**（**Eサイクル**、Execution cycle）は、[マシンサイクル](#マシンサイクル)のうち、命令を実行する段階。実行サイクルは大きく4つの[ステージ](#ステージ)に分けることができる。\n\n- **デコード** : 取り出した命令を解読する\n- 実行[アドレス](./memory.md#アドレス)の計算 : [オペランド](#オペランド部)部分の[アドレス](./memory.md#アドレス)を計算して、[メモリ](./memory.md#メモリ)内のデータの場所を求める\n- [オペランド](#オペランド部)の読み出し : 計算した実行[アドレス](./memory.md#アドレス)から対象となるデータを[汎用レジスタ](#汎用レジスタ)に読み出す\n- 命令の実行 : [汎用レジスタ](#汎用レジスタ)からデータを取り出して、[演算装置](./hardware.md#演算装置)で[演算](../../../../programming/_/chapters/operation.md#演算)を行い、結果を[汎用レジスタ](#汎用レジスタ)または[主記憶装置](./hardware.md#記憶装置)に書き出す\n\n\n"},{"term":"オペランドの読み出し","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"実行サイクル","content":"\n**実行サイクル**（**Eサイクル**、Execution cycle）は、[マシンサイクル](#マシンサイクル)のうち、命令を実行する段階。実行サイクルは大きく4つの[ステージ](#ステージ)に分けることができる。\n\n- **デコード** : 取り出した命令を解読する\n- 実行[アドレス](./memory.md#アドレス)の計算 : [オペランド](#オペランド部)部分の[アドレス](./memory.md#アドレス)を計算して、[メモリ](./memory.md#メモリ)内のデータの場所を求める\n- [オペランド](#オペランド部)の読み出し : 計算した実行[アドレス](./memory.md#アドレス)から対象となるデータを[汎用レジスタ](#汎用レジスタ)に読み出す\n- 命令の実行 : [汎用レジスタ](#汎用レジスタ)からデータを取り出して、[演算装置](./hardware.md#演算装置)で[演算](../../../../programming/_/chapters/operation.md#演算)を行い、結果を[汎用レジスタ](#汎用レジスタ)または[主記憶装置](./hardware.md#記憶装置)に書き出す\n\n\n"},{"term":"命令の実行","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"実行サイクル","content":"\n**実行サイクル**（**Eサイクル**、Execution cycle）は、[マシンサイクル](#マシンサイクル)のうち、命令を実行する段階。実行サイクルは大きく4つの[ステージ](#ステージ)に分けることができる。\n\n- **デコード** : 取り出した命令を解読する\n- 実行[アドレス](./memory.md#アドレス)の計算 : [オペランド](#オペランド部)部分の[アドレス](./memory.md#アドレス)を計算して、[メモリ](./memory.md#メモリ)内のデータの場所を求める\n- [オペランド](#オペランド部)の読み出し : 計算した実行[アドレス](./memory.md#アドレス)から対象となるデータを[汎用レジスタ](#汎用レジスタ)に読み出す\n- 命令の実行 : [汎用レジスタ](#汎用レジスタ)からデータを取り出して、[演算装置](./hardware.md#演算装置)で[演算](../../../../programming/_/chapters/operation.md#演算)を行い、結果を[汎用レジスタ](#汎用レジスタ)または[主記憶装置](./hardware.md#記憶装置)に書き出す\n\n\n"},{"term":"命令の形式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令の形式","content":"\n1つの命令は、[オペレータ部](#オペレータ部)と[オペランド部](#オペランド部)から構成されている。\n\n[オペランド部](#オペランド部)は命令の種類によって数が異なり、[オペランド部](#オペランド部)を持たない命令を**0アドレス方式**、[オペランド部](#オペランド部)を1つ持つ命令を**1アドレス方式**、[オペランド部](#オペランド部)を2つ持つ命令を**2アドレス方式**、[オペランド部](#オペランド部)を3つ持つ命令を**3アドレス方式**という。\n\n"},{"term":"0アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令の形式","content":"\n1つの命令は、[オペレータ部](#オペレータ部)と[オペランド部](#オペランド部)から構成されている。\n\n[オペランド部](#オペランド部)は命令の種類によって数が異なり、[オペランド部](#オペランド部)を持たない命令を**0アドレス方式**、[オペランド部](#オペランド部)を1つ持つ命令を**1アドレス方式**、[オペランド部](#オペランド部)を2つ持つ命令を**2アドレス方式**、[オペランド部](#オペランド部)を3つ持つ命令を**3アドレス方式**という。\n\n"},{"term":"1アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令の形式","content":"\n1つの命令は、[オペレータ部](#オペレータ部)と[オペランド部](#オペランド部)から構成されている。\n\n[オペランド部](#オペランド部)は命令の種類によって数が異なり、[オペランド部](#オペランド部)を持たない命令を**0アドレス方式**、[オペランド部](#オペランド部)を1つ持つ命令を**1アドレス方式**、[オペランド部](#オペランド部)を2つ持つ命令を**2アドレス方式**、[オペランド部](#オペランド部)を3つ持つ命令を**3アドレス方式**という。\n\n"},{"term":"2アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令の形式","content":"\n1つの命令は、[オペレータ部](#オペレータ部)と[オペランド部](#オペランド部)から構成されている。\n\n[オペランド部](#オペランド部)は命令の種類によって数が異なり、[オペランド部](#オペランド部)を持たない命令を**0アドレス方式**、[オペランド部](#オペランド部)を1つ持つ命令を**1アドレス方式**、[オペランド部](#オペランド部)を2つ持つ命令を**2アドレス方式**、[オペランド部](#オペランド部)を3つ持つ命令を**3アドレス方式**という。\n\n"},{"term":"3アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令の形式","content":"\n1つの命令は、[オペレータ部](#オペレータ部)と[オペランド部](#オペランド部)から構成されている。\n\n[オペランド部](#オペランド部)は命令の種類によって数が異なり、[オペランド部](#オペランド部)を持たない命令を**0アドレス方式**、[オペランド部](#オペランド部)を1つ持つ命令を**1アドレス方式**、[オペランド部](#オペランド部)を2つ持つ命令を**2アドレス方式**、[オペランド部](#オペランド部)を3つ持つ命令を**3アドレス方式**という。\n\n"},{"term":"オペレータ部","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペレータ部","content":"\n**オペレータ部**は、[演算](../../../../programming/_/chapters/operation.md#演算)の種類を指定する[オペコード](../../../../basics/information_theory/_/chapters/compiler_theory.md#オペコード)が格納される部分。\n\n"},{"term":"オペランド部","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"アドレス修飾部","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"即値アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"直接アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"間接アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"指標アドレス方式","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"アドレス部","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"オペランド部","content":"\n**オペランド部**は、命令の実行対象となるデータの[アドレス](./memory.md#アドレス)情報が格納される部分。オペランド部はアドレス修飾部とアドレス部からなる。\n\n- **アドレス修飾部** : アドレスの指定方式やアドレス修飾を行う[レジスタ](#レジスタ)の指定\n- **アドレス部** : [主記憶装置](./hardware.md#主記憶装置)の[アドレス](#アドレス)や[汎用レジスタ](#汎用レジスタ)の番号などの指定\n\nアドレス部の指定方式としては次のような種類がある。\n\n- **即値アドレス方式** : オペランド部の内容をそのままデータとして扱う\n- **直接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上のデータの[アドレス](./memory.md#アドレス)を示している\n- **間接アドレス方式** : オペランド部の内容が[主記憶装置](./hardware.md#主記憶装置)上でデータへの[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)を格納した[アドレス](./memory.md#アドレス)を示している\n- **指標アドレス方式** : オペランド部の内容がある基準からの相対位置を示しており、第3オペランドで基準となる[アドレス](./memory.md#アドレス)が格納された[レジスタ](#レジスタ)を指定する\n\n\n"},{"term":"プロセッサの性能","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"プロセッサの性能","content":"\n"},{"term":"クロック","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"クロック","content":"\n**クロック**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の[マザーボード](./hardware.md#マザーボード)上にある複数の装置をタイミングを合わせて動作させるための信号。クロックの単位時間当たりの発生回数のことを**クロック周波数**といい、基本的にはこの値が大きいほど[プロセッサ](#プロセッサ)は高速に動作する。\n\n"},{"term":"クロック周波数","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"クロック","content":"\n**クロック**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の[マザーボード](./hardware.md#マザーボード)上にある複数の装置をタイミングを合わせて動作させるための信号。クロックの単位時間当たりの発生回数のことを**クロック周波数**といい、基本的にはこの値が大きいほど[プロセッサ](#プロセッサ)は高速に動作する。\n\n"},{"term":"命令ミックス","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令ミックス","content":"\n**命令ミックス**は、[CPU](#cpu)の処理性能を評価するための尺度のひとつ。各命令ごとの実行時間を使用頻度に応じて重み付けし、平均命令実行時間を算出したもの。\n\n事務処理用の**コマーシャルミックス**と、科学計算用の**ギブソンミックス**がある。\n\n\n"},{"term":"コマーシャルミックス","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令ミックス","content":"\n**命令ミックス**は、[CPU](#cpu)の処理性能を評価するための尺度のひとつ。各命令ごとの実行時間を使用頻度に応じて重み付けし、平均命令実行時間を算出したもの。\n\n事務処理用の**コマーシャルミックス**と、科学計算用の**ギブソンミックス**がある。\n\n\n"},{"term":"ギブソンミックス","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"命令ミックス","content":"\n**命令ミックス**は、[CPU](#cpu)の処理性能を評価するための尺度のひとつ。各命令ごとの実行時間を使用頻度に応じて重み付けし、平均命令実行時間を算出したもの。\n\n事務処理用の**コマーシャルミックス**と、科学計算用の**ギブソンミックス**がある。\n\n\n"},{"term":"プロセッサの高速化","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"プロセッサの高速化","content":"\n"},{"term":"パイプライン","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パイプライン","content":"\n**パイプライン**は、命令[ステージ](#マシンサイクル)を独立して動作させることによって、複数の命令を並行して実行する方式。パイプラインにおいて最も効果を発揮するのは、各[ステージ](#マシンサイクル)の処理時間が同じ場合。そのため、パイプラインに向いているは[RISC](#risc)アーキテクチャである。\n\n分岐命令などによって順番が変化すると、**パイプラインハザード**が発生する。パイプラインハザードとは、複数の命令を実行する場合に、命令の処理を中断しなければいけない状況のこと。\n\n- **制御ハザード** : 分岐処理などで処理の順番が変わる\n- **データハザード** : 複数の処理で同じデータを扱うことにより不具合が生じる\n- **構造ハザード** : 同じ[ハードウェア](./hardware.md#ハードウェア)を同時に使用することによる競合が原因\n\n"},{"term":"パイプラインハザード","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パイプライン","content":"\n**パイプライン**は、命令[ステージ](#マシンサイクル)を独立して動作させることによって、複数の命令を並行して実行する方式。パイプラインにおいて最も効果を発揮するのは、各[ステージ](#マシンサイクル)の処理時間が同じ場合。そのため、パイプラインに向いているは[RISC](#risc)アーキテクチャである。\n\n分岐命令などによって順番が変化すると、**パイプラインハザード**が発生する。パイプラインハザードとは、複数の命令を実行する場合に、命令の処理を中断しなければいけない状況のこと。\n\n- **制御ハザード** : 分岐処理などで処理の順番が変わる\n- **データハザード** : 複数の処理で同じデータを扱うことにより不具合が生じる\n- **構造ハザード** : 同じ[ハードウェア](./hardware.md#ハードウェア)を同時に使用することによる競合が原因\n\n"},{"term":"制御ハザード","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パイプライン","content":"\n**パイプライン**は、命令[ステージ](#マシンサイクル)を独立して動作させることによって、複数の命令を並行して実行する方式。パイプラインにおいて最も効果を発揮するのは、各[ステージ](#マシンサイクル)の処理時間が同じ場合。そのため、パイプラインに向いているは[RISC](#risc)アーキテクチャである。\n\n分岐命令などによって順番が変化すると、**パイプラインハザード**が発生する。パイプラインハザードとは、複数の命令を実行する場合に、命令の処理を中断しなければいけない状況のこと。\n\n- **制御ハザード** : 分岐処理などで処理の順番が変わる\n- **データハザード** : 複数の処理で同じデータを扱うことにより不具合が生じる\n- **構造ハザード** : 同じ[ハードウェア](./hardware.md#ハードウェア)を同時に使用することによる競合が原因\n\n"},{"term":"データハザード","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パイプライン","content":"\n**パイプライン**は、命令[ステージ](#マシンサイクル)を独立して動作させることによって、複数の命令を並行して実行する方式。パイプラインにおいて最も効果を発揮するのは、各[ステージ](#マシンサイクル)の処理時間が同じ場合。そのため、パイプラインに向いているは[RISC](#risc)アーキテクチャである。\n\n分岐命令などによって順番が変化すると、**パイプラインハザード**が発生する。パイプラインハザードとは、複数の命令を実行する場合に、命令の処理を中断しなければいけない状況のこと。\n\n- **制御ハザード** : 分岐処理などで処理の順番が変わる\n- **データハザード** : 複数の処理で同じデータを扱うことにより不具合が生じる\n- **構造ハザード** : 同じ[ハードウェア](./hardware.md#ハードウェア)を同時に使用することによる競合が原因\n\n"},{"term":"構造ハザード","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パイプライン","content":"\n**パイプライン**は、命令[ステージ](#マシンサイクル)を独立して動作させることによって、複数の命令を並行して実行する方式。パイプラインにおいて最も効果を発揮するのは、各[ステージ](#マシンサイクル)の処理時間が同じ場合。そのため、パイプラインに向いているは[RISC](#risc)アーキテクチャである。\n\n分岐命令などによって順番が変化すると、**パイプラインハザード**が発生する。パイプラインハザードとは、複数の命令を実行する場合に、命令の処理を中断しなければいけない状況のこと。\n\n- **制御ハザード** : 分岐処理などで処理の順番が変わる\n- **データハザード** : 複数の処理で同じデータを扱うことにより不具合が生じる\n- **構造ハザード** : 同じ[ハードウェア](./hardware.md#ハードウェア)を同時に使用することによる競合が原因\n\n"},{"term":"スーパパイプライン","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"スーパパイプライン","content":"\n**スーパパイプライン**は、[ステップ](#マシンサイクル)を更に細分化することで一度に実行できる命令数を増やす方法。\n\n"},{"term":"スーパスカラ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"スーパスカラ","content":"\n**スーパスカラ**は、[パイプライン](#パイプライン)の[ステージ](#マシンサイクル)を複数同時に実行させることで効率化を実現する方法。\n\n"},{"term":"VLIW（超長命令語: Very Long Instruction Word）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"vliw","content":"\n**VLIW**（**超長命令語**: Very Long Instruction Word）は、命令語を長くすることで複数の機能を一度に実行できるようにしたもの。[パイプライン](#パイプライン)と組み合わせることもできる。\n\n\n"},{"term":"マルチプロセッサ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"マルチプロセッサ","content":"\n**マルチプロセッサ**は、複数の[プロセッサ](#プロセッサ)を同時に稼働させることで高速化を図る方法。\n\n"},{"term":"密結合マルチプロセッサ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"密結合マルチプロセッサ","content":"\n**密結合マルチプロセッサ**は、複数の[プロセッサ](#プロセッサ)が[主記憶](./hardware.md#主記憶装置)を共有する形式。外見上1つに見える[プロセッサ](#プロセッサ)（コア）を封入した**マルチコアプロセッサ**という形態も密結合マルチプロセッサの一種。\n\n"},{"term":"マルチコアプロセッサ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"密結合マルチプロセッサ","content":"\n**密結合マルチプロセッサ**は、複数の[プロセッサ](#プロセッサ)が[主記憶](./hardware.md#主記憶装置)を共有する形式。外見上1つに見える[プロセッサ](#プロセッサ)（コア）を封入した**マルチコアプロセッサ**という形態も密結合マルチプロセッサの一種。\n\n"},{"term":"疎結合マルチプロセッサ","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"疎結合マルチプロセッサ","content":"\n**疎結合マルチプロセッサ**は、複数の[プロセッサ](#プロセッサ)にそれぞれ別の[主記憶](./hardware.md#主記憶装置)を割り当てる形式。複数の独立した[コンピュータ](../../../_/chapters/computer.md#コンピュータ)システムを用いるのと同じなので、高速な通信システムによりデータのやり取りを行う。**クラスタシステム**などは疎結合マルチプロセッサの一種。\n\n"},{"term":"クラスタシステム","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"疎結合マルチプロセッサ","content":"\n**疎結合マルチプロセッサ**は、複数の[プロセッサ](#プロセッサ)にそれぞれ別の[主記憶](./hardware.md#主記憶装置)を割り当てる形式。複数の独立した[コンピュータ](../../../_/chapters/computer.md#コンピュータ)システムを用いるのと同じなので、高速な通信システムによりデータのやり取りを行う。**クラスタシステム**などは疎結合マルチプロセッサの一種。\n\n"},{"term":"プロセッサの省電力技術","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"プロセッサの省電力技術","content":"\n"},{"term":"クロックゲーティング","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"クロックゲーティング","content":"\n**クロックゲーティング**は、動作していない回路ブロックへの[クロック](#クロック)供給を停止する方法。\n\n"},{"term":"パワーゲーティング","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"パワーゲーティング","content":"\n**パワーゲーティング**は、動作していない回路ブロックへの電力供給を遮断する方法。\n\n\n"},{"term":"割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"割込み","content":"\n**割込み**は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を中断して別の処理を行う処理。\n\n"},{"term":"内部割込み（ソフトウェア割込み）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"内部割込み","content":"\n**内部割込み**（**ソフトウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の内部からの[割込み](#割込み)。\n\n- **プログラム割込み** : [プログラム](../../../../programming/_/chapters/programming.md#プログラム)内で0除算や[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が起こったときに発生\n- **SVC割込み** : **SVC**(Super Visor Call)とは、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)を呼び出すための命令。[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)に処理を依頼するときに行われる\n- **ページフォールト** : [仮想記憶管理](../../../software/_/chapters/operating_system.md#仮想記憶管理)において、存在しない[ページ](../../../software/_/chapters/operating_system.md#ページ)にアクセスするときに行われる\n\n"},{"term":"プログラム割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"内部割込み","content":"\n**内部割込み**（**ソフトウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の内部からの[割込み](#割込み)。\n\n- **プログラム割込み** : [プログラム](../../../../programming/_/chapters/programming.md#プログラム)内で0除算や[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が起こったときに発生\n- **SVC割込み** : **SVC**(Super Visor Call)とは、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)を呼び出すための命令。[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)に処理を依頼するときに行われる\n- **ページフォールト** : [仮想記憶管理](../../../software/_/chapters/operating_system.md#仮想記憶管理)において、存在しない[ページ](../../../software/_/chapters/operating_system.md#ページ)にアクセスするときに行われる\n\n"},{"term":"ページフォールト","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"内部割込み","content":"\n**内部割込み**（**ソフトウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の内部からの[割込み](#割込み)。\n\n- **プログラム割込み** : [プログラム](../../../../programming/_/chapters/programming.md#プログラム)内で0除算や[オーバフロー](../../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#オーバフロー)が起こったときに発生\n- **SVC割込み** : **SVC**(Super Visor Call)とは、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)を呼び出すための命令。[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)に処理を依頼するときに行われる\n- **ページフォールト** : [仮想記憶管理](../../../software/_/chapters/operating_system.md#仮想記憶管理)において、存在しない[ページ](../../../software/_/chapters/operating_system.md#ページ)にアクセスするときに行われる\n\n"},{"term":"外部割込み（ハードウェア割込み）","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"外部割込み","content":"\n**外部割込み**（**ハードウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)以外の、[ハードウェア](./hardware.md#ハードウェア)関連の[割込み](#割込み)。\n\n- **タイマ割込み** : タイマから行われる\n- **機械チェック割込み** : [ハードウェア](./hardware.md#ハードウェア)の異常が検出されたときに行われる\n- **入出力割込み** : [キーボード](./io_unit.md#キーボード)などの[入出力装置](./io_unit.md)から行われる\n- **コンソール割込み** : コンソールからスイッチが行われたときに発生する\n\n\n"},{"term":"タイマ割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"外部割込み","content":"\n**外部割込み**（**ハードウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)以外の、[ハードウェア](./hardware.md#ハードウェア)関連の[割込み](#割込み)。\n\n- **タイマ割込み** : タイマから行われる\n- **機械チェック割込み** : [ハードウェア](./hardware.md#ハードウェア)の異常が検出されたときに行われる\n- **入出力割込み** : [キーボード](./io_unit.md#キーボード)などの[入出力装置](./io_unit.md)から行われる\n- **コンソール割込み** : コンソールからスイッチが行われたときに発生する\n\n\n"},{"term":"機械チェック割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"外部割込み","content":"\n**外部割込み**（**ハードウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)以外の、[ハードウェア](./hardware.md#ハードウェア)関連の[割込み](#割込み)。\n\n- **タイマ割込み** : タイマから行われる\n- **機械チェック割込み** : [ハードウェア](./hardware.md#ハードウェア)の異常が検出されたときに行われる\n- **入出力割込み** : [キーボード](./io_unit.md#キーボード)などの[入出力装置](./io_unit.md)から行われる\n- **コンソール割込み** : コンソールからスイッチが行われたときに発生する\n\n\n"},{"term":"入出力割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"外部割込み","content":"\n**外部割込み**（**ハードウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)以外の、[ハードウェア](./hardware.md#ハードウェア)関連の[割込み](#割込み)。\n\n- **タイマ割込み** : タイマから行われる\n- **機械チェック割込み** : [ハードウェア](./hardware.md#ハードウェア)の異常が検出されたときに行われる\n- **入出力割込み** : [キーボード](./io_unit.md#キーボード)などの[入出力装置](./io_unit.md)から行われる\n- **コンソール割込み** : コンソールからスイッチが行われたときに発生する\n\n\n"},{"term":"コンソール割込み","link":"./note/ja/./computer/hardware/_/chapters/processor.md","flagment":"外部割込み","content":"\n**外部割込み**（**ハードウェア割込み**）は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)以外の、[ハードウェア](./hardware.md#ハードウェア)関連の[割込み](#割込み)。\n\n- **タイマ割込み** : タイマから行われる\n- **機械チェック割込み** : [ハードウェア](./hardware.md#ハードウェア)の異常が検出されたときに行われる\n- **入出力割込み** : [キーボード](./io_unit.md#キーボード)などの[入出力装置](./io_unit.md)から行われる\n- **コンソール割込み** : コンソールからスイッチが行われたときに発生する\n\n\n"},{"term":"メモリ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"メモリ","content":"\n**メモリ**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上でデータを保持しておくための[記憶装置](./hardware.md#記憶装置)。\n\n1つの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が利用できるメモリ領域は役割ごとに、[テキスト領域](#テキスト領域)、[静的領域](#静的領域)、[スタック領域](#スタック領域)、[ヒープ領域](#ヒープ領域)の4つの領域に分類される。\n\n"},{"term":"アドレス（メモリアドレス）","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"アドレス","content":"\n**アドレス**（メモリアドレス）は、[メモリ](#メモリ)上でデータがどの位置に存在するかを表す概念で、データにアクセスするために必要となる情報。アドレスは[メモリ](#メモリ)上の保存領域1[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)ごとに固有のものが割り振られている。\n\n"},{"term":"テキスト領域","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"テキスト領域","content":"\n**テキスト領域**は、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)に[コンパイル](../../../../programming/_/chapters/programming.md#コンパイル)された[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が格納される領域。この領域の[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)命令が1行ずつ[プロセッサ](./memory.md#プロセッサ)に読み込まれていくことで[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が実行される。\n\n"},{"term":"静的領域","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"静的領域","content":"\n**静的領域**は、[グローバル変数](../../../../programming/_/chapters/variable.md#グローバル変数)などの静的変数が格納される領域。[プログラム](**テキスト領域**は、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)に[コンパイル](../../../../programming/_/chapters/programming.md#コンパイル)された[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の開始から終了まで確保される。\n\n"},{"term":"スタック領域","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"スタック領域","content":"\n**スタック領域**は、[ローカル変数](../../../../programming/_/chapters/variable.md#ローカル変数)が格納される領域。[関数](../../../../programming/_/chapters/function.md#関数)が実行されるときに一時的に利用される。[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が利用できる[メモリ](#メモリ)領域の最下部から順番に[変数](../../../../programming/_/chapters/variable.md#変数)が積まれていき、使い終わった[変数](../../../../programming/_/chapters/variable.md#変数)は順番に取り除かれていく。[プリミティブ](../../../../programming/_/chapters/data_type.md#プリミティブ型)な[データ型](../../../../programming/_/chapters/data_type.md#型)などはスタック領域に直接格納され、[配列](../../../../programming/_/chapters/data_type.md#配列)や[オブジェクト型](../../../../programming/_/chapters/data_type.md#オブジェクト型)などのデータは[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)がスタック領域に格納される。\n\n"},{"term":"ヒープ領域","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ヒープ領域","content":"\n**ヒープ領域**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が動的に確保と解放を繰り返すことができる[メモリ](#メモリ)領域で、[コンパイル](../../../../programming/_/chapters/programming.md#コンパイル)時にサイズが決まっていないような可変長の[コンテナ](../../../../programming/_/chapters/data_type.md#コンテナ型)や[オブジェクト型](../../../../programming/_/chapters/data_type.md#オブジェクト型)のデータの実体が格納される。\n\n\n"},{"term":"記憶階層","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"記憶階層","content":"\n**記憶階層**は、速度や容量の異なる複数の[記憶装置](./hardware.md#記憶装置)を階層的に組み合わせることで、全体として効率の良い記憶システムを構築したもの。それぞれの[記憶装置](./hardware.md#記憶装置)の間に**緩急記憶装置**を置くことで、各装置の速度ギャップを埋めることができる。\n\n記憶階層は速度が早いものから順に、[レジスタ](./processor.md#レジスタ)、[主記憶装置](./hardware.md#主記憶装置)、[補助記憶装置](./auxiliary_memory_unit.md#補助記憶装置)となっている。また緩急記憶装置として、[レジスタ](./processor.md#レジスタ)と[主記憶装置](./hardware.md#主記憶装置)の間に[キャッシュメモリ](#キャッシュメモリ)、[主記憶装置](./hardware.md#主記憶装置)と[補助記憶装置](./auxiliary_memory_unit.md#補助既往装置)の間に**ディスクキャッシュ**がある。\n\n\n"},{"term":"緩急記憶装置","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"記憶階層","content":"\n**記憶階層**は、速度や容量の異なる複数の[記憶装置](./hardware.md#記憶装置)を階層的に組み合わせることで、全体として効率の良い記憶システムを構築したもの。それぞれの[記憶装置](./hardware.md#記憶装置)の間に**緩急記憶装置**を置くことで、各装置の速度ギャップを埋めることができる。\n\n記憶階層は速度が早いものから順に、[レジスタ](./processor.md#レジスタ)、[主記憶装置](./hardware.md#主記憶装置)、[補助記憶装置](./auxiliary_memory_unit.md#補助記憶装置)となっている。また緩急記憶装置として、[レジスタ](./processor.md#レジスタ)と[主記憶装置](./hardware.md#主記憶装置)の間に[キャッシュメモリ](#キャッシュメモリ)、[主記憶装置](./hardware.md#主記憶装置)と[補助記憶装置](./auxiliary_memory_unit.md#補助既往装置)の間に**ディスクキャッシュ**がある。\n\n\n"},{"term":"ディスクキャッシュ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"記憶階層","content":"\n**記憶階層**は、速度や容量の異なる複数の[記憶装置](./hardware.md#記憶装置)を階層的に組み合わせることで、全体として効率の良い記憶システムを構築したもの。それぞれの[記憶装置](./hardware.md#記憶装置)の間に**緩急記憶装置**を置くことで、各装置の速度ギャップを埋めることができる。\n\n記憶階層は速度が早いものから順に、[レジスタ](./processor.md#レジスタ)、[主記憶装置](./hardware.md#主記憶装置)、[補助記憶装置](./auxiliary_memory_unit.md#補助記憶装置)となっている。また緩急記憶装置として、[レジスタ](./processor.md#レジスタ)と[主記憶装置](./hardware.md#主記憶装置)の間に[キャッシュメモリ](#キャッシュメモリ)、[主記憶装置](./hardware.md#主記憶装置)と[補助記憶装置](./auxiliary_memory_unit.md#補助既往装置)の間に**ディスクキャッシュ**がある。\n\n\n"},{"term":"主記憶装置の種類","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"主記憶装置の種類","content":"\n"},{"term":"揮発性メモリ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ram","content":"\n**RAM**(Random Access Memory)は、読み書きが可能な[メモリ](#メモリ)。電源の供給がなくなると内容が消えてしまうという性質から、**揮発性メモリ**とも呼ばれる。\n\n"},{"term":"リフレッシュ動作","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"dram","content":"\n**DRAM**(Dynamic RAM)は、一定時間たつとデータが消失してしまうという性質を持っており、低速で高消費電力である代わりに、安価で大容量である[RAM](#ram)。1[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)の情報を記憶するメモリセルが、コンデンサとトランジスタで構成されている。また、放置しておくと自然に放電してしまうため、一定時間間隔でコンデンサを再充電する**リフレッシュ動作**が必要となる。現在ではほとんどの場合、システムの[バス](./bus.md#バス)と同期して動作する**SDRAM**(Synchronous DRAM)となっている。\n\n"},{"term":"不揮発性メモリ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"rom","content":"\n**ROM**(Read Only Memory)は、読み出し専用の[メモリ](#メモリ)。種類によっては全消去や書き込み、追記が可能なものもある。電源の供給がなくても記憶を保持することが可能であるという性質から、**不揮発性メモリ**とも呼ばれる。\n\n"},{"term":"マスクROM","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"マスクrom","content":"\n**マスクROM**は、出荷時にデータが書き込まれており、内容の変更ができない[ROM](#rom)。\n\n"},{"term":"EPROM","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"prom","content":"\n**PROM**(Programmable ROM)は、特殊な装置により一度だけ書き込むことができるが、一度書き込んだものを消去できない[ROM](#rom)。基本的に読み出し専用であり、[RAM](#ram)に比べると書き込みには時間がかかる。また、PROMの中でも**EPROM**は紫外線照射により内容の消去が可能で、再書き込みも可能。**EEPROM**は電気的に[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)単位での内容の書き換えが可能なもので、[BIOS](../../../software/_/chapters/operating_system.md#bios)や電子機器の制御[プログラム](../../../../programming/_/chapters/programming.md#プログラム)格納のために使用される。\n\n"},{"term":"EEPROM","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"prom","content":"\n**PROM**(Programmable ROM)は、特殊な装置により一度だけ書き込むことができるが、一度書き込んだものを消去できない[ROM](#rom)。基本的に読み出し専用であり、[RAM](#ram)に比べると書き込みには時間がかかる。また、PROMの中でも**EPROM**は紫外線照射により内容の消去が可能で、再書き込みも可能。**EEPROM**は電気的に[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)単位での内容の書き換えが可能なもので、[BIOS](../../../software/_/chapters/operating_system.md#bios)や電子機器の制御[プログラム](../../../../programming/_/chapters/programming.md#プログラム)格納のために使用される。\n\n"},{"term":"フラッシュメモリ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"フラッシュメモリ","content":"\n**フラッシュメモリ**は、[ブロック](./auxiliary_memory_unit.md#ブロック)単位もしくは一括での大容量のデータの消去や書き込みができるように最適化された[ROM](#rom)。[USB](./bus.md#usb)[メモリ](#メモリ)や[SSD](./auxiliary_memory_unit.md#ssd)に利用されているが、本来は[ROM](#rom)であるため、何度も書き換えを行うと劣化してしまう。\n\n\n"},{"term":"キャッシュメモリ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"キャッシュメモリ","content":"\n**キャッシュメモリ**は、[プロセッサ](./processor.md#プロセッサ)と[メモリ](#メモリ)の性能差を埋めるために両者の間で用いられる[メモリ](#メモリ)。直近に使用したデータをキャッシュメモリに一時的に蓄えておくことで、同じデータを再利用したい場合に高速で読み出すことができるようになる。これは、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は直近にアクセスした命令やデータに再度アクセスすることが多い、という**プログラムの局所性**を利用している。\n\n高速である必要があり、[CPU](./processor.md#cpu)のチップに内蔵されることが一般的。また、キャッシュメモリを多段構成にして、[CPU](./processor.md#cpu)から近い順に**1次キャッシュ**、**2次キャッシュ**とするものもある。\n\n"},{"term":"プログラムの局所性","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"キャッシュメモリ","content":"\n**キャッシュメモリ**は、[プロセッサ](./processor.md#プロセッサ)と[メモリ](#メモリ)の性能差を埋めるために両者の間で用いられる[メモリ](#メモリ)。直近に使用したデータをキャッシュメモリに一時的に蓄えておくことで、同じデータを再利用したい場合に高速で読み出すことができるようになる。これは、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は直近にアクセスした命令やデータに再度アクセスすることが多い、という**プログラムの局所性**を利用している。\n\n高速である必要があり、[CPU](./processor.md#cpu)のチップに内蔵されることが一般的。また、キャッシュメモリを多段構成にして、[CPU](./processor.md#cpu)から近い順に**1次キャッシュ**、**2次キャッシュ**とするものもある。\n\n"},{"term":"1次キャッシュ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"キャッシュメモリ","content":"\n**キャッシュメモリ**は、[プロセッサ](./processor.md#プロセッサ)と[メモリ](#メモリ)の性能差を埋めるために両者の間で用いられる[メモリ](#メモリ)。直近に使用したデータをキャッシュメモリに一時的に蓄えておくことで、同じデータを再利用したい場合に高速で読み出すことができるようになる。これは、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は直近にアクセスした命令やデータに再度アクセスすることが多い、という**プログラムの局所性**を利用している。\n\n高速である必要があり、[CPU](./processor.md#cpu)のチップに内蔵されることが一般的。また、キャッシュメモリを多段構成にして、[CPU](./processor.md#cpu)から近い順に**1次キャッシュ**、**2次キャッシュ**とするものもある。\n\n"},{"term":"2次キャッシュ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"キャッシュメモリ","content":"\n**キャッシュメモリ**は、[プロセッサ](./processor.md#プロセッサ)と[メモリ](#メモリ)の性能差を埋めるために両者の間で用いられる[メモリ](#メモリ)。直近に使用したデータをキャッシュメモリに一時的に蓄えておくことで、同じデータを再利用したい場合に高速で読み出すことができるようになる。これは、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は直近にアクセスした命令やデータに再度アクセスすることが多い、という**プログラムの局所性**を利用している。\n\n高速である必要があり、[CPU](./processor.md#cpu)のチップに内蔵されることが一般的。また、キャッシュメモリを多段構成にして、[CPU](./processor.md#cpu)から近い順に**1次キャッシュ**、**2次キャッシュ**とするものもある。\n\n"},{"term":"ヒット率","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ヒット率","content":"\n**ヒット率**は、[キャッシュメモリ](#キャッシュメモリ)を用いて[CPU](./processor.md#cpu)と[メモリ](#メモリ)がやり取りをするときに、データが[キャッシュメモリ](#キャッシュメモリ)上にある[確率](../../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)。ヒット率が高いほど[キャッシュメモリ](#キャッシュメモリ)が使用される[確率](../../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)が高く、高速な処理が可能となる。\n\n一方で、呼び出したいデータが[キャッシュメモリ](#キャッシュメモリ)上に無い[確率](../../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)を**NFP**(Not Found Probability)という。\n\n"},{"term":"実行アクセス時間（平均メモリアクセス時間）","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"実行アクセス時間","content":"\n**実行アクセス時間**（**平均メモリアクセス時間**）は、[キャッシュメモリ](#キャッシュメモリ)にデータが存在する場合と存在しない場合を含めた平均的なデータへのアクセス時間。\n\n```math\n実行アクセス時間 = キャッシュメモリへのアクセス時間 \\times ヒット率 + メモリへのアクセス時間 \\times (1 - ヒット率)\n```\n\n"},{"term":"ダイレクトマップ方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ダイレクトマップ方式","content":"\n**ダイレクトマップ方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの格納方法のひとつで、[メモリ](#メモリ)の[アドレス](#アドレス)ごとに[キャッシュメモリ](#キャッシュメモリ)の格納場所がひとつに決まる。データの検索が高速であるが、衝突が起こりやすくなり[ヒット率](#ヒット率)が下がる。\n\n"},{"term":"フルアソシアティブ方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"フルアソシアティブ方式","content":"\n**フルアソシアティブ方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの格納方法のひとつで、[キャッシュメモリ](#キャッシュメモリ)の空いている[ブロック](./auxiliary_memory_unit.md#ブロック)に[メモリ](#メモリ)のデータを格納する。衝突は少ないものの、データの使用時に毎回検索が必要になるので低速。\n\n**連想メモリ**(**CAM**: Content Addressable Memory)を使用することで検索を高速化している。\n\n"},{"term":"セットアソシアティブ方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"セットアソシアティブ方式","content":"\n**セットアソシアティブ方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの格納方法のひとつで、[キャッシュメモリ](#キャッシュメモリ)を複数のグループに分け、そのグループ内ならどこでも使えるようにしたもの。\n\n[フルアソシアティブ方式](#フルアソシアティブ方式)と同様[連想メモリ](#フルアソシアティブ方式)によって検索を高速化している。\n\n"},{"term":"ライトスルー方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ライトスルー方式","content":"\n**ライトスルー方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの更新方法のひとつで、[プロセッサ](./processor.md#プロセッサ)が[キャシュメモリ](#キャッシュメモリ)に書き込みを行った場合に、同時に[メモリ](#メモリ)にもその内容を転送する。[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)は下がるが、**コヒーレント**（データの一貫性）は保たれる。\n\n"},{"term":"コヒーレント","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ライトスルー方式","content":"\n**ライトスルー方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの更新方法のひとつで、[プロセッサ](./processor.md#プロセッサ)が[キャシュメモリ](#キャッシュメモリ)に書き込みを行った場合に、同時に[メモリ](#メモリ)にもその内容を転送する。[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)は下がるが、**コヒーレント**（データの一貫性）は保たれる。\n\n"},{"term":"ライトバック方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ライトバック方式","content":"\n**ライトバック方式**は、[キャッシュメモリ](#キャッシュメモリ)におけるデータの更新方法のひとつで、[プロセッサ](./processor.md#プロセッサ)が[キャシュメモリ](#キャッシュメモリ)に書き込みを行った場合に、すぐには[メモリ](#メモリ)にその内容を転送しない。条件を満たした場合にのみ[メモリ](#メモリ)に書き込まれるため、[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)は上がるが、[コヒーレント](#ライトスルー方式)が保たれないことがある。\n\n\n"},{"term":"メモリインタリープ","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"メモリインタリープ","content":""},{"term":"メモリバンク","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"メモリインタリープ","content":""},{"term":"記憶領域の管理方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"記憶領域の管理方式","content":"\n"},{"term":"ファーストフィット方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ファーストフィット方式","content":"\n**ファーストフィット方式**は、記憶領域を管理する[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)のひとつで、記憶領域の空き領域を[アドレス](#アドレス)の下位から順番に検索して最初に見つかった空き領域を割り当てる。\n\n"},{"term":"ベストフィット方式","link":"./note/ja/./computer/hardware/_/chapters/memory.md","flagment":"ベストフィット方式","content":"\n**ベストフィット方式**は、記憶領域を管理する[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)のひとつで、空き領域のうち要求されたサイズを満たす最小のものを割り当てる。\n\n\n"},{"term":"バス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バス","content":"\n**バス**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)内部の各装置を接続するための共通の伝送路。データや信号はバスを介して伝送される。バスは[クロック](./processor.md#クロック)により同期をとりながらデータをやり取りする。\n\n"},{"term":"アドレスバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"アドレスバス","content":"\n**アドレスバス**は、[メモリ](./memory.md#メモリ)[アドレス](./memory.md#アドレス)や[入出力装置](./io_unit.md)のアドレスをやり取りするための[バス](#バス)。\n\n"},{"term":"データバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"データバス","content":"\n**データバス**は、[CPU](./processor.md#cpu)の[レジスタ](./processor.md#レジスタ)と各装置間でデータや[プログラム](../../../../programming/_/chapters/programming.md#プログラム)のやり取りを行うための[バス](#バス)。\n\n"},{"term":"コントロールバス（制御バス）","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"コントロールバス","content":"\n**コントロールバス**（**制御バス**）は、各[バス](#バス)を制御するための[バス](#バス)。[アドレスバス](#アドレスバス)や[データバス](#データバス)で実際に入出力を行うタイミングや、[CPU](./processor.md#cpu)と外部との間での必要な制御情報のやり取りなどを行う。\n\n[アドレスバス](#アドレスバス)での[アドレス](./memory.md#アドレス)に対して、読み込みを行うのか書き込みを行うのかは、コントロールバスで指定する。書き込みが指定されていれば、[データバス](#データバス)で送られてきたデータを受け取る。読み込みが指定されていれば、[データバス](#データバス)に指定[アドレス](./memory.md#アドレス)のデータを渡す。\n\n\n"},{"term":"内部バス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"内部バス","content":"\n**内部バス**は、[CPU](./processor.md#cpu)内部の装置（[制御装置](./hardware.md#制御装置)、[演算装置](./hardware.md#演算装置)、[キャッシュメモリ](./memory.md#キャッシュメモリ)など）を接続するための[バス](#バス)。\n\n\n"},{"term":"外部バス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"外部バス","content":"\n**外部バス**は、[CPU](./processor.md#cpu)と外部にある[主記憶装置](./hardware.md#主記憶装置)や周辺機器などを接続するための[バス](#バス)。\n\n"},{"term":"システムバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"システムバス","content":"\n**システムバス**は、[CPU](./processor.md#cpu)や主記憶を接続する高速な[バス](#バス)。\n\n- **フロントサイドバス** : [CPU](./processor.md#cpu)とチップセットを接続する伝送路\n- **メモリバス** : チップセットと[メモリ](./memory.md#メモリ)を接続する伝送路\n\n"},{"term":"フロントサイドバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"システムバス","content":"\n**システムバス**は、[CPU](./processor.md#cpu)や主記憶を接続する高速な[バス](#バス)。\n\n- **フロントサイドバス** : [CPU](./processor.md#cpu)とチップセットを接続する伝送路\n- **メモリバス** : チップセットと[メモリ](./memory.md#メモリ)を接続する伝送路\n\n"},{"term":"メモリバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"システムバス","content":"\n**システムバス**は、[CPU](./processor.md#cpu)や主記憶を接続する高速な[バス](#バス)。\n\n- **フロントサイドバス** : [CPU](./processor.md#cpu)とチップセットを接続する伝送路\n- **メモリバス** : チップセットと[メモリ](./memory.md#メモリ)を接続する伝送路\n\n"},{"term":"入出力バス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"入出力バス","content":"\n**入出力バス**（**I/Oバス**）は、入出力制御装置と[入出力装置](./io_unit.md)を接続する[バス](#バス)。\n\n\n"},{"term":"拡張バス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"拡張バス","content":"\n**拡張バス**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に機能を追加するために接続する[バス](#バス)。PCIなどの拡張カードを直接接続する[バス](#バス)などがある。\n\n\n"},{"term":"ハブ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ハブ","content":"\n**ハブ**は、集線装置のことで、ハブを介することで接続ポート数を増やしたり、信号を増幅して伝送距離を延ばしたりすることができる。[USB](#usb)ハブや[LAN](../../../../network/_/chapters/network.md#lan)用のネットワークハブなどがある。\n\n\n"},{"term":"バスの種類","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バスの種類","content":"\n"},{"term":"シリアルバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"シリアルバス","content":"\n**シリアルバス**は、データを1本の伝送路で1[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)ずつ転送する[バス](#バス)。高周波信号で高速にデータを送るには[パラレルバス](#パラレルバス)よりもシリアルバスが適しており、パラレルバスに比べて高速でデータが伝送できる。\n\n"},{"term":"パラレルバス","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"パラレルバス","content":"\n**パラレルバス**は、データを複数[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)でひとかたまりにして複数本の伝送路で送る[バス](#バス)。一時期は伝送の高速化のためにパラレルバスが用いられていたが、複数の伝送路でデータを送ると**タイミングスキュー**や干渉（**クロストーク**）といった問題が発生するため、高速のデータ伝送には向いていない。\n\n\n"},{"term":"タイミングスキュー","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"パラレルバス","content":"\n**パラレルバス**は、データを複数[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)でひとかたまりにして複数本の伝送路で送る[バス](#バス)。一時期は伝送の高速化のためにパラレルバスが用いられていたが、複数の伝送路でデータを送ると**タイミングスキュー**や干渉（**クロストーク**）といった問題が発生するため、高速のデータ伝送には向いていない。\n\n\n"},{"term":"クロストーク","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"パラレルバス","content":"\n**パラレルバス**は、データを複数[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)でひとかたまりにして複数本の伝送路で送る[バス](#バス)。一時期は伝送の高速化のためにパラレルバスが用いられていたが、複数の伝送路でデータを送ると**タイミングスキュー**や干渉（**クロストーク**）といった問題が発生するため、高速のデータ伝送には向いていない。\n\n\n"},{"term":"バスの規格","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バスの規格","content":"\n"},{"term":"バスパワー方式","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バスパワー方式","content":"\n**バスパワー方式**は、接続ケーブルによって[コンピュータ](../../../_/chapters/computer.md#コンピュータ)本体から供給される電力を用いる方式。ケーブルで供給できる電源容量には制限があるため、周辺装置の消費電力が大きい場合には電力不足となる場合もある。\n\n"},{"term":"プラグアンドプレイ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"プラグアンドプレイ","content":"\n**プラグアンドプレイ**は、装置を接続して[コンピュータ](../../../_/chapters/computer.md#コンピュータ)を起動すると、自動的に認識されて[デバイスドライバ](./io_unit.md#デバイスドライバ)などのインストールが行われる機能。\n\n"},{"term":"ホットプラグ機能","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ホットプラグ機能","content":"\n**ホットプラグ機能**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の電源を入れたままコネクタの抜き差しが可能で、接続すれば直ちに利用可能となるような機能。\n\n"},{"term":"Type-A","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"Type-B","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"Type-C","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"Mini-B","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"Micro-B","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"アイソクロナス転送","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"インタラプト転送","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"コントロール転送","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"バルク転送","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"スター接続","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"ツリー接続","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"カスケード接続","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"usb","content":"\n**USB**(Universal Serial Bus)は、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)、[プリンタ](./io_unit.md#プリンタ)などの接続に用いられる。[バスパワー方式](#バスパワー方式)や[ホットプラグ機能](#ホットプラグ機能)にも対応している。\n\n転送速度は、USB1.0では12Mbps、USB2.0では480Mbpsとなっている。USB3.0は、[全二重通信](../../../../network/_/chapters/network.md#全二重通信)を行う高速シリアルインタフェース規格で、転送速度は5Gbpsとなっている。さらにUSB3.1では転送速度が10Gbpsとなっている。\n\nUSBには**Type-A**、**Type-B**、**Type-C**、**Mini-B**、**Micro-B**など様々な形状がある。\n\nUSBの転送モードは以下の4種類。\n\n- **アイソクロナス転送** : 動画や音声などのリアルタイム性が必要となるデータの転送に適した転送方式で、エラーが発生しても再送が行われない\n- **インタラプト転送** : 少量のデータの転送に用いられる転送方式で、[キーボード](./io_unit.md#キーボード)や[マウス](./io_unit.md#ポインティングデバイス)などの入力データの転送に利用される\n- **コントロール転送** : 機器の初期化や設定用に用いられる転送方式で、標準リクエストやクラスリクエスト、ベンダリクエストといった様々なコマンドのやり取りに利用される\n- **バルク転送** : [磁気ディスク](./auxiliary_memory_unit.md#ハードディスク)やスキャナなどの大容量のデータ転送に用いられる転送方式で、エラー検知や再送が行われる\n\nUSBの接続形態にはスター接続とツリー接続がある。**スター接続**は、1台のUSB[ハブ](#ハブ)を使って最大127台の装置を接続可能。**ツリー接続**は、複数の[ハブ](#ハブ)を階層的に配置することで最大6階層（[ハブ](#ハブ)5台まで）まで接続可能。このような階層的な接続を**カスケード接続**という。\n\n"},{"term":"ポイントツーポイント接続","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"シリアルata","content":"\n**シリアルATA**(**SATA**)は、従来から[ハードディスク](./auxiliary_memory_unit.md#ハードディスク)の接続用に用いられていたパラレル伝送のATAを、より高速なシリアル伝送に置き換えたもの。転送速度は6Gbpsとなっている。**eSATA**(External Serial ATA)は、シリアルATAの外付け用規格。\n\nシリアルATAの接続形態は**ポイントツーポイント接続**で、コントローラと装置を1対1で接続する。装置の数だけポートが必要になる。\n\n"},{"term":"IEEE1394","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ieee1394","content":"\n**IEEE1394**は、高速シリアルインタフェース規格で、外付け[ハードディスク](./auxiliary_memory_unit.md#ハードディスク)装置との接続や、デジタルビデオと接続してビデオ画像の取り込みなどに利用されている。\n\nIEEE1394の接続形態は**デイジーチェーン接続**で、装置同士を芋づる式に最大17台まで接続できる。また、[ハブ](#ハブ)を用いたツリー接続も可能で、これを加えると最大63台まで接続可能となる。\n\n"},{"term":"デイジーチェーン接続","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ieee1394","content":"\n**IEEE1394**は、高速シリアルインタフェース規格で、外付け[ハードディスク](./auxiliary_memory_unit.md#ハードディスク)装置との接続や、デジタルビデオと接続してビデオ画像の取り込みなどに利用されている。\n\nIEEE1394の接続形態は**デイジーチェーン接続**で、装置同士を芋づる式に最大17台まで接続できる。また、[ハブ](#ハブ)を用いたツリー接続も可能で、これを加えると最大63台まで接続可能となる。\n\n"},{"term":"DisplayPort","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"displayport","content":"\n**DisplayPort**は、[パソコン](../../../_/chapters/computer.md#パーソナルコンピュータ)やAV機器と[ディスプレイ装置](./io_unit.md#ディスプレイ装置)を接続するための[デジタル](../../../../basics/information_theory/_/chapters/coding_theory.md#デジタル)接続規格で、映像と音声をパケット化し、シリアル伝送を行う。[HDMI](#hdmi)と同様、1本のケーブルで映像と音声の入出力が可能なほか、著作権保護技術にも対応している。\n\n"},{"term":"ターミネータ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"scsi","content":"\n**SCSI**（スカジー: Small Computer System Interface）は、パラレルインタフェースの規格で、最大16台までの機器を[デイジーチェーン接続](#ieee1394)できる。接続機器の両端には**ターミネータ**と呼ばれる終端抵抗が必要。\n\n"},{"term":"IrDA","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"irda","content":"\n**IrDA**は、近距離赤外線通信規格で、[パソコン](../../../_/chapters/computer.md#パーソナルコンピュータ)の周辺機器や携帯端末との無線接続が可能。\n\n"},{"term":"Bluetooth","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"bluetooth","content":"\n**Bluetooth**は、2.4GHz帯の電波を利用した近距離無線通信の接続規格。10m～数十mの接続範囲でのデータや音声の送受信に使用され、最大7台まで接続が可能。\n\n大幅な省電力化が行われた新しい規格を**BLE**(Bluetooth Low Energy)といい、これと区別するために古い規格のことを**Bluetooth Classic**と呼ぶ。\n\n"},{"term":"Bluetooth Classic","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"bluetooth","content":"\n**Bluetooth**は、2.4GHz帯の電波を利用した近距離無線通信の接続規格。10m～数十mの接続範囲でのデータや音声の送受信に使用され、最大7台まで接続が可能。\n\n大幅な省電力化が行われた新しい規格を**BLE**(Bluetooth Low Energy)といい、これと区別するために古い規格のことを**Bluetooth Classic**と呼ぶ。\n\n"},{"term":"Zigbee（ジグビー）","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"zigbee","content":"\n**Zigbee**（ジグビー）は、多数の機器との接続を行うセンサネットワークを前提とした2.4GHz帯の電波による近距離無線通信規格。[Bluetooth](#bluetooth)に比べて伝送距離が短く、速度も遅いものの、低消費電力・低コストで中継機能を持つという特徴がある。\n\n"},{"term":"RFID","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"nfc","content":"\n**NFC**(Near field radio communication)は、電波によって近距離での無線通信を行う接続規格で、通信機能と識別・認証機能を持っている。もともとはICカードの接続規格として作られ、**RFID**技術（無線通信によってICタグとの情報交換を行う技術）を利用している。日本では、NFC規格のひとつである**Felica**が普及しており、交通系ICや電子マネーカードの通信に利用されている。\n\n**アクティブ方式**のICタグは、電源を持っており通信可能距離が長い。一方、**パッシブ方式**のICタグは、電源を持たずに読み取り装置からの電磁波（または磁界）による電力で稼働する。\n\n\n"},{"term":"Felica","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"nfc","content":"\n**NFC**(Near field radio communication)は、電波によって近距離での無線通信を行う接続規格で、通信機能と識別・認証機能を持っている。もともとはICカードの接続規格として作られ、**RFID**技術（無線通信によってICタグとの情報交換を行う技術）を利用している。日本では、NFC規格のひとつである**Felica**が普及しており、交通系ICや電子マネーカードの通信に利用されている。\n\n**アクティブ方式**のICタグは、電源を持っており通信可能距離が長い。一方、**パッシブ方式**のICタグは、電源を持たずに読み取り装置からの電磁波（または磁界）による電力で稼働する。\n\n\n"},{"term":"アクティブ方式","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"nfc","content":"\n**NFC**(Near field radio communication)は、電波によって近距離での無線通信を行う接続規格で、通信機能と識別・認証機能を持っている。もともとはICカードの接続規格として作られ、**RFID**技術（無線通信によってICタグとの情報交換を行う技術）を利用している。日本では、NFC規格のひとつである**Felica**が普及しており、交通系ICや電子マネーカードの通信に利用されている。\n\n**アクティブ方式**のICタグは、電源を持っており通信可能距離が長い。一方、**パッシブ方式**のICタグは、電源を持たずに読み取り装置からの電磁波（または磁界）による電力で稼働する。\n\n\n"},{"term":"パッシブ方式","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"nfc","content":"\n**NFC**(Near field radio communication)は、電波によって近距離での無線通信を行う接続規格で、通信機能と識別・認証機能を持っている。もともとはICカードの接続規格として作られ、**RFID**技術（無線通信によってICタグとの情報交換を行う技術）を利用している。日本では、NFC規格のひとつである**Felica**が普及しており、交通系ICや電子マネーカードの通信に利用されている。\n\n**アクティブ方式**のICタグは、電源を持っており通信可能距離が長い。一方、**パッシブ方式**のICタグは、電源を持たずに読み取り装置からの電磁波（または磁界）による電力で稼働する。\n\n\n"},{"term":"バスのアーキテクチャ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バスのアーキテクチャ","content":"\n"},{"term":"ハーバードアーキテクチャ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ハーバードアーキテクチャ","content":"\n**ハーバードアーキテクチャ**は、命令とデータを分離して[バス](#バス)で転送するアーキテクチャ。命令の実行が完了すると同時に次の命令を読み込むことができるため高速化が可能であるが、より多くの電気回路を必要とする。\n\n"},{"term":"ノイマンアーキテクチャ","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"ノイマンアーキテクチャ","content":"\n**ノイマンアーキテクチャ**は、命令とデータを分離せずに同一の[バス](#バス)で転送するアーキテクチャ。命令とデータを同時に転送することはできない。\n\n\n"},{"term":"バス幅","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バス幅","content":"\n**バス幅**は、[バス](#バス)が一回の[クロック](./processor.md#クロック)信号で同時に伝送することができるデータ量。バス幅はデータ伝送のための信号線の数によって左右され、単位は[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)となる。[内部バス](#内部バス)の[クロック周波数](./processor.md#クロック)を**コアクロック周波数**、外部バスのクロック周波数を**外部クロック周波数**という。\n\n\n"},{"term":"コアクロック周波数","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バス幅","content":"\n**バス幅**は、[バス](#バス)が一回の[クロック](./processor.md#クロック)信号で同時に伝送することができるデータ量。バス幅はデータ伝送のための信号線の数によって左右され、単位は[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)となる。[内部バス](#内部バス)の[クロック周波数](./processor.md#クロック)を**コアクロック周波数**、外部バスのクロック周波数を**外部クロック周波数**という。\n\n\n"},{"term":"外部クロック周波数","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"バス幅","content":"\n**バス幅**は、[バス](#バス)が一回の[クロック](./processor.md#クロック)信号で同時に伝送することができるデータ量。バス幅はデータ伝送のための信号線の数によって左右され、単位は[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)となる。[内部バス](#内部バス)の[クロック周波数](./processor.md#クロック)を**コアクロック周波数**、外部バスのクロック周波数を**外部クロック周波数**という。\n\n\n"},{"term":"アクセスモード","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"アクセスモード","content":"\n**アクセスモード**は、データを伝送するときの[バス幅](#バス幅)や方式を制御するモード。\n\n\n"},{"term":"チャネル制御方式","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"チャネル制御方式","content":"\n**チャネル制御方式**は、[CPU](./processor.md#cpu)の指示を受けて独立して入出力の制御を行う**チャネル**という装置を用いるデータ転送の制御方式。この方式では、[記憶装置](./hardware.md#記憶装置)と[入出力装置](./io_unit.md)の間にチャネルを設置してデータ転送を制御する。1つの装置の制御を行う**セレクタチャネル**と、低速な[入出力装置](./io_unit.md)の制御を時分割により並行的に行う**マルチプレクサチャネル**がある。\n\n\n"},{"term":"チャネル","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"チャネル制御方式","content":"\n**チャネル制御方式**は、[CPU](./processor.md#cpu)の指示を受けて独立して入出力の制御を行う**チャネル**という装置を用いるデータ転送の制御方式。この方式では、[記憶装置](./hardware.md#記憶装置)と[入出力装置](./io_unit.md)の間にチャネルを設置してデータ転送を制御する。1つの装置の制御を行う**セレクタチャネル**と、低速な[入出力装置](./io_unit.md)の制御を時分割により並行的に行う**マルチプレクサチャネル**がある。\n\n\n"},{"term":"セレクタチャネル","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"チャネル制御方式","content":"\n**チャネル制御方式**は、[CPU](./processor.md#cpu)の指示を受けて独立して入出力の制御を行う**チャネル**という装置を用いるデータ転送の制御方式。この方式では、[記憶装置](./hardware.md#記憶装置)と[入出力装置](./io_unit.md)の間にチャネルを設置してデータ転送を制御する。1つの装置の制御を行う**セレクタチャネル**と、低速な[入出力装置](./io_unit.md)の制御を時分割により並行的に行う**マルチプレクサチャネル**がある。\n\n\n"},{"term":"マルチプレクサチャネル","link":"./note/ja/./computer/hardware/_/chapters/bus.md","flagment":"チャネル制御方式","content":"\n**チャネル制御方式**は、[CPU](./processor.md#cpu)の指示を受けて独立して入出力の制御を行う**チャネル**という装置を用いるデータ転送の制御方式。この方式では、[記憶装置](./hardware.md#記憶装置)と[入出力装置](./io_unit.md)の間にチャネルを設置してデータ転送を制御する。1つの装置の制御を行う**セレクタチャネル**と、低速な[入出力装置](./io_unit.md)の制御を時分割により並行的に行う**マルチプレクサチャネル**がある。\n\n\n"},{"term":"デバイスドライバ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"デバイスドライバ","content":"\n**デバイスドライバ**は、接続された周辺装置を制御するための[ソフトウェア](../../../software/_/chapters/software.md#ソフトウェア)。[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)に組み込まれる形で、周辺装置ごとに専用のデバイスドライバがある。[ハードウェア](./hardware.md#ハードウェア)を制御して、[アプリケーション](../../../software/_/chapters/software.md#応用ソフトウェア)に対して抽象化したインタフェースを提供する。[プラグアンドプレイ](./bus.md#プラグアンドプレイ)がサポートされている[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)であれば、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に周辺機器が接続されるとそれを認識して自動的に適切なデバイスドライバをインストールする。\n\n\n"},{"term":"入力装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"入力装置","content":"\n**入力装置**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にデータを取り込むための装置。\n\n"},{"term":"キーボード","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"キーボード","content":"\n**キーボード**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に文字を入力するための入力装置。\n\n"},{"term":"ポインティングデバイス","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"マウス","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"ジョイスティック","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"トラックボール","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"タッチパネル（タッチスクリーン）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"デジタイザ（ペンタブレット）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ポインティングデバイス","content":"\n**ポインティングデバイス**は、装置を操作することで画面に表示されたカーソルを動かし、画面上の特定の位置を指し示す入力装置。\n\n- **マウス** : 一般的な光学式マウスでは、マウスから出る光の反射を読み取って座標一の検知を行う\n- **ジョイスティック** : ゲームソフトの操作用などに利用される装置で、スティックを倒すことで位置情報の変化を入力する\n- **トラックボール** : ボールを回転させることで位置情報を入力する装置\n- **タッチパネル**（**タッチスクリーン**） : 表示されている画面に触れることで位置情報を入力する装置\n- **デジタイザ**（**ペンタブレット**） : パネルの上で専用のペンやマウス上のカーソルを移動させることで座標情報を入力する\n\n"},{"term":"図形入力装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"図形入力装置","content":"\n- **スキャナ** : 絵や写真などに光を当て、その反射の強弱を電気信号に変えてイメージ画像として読み取る装置\n- **OCR**（光学式文字読取装置）、**OMR**（光学式マーク読取装置） : OCRは手書きの文字を文字データとして読み取る装置で、OMRはマークシートを読み取る装置\n- **バーコードリーダ** : 光学的にバーコードを読み取る装置で、バーコードの規格としては日本ではJANコードが使われている（そのほか、ITFコードやISBNコード、2次元バーコード（QRコード）などがある）\n\n"},{"term":"スキャナ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"図形入力装置","content":"\n- **スキャナ** : 絵や写真などに光を当て、その反射の強弱を電気信号に変えてイメージ画像として読み取る装置\n- **OCR**（光学式文字読取装置）、**OMR**（光学式マーク読取装置） : OCRは手書きの文字を文字データとして読み取る装置で、OMRはマークシートを読み取る装置\n- **バーコードリーダ** : 光学的にバーコードを読み取る装置で、バーコードの規格としては日本ではJANコードが使われている（そのほか、ITFコードやISBNコード、2次元バーコード（QRコード）などがある）\n\n"},{"term":"OCR（光学式文字読取装置）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"図形入力装置","content":"\n- **スキャナ** : 絵や写真などに光を当て、その反射の強弱を電気信号に変えてイメージ画像として読み取る装置\n- **OCR**（光学式文字読取装置）、**OMR**（光学式マーク読取装置） : OCRは手書きの文字を文字データとして読み取る装置で、OMRはマークシートを読み取る装置\n- **バーコードリーダ** : 光学的にバーコードを読み取る装置で、バーコードの規格としては日本ではJANコードが使われている（そのほか、ITFコードやISBNコード、2次元バーコード（QRコード）などがある）\n\n"},{"term":"OMR（光学式マーク読取装置）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"図形入力装置","content":"\n- **スキャナ** : 絵や写真などに光を当て、その反射の強弱を電気信号に変えてイメージ画像として読み取る装置\n- **OCR**（光学式文字読取装置）、**OMR**（光学式マーク読取装置） : OCRは手書きの文字を文字データとして読み取る装置で、OMRはマークシートを読み取る装置\n- **バーコードリーダ** : 光学的にバーコードを読み取る装置で、バーコードの規格としては日本ではJANコードが使われている（そのほか、ITFコードやISBNコード、2次元バーコード（QRコード）などがある）\n\n"},{"term":"バーコードリーダ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"図形入力装置","content":"\n- **スキャナ** : 絵や写真などに光を当て、その反射の強弱を電気信号に変えてイメージ画像として読み取る装置\n- **OCR**（光学式文字読取装置）、**OMR**（光学式マーク読取装置） : OCRは手書きの文字を文字データとして読み取る装置で、OMRはマークシートを読み取る装置\n- **バーコードリーダ** : 光学的にバーコードを読み取る装置で、バーコードの規格としては日本ではJANコードが使われている（そのほか、ITFコードやISBNコード、2次元バーコード（QRコード）などがある）\n\n"},{"term":"そのほかの入力装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"音声入力装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"ICカード読取装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"磁気カード読取装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"磁気ストライプカード","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"生体認証装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"そのほかの入力装置","content":"\n- **音声入力装置** : マイクなど、音声データを入力するための装置\n- **ICカード読取装置** : ICチップの情報を読み取る装置で、接触型のICカードとして銀行やクレジットカード、非接触型のICカードとして交通機関のICタグなどがある\n- **磁気カード読取装置** : 銀行やクレジットカードなどで利用されている**磁気ストライプカード**を読み取る装置\n- **生体認証装置** : 指紋や虹彩、声紋など、生体認証技術に基づいた入力装置\n\n\n"},{"term":"出力装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"出力装置","content":"\n**出力装置**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)からデータを取り出すための装置。\n\n"},{"term":"ディスプレイ装置","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"ディスプレイ装置","content":"\n- **液晶ディスプレイ**(**LCD**: Liquid Crystal Display) : 電圧をかけて液晶分子の並ぶ向きを変えることで、光の通過・遮断をコントロールする方式\n- **有機ELディスプレイ**(Electro Luminescence Display) : 傾向性化学物に電圧をかけて発行させる方式で、大型化は難しいが薄型化が可能\n\n"},{"term":"プリンタ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"ドットインパクトプリンタ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"インクジェットプリンタ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"ページプリンタ（レーザプリンタ）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"プロッタ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"3Dプリンタ","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"プリンタ","content":"\n- **ドットインパクトプリンタ** : 字形を構成する細いピンの集合でインクリボンをたたいて印字する方法\n- **インクジェットプリンタ** : プリンタヘッドのノズルからインクを吹き付けて印字する方法\n- **ページプリンタ**（**レーザプリンタ**） : 1ページ分のイメージに従い、ドラム上にトナーを付着させて印字する方法\n- **プロッタ** : CADなどで図形出力に使用される\n- **3Dプリンタ** : 3次元のオブジェクトを出力するプリンタで、順に積層させることで造形を行う\n\n"},{"term":"ビデオボード（ビデオカード）","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"vram","content":"\n**VRAM**(Video RAM)は、[ディスプレイ装置](#ディスプレイ装置)に表示されている内容を記録する[メモリ](./memory.md#メモリ)で、画面表示の品質（解像度、色数）を左右する。16色表示であれば画面1[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)あたりに4[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)が、256色表示であれば画面1[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)あたりに8[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)が、65536色表示であれば画面1[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)あたりに16[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)が必要になる。[ディスプレイ](#ディスプレイ装置)への情報の表示に必要なデータの処理は、[CPU](./processor.md#cpu)負荷を軽減するために**ビデオボード**（**ビデオカード**）が行う。\n\n```math\n画像データの容量 = 画像の総ドット数 \\times 色情報\n```\n\n\n"},{"term":"3D映像の立体化","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"3d映像の立体化","content":"\n"},{"term":"アクティブシャッタ方式","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"アクティブシャッタ方式","content":"\n**アクティブシャッタ方式**は、利用者が専用を眼鏡を利用することで、遠近感を伴う映像を表現する方式。左右の目用に映像をそれぞれ用意し、交互に映像を透過・遮断することで立体視を可能としている。\n\n"},{"term":"アナグリフ方式","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"アナグリフ方式","content":"\n**アナグリフ方式**は、片目に赤色、もう一方の目に青色のフィルタをつけた眼鏡を利用する方式。左右の目用の映像を重ねて描画することで立体視を可能としている。\n\n"},{"term":"パララックスバリア方式","link":"./note/ja/./computer/hardware/_/chapters/io_unit.md","flagment":"パララックスバリア方式","content":"\n**パララックスバリア方式**は、専用のメガネは利用せず、専用の特殊なディスプレイに左右の目用の映像を同時に描画し、網目状のフィルタを用いて立体視を実現する方式。\n\n\n"},{"term":"補助記憶装置","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"補助記憶装置","content":"\n**補助記憶装置**は、電源を切ってもデータを保持しておくことができる不揮発性の[記憶装置](./hardware.md#記憶装置)。[主記憶装置](./hardware.md#主記憶装置)に比べて読み書きの速度は遅いが、大容量なのが特徴。\n\n\n"},{"term":"プラッタ（磁気ディスク）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"プラッタ","content":"\n**プラッタ**（**磁気ディスク**）は、情報が記録される媒体そのもので、表面の磁性体の磁性の向きによって情報を記録する。\n\n"},{"term":"スピンドルモータ","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"スピンドルモータ","content":"\n**スピンドルモータ**は、[プラッタ](#プラッタ)を回転させるための動力。\n\n"},{"term":"アクセスアーム（スイングアーム）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクセスアーム","content":"\n**アクセスアーム**（**スイングアーム**）は、[磁気ヘッド](#磁気ヘッド)と[アクチュエータ](#アクチュエータ)を結びつけるアーム。\n\n"},{"term":"磁気ヘッド","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"磁気ヘッド","content":"\n**磁気ヘッド**は、[アクセスアーム](#アクセスアーム)の先端に取り付けられており、[プラッタ](#プラッタ)表面の磁気記録層に対して磁気データを読み書きする部品。\n\n"},{"term":"アクチュエータ（位置決め装置、ヘッドポジショナ）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクチュエータ","content":"\n**アクチュエータ**（**位置決め装置**、**ヘッドポジショナ**）は、[磁気ヘッド](#磁気ヘッド)を[プラッタ](#プラッタ)上の適切な位置に移動させるための部品。\n\n"},{"term":"トラック","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"トラック","content":"\n**トラック**は、[磁気ディスク](#プラッタ)に同心円上に設けられたデータの記憶領域。1つの円を1トラックという。\n\n"},{"term":"セクタ","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"セクタ","content":"\n**セクタ**は、[トラック](#トラック)を放射状に分割した記憶領域。\n\n"},{"term":"クラスタ","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"クラスタ","content":"\n**クラスタ**は、複数の[セクタ](#セクタ)をまとめた物理的な単位。\n\n"},{"term":"レコード","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"レコード","content":"\n**レコード**は、データを記録する最小単位で、1つの[セクタ](#セクタ)が複数のレコードに区切られる。\n\n"},{"term":"ブロック","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"ブロック","content":"\n**ブロック**は、[レコード](#レコード)の読み書きの効率化のために複数の[レコード](#レコード)をまとめた物理的な単位。\n\n"},{"term":"シリンダ","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"シリンダ","content":"\n**シリンダ**は、同心円状の[トラック](#トラック)の集合。\n\n"},{"term":"アクセス時間","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクセス時間","content":"\n**アクセス時間**は、[ハードディスク](#ハードディスク)にデータの入出力を要求してから実際にデータの転送が完了するまでにかかる時間で、次の要素によって決まる。\n\n- **平均シーク時間**（**平均位置決め時間**） : [磁気ヘッド](#磁気ヘッド)を目的の[トラック](#トラック)まで移動するのに要する時間\n- **平均サーチ時間**（**平均回転待ち時間**） : [トラック](#トラック)で該当のデータの先頭が[磁気ヘッド](#磁気ヘッド)の位置に来るまでに要する時間（[トラック](#トラック)の回転数から算出）\n- **データ転送時間** : データの転送に要する時間\n\n```math\nハードディスクへのアクセス時間 = 平均待ち時間 + データ転送時間 = 平均シーク時間 + 平均サーチ時間 + データ転送時間\n```\n\n"},{"term":"平均シーク時間（平均位置決め時間）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクセス時間","content":"\n**アクセス時間**は、[ハードディスク](#ハードディスク)にデータの入出力を要求してから実際にデータの転送が完了するまでにかかる時間で、次の要素によって決まる。\n\n- **平均シーク時間**（**平均位置決め時間**） : [磁気ヘッド](#磁気ヘッド)を目的の[トラック](#トラック)まで移動するのに要する時間\n- **平均サーチ時間**（**平均回転待ち時間**） : [トラック](#トラック)で該当のデータの先頭が[磁気ヘッド](#磁気ヘッド)の位置に来るまでに要する時間（[トラック](#トラック)の回転数から算出）\n- **データ転送時間** : データの転送に要する時間\n\n```math\nハードディスクへのアクセス時間 = 平均待ち時間 + データ転送時間 = 平均シーク時間 + 平均サーチ時間 + データ転送時間\n```\n\n"},{"term":"平均サーチ時間（平均回転待ち時間）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクセス時間","content":"\n**アクセス時間**は、[ハードディスク](#ハードディスク)にデータの入出力を要求してから実際にデータの転送が完了するまでにかかる時間で、次の要素によって決まる。\n\n- **平均シーク時間**（**平均位置決め時間**） : [磁気ヘッド](#磁気ヘッド)を目的の[トラック](#トラック)まで移動するのに要する時間\n- **平均サーチ時間**（**平均回転待ち時間**） : [トラック](#トラック)で該当のデータの先頭が[磁気ヘッド](#磁気ヘッド)の位置に来るまでに要する時間（[トラック](#トラック)の回転数から算出）\n- **データ転送時間** : データの転送に要する時間\n\n```math\nハードディスクへのアクセス時間 = 平均待ち時間 + データ転送時間 = 平均シーク時間 + 平均サーチ時間 + データ転送時間\n```\n\n"},{"term":"データ転送時間","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"アクセス時間","content":"\n**アクセス時間**は、[ハードディスク](#ハードディスク)にデータの入出力を要求してから実際にデータの転送が完了するまでにかかる時間で、次の要素によって決まる。\n\n- **平均シーク時間**（**平均位置決め時間**） : [磁気ヘッド](#磁気ヘッド)を目的の[トラック](#トラック)まで移動するのに要する時間\n- **平均サーチ時間**（**平均回転待ち時間**） : [トラック](#トラック)で該当のデータの先頭が[磁気ヘッド](#磁気ヘッド)の位置に来るまでに要する時間（[トラック](#トラック)の回転数から算出）\n- **データ転送時間** : データの転送に要する時間\n\n```math\nハードディスクへのアクセス時間 = 平均待ち時間 + データ転送時間 = 平均シーク時間 + 平均サーチ時間 + データ転送時間\n```\n\n"},{"term":"フラグメンテーション（断片化）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"フラグメンテーション","content":"\n**フラグメンテーション**（**断片化**）は、[記憶装置](./hardware.md#記憶装置)に対して書き込みや削除といった操作を繰り返していくことで、データの保存間隔が飛び飛びになる状態。まとまった空き容量が少なくなると、ファイルが小さな容量に分割されて保存されるといった状態になる。\n\n[ハードディスク](./hardware.md#ハードディスク)ではフラグメンテーションが発生すると[アクセス時間](#アクセス時間)が増加してしまう。\n\nまた、このような[ストレージ](./hardware.md#記憶装置)のフラグメンテーションと似た現象として、[メモリ](./memory.md#メモリ)でもフラグメンテーションが起こる。\n\n"},{"term":"デフラグメンテーション（デフラグ）","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"デフラグメンテーション","content":"\n**デフラグメンテーション**（**デフラグ**）は、[フラグメンテーション](#フラグメンテーション)を解消する処理。小さな空き領域を1つにまとめたり、[断片化](#フラグメンテ―ション)したデータを連続した領域に移したりする。\n\n\n"},{"term":"光ディスク","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"光ディスク","content":"\n**光ディスク**は、レーザ光を用いて樹脂のディスクにデータを読み書きする[補助記憶装置](#補助記憶装置)。光ディスクには、あらかじめデータが書き込まれており新たに読み書きができない**読み出し専用型**、追加の書き込みのみ可能で消去はできない**追記型**、消去も書き込みも可能な**書換え型**がある。\n\n追記型にはCD-RやDVD-R、BD-R、BD-R XL、書換え型にはCD-RWやDVD-RW、BD-RE、BD-RE XLがある。\n\n\n"},{"term":"読み出し専用型","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"光ディスク","content":"\n**光ディスク**は、レーザ光を用いて樹脂のディスクにデータを読み書きする[補助記憶装置](#補助記憶装置)。光ディスクには、あらかじめデータが書き込まれており新たに読み書きができない**読み出し専用型**、追加の書き込みのみ可能で消去はできない**追記型**、消去も書き込みも可能な**書換え型**がある。\n\n追記型にはCD-RやDVD-R、BD-R、BD-R XL、書換え型にはCD-RWやDVD-RW、BD-RE、BD-RE XLがある。\n\n\n"},{"term":"追記型","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"光ディスク","content":"\n**光ディスク**は、レーザ光を用いて樹脂のディスクにデータを読み書きする[補助記憶装置](#補助記憶装置)。光ディスクには、あらかじめデータが書き込まれており新たに読み書きができない**読み出し専用型**、追加の書き込みのみ可能で消去はできない**追記型**、消去も書き込みも可能な**書換え型**がある。\n\n追記型にはCD-RやDVD-R、BD-R、BD-R XL、書換え型にはCD-RWやDVD-RW、BD-RE、BD-RE XLがある。\n\n\n"},{"term":"書換え型","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"光ディスク","content":"\n**光ディスク**は、レーザ光を用いて樹脂のディスクにデータを読み書きする[補助記憶装置](#補助記憶装置)。光ディスクには、あらかじめデータが書き込まれており新たに読み書きができない**読み出し専用型**、追加の書き込みのみ可能で消去はできない**追記型**、消去も書き込みも可能な**書換え型**がある。\n\n追記型にはCD-RやDVD-R、BD-R、BD-R XL、書換え型にはCD-RWやDVD-RW、BD-RE、BD-RE XLがある。\n\n\n"},{"term":"フラッシュメモリカード","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"フラッシュメモリカード","content":"\n**フラッシュメモリカード**は、デジタルカメラや携帯電話などの記録メディアとして普及している補助記憶装置で、[フラッシュメモリ](./memory.md#rom)を用いている。\n\n"},{"term":"SDカード","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"sdカード","content":"\n**SDカード**は、フラッシュメモリカードの代表的な企画で、メモリサイズの違いによって**SD**、**miniSD**、**microSD**の3種類がある。\n\n\n"},{"term":"SD","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"sdカード","content":"\n**SDカード**は、フラッシュメモリカードの代表的な企画で、メモリサイズの違いによって**SD**、**miniSD**、**microSD**の3種類がある。\n\n\n"},{"term":"miniSD","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"sdカード","content":"\n**SDカード**は、フラッシュメモリカードの代表的な企画で、メモリサイズの違いによって**SD**、**miniSD**、**microSD**の3種類がある。\n\n\n"},{"term":"microSD","link":"./note/ja/./computer/hardware/_/chapters/auxiliary_memory_unit.md","flagment":"sdカード","content":"\n**SDカード**は、フラッシュメモリカードの代表的な企画で、メモリサイズの違いによって**SD**、**miniSD**、**microSD**の3種類がある。\n\n\n"},{"term":"論理回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"MIL記号","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"OR回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"AND回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"NOT回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"NOR回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"NAND回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"XOR回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"論理回路","content":"\n**論理回路**は、[論理演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#論理演算)を行う電気回路のことで、論理回路を組み合わせることで複雑な回路を構成することができる。論理回路は**MIL記号**により表記される。\n\n代表的な論理回路には、[OR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#or演算)を行う**OR回路**、[AND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を行う**AND回路**、[NOT演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#not演算)を行う**NOT回路**、[NOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nor演算)を行う**NOR回路**、[NAND演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#nand演算)を行う**NAND回路**、[XOR演算](../../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を行う**XOR回路**がある。中でもNAND回路は他の回路に比べて回路構成が簡単で作りやすいという特徴があり、他の論理回路もすべてNAND回路のみを組み合わせて作ることができる。\n\n\n"},{"term":"加算回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"加算回路","content":"\n**加算回路**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の計算の基本となる加算を行うための回路。[コンピュータ](../../../_/chapters/computer.md#コンピュータ)では[補数](../../../../basics/discrete_mathematics/_/chapters/numeric_representation.md#補数)を用いることによって、減算も加算により計算することができる。\n\n"},{"term":"多数決回路","link":"./note/ja/./computer/hardware/_/chapters/logical_circuit.md","flagment":"多数決回路","content":"\n**多数決回路**は、[2進数](../../../../basics/discrete_mathematics/_/chapters/radix.md#2進数)1桁の値が複数入力され、その中でも多い方の入力と同じ値を出力する回路。3入力多数決回路であれば、2つ以上同じ値であればその値を出力する。\n\n\n"},{"term":"機械電子制御","link":"./note/ja/./computer/hardware/_/chapters/mechanical_electronic_control.md","flagment":"機械電子制御","content":"\n**機械電子制御**は、[ハードウェア](./hardware.md#ハードウェア)の動作を[コンピュータ](../../../_/chapters/computer.md#コンピュータ)によってコントロールすること。\n\n"},{"term":"シーケンス制御","link":"./note/ja/./computer/hardware/_/chapters/mechanical_electronic_control.md","flagment":"シーケンス制御","content":"\n**シーケンス制御**は、決められた動作に従って制御を進めていく方式。\n\n"},{"term":"フィードバック制御","link":"./note/ja/./computer/hardware/_/chapters/mechanical_electronic_control.md","flagment":"フィードバック制御","content":"\n**フィードバック制御**は、あらかじめ設定された目標値と現在の状況を比較し、両方を一致させるように制御を行っていく方式。\n\n- **サーボ制御**: ロボット制御や工作機器の制御など、位置や角度が目標値として明確に決まるように制御を行う\n- **プロセス制御**: 製鉄や化学工場の製造工程において、温度や圧力などを目標の範囲に収まるように制御を行う\n\n"},{"term":"サーボ制御","link":"./note/ja/./computer/hardware/_/chapters/mechanical_electronic_control.md","flagment":"フィードバック制御","content":"\n**フィードバック制御**は、あらかじめ設定された目標値と現在の状況を比較し、両方を一致させるように制御を行っていく方式。\n\n- **サーボ制御**: ロボット制御や工作機器の制御など、位置や角度が目標値として明確に決まるように制御を行う\n- **プロセス制御**: 製鉄や化学工場の製造工程において、温度や圧力などを目標の範囲に収まるように制御を行う\n\n"},{"term":"プロセス制御","link":"./note/ja/./computer/hardware/_/chapters/mechanical_electronic_control.md","flagment":"フィードバック制御","content":"\n**フィードバック制御**は、あらかじめ設定された目標値と現在の状況を比較し、両方を一致させるように制御を行っていく方式。\n\n- **サーボ制御**: ロボット制御や工作機器の制御など、位置や角度が目標値として明確に決まるように制御を行う\n- **プロセス制御**: 製鉄や化学工場の製造工程において、温度や圧力などを目標の範囲に収まるように制御を行う\n\n"},{"term":"IC（集積回路: Integrated Circuit）","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"ic","content":"\n**IC**（**集積回路**: Integrated Circuit）は、半導体素子（半導体による電子部品）のひとつで、基板上に様々な部品をまとめた小型の回路。\n\n"},{"term":"LSI（大規模集積回路: Large Scale Integration）","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"lsi","content":"\n**LSI**（**大規模集積回路**: Large Scale Integration）は、[IC](#ic)よりも集積度を高めた素子。\n\n"},{"term":"VLSI（Very Large Scale Integration）","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"vlsi","content":"\n**VLSI**(Very Large Scale Integration)は、[LSI](#lsi)よりもさらに集積度を高めた素子。\n\n"},{"term":"カスタムIC","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"カスタムic","content":"\n**カスタムIC**は、利用者が要求する特定の用途に特化した[IC](#ic)。製造するときに回路設計を決定する**ASIC**(Application Specific Integrated Circuit)や、製造後に回路を変更できる**FPGA**(Field-Programmable Gate Array)がある。FPGAの構成を記述するハードウェア言語として**HDL**(Hardware Description Language)を用いる。\n\n"},{"term":"システムLSI","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"システムlsi","content":"\n**システムLSI**は、組込みシステム製品の電子回路を1チップに集約した半導体製品で、その設計手法は**SoC**(System On a Chip)と呼ばれる。\n\n"},{"term":"ラッチアップ","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"ラッチアップ","content":"\n**ラッチアップ**は、半導体特有の故障のひとつで、期待しない位置に[トランジスタ](../../../_/chapters/computer.md#第2世代)やサイリスタができてしまうことで回路に不具合を生じること。これを寄生トランジスタや寄生サイリスタなどと呼ぶ。\n\n"},{"term":"寄生トランジスタ","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"ラッチアップ","content":"\n**ラッチアップ**は、半導体特有の故障のひとつで、期待しない位置に[トランジスタ](../../../_/chapters/computer.md#第2世代)やサイリスタができてしまうことで回路に不具合を生じること。これを寄生トランジスタや寄生サイリスタなどと呼ぶ。\n\n"},{"term":"寄生サイクリスタ","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"ラッチアップ","content":"\n**ラッチアップ**は、半導体特有の故障のひとつで、期待しない位置に[トランジスタ](../../../_/chapters/computer.md#第2世代)やサイリスタができてしまうことで回路に不具合を生じること。これを寄生トランジスタや寄生サイリスタなどと呼ぶ。\n\n"},{"term":"ストレスマイグレーション","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"ストレスマイグレーション","content":"\n**ストレスマイグレーション**は、機械的な力によって配線が切断されるなどによって、半導体素子が不良になる現象。\n\n"},{"term":"エレクトロマイグレーション","link":"./note/ja/./computer/hardware/_/chapters/ic.md","flagment":"エレクトロマイグレーション","content":"\n**エレクトロマイグレーション**は、電流が過度に流れることによって配線が切断されるなどによって、半導体素子が不良になる現象。\n\n\n"},{"term":"ソフトウェア","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ソフトウェア","content":"\n**ソフトウェア**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)を構成する要素のうち、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上で動作する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n"},{"term":"基本ソフトウェア","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"基本ソフトウェア","content":"\n**基本ソフトウェア**は、主に[OS](./operating_system.md#オペレーティングシステム)のことであり、ユーザが[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)にデータを入力したり、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)からの出力をユーザに表示したり、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にインストールされた[アプリケーション](#応用ソフトウェア)の動作を管理したりといった、基本的な動作を行うための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n基本ソフトウェアは以下の[ソフトウェア](#ソフトウェア)群により構成される。\n\n- **制御プログラム**（狭義の[OS](./operating_system.md#オペレーティングシステム): [ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)を管理・制御し、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)資源を[アプリケーションソフトウェア](#応用ソフトウェア)に配分する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **サービスプログラム**: [コンピュータ](../../../_/chapters/computer.md#コンピュータ)を利用者が容易に操作できるように提供される、補助的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **言語処理プログラム**: [プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)で書かれた[ソースプログラム](../../../../programming/_/chapters/programming.md#ソースコード)を、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n\nほとんどの[応用ソフトウェア](#応用ソフトウェア)にはウィンドウやツールバー、確認メッセージなどの要素が含まれる。こういった要素を共通化してその部品を[応用ソフトウェア](#応用ソフトウェア)に提供するのは基本ソフトウェアの役割のひとつ。また、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)が持つ資源（[CPU](../../../hardware/_/chapters/processor.md#cpu)や[メモリ](../../../hardware/_/chapters/memory.md#メモリ)、その他の装置など）を管理して[応用ソフトウェア](#応用ソフトウェア)に分配し、同時に複数の処理を行えるようにするのも基本ソフトウェアの役割となっている。\n\n"},{"term":"制御プログラム（狭義のOS）","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"基本ソフトウェア","content":"\n**基本ソフトウェア**は、主に[OS](./operating_system.md#オペレーティングシステム)のことであり、ユーザが[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)にデータを入力したり、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)からの出力をユーザに表示したり、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にインストールされた[アプリケーション](#応用ソフトウェア)の動作を管理したりといった、基本的な動作を行うための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n基本ソフトウェアは以下の[ソフトウェア](#ソフトウェア)群により構成される。\n\n- **制御プログラム**（狭義の[OS](./operating_system.md#オペレーティングシステム): [ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)を管理・制御し、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)資源を[アプリケーションソフトウェア](#応用ソフトウェア)に配分する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **サービスプログラム**: [コンピュータ](../../../_/chapters/computer.md#コンピュータ)を利用者が容易に操作できるように提供される、補助的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **言語処理プログラム**: [プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)で書かれた[ソースプログラム](../../../../programming/_/chapters/programming.md#ソースコード)を、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n\nほとんどの[応用ソフトウェア](#応用ソフトウェア)にはウィンドウやツールバー、確認メッセージなどの要素が含まれる。こういった要素を共通化してその部品を[応用ソフトウェア](#応用ソフトウェア)に提供するのは基本ソフトウェアの役割のひとつ。また、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)が持つ資源（[CPU](../../../hardware/_/chapters/processor.md#cpu)や[メモリ](../../../hardware/_/chapters/memory.md#メモリ)、その他の装置など）を管理して[応用ソフトウェア](#応用ソフトウェア)に分配し、同時に複数の処理を行えるようにするのも基本ソフトウェアの役割となっている。\n\n"},{"term":"サービスプログラム","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"基本ソフトウェア","content":"\n**基本ソフトウェア**は、主に[OS](./operating_system.md#オペレーティングシステム)のことであり、ユーザが[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)にデータを入力したり、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)からの出力をユーザに表示したり、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にインストールされた[アプリケーション](#応用ソフトウェア)の動作を管理したりといった、基本的な動作を行うための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n基本ソフトウェアは以下の[ソフトウェア](#ソフトウェア)群により構成される。\n\n- **制御プログラム**（狭義の[OS](./operating_system.md#オペレーティングシステム): [ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)を管理・制御し、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)資源を[アプリケーションソフトウェア](#応用ソフトウェア)に配分する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **サービスプログラム**: [コンピュータ](../../../_/chapters/computer.md#コンピュータ)を利用者が容易に操作できるように提供される、補助的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **言語処理プログラム**: [プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)で書かれた[ソースプログラム](../../../../programming/_/chapters/programming.md#ソースコード)を、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n\nほとんどの[応用ソフトウェア](#応用ソフトウェア)にはウィンドウやツールバー、確認メッセージなどの要素が含まれる。こういった要素を共通化してその部品を[応用ソフトウェア](#応用ソフトウェア)に提供するのは基本ソフトウェアの役割のひとつ。また、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)が持つ資源（[CPU](../../../hardware/_/chapters/processor.md#cpu)や[メモリ](../../../hardware/_/chapters/memory.md#メモリ)、その他の装置など）を管理して[応用ソフトウェア](#応用ソフトウェア)に分配し、同時に複数の処理を行えるようにするのも基本ソフトウェアの役割となっている。\n\n"},{"term":"言語処理プログラム","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"基本ソフトウェア","content":"\n**基本ソフトウェア**は、主に[OS](./operating_system.md#オペレーティングシステム)のことであり、ユーザが[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)にデータを入力したり、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)からの出力をユーザに表示したり、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にインストールされた[アプリケーション](#応用ソフトウェア)の動作を管理したりといった、基本的な動作を行うための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n基本ソフトウェアは以下の[ソフトウェア](#ソフトウェア)群により構成される。\n\n- **制御プログラム**（狭義の[OS](./operating_system.md#オペレーティングシステム): [ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)を管理・制御し、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)資源を[アプリケーションソフトウェア](#応用ソフトウェア)に配分する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **サービスプログラム**: [コンピュータ](../../../_/chapters/computer.md#コンピュータ)を利用者が容易に操作できるように提供される、補助的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n- **言語処理プログラム**: [プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)で書かれた[ソースプログラム](../../../../programming/_/chapters/programming.md#ソースコード)を、[機械語](../../../../basics/information_theory/_/chapters/compiler_theory.md#機械語)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)に変換するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)\n\nほとんどの[応用ソフトウェア](#応用ソフトウェア)にはウィンドウやツールバー、確認メッセージなどの要素が含まれる。こういった要素を共通化してその部品を[応用ソフトウェア](#応用ソフトウェア)に提供するのは基本ソフトウェアの役割のひとつ。また、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)が持つ資源（[CPU](../../../hardware/_/chapters/processor.md#cpu)や[メモリ](../../../hardware/_/chapters/memory.md#メモリ)、その他の装置など）を管理して[応用ソフトウェア](#応用ソフトウェア)に分配し、同時に複数の処理を行えるようにするのも基本ソフトウェアの役割となっている。\n\n"},{"term":"応用ソフトウェア","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"応用ソフトウェア","content":"\n**応用ソフトウェア**（**アプリケーションソフトウェア**）は、ワープロソフトや表計算ソフト、画像編集用のソフトといった、ある特定の業務や目的を達成するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n\n"},{"term":"ミドルウェア","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ミドルウェア","content":"\n**ミドルウェア**は、[基本ソフトウェア](#基本ソフトウェア)と[応用ソフトウェア](#応用ソフトウェア)の中間に位置し、複数の[アプリケーションソフトウェア](#応用ソフトウェア)に共通の機能を提供する。\n\n\n"},{"term":"プラットフォーム","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"プラットフォーム","content":"\n**プラットフォーム**は、[アプリケーションソフトウェア](#応用ソフトウェア)が動作する環境。[ソフトウェア](#ソフトウェア)が動作するデバイス（[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)）や[OS](./operating_system.md#オペレーティングシステム)を指す。\n\n"},{"term":"マルチプラットフォーム（クロスプラットフォーム）","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"マルチプラットフォーム","content":"\n**マルチプラットフォーム**（**クロスプラットフォーム**）は、[ソフトウェア](#ソフトウェア)が複数の[プラットフォーム](#プラットフォーム)で実行できたり、複数の[プラットフォーム](#プラットフォーム)の[ソフトウェア](#ソフトウェア)同士が通信できること。\n\n\n"},{"term":"ランタイム","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ランタイム","content":"\n**ランタイム**は、開発された[ソフトウェア](#ソフトウェア)の実行時に必要となる[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や、[ソフトウェア](#ソフトウェア)が実行される時のことを指す用語。\n\n\n"},{"term":"ユーザビリティ","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ユーザビリティ","content":"\n**ユーザビリティ**は、[ソフトウェア](#ソフトウェア)やサービス、周辺機器などが、ユーザにとってどれほど使いやすいかを表す指標。\n\n"},{"term":"アクセシビリティ","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"アクセシビリティ","content":"\n**アクセシビリティ**は、[ソフトウェア](#ソフトウェア)やサービス、周辺機器などが、ユーザの年齢や障害の有無に関わらずに利用しやすいかを表す指標。\n\n"},{"term":"ヒューリスティック評価","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ヒューリスティック評価","content":"\n**ヒューリスティック評価**は、[UI](ui)を評価するための方法で、数人の専門家が[ユーザビリティ](#ユーザビリティ)のガイドラインに沿ってそれぞれ評価を行い、それを集約して問題点を明確にする。\n\n"},{"term":"ユニバーサルデザイン","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"ユニバーサルデザイン","content":"\n**ユニバーサルデザイン**は、文化や言語、年齢や性別の違いに配慮した、より多くの人が快適ん利用できるインタフェースを設計すること。\n\n"},{"term":"ノンバーバル","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"タップ","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"フリック","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"スワイプ","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"ドラッグ","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"ピンチアウト/ピンチイン","link":"./note/ja/./computer/software/_/chapters/software.md","flagment":"nui","content":"\n**NUI**(Natural User Interface)は、人が日常行う自然な動作で操作するインタフェース。**ノンバーバル**（動作や表情といった要素）なインタフェースのことで、タッチパネルや指によるジェスチャ動作（**タップ**、**フリック**、**スワイプ**、**ドラッグ**、**ピンチアウト/ピンチイン**などがこれに当たる。\n\n\n"},{"term":"Windows","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"windows","content":"\n**Windows**は、Microsoftが提供する[オペレーティングシステム](#オペレーティングシステム)で、個人利用の[OS](#オペレーティングシステム)としては世界で最も利用者数が多い。技術的な知識を有さないユーザ数も多いため、攻撃者からも狙われやすく、ウィルスの種類も多い。\n\n"},{"term":"macOS","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"macos","content":"\n**macOS**は、Appleが提供する[オペレーティングシステム](#オペレーティングシステム)で、美しい[UI](./software.md#ui)や高い[UX](./software.md#ux)が特徴。一般ビジネスや個人利用においては[Windows](#windows)に及ばないものの、クリエイティブな分野で活躍している。\n\n"},{"term":"UNIX","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"unix","content":"\n**UNIX**は、1960年代にアメリカのAT&T社のベル研究所で誕生した[OS](#オペレーティングシステム)。同研究所でもともと開発されていた**MULTICS**という[OS](#オペレーティングシステム)があったが、多機能な[OS](#オペレーティングシステム)を目指したことで研究が頓挫し、その片隅で開発されていたミニマルな[OS](#オペレーティングシステム)であるUNIXが様々な実験プロジェクトに用いられるようになった。当時UNIXは商用として考えられていなかったため、[ライセンス](./open_source_software.md#ライセンス)が無料で自由に利用でき、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)も配布されていたことから多くのユーザが研究や開発に利用できた。\n\nこのような背景から多くの企業や団体が独自実装したUNIXが登場したため、AT&Tが正式に[ライセンス](./open_source_software.md#ライセンス)契約を始めることとなった。AT&TのUNIXを**System V**と呼び、正式な[ライセンス](./open_source_software.md#ライセンス)契約を結んだ組織のみが自社のOSをUNIXと宣言できるようになった。一方でAT&Tと[ライセンス](./open_source_software.md#ライセンス)契約を結ばなかった組織の[OS](#オペレーティングシステム)は**UNIX互換OS**と呼ばれるようになった。\n\n様々な種類のUNIXが広まる中、**BSD**（Berkeley Software Distribution: バークレー版UNIX）は初めて本格的に[TCP/IP](../../../../network/_/chapters/communication_protocol.md#tcpip)による通信をサポートしたことで広く知られるようになった。\n\nUNIXは現在でも、IT業界や[サーバ](../../../_/chapters/computer.md#サーバ)の分野においては一定のシェアを有している。基本的には[CUI](./software.md#cui)による操作となっているが、[GUI](./software.md#gui)環境の導入も可能。\n\n"},{"term":"MULTICS","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"unix","content":"\n**UNIX**は、1960年代にアメリカのAT&T社のベル研究所で誕生した[OS](#オペレーティングシステム)。同研究所でもともと開発されていた**MULTICS**という[OS](#オペレーティングシステム)があったが、多機能な[OS](#オペレーティングシステム)を目指したことで研究が頓挫し、その片隅で開発されていたミニマルな[OS](#オペレーティングシステム)であるUNIXが様々な実験プロジェクトに用いられるようになった。当時UNIXは商用として考えられていなかったため、[ライセンス](./open_source_software.md#ライセンス)が無料で自由に利用でき、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)も配布されていたことから多くのユーザが研究や開発に利用できた。\n\nこのような背景から多くの企業や団体が独自実装したUNIXが登場したため、AT&Tが正式に[ライセンス](./open_source_software.md#ライセンス)契約を始めることとなった。AT&TのUNIXを**System V**と呼び、正式な[ライセンス](./open_source_software.md#ライセンス)契約を結んだ組織のみが自社のOSをUNIXと宣言できるようになった。一方でAT&Tと[ライセンス](./open_source_software.md#ライセンス)契約を結ばなかった組織の[OS](#オペレーティングシステム)は**UNIX互換OS**と呼ばれるようになった。\n\n様々な種類のUNIXが広まる中、**BSD**（Berkeley Software Distribution: バークレー版UNIX）は初めて本格的に[TCP/IP](../../../../network/_/chapters/communication_protocol.md#tcpip)による通信をサポートしたことで広く知られるようになった。\n\nUNIXは現在でも、IT業界や[サーバ](../../../_/chapters/computer.md#サーバ)の分野においては一定のシェアを有している。基本的には[CUI](./software.md#cui)による操作となっているが、[GUI](./software.md#gui)環境の導入も可能。\n\n"},{"term":"System V","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"unix","content":"\n**UNIX**は、1960年代にアメリカのAT&T社のベル研究所で誕生した[OS](#オペレーティングシステム)。同研究所でもともと開発されていた**MULTICS**という[OS](#オペレーティングシステム)があったが、多機能な[OS](#オペレーティングシステム)を目指したことで研究が頓挫し、その片隅で開発されていたミニマルな[OS](#オペレーティングシステム)であるUNIXが様々な実験プロジェクトに用いられるようになった。当時UNIXは商用として考えられていなかったため、[ライセンス](./open_source_software.md#ライセンス)が無料で自由に利用でき、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)も配布されていたことから多くのユーザが研究や開発に利用できた。\n\nこのような背景から多くの企業や団体が独自実装したUNIXが登場したため、AT&Tが正式に[ライセンス](./open_source_software.md#ライセンス)契約を始めることとなった。AT&TのUNIXを**System V**と呼び、正式な[ライセンス](./open_source_software.md#ライセンス)契約を結んだ組織のみが自社のOSをUNIXと宣言できるようになった。一方でAT&Tと[ライセンス](./open_source_software.md#ライセンス)契約を結ばなかった組織の[OS](#オペレーティングシステム)は**UNIX互換OS**と呼ばれるようになった。\n\n様々な種類のUNIXが広まる中、**BSD**（Berkeley Software Distribution: バークレー版UNIX）は初めて本格的に[TCP/IP](../../../../network/_/chapters/communication_protocol.md#tcpip)による通信をサポートしたことで広く知られるようになった。\n\nUNIXは現在でも、IT業界や[サーバ](../../../_/chapters/computer.md#サーバ)の分野においては一定のシェアを有している。基本的には[CUI](./software.md#cui)による操作となっているが、[GUI](./software.md#gui)環境の導入も可能。\n\n"},{"term":"UNIX互換OS","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"unix","content":"\n**UNIX**は、1960年代にアメリカのAT&T社のベル研究所で誕生した[OS](#オペレーティングシステム)。同研究所でもともと開発されていた**MULTICS**という[OS](#オペレーティングシステム)があったが、多機能な[OS](#オペレーティングシステム)を目指したことで研究が頓挫し、その片隅で開発されていたミニマルな[OS](#オペレーティングシステム)であるUNIXが様々な実験プロジェクトに用いられるようになった。当時UNIXは商用として考えられていなかったため、[ライセンス](./open_source_software.md#ライセンス)が無料で自由に利用でき、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)も配布されていたことから多くのユーザが研究や開発に利用できた。\n\nこのような背景から多くの企業や団体が独自実装したUNIXが登場したため、AT&Tが正式に[ライセンス](./open_source_software.md#ライセンス)契約を始めることとなった。AT&TのUNIXを**System V**と呼び、正式な[ライセンス](./open_source_software.md#ライセンス)契約を結んだ組織のみが自社のOSをUNIXと宣言できるようになった。一方でAT&Tと[ライセンス](./open_source_software.md#ライセンス)契約を結ばなかった組織の[OS](#オペレーティングシステム)は**UNIX互換OS**と呼ばれるようになった。\n\n様々な種類のUNIXが広まる中、**BSD**（Berkeley Software Distribution: バークレー版UNIX）は初めて本格的に[TCP/IP](../../../../network/_/chapters/communication_protocol.md#tcpip)による通信をサポートしたことで広く知られるようになった。\n\nUNIXは現在でも、IT業界や[サーバ](../../../_/chapters/computer.md#サーバ)の分野においては一定のシェアを有している。基本的には[CUI](./software.md#cui)による操作となっているが、[GUI](./software.md#gui)環境の導入も可能。\n\n"},{"term":"Linux","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"linux","content":"\n**Linux**は、Linux[カーネル](#カーネル)（[狭義のLinux](../../../linux/_/chapters/linux.md#狭義のlinux)）と、GNUが提供する[ソフトウェア](./software.md#ソフトウェア)群などから構成される[OS](#オペレーティングシステム)。[UNIX](#unix)を模倣して作られているが、全く別の[OS](#オペレーティングシステム)として設計されており、[オープンソースソフトウェア](./open_source_software.md#オープンソースソフトウェア)として提供されている。基本的には[CUI](./software.md#cui)による操作となっているが、[GUI](./software.md#gui)環境の導入も可能。\n\n"},{"term":"Android","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"android","content":"\n**Android**は、Googleが開発しているモバイル向けの[OS](#オペレーティングシステム)。[Linux](#linux)や[OSS](./open_source_software.md#オープンソースソフトウェア)をベースとしており、主にスマートフォンやタブレットなどの[タッチスクリーン](../../../hardware/_/chapters/io_unit.md#ポインティングデバイス)モバイルデバイス向けに設計されている。そのほか、IoTデバイスにも組み込まれることが多い。\n\n"},{"term":"iOS","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ios","content":"\n**iOS**は、Appleが開発しているモバイル用の[OS](#オペレーティングシステム)。スマートフォンのiPhoneシリーズに搭載されている[OS](#オペレーティングシステム)で、[Android](#android)と比べるとカスタマイズ性やコスト面では劣るものの、[アプリケーション](./software.md#応用ソフトウェア)のセキュリティが高いという利点がある。\n\n\n"},{"term":"カーネル","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"カーネル","content":"\n**カーネル**は、[OS](#オペレーティングシステム)の最も核となる機能を担う[ソフトウェア](./software.md#ソフトウェア)。個々の[アプリケーション](./software.md#応用ソフトウェア)からカーネルの機能を使用するには[システムコール](#システムコール)を利用する。\n\n"},{"term":"マイクロカーネル","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"マイクロカーネル","content":"\n**マイクロカーネル**は、[OS](#オペレーティングシステム)の機能の中でも最小限の機能だけを有する[カーネル](#カーネル)。他の機能はサービスとして実行する。\n\n"},{"term":"モノリシックカーネル","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"モノリシックカーネル","content":"\n**モノリシックカーネル**は、[OS](#オペレーティングシステム)の機能の多くを[カーネル](#カーネル)に含み、[カーネル](#カーネル)だけで豊富な機能を提供できるもの。\n\n"},{"term":"カーネルモード（スーパーバイザモード）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"カーネルモード","content":"\n**カーネルモード**（**スーパーバイザモード**）は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に対する高い権限を持って処理を実行するモード。[コンピュータ](../../../_/chapters/computer.md#コンピュータ)資源のあらゆる部分にアクセスが可能で、実行する命令も優先度が高くなっている。\n\n"},{"term":"ユーザモード","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ユーザモード","content":"\n**ユーザモード**は、[アプリケーションソフトウェア](./software.md#応用ソフトウェア)を実行するためのモードで、比較的権限が低く、[アプリケーション](./software.md#応用ソフトウェア)に必要な資源だけにアクセスできる。\n\n"},{"term":"カーネル空間","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"カーネル空間","content":"\n**カーネル空間**は、[OS](#オペレーティングシステム)の[カーネル](#カーネル)が使用する[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域。\n\n"},{"term":"ユーザ空間","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ユーザ空間","content":"\n**ユーザ空間**は、[アプリケーションソフトウェア](./software.md#応用ソフトウェア)が使用する[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域。[カーネル空間](#カーネル空間)とは独立しており、互いの[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域に直接アクセスすることはできない。\n\n\n"},{"term":"OSの起動","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"osの起動","content":"\n[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の電源を入れると、[CPU](../../../hardware/_/chapters/processor.md#cpu)は[マザーボード](../../../hardware/_/chapters/hardware.md#マザーボード)上の[ROM](../../../hardware/_/chapters/memory.md#rom)に記憶されている[BIOS](#bios)や[UEFI](#uefi)といった[ファームウェア](../../../_/chapters/computer.md#ファームウェア)インタフェース[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行する。その後、[ファームウェアインタフェース](#ファームウェアインタフェース)によって読み込まれた[ブートローダ](#ブートローダ)を用いて[オペレーティングシステム](#オペレーティングシステム)が起動される。\n\n"},{"term":"ファームウェアインタフェース","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ファームウェアインタフェース","content":"\n**ファームウェアインタフェース**は、[OS](#オペレーティングシステム)と[ファームウェア](../../../_/chapters/computer.md#ファームウェア)の間の通信仕様を定めた規格。\n\n"},{"term":"ブートローダ（ブートストラップ）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ブートローダ","content":"\n**ブートローダ**（**ブートストラップ**）は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に[OS](#オペレーティングシステム)を読み込ませるために用いる[プログラム](../../../../programming/_/chapters/programming.md#プログラム)のことで、[OS](#オペレーティングシステム)自身に組み込まれている。ブートローダとしては、[Linux](#linux)に付属している**LILO**(Linux Loader)や、[UNIX系OS](#unix)で使われる**GRUB**(Grand Unified Bootloader)といったものが代表的。\n\n"},{"term":"ネットワークブート","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ネットワークブート","content":"\n**ネットワークブート**は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上の他の[コンピュータ](../../../_/chapters/computer.md#コンピュータ)から[OS](#オペレーティングシステム)を取り込んで起動する仕組み。\n\n"},{"term":"マルチブート（デュアルブート、トリプルブート）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"マルチブート","content":"\n**マルチブート**（**デュアルブート**、**トリプルブート**...）は、1台の[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に複数の[OS](#オペレーティングシステム)を組み込む機能。[BIOS](#bios)の設定によって[ブートローダ](#ブートローダ)の起動優先順位を入れ替えたり、マルチブート対応の[ブートローダ](#ブートローダ)によって起動時にどの[OS](#オペレーティングシステム)を読み込むか選択したりする。\n\n"},{"term":"フラッシュブートローダ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"フラッシュブートローダ","content":"\n**フラッシュブートローダ**は、書き換え可能な[フラッシュメモリ](../../../hardware/_/chapters/memory.md#フラッシュメモリ)の[ブートローダ](#ブートローダ)領域に配置された[ブートローダ](#ブートローダ)。\n\n\n"},{"term":"ジョブ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ","content":"\n**ジョブ**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)によって実行される仕事の単位。ユーザから見た実行単位で、単一の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や連続的な一連の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)群を指す。1つの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の実行（ジョブ）はいくつかの[ジョブステップ](#ジョブステップ)に分解され、さらに[カーネル](#カーネル)が処理する単位である[プロセス](#プロセス)に分解される。\n\n"},{"term":"ジョブステップ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブステップ","content":"\n**ジョブステップ**は、[ジョブ](#ジョブ)を小さな単位の処理に分けたうちの、ひとつの処理。[ジョブ](#ジョブ)はいくつかのジョブステップから構成されており、ジョブステップを実行する際には、[カーネル](#カーネル)の処理単位である[プロセス](#プロセス)に分解されて実行される。\n\n"},{"term":"ジョブ管理システム（ジョブスケジューラ）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"リーダ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"イニシエータ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"ターミネータ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"ライタ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"スケジューリング","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ジョブ管理システム","content":"\n**ジョブ管理システム**（**ジョブスケジューラ**）は、複数の[ジョブ](#ジョブ)の起動や終了を制御したり、[ジョブ](#ジョブ)の実行・終了状態の監視などを行う[ソフトウェア](./software.md#ソフトウェア)。ジョブ管理システムは、以下の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)から構成される。\n\n- **リーダ**（[ジョブ](#ジョブ)読み取り）: [ジョブ](#ジョブ)の入力、入力[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)を作成する\n- **イニシエータ**（[ジョブ](#ジョブ)開始）: [待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)の[ジョブ](#ジョブ)の優先度を考慮して実行する[ジョブ](#ジョブ)を選択し、資源を割り当てる\n- **ターミネータ**（[ジョブ](#ジョブ)終了）: 実行終了した[ジョブステップ](#ジョブステップ)が使用していた資源を開放する\n- **ライタ**（[ジョブ](#ジョブ)書き出し）: 出力[ジョブ](#ジョブ)[待ち行列](../../../../basics/applied_mathematics/_/chapters/waiting_queue_theory.md#待ち行列)に登録されている[ジョブ](#ジョブ)から、出力するべき情報を決定する\n\n[ジョブ](#ジョブ)の実行順序を決定することを**スケジューリング**という。\n\n"},{"term":"JCL（ジョブ制御言語: Job Control Language）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"jcl","content":"\n**JCL**（**ジョブ制御言語**: Job Control Language）は、[ジョブステップ](#ジョブステップ)を指定するための言語。JCLによって[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の実行順序、[ジョブ](#ジョブ)の実行に必要な資源などを記述する。\n\n"},{"term":"ジョブステップ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"jcl","content":"\n**JCL**（**ジョブ制御言語**: Job Control Language）は、[ジョブステップ](#ジョブステップ)を指定するための言語。JCLによって[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の実行順序、[ジョブ](#ジョブ)の実行に必要な資源などを記述する。\n\n"},{"term":"マスタスケジューラ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"マスタスケジューラ","content":"\n**マスタスケジューラ**は、オペレータからの指示を解釈して[ジョブスケジューラ](#ジョブ管理システム)へ指示を出したり、メッセージを返す役割を担うスケジューラで、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上に常駐する。\n\n"},{"term":"スプーリング（スプール）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スプーリング","content":"\n**スプーリング**（**スプール**）は、[プリンタ](../../../hardware/_/chapters/io_unit.md#プリンタ)などの低速の[入出力装置](../../../hardware/_/chapters/io_unit.md)に[ジョブ](#ジョブ)の結果を出力する場合に、一時的にデータを書き込んでおくこと、あるいはその領域。[CPU](../../../hardware/_/chapters/processor.md#cpu)を素早く解放し、[出力装置](../../../hardware/_/chapters/io_unit.md#出力装置)がデータを受け付ける準備ができてから処理を行うことで、資源の無駄をなくす。\n\n\n"},{"term":"プロセス（タスク）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"プロセス","content":"\n**プロセス**（**タスク**）は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)から見た仕事の単位（[OS](#オペレーティングシステム)の元で実行される内部処理の単位）。[ジョブ](#ジョブ)（[ジョブステップ](#ジョブステップ)）を[CPU](../../../hardware/_/chapters/processor.md#cpu)が実行するのに適した単位に分割したもの。\n\n"},{"term":"タスク管理システム（タスクスケジューラ）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"タスク管理システム","content":"\n**タスク管理システム**（**タスクスケジューラ**）は、複数の[タスク](#プロセス)の実行順を決定する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n"},{"term":"実行可能状態","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"実行可能状態","content":"\n**実行可能状態**は、[プロセス](#プロセス)が実行可能であるが、他の優先度の高い[プロセス](#プロセス)が実行中であるため待機している状態。[プロセス](#プロセス)は生成されるとまずとなる。そこで[CPU](../../../hardware/_/chapters/processor.md#cpu)に空きができると[実行状態](#実行状態)に移り、処理を実行する。\n\n"},{"term":"実行状態","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"実行状態","content":"\n**実行状態**は、[プロセス](#プロセス)が実行されている状態。[実行可能状態](#実行可能状態)の[プロセス](#プロセス)のうち最も優先度が高い[プロセス](#プロセス)がこの状態になる。[プロセス](#プロセス)の実行が完了するとその[プロセス](#プロセス)は消滅する。\n\n"},{"term":"待ち状態","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"待ち状態","content":"\n**待ち状態**は、入出力待ちなどにより、[CPU](../../../hardware/_/chapters/processor.md#cpu)の使用権を与えられても使用できない待ちの状態。[プロセス](#プロセス)の実行中に入出力が必要な処理などの[CPU](../../../hardware/_/chapters/processor.md#cpu)以外を使用する処理が発生すると、待ち状態に移る。入出力などの処理が完了すると、待ち状態から[実行可能状態](#実行可能状態)に移行する。\n\n"},{"term":"ゾンビ状態","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ゾンビ状態","content":"\n**ゾンビ状態**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上では処理が終了しているにも関わらず、[オペレーティングシステム](#オペレーティングシステム)に残存している状態。[コンピュータ](../../../_/chapters/computer.md#コンピュータ)資源を専有したまま停止しているため、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の動作に悪影響を及ぼす。ゾンビ状態にある[プロセス](#プロセス)を**ゾンビプロセス**という。\n\n"},{"term":"タイムクォンタム（タイムスライス）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"タイムクォンタム","content":"\n**タイムクォンタム**（**タイムスライス**）は、ひとつの[プロセス](#プロセス)が[CPU](../../../hardware/_/chapters/processor.md#cpu)を利用できる時間単位。[実行状態](#実行状態)の[プロセス](#プロセス)が与えられたタイムクォンタムを使い切ると、[実行可能状態](#実行可能状態)に遷移する。繰り返しタイムクォンタムに達した[プロセス](#プロセス)は実行の優先度を下げられる。\n\n"},{"term":"プリエンプション","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"プリエンプション","content":"\n**プリエンプション**は、実行中の[プロセス](#プロセス)を強制的に一時中断し、他の[プロセス](#プロセス)を[実行状態](#実行状態)に遷移させる処理。優先度の高い[プロセス](#プロセス)が生成された場合や、[割込み](../../../hardware/_/chapters/processor.md#割込み)が起こった場合に発生する。\n\n"},{"term":"コンテキストスイッチ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"コンテキストスイッチ","content":"\n**コンテキストスイッチ**は、[CPU](../../../hardware/_/chapters/processor.md#cpu)が複数の[プロセス](#プロセス)を切り替えながら実行する際に、その時点での[プロセス](#プロセス)の実行状態（[レジスタ](../../../hardware/_/chapters/processor.md#レジスタ)の値や[プログラムカウンタ](../../../hardware/_/chapters/processor.md#プログラムカウンタ)など）を保存して、別の[プロセス](#プロセス)の実行状態を復元する処理。\n\n"},{"term":"到着順方式（ノンプリエンプション方式、FIFO）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"到着順方式","content":"\n**到着順方式**（**ノンプリエンプション方式**）は、[プロセス](#プロセス)を到着順で処理する方式。**FIFO**(First In First Out)とも呼ばれる。\n\n"},{"term":"処理時間順方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"処理時間順方式","content":"\n**処理時間方式**は、[プロセス](#プロセス)の処理時間が短いものから順に処理を行う方式。\n\n"},{"term":"優先度順方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"優先度順方式","content":"\n**優先度順方式**は、[プロセス](#プロセス)を優先度順で処理する方式。\n\n"},{"term":"ラウンドロビン方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ラウンドロビン方式","content":"\n**ラウンドロビン方式**は、ひとつひとつの[プロセス](#プロセス)に同じ[タイムクォンタム](#タイムクォンタム)を割り当て、一定時間ごとに順番に処理を回していく方式。\n\n"},{"term":"プリエンプション方式（プリエンプティブ方式）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"プリエンプション方式","content":"\n**プリエンプション方式**（**プリエンプティブ方式**）は、[タスク](#プロセス)に優先度を付け、優先度の高い[タスク](#プロセス)が[実行可能状態](#プロセスの状態)になると[プリエンプション](#プロセスの状態)を発生させる方式。\n\n"},{"term":"多段フィードバック待ち行列","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"多段フィードバック待ち行列","content":"\n**多段フィードバック待ち行列**は、複数の優先度待ち行列を持ち、高い優先度の待ち行列から順次処理していく方式。低い優先度で長時間待っている[タスク](#プロセス)は優先度を上げ、一度実行した[タスク](#プロセス)は優先度を下げるといったフィードバック調整を行う。\n\n"},{"term":"イベントドリブンプリエンプション方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"イベントドリブンプリエンプション方式","content":"\n**イベントドリブンプリエンプション方式**は、[割込み](../../../hardware/_/chapters/processor.md#割込み)によって[プロセス](#プロセス)の切り替えを行うイベントドリブン方式と、優先度の高い[プロセス](#プロセス)を実行させる[プリエンプション方式](#プリエンプション方式)を組み合わせた方式。**イベント**は、[プロセス](#プロセス)の状態を、入出力の終了や外部からのコマンド入力などで[割込み](../../../hardware/_/chapters/processor.md#割込み)により通知する仕組み。\n\n"},{"term":"イベント","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"イベントドリブンプリエンプション方式","content":"\n**イベントドリブンプリエンプション方式**は、[割込み](../../../hardware/_/chapters/processor.md#割込み)によって[プロセス](#プロセス)の切り替えを行うイベントドリブン方式と、優先度の高い[プロセス](#プロセス)を実行させる[プリエンプション方式](#プリエンプション方式)を組み合わせた方式。**イベント**は、[プロセス](#プロセス)の状態を、入出力の終了や外部からのコマンド入力などで[割込み](../../../hardware/_/chapters/processor.md#割込み)により通知する仕組み。\n\n"},{"term":"ディスパッチャ（タスク指名ルーチン）","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ディスパッチャ","content":"\n**ディスパッチャ**（**タスク指名ルーチン**）は、[実行可能状態](#プロセスの状態)の[プロセス](#プロセス)を調べ、最も優先度の高い[プロセス](#プロセス)を[実行状態](#プロセスの状態)にしたり、[実行状態](#プロセスの状態)の[プロセス](#プロセス)を中断したりする[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。\n\n"},{"term":"スレッド","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スレッド","content":"\n**スレッド**は、[プロセス](#プロセス)中で生成された子[プロセス](#プロセス)。\n\n\n"},{"term":"記憶管理","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"記憶管理","content":"\n**記憶管理**は、[主記憶](../../../hardware/_/chapters/hardware.md#主記憶装置)に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を効率的に配置し、[主記憶](../../../hardware/_/chapters/hardware.md#主記憶装置)を有効に利用するための機能。\n\n"},{"term":"ロード","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ロード","content":"\n**ロード**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行するために、[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)から[主記憶装置](../../../hardware/_/chapters/hardware.md#主記憶装置)に読み込む処理。\n\n"},{"term":"オーバレイ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"オーバレイ","content":"\n**オーバレイ**は、あらかじめ[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を分けて[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)に格納しておき、必要な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)だけを[主記憶装置](../../../hardware/_/chapters/hardware.md#主記憶装置)に[ロード](#ロード)する方式。\n\n"},{"term":"スワッピング","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スワッピング","content":"\n**スワッピング**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容を[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)のスワップファイルに書き出して、他の[プロセス](#プロセス)が[メモリ](../../../hardware/_/chapters/memory.md#メモリ)を使えるように解放する方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)からスワップに取り出すことを**スワップアウト**、スワップから[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**スワップイン**という。\n\n\n"},{"term":"スワップアウト","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スワッピング","content":"\n**スワッピング**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容を[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)のスワップファイルに書き出して、他の[プロセス](#プロセス)が[メモリ](../../../hardware/_/chapters/memory.md#メモリ)を使えるように解放する方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)からスワップに取り出すことを**スワップアウト**、スワップから[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**スワップイン**という。\n\n\n"},{"term":"スワップイン","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スワッピング","content":"\n**スワッピング**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容を[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)のスワップファイルに書き出して、他の[プロセス](#プロセス)が[メモリ](../../../hardware/_/chapters/memory.md#メモリ)を使えるように解放する方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)からスワップに取り出すことを**スワップアウト**、スワップから[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**スワップイン**という。\n\n\n"},{"term":"仮想記憶管理","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"仮想記憶管理","content":"\n"},{"term":"仮想記憶","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"仮想記憶","content":"\n"},{"term":"ページング方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"ページ","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"ページアウト","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"ページイン","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"ページフォールト","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページフォールト","content":"\n**ページフォールト**は、[ページング方式](#ページング方式)において、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上に必要な[ページ](#ページング方式)がない状態。\n\n"},{"term":"スラッシング","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"スラッシング","content":"\n**スラッシング**は、[ページフォールト](#ページフォールト)が頻繁に発生することで、[ページイン](#ページング方式)と[ページアウト](#ページング方式)が繰り返される現象。スラッシングが発生すると、システムの応答速度が著しく低下する。\n\n"},{"term":"デマンドページング方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"プリページング方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ページング方式","content":"\n**ページング方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を固定長の**ページ**という単位に分けて、ページごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶](#仮想記憶)領域に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶)に取り出すことを**ページアウト**、[仮想記憶](#仮想記憶)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ページイン**という。\n\n"},{"term":"セグメント方式","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"セグメント方式","content":"\n**セグメント方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を可変長の**セグメント**という単位に分けて、セグメントごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶領域](#仮想記憶管理)に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶管理)に取り出すことを**ロールアウト**、[仮想記憶](#仮想記憶管理)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ロールイン**という。\n\n\n"},{"term":"セグメント","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"セグメント方式","content":"\n**セグメント方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を可変長の**セグメント**という単位に分けて、セグメントごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶領域](#仮想記憶管理)に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶管理)に取り出すことを**ロールアウト**、[仮想記憶](#仮想記憶管理)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ロールイン**という。\n\n\n"},{"term":"ロールアウト","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"セグメント方式","content":"\n**セグメント方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を可変長の**セグメント**という単位に分けて、セグメントごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶領域](#仮想記憶管理)に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶管理)に取り出すことを**ロールアウト**、[仮想記憶](#仮想記憶管理)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ロールイン**という。\n\n\n"},{"term":"ロールイン","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"セグメント方式","content":"\n**セグメント方式**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を可変長の**セグメント**という単位に分けて、セグメントごとに[補助記憶装置](../../../hardware/_/chapters/auxiliary_memory_unit.md#補助記憶装置)の[仮想記憶領域](#仮想記憶管理)に取り出す方式。[メモリ](../../../hardware/_/chapters/memory.md#メモリ)から[仮想記憶](#仮想記憶管理)に取り出すことを**ロールアウト**、[仮想記憶](#仮想記憶管理)から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に戻すことを**ロールイン**という。\n\n\n"},{"term":"ミドルウェア","link":"./note/ja/./computer/software/_/chapters/operating_system.md","flagment":"ミドルウェア","content":""},{"term":"ファイル","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ファイル","content":"\n**ファイル**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)におけるデータの管理単位のひとつで、[ストレージ](../../../hardware/_/chapters/hardware.md#記憶装置)装置などにデータを記録する際にユーザや[OS](./operating_system.md#オペレーティングシステム)から見た最小の記録単位となる。ユーザが[コンピュータ](../../../_/chapters/computer.md#コンピュータ)を用いて[ストレージ](../../../hardware/_/chapters/hardware.md#記憶装置)にデータを保存、読み込み、移動、削除をする際にひとつのまとまりとしてデータの集合を表し、[ファイルシステム](#ファイルシステム)によって管理される。\n\n"},{"term":"レコード","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"レコード","content":"\n**レコード**は、[ファイル](#ファイル)を構成する論理的な単位。\n\n"},{"term":"フィールド","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"フィールド","content":"\n**フィールド**は、[レコード](#レコード)内の各項目。\n\n"},{"term":"実行ファイル（実行可能ファイル）","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"実行ファイル","content":"\n**実行ファイル**（**実行可能ファイル**）は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)がそのまま解釈して実行することができる[ファイル](#ファイル)。[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)によって書かれた[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を[コンパイル](../../../../programming/_/chapters/programming.md#コンパイル)した結果得られる[ファイル](#ファイル)で、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)にインストールされる[アプリケーション](./software.md#応用ソフトウェア)も実行可能ファイルとして提供される。[Windows](./operating_system.md#windows)では実行ファイルの[拡張子](#拡張子)として `.exe` が用いられる。\n\n"},{"term":"データファイル","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"データファイル","content":"\n**データファイル**は、実行中の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)によって解釈されることで[コンピュータ](../../../_/chapters/computer.md#コンピュータ)が処理できるようになる[ファイル](#ファイル)。[テキストファイル](#テキストファイル)や画像ファイル、サウンドファイルなどといった、[アプリケーション](./software.md#応用ソフトウェア)により処理される[ファイル](#ファイル)などはデータファイルである。\n\n"},{"term":"バイナリファイル","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"バイナリファイル","content":"\n**バイナリファイル**は、データを生の[バイト](../../../../basics/_/chapters/computer_and_number.md#バイト)列として扱う[ファイル](#ファイル)。画像ファイルやサウンドファイルなどはバイナリファイルとして保存される。\n\n"},{"term":"ファイルフォーマット","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ファイルフォーマット","content":"\n**ファイルフォーマット**は、[データファイル](#データファイル)を保存する際の形式。[アプリケーション](./software.md#応用ソフトウェア)ごとに独自の形式を定義されたものや、複数の[アプリケーション](./software.md#応用ソフトウェア)に対応できるような一般化されたファイルフォーマットがある。画像ファイルであればJPEGやPNG、GIFといったファイルフォーマットが一般的。\n\n"},{"term":"拡張子","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"拡張子","content":"\n**拡張子**は、[ファイル](#ファイル)がどのような[ファイルフォーマット](#ファイルフォーマット)で記述されているのかを[OS](./operating_system.md#オペレーティングシステム)やユーザが識別するために、[ファイル](#ファイル)名の末尾に付与される文字列。[ファイル](#ファイル)名本体とは `.` で区切られる（例えば、 `test.txt` であれば `test` が[ファイル](#ファイル)名本体で `.txt` が拡張子となる）。拡張子は、[ファイルフォーマット](#ファイルフォーマット)を識別するための判断材料とはなるが、本来の[ファイルフォーマット](#ファイルフォーマット)とは異なる形式を指す拡張子を付与することもできる。\n\n"},{"term":"ボリューム","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ボリューム","content":"\n**ボリューム**は、[ファイル](#ファイル)を格納している装置のことで、[Windows](./operating_system.md#windows)では**ドライブ**と呼ばれる。\n\n\n"},{"term":"ドライブ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ボリューム","content":"\n**ボリューム**は、[ファイル](#ファイル)を格納している装置のことで、[Windows](./operating_system.md#windows)では**ドライブ**と呼ばれる。\n\n\n"},{"term":"ディレクトリ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ディレクトリ","content":"\n**ディレクトリ**は、[ファイル](#ファイル)をまとめて管理するための仕組みで、ディレクトリの下にさらにディレクトリを作るといった[ツリー構造](#ツリー構造)にすることができる。[Linux](./operating_system.md#linux)ではディレクトリは[ファイル](#ファイル)の一種として扱われる。また、[Windows](./operating_system.md#windows)や[macOS](./operating_system.md#macos)においてはディレクトリにあたる機能のことを**フォルダ**と呼ぶ。\n\n"},{"term":"フォルダ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ディレクトリ","content":"\n**ディレクトリ**は、[ファイル](#ファイル)をまとめて管理するための仕組みで、ディレクトリの下にさらにディレクトリを作るといった[ツリー構造](#ツリー構造)にすることができる。[Linux](./operating_system.md#linux)ではディレクトリは[ファイル](#ファイル)の一種として扱われる。また、[Windows](./operating_system.md#windows)や[macOS](./operating_system.md#macos)においてはディレクトリにあたる機能のことを**フォルダ**と呼ぶ。\n\n"},{"term":"ツリー構造（階層構造）","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ツリー構造","content":"\n**ツリー構造**（**階層構造**）は、データを管理するための構造のひとつで、[ファイル](#ファイル)を[ディレクトリ](#ディレクトリ)により分類し、[ディレクトリ](#ディレクトリ)同士に親子関係をもたせた構造。\n\n"},{"term":"パス","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"パス","content":"\n**パス**は、[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)が[ディレクトリ](#ディレクトリ)階層の中のどの位置に存在しているかを指し示す情報。[ディレクトリ](#ディレクトリ)と[ディレクトリ](#ディレクトリ)の区切りを `/` （**デリミタ**、[Windows](./operating_system.md#windows)では `\\` ）で表す。同じ[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上で同一のパスを持つ[ファイル](#ファイル)は存在しない。\n\n"},{"term":"デリミタ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"パス","content":"\n**パス**は、[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)が[ディレクトリ](#ディレクトリ)階層の中のどの位置に存在しているかを指し示す情報。[ディレクトリ](#ディレクトリ)と[ディレクトリ](#ディレクトリ)の区切りを `/` （**デリミタ**、[Windows](./operating_system.md#windows)では `\\` ）で表す。同じ[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上で同一のパスを持つ[ファイル](#ファイル)は存在しない。\n\n"},{"term":"絶対パス","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"絶対パス","content":"\n**絶対パス**は、ある[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)の、[ルートディレクトリ](#ルートディレクトリ)からの[パス](#パス)。 [ルートディレクトリ](#ルートディレクトリ)を表す `/` から始まる[パス](#パス)で、 `/var/www/html/index.html` や `/home/user/document` のように表される。絶対パスは、[カレントディレクトリ](#カレントディレクトリ)に関わらず常に同じ[パス](#パス)で表すことができるという特徴がある。\n\n"},{"term":"相対パス","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"相対パス","content":"\n**相対パス**は、[カレントディレクトリ](#カレントディレクトリ)やある[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)の[パス](#パス)を基準としたときの、対象の[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)の[パス](#パス)。[絶対パス](#絶対パス)に比べて短く記述できる場合が多く、[ディレクトリ](#ディレクトリ)構造が変わらなければ別のシステムなどにおいても同じ[パス](#パス)を用いることができるという特徴がある。\n\n"},{"term":"ルートディレクトリ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ルートディレクトリ","content":"\n**ルートディレクトリ**は、[ディレクトリ](#ディレクトリ)階層の最上位に位置する[ディレクトリ](#ディレクトリ)。ルートディレクトリのパスは `/` で表される。[サーバ](../../../_/chapters/computer.md#サーバ)として外部に公開する[ディレクトリ](#ディレクトリ)の最上位は**ドキュメントルート**（**仮想ルートディレクトリ**）と呼ばれる。\n\n"},{"term":"ドキュメントルート（仮想ルートディレクトリ）","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ドキュメントルート","content":"\n**ドキュメントルート**（**仮想ルートディレクトリ**）は、システムの最上位の[ディレクトリ](#ディレクトリ)を仮想的な[ルートディレクトリ](#ルートディレクトリ)とすることで、[パス](#パス)の記述を簡略化したり、[サーバ](../../../_/chapters/computer.md#サーバ)として外部に公開する[ディレクトリ](#ディレクトリ)を限定するために用いられる。\n\n"},{"term":"カレントディレクトリ（ワーキングディレクトリ）","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"カレントディレクトリ","content":"\n**カレントディレクトリ**（**ワーキングディレクトリ**）は、実行中の[プロセス](#プロセス)が現在位置として指し示している[ディレクトリ](#ディレクトリ)。カレントディレクトリのパスは `.` で表される。\n\n"},{"term":"ホームディレクトリ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ホームディレクトリ","content":"\n**ホームディレクトリ**は、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)のユーザアカウントごとに割り当てられる個別の[ディレクトリ](#ディレクトリ)。[Linux](./operating_system.md#linux)では `/home/<username>` 、[Windows](./operating_system.md#windows)では `C:\\Users\\<username>` がホームディレクトリになる。ホームディレクトリのパスは `~` で表される。\n\n"},{"term":"親ディレクトリ","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"親ディレクトリ","content":"\n**親ディレクトリ**は、ある[ファイル](#ファイル)や[ディレクトリ](#ディレクトリ)から見てひとつ上の階層にある[ディレクトリ](#ディレクトリ)。親ディレクトリの[パス](#パス)は `..` で表され、親ディレクトリの更に親ディレクトリは `../..` のように表される。\n\n"},{"term":"サブディレクトリ（子ディレクトリ）","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"サブディレクトリ","content":"\n**サブディレクトリ**（**子ディレクトリ**）は、ある[ディレクトリ](#ディレクトリ)の中に作られた[ディレクトリ](#ディレクトリ)。\n\n\n"},{"term":"ファイルシステム","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"ファイルシステム","content":"\n**ファイルシステム**は、[ファイル](#ファイル)が持つデータとその[ファイル](#ファイル)の名前やメタデータ（作成日や更新日、作成者といった属性など）を効率よく管理するために[OS](./operating_system.md#オペレーティングシステム)が提供する機能。利用するファイルシステムの種類によって[ファイル](#ファイル)にアクセスするときの速度や安全性が異なる。[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)上でデータが格納されている場所の管理も行っている。\n\n"},{"term":"パーティション","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"パーティション","content":"\n**パーティション**は、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)を仮想的に分割した領域のことで、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)を複数のパーティションに分ける操作を**パーティショニング**という。パーティションを分けることで、複数の[ファイルシステム](#ファイルシステム)を1つの[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上に混在させたり、通常時に利用する[ファイルシステム](#ファイルシステム)とバックアップ用の領域を分けたりすることができる。\n\n"},{"term":"パーティショニング","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"パーティション","content":"\n**パーティション**は、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)を仮想的に分割した領域のことで、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)を複数のパーティションに分ける操作を**パーティショニング**という。パーティションを分けることで、複数の[ファイルシステム](#ファイルシステム)を1つの[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上に混在させたり、通常時に利用する[ファイルシステム](#ファイルシステム)とバックアップ用の領域を分けたりすることができる。\n\n"},{"term":"マウント","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"マウント","content":"\n**マウント**は、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)の[パーティション](#パーティション)上に作成された[ファイルシステム](#ファイルシステム)を、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上のどこかの[ディレクトリ](#ディレクトリ)に接続する操作。\n\nマウントされていない[ファイルシステム](#ファイルシステム)には[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上からアクセスすることはできず、マウントすることで読み書き可能となる。[ファイルシステム](#ファイルシステム)をマウントする[ディレクトリ](#ディレクトリ)のことを**マウントポイント**という。\n\n"},{"term":"マウントポイント","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"マウント","content":"\n**マウント**は、[記憶装置](../../../hardware/_/chapters/hardware.md#記憶装置)の[パーティション](#パーティション)上に作成された[ファイルシステム](#ファイルシステム)を、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上のどこかの[ディレクトリ](#ディレクトリ)に接続する操作。\n\nマウントされていない[ファイルシステム](#ファイルシステム)には[コンピュータ](../../../_/chapters/computer.md#コンピュータ)上からアクセスすることはできず、マウントすることで読み書き可能となる。[ファイルシステム](#ファイルシステム)をマウントする[ディレクトリ](#ディレクトリ)のことを**マウントポイント**という。\n\n"},{"term":"アンマウント","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"アンマウント","content":"\n**アンマウント**は、[マウント](#マウント)された[ファイルシステム](#ファイルシステム)を[ディレクトリ](#ディレクトリ)から切断する操作。\n\n"},{"term":"exFAT","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"exfat","content":"\n**exFAT**は、[FAT](#fat)の一種で、[USB](../../../hardware/_/chapters/bus.md#usb)[メモリ](../../../hardware/_/chapters/memory.md#メモリ)や[SDカード](../../../hardware/_/chapters/auxiliary_memory_unit.md#sdカード)などのフラッシュドライブ用に開発された[ファイルシステム](#ファイルシステム)。[Windows](./operating_system.md#windows)と[macOS](./operating_system.md#macos)の両方に互換性があるのが特徴。内蔵[ハードディスク](../../../hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)には対応していない。\n\n"},{"term":"HFS+","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"hfs","content":"\n**HFS**(Hierarchical File System)は、[macOS](./operating_system.md#macos)で使用されている[ファイルシステム](#ファイルシステム)。**HFS+** は、1つあたりの[ファイル](#ファイル)の最大容量が8EBと大容量である特徴がある。現在、Apple製品の[ファイルシステム](#ファイルシステム)は[APFS](#apfs)へ移行されている。\n\n"},{"term":"APFS","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"apfs","content":"\n**APFS**は、Apple社が開発する比較的新しい[ファイルシステム](#ファイルシステム)。[ファイル](#ファイル)のコピー速度の高速化、レスポンスの向上、情報を守る高度な暗号化機能が搭載されているのが特徴。\n\n"},{"term":"XFS","link":"./note/ja/./computer/software/_/chapters/file_system.md","flagment":"xfs","content":"\n**XFS**は、主に[Linux](./operating_system.md#linux)で使用されている歴史の古い[ファイルシステム](#ファイルシステム)。[ファイル](#ファイル)変更の記録が残るジャーナリングシステムに対応しており、セキュリティが強固であるという特徴がある。\n\n"},{"term":"パッケージ","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"パッケージ","content":"\n**パッケージ**は、[ソフトウェア](./software.md#ソフトウェア)を配布可能な形にしたものや、関連する機能を持つ[プログラム](../../../../programming/_/chapters/programming.md#プログラム)をひとつにまとめて再利用しやすくしたものを指す用語。\n\n"},{"term":"スイート","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"スイート","content":"\n**スイート**は、単体で機能を提供されているものを組み合わせた[パッケージ](#パッケージ)。例えば、[インターネット](../../../../network/_/chapters/network.md#インターネット)は複数の通信規約の実装（[プロトコル](../../../../network/_/chapters/communication_protocol.md#プロトコル)）からなっており、これらを[インターネットプロトコルスイート](../../../../network/_/chapters/communication_protocol.md#プロトコルスイート)と呼ぶ。\n\n"},{"term":"依存関係","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"依存関係","content":"\n**依存関係**は、[パッケージ](#パッケージ)が別の[パッケージ](#パッケージ)を必要としていたり、必要とする[パッケージ](#パッケージ)の[バージョン](#バージョン)が限定されていたりといった、[パッケージ](#パッケージ)間の関係性。依存する[パッケージ](#パッケージ)が多くなると依存関係も複雑化し、必要な[パッケージ](#パッケージ)の[バージョン](#バージョン)が異なると[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が動かないといったこともある。さらに、複数の[パッケージ](#パッケージ)が、ひとつの[パッケージ](#パッケージ)の別の[バージョン](#バージョン)に依存している、といったことも起こりうる。このように依存関係をすべて把握して管理することが困難な場合もあるため、[パッケージマネージャ](#パッケージマネージャ)のような依存関係を解決できるツールを利用すると良い。\n\n"},{"term":"パッケージマネージャ","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"パッケージマネージャ","content":"\n**パッケージマネージャ**は、[パッケージ](#パッケージ)間の[依存関係](#依存関係)や[バージョン](#バージョン)を管理したり、[パッケージ](#パッケージ)の導入の補助を行ったりするツール。パッケージマネージャの導入により、[プログラマ](../../../../programming/_/chapters/programming.md#プログラマ)を[パッケージ](#パッケージ)の[依存関係](#依存関係)管理の責任から解放し、より[ビジネスロジック](../../../../system/_/chapters/system.md#ビジネスロジック)の実装に集中させることができる。\n\n[ソフトウェア](./software.md#ソフトウェア)開発の際に全ての機能を1から実装しようとすると非常にコストが大きいため、様々な[パッケージ](#パッケージ)を組み合わせることはよくあり、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)ごとに様々なパッケージマネージャが提供されている。\n\n\n"},{"term":"バージョン","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"パッチバージョン","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"マイナーバージョン","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"メジャーバージョン","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"正式版","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"アルファ版","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"ベータ版","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"バージョン","content":"\n**バージョン**は、同じ名前の[ソフトウェア](./software.md#ソフトウェア)の新旧を区別する番号などを指す用語。[ソフトウェア](./software.md#ソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多いため、どのバージョンの[ソフトウェア](./software.md#ソフトウェア)を使用しているかを識別できることは非常に重要である。\n\nバージョンのつけ方は開発チームによって様々であるが、一般的には3つの数字を用いて `x.y.z` のように表記することが多い。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](../../../../programming/_/chapters/programming.md#バグ)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保った[ソフトウェア](./software.md#ソフトウェア)の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、[後方互換性](#後方互換性)を保てないようなシステム自体の大規模なアップデートがあった場合にカウントされる。\n\n他にも**正式版**の[ソフトウェア](./software.md#ソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部機能が足りておらず動作が不安定である**ベータ版**が試験的に公開される場合もある。\n\n"},{"term":"後方互換性","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"後方互換性","content":"\n**後方互換性**は、ある[バージョン](#バージョン)の[ソフトウェア](./software.md#ソフトウェア)が、以前の[バージョン](#バージョン)の機能を継続的に利用できる性質。後方互換性を失った[ソフトウェア](./software.md#ソフトウェア)は[依存関係](#依存関係)を大きく侵害してしまう恐れがあるため、注意が必要となる。\n\n\n"},{"term":"コンポーネント","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"コンポーネント","content":"\n**コンポーネント**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の構成要素を指す用語で、他の構成要素と組み合わせることで機能するもの。[モジュール](#モジュール)よりも広義の意味で使用されることが多く、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)だけではなく、[ファイル](./file_system.md#ファイル)や物理的な構成要素に対しても用いられる。\n\n\n"},{"term":"モジュール","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"モジュール","content":"\n**モジュール**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の中で何かひとまとまりの機能を持った部品（特に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)）を指す用語。他の構成要素と組み合わせることで機能する。\n\n\n"},{"term":"ライブラリ","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"ライブラリ","content":"\n**ライブラリ**は、汎用的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を再利用しやすい形でまとめたもの。[モジュール](#モジュール)などを組み合わせることで、複数のシステムで必要となる汎用的な機能を繰り返し利用できるようにする目的がある。ライブラリを適切に活用すると、システム開発のコストを大幅に削減できる。\n\n"},{"term":"標準ライブラリ","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"標準ライブラリ","content":"\n**標準ライブラリ**は、各[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の仕様としてあらかじめ用意されている[ライブラリ](#ライブラリ)。[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の更新に合わせて標準ライブラリ自体も更新される場合が多いため、[サードパーティ製ライブラリ](#サードパーティ製ライブラリ)に比べて信頼性が高い。一方で、汎用的な機能のみを提供していることが一般的であるため、要件によっては標準ライブラリだけでは機能の実現が難しい場合もある。また、標準ライブラリの変更は影響範囲が大きいため、より性能の高い[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)への置き換えや新しい機能の導入が遅くなり、[サードパーティ製ライブラリ](#サードパーティ製ライブラリ)に比べてパフォーマンスが下がることもある。\n\n"},{"term":"サードパーティ製ライブラリ","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"サードパーティ製ライブラリ","content":"\n**サードパーティ製ライブラリ**は、[標準ライブラリ](#標準ライブラリ)や自分が属する開発チームが実装した[ライブラリ](#ライブラリ)以外の、第三者にって提供された[ライブラリ](#ライブラリ)の総称。あらゆる[プログラマ](../../../../programming/_/chapters/programming.md#プログラマ)が自由に開発・公開できるため、様々な機能を持つものや限定的な用途にも対応した[ライブラリ](#ライブラリ)などが存在する。\n\n[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)自体の更新により[ライブラリ](#ライブラリ)が動作しなくなったり（サポートの終了）、そもそも正しく動作しなかったり、要件を満たす機能がそろっていなかったりといったリスクもある。また、利用する[ライブラリ](#ライブラリ)が増加すると[依存関係](#依存関係)が複雑化し、システムのメンテナンスが困難になる場合もあるため注意が必要。[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)の学習と併せて[ライブラリ](#ライブラリ)の機能に対する理解が必要となるため、学習コストがかかるといったデメリットもある。独自実装したときのコストが学習コストを大きく上回る場合は利用を検討するなど、開発チーム内でルールを設けると良い。\n\nサードパーティ製の[ライブラリ](#ライブラリ)を用いる場合には、[ライセンス](./open_source_software.md#ライセンス)にも注意する必要がある。\n\n\n"},{"term":"プラグイン","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"プラグイン","content":"\n**プラグイン**は、既存の[ソフトウェア](./software.md#ソフトウェア)に対して拡張的な機能を提供する[モジュール](#モジュール)。[ライブラリ](#ライブラリ)はプログラムの再利用を目的としているが、プラグインは既にある機能の単なる拡張を目的としている。\n\n\n"},{"term":"フレームワーク","link":"./note/ja/./computer/software/_/chapters/package.md","flagment":"フレームワーク","content":"\n**フレームワーク**は、[アプリケーション](./software.md#応用ソフトウェア)を構成するための骨組みとなる[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。システム開発を快適にする様々な機能やツールをそろえており、大幅に開発コストを削減できる。フレームワークは、アーキテクチャの実装をベースとして、各種[ライブラリ](#ライブラリ)を組み合わせるなどして作られているものが多い。フレームワークを利用することで、[プログラマ](../../../../programming/_/chapters/programming.md#プログラマ)は[ビジネスロジック](../../../../system/_/chapters/system.md#ビジネスロジック)に集中して[プログラミング](../../../../programming/_/chapters/programming.md#プログラミング)ができる。\n"},{"term":"コントリビュータ","link":"./note/ja/./computer/software/_/chapters/open_source_software.md","flagment":"コントリビュータ","content":"\n**コントリビュータ**は、[OSS](#オープンソースソフトウェア)の開発やメンテナンスなど行い、プロジェクトに貢献する人や団体。\n\n\n"},{"term":"ライセンス","link":"./note/ja/./computer/software/_/chapters/open_source_software.md","flagment":"ライセンス","content":"\n**ライセンス**は、[ソフトウェア](./software.md#ソフトウェア)の使用やコピー、改変、再頒布（販売を含む）に関する一定の条件。\n\n"},{"term":"デュアルライセンス","link":"./note/ja/./computer/software/_/chapters/open_source_software.md","flagment":"デュアルライセンス","content":"\n**デュアルライセンス**は、ひとつの[ソフトウェア](./software.md#ソフトウェア)を複数の[ライセンス](#ライセンス)で配布する形態。利用者はどの[ライセンス](#ライセンス)を適用するか選択することができる。\n\n"},{"term":"コピーレフト","link":"./note/ja/./computer/software/_/chapters/open_source_software.md","flagment":"コピーレフト","content":"\n**コピーレフト**は、著作権保有者が著作権を保持したまま、著作物の利用、コピー、再頒布、改変を制限しないという考え方。コピーレフトの[ソフトウェア](./software.md#ソフトウェア)を改変した場合、この考えをそのまま適用する必要がある。\n\n"},{"term":"GPL汚染","link":"./note/ja/./computer/software/_/chapters/open_source_software.md","flagment":"gpl","content":"\n**GPL**(General Public License)は、GNUで採用されているフリーソフトのための[ライセンス](#ライセンス)。[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)の公開を原則としている（**GPL汚染**が発生する）[コピーレフト](#コピーレフト)の[ライセンス](#ライセンス)。\n\n"},{"term":"マルチメディア","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディア","content":"\n**マルチメディア**は、情報を[デジタル](../../../../basics/information_theory/_/chapters/coding_theory.md#デジタル)化することで、テキストデータだけでなく画像や音声、映像情報を統合して扱うことのできるメディア。\n\n"},{"term":"オーサリング","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"オーサリング","content":"\n**オーサリング**は、文字や画像、動画、音声などの[マルチメディア](#マルチメディア)データを組み合わせて[マルチメディア](#マルチメディア)コンテンツを作成すること。オーサリングを行うための[ソフト](./software.md3ソフトウェア)を**オーサリングツール**と呼ぶ。\n\n"},{"term":"オーサリングツール","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"オーサリング","content":"\n**オーサリング**は、文字や画像、動画、音声などの[マルチメディア](#マルチメディア)データを組み合わせて[マルチメディア](#マルチメディア)コンテンツを作成すること。オーサリングを行うための[ソフト](./software.md3ソフトウェア)を**オーサリングツール**と呼ぶ。\n\n"},{"term":"ストリーミング","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"ストリーミング","content":"\n**ストリーミング**は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上にある音声や動画データの配信技術で、データファイル全体をまとめてダウンロードするのではなく、分割されたデータを読み込みながら再生する方式。これによりユーザがコンテンツを利用できるまでの時間が短縮され、[UX](./software.md#ux)が向上する。\n\n\n"},{"term":"静止画処理","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"静止画処理","content":"\n静止画の画質は、画素数、解像度、階調、色空間によって決まる。\n\n"},{"term":"画素数","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"画素数","content":"\n**画素数**は、静止画を構成するドットの数。\n\n"},{"term":"解像度","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"解像度","content":"\n**解像度**は、静止画の面積あたりの[画素数](#画素数)。\n\n"},{"term":"階調","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"階調","content":"\n**階調**は、静止画の明るさや濃さを表現する能力。\n\n"},{"term":"色空間","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"色空間","content":"\n**色空間**は、光または色の三原色の表現範囲。\n\n"},{"term":"色の三原色","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"色の三原色","content":"\n**色の三原色**は、Cyan（青緑）、Magenta（赤紫）、Yello（黄）による色の表現で、これら3色を組み合わせることで他の色を表現する。また、この3色をすべて混ぜると黒になる。印刷物などに用いられる。\n\n"},{"term":"光の三原色","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"h光の三原色","content":""},{"term":"アーカイブ","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"アーカイブ","content":"\n**アーカイブ**は、複数の[ファイル](./file_system.md#ファイル)をひとつにまとめる操作、またはこの操作によって生成された[ファイル](./file_system.md#ファイル)。\n\n\n"},{"term":"マルチメディアデータの標準形式","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"TAR","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"ZIP","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"JPEG","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"PNG","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"HEIC","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"GIF","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"TIFF","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"BMP","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"MP4","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"MOV","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"MP3","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"PCM","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"WAV","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"MIDI","link":"./note/ja/./computer/software/_/chapters/multimedia.md","flagment":"マルチメディアデータの標準形式","content":"\n| 分類     | 名称 | 特徴                                                                                                    |\n| -------- | ---- | :------------------------------------------------------------------------------------------------------ |\n| ファイル | TAR  | 圧縮は行わない、アーカイブ専用                                                                          |\n| ファイル | ZIP  | 多くのパソコン用OSに標準で組み込まれているアーカイブ・圧縮形式                                          |\n| 静止画   | JPEG | 一般的な画像圧縮方式で、写真などのフルカラー画像に適している                                            |\n| 静止画   | PNG  | GIFよりも圧縮率が高く、フルカラーを扱える可逆圧縮の画像形式                                             |\n| 静止画   | HEIC | Apple製品で標準的に用いられており、JPEGに比べて高い圧縮率を実現した方式                                 |\n| 静止画   | GIF  | 標準では256食のみ表現可能で、複数画像を連続的に表示したアニメーションや、透明色を利用した透化形式がある |\n| 静止画   | TIFF | 画素数や色数の異なる画像を1つのファイルとして扱えるようにファイル形式                                   |\n| 静止画   | BMP  | ビットマップファイルのことで、Windowsが標準で利用する非圧縮の画像データ形式                             |\n| 動画     | MP4  | mpegの標準規格のひとつで、静止画と音声を組み合わせて動画を表現する、一般的な動画データの形式           |\n| 動画     | MOV  | Appleが提供するマルチメディア拡張技術及びソフトウェアであるQuickTimeのフォーマット                      |\n| 音声     | MP3  | mpegの標準規格のひとつで、高音質で高い圧縮率を実現する音声の非可逆圧縮方式                              |\n| 音声     | PCM  | アナログ音声のデジタル変換方式                                                                          |\n| 音声     | WAV  | PCM方式によりアナログデータをデジタル化したもので、Windowsで使われる形式                                |\n| 音楽     | MIDI | コンピュータで電子音楽を表現するための符号化方式                                                        |\n"},{"term":"Linux","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"linux","content":"\n**Linux**は、Linus Torvaldsによって実装された[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)であり、[サーバ](../../../_/chapters/computer.md#サーバ)用から組み込み機器用、学習用、デスクトップ用など、幅広い用途で利用されている。設計は[UNIX](../../../software/_/chapters/operating_system.md#unix)に非常に似ているものの、[System V](../../../software/_/chapters/operating_system.md#unix)の流れも[BSD](../../../software/_/chapters/operating_system.md#unix)の流れも汲まない独自の[UNIX互換OS](../../../software/_/chapters/operating_system.md#unix)として開発された。\n\n[UNIX](../../../software/_/chapters/operating_system.md#unix)は高いライセンス使用料が必要であり、個人用として利用するには敷居が高いが、Linuxは[GPLライセンス](../../../software/_/chapters/open_source_software.md#gpl)であり誰でも無償で利用することができる。さらに、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)の改変や再配布も自由に行えたため多くの[ディストリビュータ](#ディストリビュータ)により改良され、一般に広まることとなった。\n\nまた、Linuxには高品質の[ソフトウェア](../../../software/_/chapters/software.md#ソフトウェア)が多く揃っているため、大変使いやすい[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)となっている。\n\n"},{"term":"狭義のLinux","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"狭義のlinux","content":"\n**狭義のLinux**は、[Linux](#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)を指す言葉。[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)の中核となる、[ハードウェア](../../../hardware/_/chapters/hardware.md#ハードウェア)制御を行う[ソフトウェア](../../../software/_/chapters/software.md#ソフトウェア)のみを指し、実際にユーザが用いるツールや[アプリケーション](../../../software/_/chapters/#応用ソフトウェア)は含まれない。\n\n"},{"term":"広義のLinux","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"広義のlinux","content":"\n**広義のLinux**は、[Linux](#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)に加えて、基本的な[コマンド](./basic_command.md#コマンド)群や[アプリケーション](../../../software/_/chapters/#応用ソフトウェア)などを含めて、ユーザがそのまま利用できるようにパッケージングして提供されたものを指す言葉。一般的には、単に[Linux](#linux)というときには、広義のLinuxのことを指す場合が多い。\n\n\n"},{"term":"ディストリビューション（Linuxディストリビューション）","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"ディストリビューション","content":"\n**ディストリビューション**（**Linuxディストリビューション**）は、[Linux](#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)と様々なツールや[アプリケーション](../../../software/_/chapters/software.md#応用ソフトウェア)群を組み合わせて[パッケージ](../../../software/_/chapters/package.md#パッケージ)化したもの。[Linux](#linux)は[OSS](../../../software/_/chapters/open_source_software.md#オープンソースソフトウェア)である性質上、様々な開発者によってメンテナンスされる、多くの種類のディストリビューションが存在する。\n\n"},{"term":"ディストリビュータ","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"ディストリビュータ","content":"\n**ディストリビュータ**は、[Linuxディストリビューション](#ディストリビューション)の開発やメンテナンスを行う人、あるいは団体を指す言葉。[Linux](#linux)に限らず、[OSS](../../../software/_/chapters/open_source_software.md#オープンソースソフトウェア)のメンテナンスを行う人のことを指す場合にも用いられる。\n\n"},{"term":"Red Hat系","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"red-hat系","content":""},{"term":"CentOS","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"red-hat系","content":""},{"term":"Fedora","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"red-hat系","content":""},{"term":"Debian系","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"debian系","content":"\n**Debian系**の[ディストリビューション](#ディストリビューション)は、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発された[ディストリビューション](#ディストリビューション)。見た目の美しさや、[Linux](#linux)に不慣れなユーザにも使いやすいことから人気が高い。\n\n**Debian GNU/Linux**や**Ubuntu**、**Linux Mint**などが有名で、デスクトップ用途での人気が高い。\n\n"},{"term":"Debian GNU/Linux","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"debian系","content":"\n**Debian系**の[ディストリビューション](#ディストリビューション)は、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発された[ディストリビューション](#ディストリビューション)。見た目の美しさや、[Linux](#linux)に不慣れなユーザにも使いやすいことから人気が高い。\n\n**Debian GNU/Linux**や**Ubuntu**、**Linux Mint**などが有名で、デスクトップ用途での人気が高い。\n\n"},{"term":"Ubuntu","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"debian系","content":"\n**Debian系**の[ディストリビューション](#ディストリビューション)は、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発された[ディストリビューション](#ディストリビューション)。見た目の美しさや、[Linux](#linux)に不慣れなユーザにも使いやすいことから人気が高い。\n\n**Debian GNU/Linux**や**Ubuntu**、**Linux Mint**などが有名で、デスクトップ用途での人気が高い。\n\n"},{"term":"Linux Mint","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"debian系","content":"\n**Debian系**の[ディストリビューション](#ディストリビューション)は、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発された[ディストリビューション](#ディストリビューション)。見た目の美しさや、[Linux](#linux)に不慣れなユーザにも使いやすいことから人気が高い。\n\n**Debian GNU/Linux**や**Ubuntu**、**Linux Mint**などが有名で、デスクトップ用途での人気が高い。\n\n"},{"term":"Slackware系","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"slackware系","content":"\n**Slackware系**の[ディストリビューション](#ディスとリビューション)は、最古の[ディストリビューション](#ディストリビューション)であるSlackwareをベースに開発された[ディストリビューション](#ディストリビューション)。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。\n\n**Slackware**や**openSUSE**などが有名。\n\n"},{"term":"Slackware","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"slackware系","content":"\n**Slackware系**の[ディストリビューション](#ディスとリビューション)は、最古の[ディストリビューション](#ディストリビューション)であるSlackwareをベースに開発された[ディストリビューション](#ディストリビューション)。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。\n\n**Slackware**や**openSUSE**などが有名。\n\n"},{"term":"openSUSE","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"slackware系","content":"\n**Slackware系**の[ディストリビューション](#ディスとリビューション)は、最古の[ディストリビューション](#ディストリビューション)であるSlackwareをベースに開発された[ディストリビューション](#ディストリビューション)。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。\n\n**Slackware**や**openSUSE**などが有名。\n\n"},{"term":"独立系","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"独立系","content":"\n**独立系**の[ディストリビューション](#ディストリビューション)は、独自の進歩を遂げた[ディストリビューション](#ディストリビューション)の総称で、個性的なものも多い。\n\n**Arch Linux**は、シンプリシティ、ミニマリズム、エレガンスに焦点を当てて開発された[Linux](#linux)。\n\n\n"},{"term":"Arch Linux","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"独立系","content":"\n**独立系**の[ディストリビューション](#ディストリビューション)は、独自の進歩を遂げた[ディストリビューション](#ディストリビューション)の総称で、個性的なものも多い。\n\n**Arch Linux**は、シンプリシティ、ミニマリズム、エレガンスに焦点を当てて開発された[Linux](#linux)。\n\n\n"},{"term":"パッケージ","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"パッケージ","content":"\n**パッケージ**は、[Linux](#linux)で利用可能な[アプリケーション](../../../software/_/chapters/software.md#応用ソフトウェア)を、ユーザが容易に利用できるように[ディストリビュータ](#ディストリビュータ)によって提供されたもの。パッケージを利用しない場合は、ユーザ自身で[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)をダウンロードしてそれをビルドする必要がある。\n\n"},{"term":"パッケージマネージャ","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"パッケージマネージャ","content":"\n**パッケージマネージャ**は、[パッケージ](#パッケージ)の導入や管理を容易にするためのツール。[パッケージ](#パッケージ)が依存している[ライブラリ](../../../software/_/chapters/package.md#ライブラリ)の解決を行ったり、パッケージマネージャを通して導入した[パッケージ](#パッケージ)の更新などを補助したりする。[Linuxディストリビューション](#ディストリビューション)にはパッケージマネージャが備えられている。\n\n"},{"term":"dpkg","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"dpkg","content":"\n**dpkg**は、[Debian系](#debian系)の[ディストリビューション](#ディストリビューション)で利用されている[パッケージマネージャ](#パッケージマネージャ)。\n\n"},{"term":"apt","link":"./note/ja/./computer/linux/_/chapters/linux.md","flagment":"apt","content":"\n**apt**は、[Debian系](#debian系)の[ディストリビューション](#ディストリビューション)で利用されている[パッケージマネージャ](#パッケージマネージャ)。[dpkg](#dpkg)の機能に加えて、[パッケージ](#パッケージ)間の[依存関係](../../../software/_/chapters/package.md#依存関係)を管理する機能を持っている。\n"},{"term":"シェル","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"シェル","content":"\n**シェル**は、[ユーザ](./user_and_permission.md#ユーザ)と[Linux](./linux.md#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の橋渡しをする[プログラム](../../../../programming/_/chapters/programming.md#プログラム)で、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の機能を[ユーザ](./user_and_permission.md#ユーザ)に提供するためのインタフェース。シェルはまず、[キーボード](../../../hardware/_/chapters/io_unit.md#キーボード)に入力された[ユーザ](./user_and_permission.md#ユーザ)の[コマンド](./basic_command.md#コマンド)を受け取り、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)に対して処理命令を行う。そして、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の処理結果を受け取ってそれを出力する。シェルは、このようなやり取りを繰り返すインタラクティブな操作を提供する。\n\n[Linux](./linux.md#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)とシェルのレイヤを分離することにより、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)には手を入れずにシェルのみをユースケースに合わせて変更することができたり、別の[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)を利用する際にシェルのみを移植すれば同様のインタフェースが利用できる、といった利点がある。\n\n"},{"term":"ログインシェル","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ログインシェル","content":"\n**ログインシェル**は、[ユーザ](./user_and_permission.md#ユーザ)がログイン時に最初に[Linux](./linux.md#linux)によって自動的に起動される[シェル](#シェル)。ログインシェルは、 `SHELL` [環境変数](#環境変数)に指定された[コマンド](./basic_command.md#コマンド)で起動されるものとなる。ログインシェルを変更するには、 `chsh` [コマンド](./basic_command.md#コマンド)を使用する。\n\n```sh\n"},{"term":"SHELL環境変数","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ログインシェル","content":"\n**ログインシェル**は、[ユーザ](./user_and_permission.md#ユーザ)がログイン時に最初に[Linux](./linux.md#linux)によって自動的に起動される[シェル](#シェル)。ログインシェルは、 `SHELL` [環境変数](#環境変数)に指定された[コマンド](./basic_command.md#コマンド)で起動されるものとなる。ログインシェルを変更するには、 `chsh` [コマンド](./basic_command.md#コマンド)を使用する。\n\n```sh\n"},{"term":"chsh","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ログインシェル","content":"\n**ログインシェル**は、[ユーザ](./user_and_permission.md#ユーザ)がログイン時に最初に[Linux](./linux.md#linux)によって自動的に起動される[シェル](#シェル)。ログインシェルは、 `SHELL` [環境変数](#環境変数)に指定された[コマンド](./basic_command.md#コマンド)で起動されるものとなる。ログインシェルを変更するには、 `chsh` [コマンド](./basic_command.md#コマンド)を使用する。\n\n```sh\n"},{"term":"プロンプト","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"プロンプト","content":"\n**プロンプト**は、[シェル](#シェル)が[ユーザ](./user_and_permission.md#ユーザ)の入力を受け付けている状態を示す記号。多くの場合は `$` や `#` で表わされ、さらにログイン中のユーザ名やホスト名、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)などの付加情報を表示することもできる。プロンプトの表示は、[シェル](#シェル)の設定により[ユーザ](./user_and_permission.md#ユーザ)が任意に変更できる（ `PROMPT` や `RPROMPT` といった環境変数）。\n\n[Ubuntu](./linux.md#debian系)のデフォルトのプロンプトは以下の通り。（ユーザ名が `user` 、ホスト名が `host` の場合）\n\n```sh\nuser@host:~$\n```\n\nプロンプト記号の `$` は[一般ユーザ](./user_and_permission.md#ユーザ)での操作、 `#` は[スーパユーザ](./user_and_permission.md#rootユーザ)での操作を例示しているドキュメントが多い。\n\nまた、長い[コマンド](./basic_command.md#コマンド)などの途中で `\\` により改行された際には、**セカンダリプロンプト**が表示される。\n\n"},{"term":"PROMPT、RPROMPT環境変数","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"プロンプト","content":"\n**プロンプト**は、[シェル](#シェル)が[ユーザ](./user_and_permission.md#ユーザ)の入力を受け付けている状態を示す記号。多くの場合は `$` や `#` で表わされ、さらにログイン中のユーザ名やホスト名、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)などの付加情報を表示することもできる。プロンプトの表示は、[シェル](#シェル)の設定により[ユーザ](./user_and_permission.md#ユーザ)が任意に変更できる（ `PROMPT` や `RPROMPT` といった環境変数）。\n\n[Ubuntu](./linux.md#debian系)のデフォルトのプロンプトは以下の通り。（ユーザ名が `user` 、ホスト名が `host` の場合）\n\n```sh\nuser@host:~$\n```\n\nプロンプト記号の `$` は[一般ユーザ](./user_and_permission.md#ユーザ)での操作、 `#` は[スーパユーザ](./user_and_permission.md#rootユーザ)での操作を例示しているドキュメントが多い。\n\nまた、長い[コマンド](./basic_command.md#コマンド)などの途中で `\\` により改行された際には、**セカンダリプロンプト**が表示される。\n\n"},{"term":"セカンダリプロンプト","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"プロンプト","content":"\n**プロンプト**は、[シェル](#シェル)が[ユーザ](./user_and_permission.md#ユーザ)の入力を受け付けている状態を示す記号。多くの場合は `$` や `#` で表わされ、さらにログイン中のユーザ名やホスト名、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)などの付加情報を表示することもできる。プロンプトの表示は、[シェル](#シェル)の設定により[ユーザ](./user_and_permission.md#ユーザ)が任意に変更できる（ `PROMPT` や `RPROMPT` といった環境変数）。\n\n[Ubuntu](./linux.md#debian系)のデフォルトのプロンプトは以下の通り。（ユーザ名が `user` 、ホスト名が `host` の場合）\n\n```sh\nuser@host:~$\n```\n\nプロンプト記号の `$` は[一般ユーザ](./user_and_permission.md#ユーザ)での操作、 `#` は[スーパユーザ](./user_and_permission.md#rootユーザ)での操作を例示しているドキュメントが多い。\n\nまた、長い[コマンド](./basic_command.md#コマンド)などの途中で `\\` により改行された際には、**セカンダリプロンプト**が表示される。\n\n"},{"term":"インクリメンタルサーチ","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"インクリメンタルサーチ","content":"\n**インクリメンタルサーチ**は、キーボードから1文字入力するごとに[コマンド](./basic_command.md#コマンド)履歴を検索する機能。インクリメンタルサーチモード中は、次のようなキーバインドが利用できる。\n\n| キーマップ   | 内容                                               |\n| ------------ | :------------------------------------------------- |\n| `Ctrl` + `r` | 1つ前の検索結果へ移動                              |\n| `Enter`      | 現在の検索結果をそのまま実行                       |\n| `Esc`        | 現在の検索結果を表示したまま、コマンドラインに戻る |\n| `Ctrl` + `g` | 検索結果を破棄し、プロンプトに戻る                 |\n\n\n"},{"term":"シェルセッション","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"シェルセッション","content":"\n**シェルセッション**は、[ユーザ](./user_and_permission.md#ユーザ)がシェルにログインしてから[シェル](#シェル)を閉じるまでの一連の流れ。セッションが開始されると、[シェル](#シェル)は設定を読み込んで[ユーザ](./user_and_permission.md#ユーザ)に[プロンプト](#プロンプト)を返し、[コマンド](#コマンド)を入力できる状態となる。セッションは、[ユーザ](./user_and_permission.md#ユーザ)がログアウトするか、システムが再起動されると終了する。\n\n\n"},{"term":"ターミナル（端末）","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナル","content":"\n**ターミナル**（**端末**）は、[ユーザ](./user_and_permission.md#ユーザ)が[コンピュータ](../../../_/chapters/computer.md#コンピュータ)へ入出力する際に利用する[ハードウェア](../../../_/chapters/computer.md#ハードウェア)を指す言葉。[入力装置](../../../hardware/_/chapters/hardware.md#入力装置)にはキーボード、[出力装置](../../../hardware/_/chapters/hardware.md#出力装置)にはディスプレイが主に用いられる。\n\n[ターミナルエミューレタ](#ターミナルエミュレータ)のことを単にターミナルと呼ぶ場合もある。\n\n"},{"term":"TeraTerm","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナル","content":"\n**ターミナル**（**端末**）は、[ユーザ](./user_and_permission.md#ユーザ)が[コンピュータ](../../../_/chapters/computer.md#コンピュータ)へ入出力する際に利用する[ハードウェア](../../../_/chapters/computer.md#ハードウェア)を指す言葉。[入力装置](../../../hardware/_/chapters/hardware.md#入力装置)にはキーボード、[出力装置](../../../hardware/_/chapters/hardware.md#出力装置)にはディスプレイが主に用いられる。\n\n[ターミナルエミューレタ](#ターミナルエミュレータ)のことを単にターミナルと呼ぶ場合もある。\n\n"},{"term":"RLogin","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナル","content":"\n**ターミナル**（**端末**）は、[ユーザ](./user_and_permission.md#ユーザ)が[コンピュータ](../../../_/chapters/computer.md#コンピュータ)へ入出力する際に利用する[ハードウェア](../../../_/chapters/computer.md#ハードウェア)を指す言葉。[入力装置](../../../hardware/_/chapters/hardware.md#入力装置)にはキーボード、[出力装置](../../../hardware/_/chapters/hardware.md#出力装置)にはディスプレイが主に用いられる。\n\n[ターミナルエミューレタ](#ターミナルエミュレータ)のことを単にターミナルと呼ぶ場合もある。\n\n"},{"term":"Alacritty","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナル","content":"\n**ターミナル**（**端末**）は、[ユーザ](./user_and_permission.md#ユーザ)が[コンピュータ](../../../_/chapters/computer.md#コンピュータ)へ入出力する際に利用する[ハードウェア](../../../_/chapters/computer.md#ハードウェア)を指す言葉。[入力装置](../../../hardware/_/chapters/hardware.md#入力装置)にはキーボード、[出力装置](../../../hardware/_/chapters/hardware.md#出力装置)にはディスプレイが主に用いられる。\n\n[ターミナルエミューレタ](#ターミナルエミュレータ)のことを単にターミナルと呼ぶ場合もある。\n\n"},{"term":"ターミナルマルチプレクサ","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナルマルチプレクサ","content":"\n**ターミナルマルチプレクサ**は、1つの[ターミナル](#ターミナル)を複数の仮想[ターミナル](#ターミナル)に分割して、同時に複数の[ターミナル](#ターミナル)を実行できるようにするツール。特に有名なターミナルマルチプレクサとしては、 `tmux` がある。リモートアクセスなどにより[Linux](./linux.md#linux)を利用する場合、コネクションが切断されたときに前のセッションを復元することができたり、複数のコネクションを張ることなくマルチターミナルで作業ができるといった利点がある。\n\n"},{"term":"tmux","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"ターミナルマルチプレクサ","content":"\n**ターミナルマルチプレクサ**は、1つの[ターミナル](#ターミナル)を複数の仮想[ターミナル](#ターミナル)に分割して、同時に複数の[ターミナル](#ターミナル)を実行できるようにするツール。特に有名なターミナルマルチプレクサとしては、 `tmux` がある。リモートアクセスなどにより[Linux](./linux.md#linux)を利用する場合、コネクションが切断されたときに前のセッションを復元することができたり、複数のコネクションを張ることなくマルチターミナルで作業ができるといった利点がある。\n\n"},{"term":"エイリアス","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"エイリアス","content":"\n**エイリアス**は、既存の[コマンド](./basic_command.md#コマンド)に対して別名をつけて実行できるようにする機能。\n\n例えば以下のようなエイリアスを設定すると、 `ls` [コマンド](./basic_command.md#コマンド)を実行したときに `-F` [オプション](./basic_command.md#オプション)が自動で付与されるようになる。\n\n```sh\n$ alias ls='ls -F'\n```\n\nある[コマンド](./basic_command.md#コマンド)が、本当に[コマンド](./basic_command.md#コマンド)であるかエイリアスであるかを確認するには、 `type` [コマンド](./basic_command.md#コマンド)を使用する。\n\n```sh\n$ type ls\nls is an alias for ls -F\n```\n\nまた、エイリアスを削除するには `unalias` [コマンド](./basic_command.md#コマンド)を使用する。\n\n```sh\n$ unalias ls\n```\n\n`command` [コマンド](./basic_command.md#コマンド)を使用したり、[コマンド](./basic_command.md#コマンド)の先頭に `\\` を付与することで、一時的にエイリアスを無視して元の[コマンド](./basic_command.md#コマンド)を実行することもできる。\n\n```sh\n$ command ls\n$ \\ls\n```\n\n\n"},{"term":"環境変数","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"環境変数","content":"\n**環境変数**は、[Linux](./linux.md#linux)においてシステム全体に影響を与える[変数](../../../../programming/_/chapters/variable.md#変数)のことで、主に[シェル](#シェル)の振る舞いを制御するために使用される。環境変数は[プロセス](./process_and_job.md#プロセス)が実行されるときに[プロセス](./process_and_job.md#プロセス)に渡され、その[プロセス](./process_and_job.md#プロセス)の動作を変更することができる。環境変数は以下のような場合に利用される。\n\n- [ユーザ](./user_and_permission.md#ユーザ)の設定やシステムの設定を制御する\n- [プログラム](../../../../programming/_/chapters/programming.md#プログラム)が必要とする[パス](../../../software/_/chapters/file_system.md#パス)や[ライブラリ](../../../software/_/chapters/package.md#ライブラリ)の場所を指定する\n- 各[ユーザ](./user_and_permission.md#ユーザ)の[シェル](#シェル)の動作をカスタマイズする\n\n以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `MY_VAR` という[変数](../../../../programming/_/chapters/variable.md#変数)に `avlue` という値を設定することができる。\n\n```Sh\n$ export MY_VAR=value\n```\n\nまた、環境変数を確認するには、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ echo $MY_VAR\n```\n\n環境変数の設定は[シェルセッション](#シェルセッション)が終了すると消えるので、永続化したい場合は[シェル](#シェル)の設定ファイル内などで定義しておくとよい。\n\n"},{"term":"シェル変数","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"シェル変数","content":"\n**シェル変数**は、[シェル](#シェル)内でのみ使用される[変数](../../../../programming/_/chapters/variable.md#変数)で、その[シェル](#シェル)自体とその子[プロセス](./process_and_job.md#プロセス)でのみ使用される。シェル変数は[環境変数](#環境変数)とは異なり、他の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)には影響を与えない。\n\nシェル変数を設定するには、以下の例のようにシェル変数名と値を等号で結ぶ。\n\n```sh\n$ MY_SHELL_VAR=value\n```\n\n"},{"term":"PATH","link":"./note/ja/./computer/linux/_/chapters/shell_and_terminal.md","flagment":"path","content":"\n`PATH` は、[シェル](#シェル)が[コマンド](./basic_command.md#コマンド)を実行する際に検索する[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)のリストを含む[環境変数](#環境変数)。 `PATH` には、[シェル](#シェル)が[コマンド](./basic_command.md#コマンド)を検索する順序で、コロンで区切られた[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)のリストが格納される。\n\n例えば、 `PATH` が `/usr/local/bin:/usr/bin:/bin` に設定されている場合、[シェル](#シェル)はまず `/usr/local/bin` を検索し、次に `/usr/bin` を検索し、最後に `/bin` を検索する。\n\n`PATH` 環境変数を修正することで、独自定義の[コマンド](./basic_command.md#コマンド)をどこからでも実行できるようにしたりすることができる。\n\n\n"},{"term":"コマンド","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"コマンド","content":"\n**コマンド**は、[ユーザ](./user_and_permission.md#ユーザ)が[シェル](./shell_and_terminal.md#シェル)に対して与える命令。様々な[オプション](#オプション)を付与するなどして、1行に入力するには長い場合は、 `\\` を入力して改行することができる。\n\n"},{"term":"サブコマンド","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"サブコマンド","content":"\n**サブコマンド**は、様々な機能をまとめた[コマンド](#コマンド)に対して、具体的な操作の種類を指定する命令。第一[コマンド](#コマンド)に続けて指定する。以下の例では、 `systemctl` [コマンド](#コマンド)のサブコマンドとして `start` を指定している。\n\n```sh\n$ systemctl start httpd\n```\n\n"},{"term":"オプション（引数、フラグ、パラメータ）","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"オプション","content":"\n**オプション**（**引数**、**フラグ**、**パラメータ**）は、[コマンド](#コマンド)の操作対象や処理内容の詳細を指定する部分。オプションの形式は[コマンド](#コマンド)によって異なるが、 `-` から始まる**ショートオプション**や、 `--` から始まる**ロングオプション**などが一般的。\n\n\n"},{"term":"ショートオプション","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ショートオプション","content":""},{"term":"ロングオプション","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ロングオプション","content":""},{"term":"man","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"マニュアル","content":"\n`man` は、[Linux](./linux.md#linux)のマニュアルページを表示するために使用される[コマンド](#コマンド)。マニュアルページには、[Linux](./linux.md#linux)システムや[ソフトウェア](../../../software/_/chapters/software.md#ソフトウェア)の機能、[オプション](#オプション)、使用例などが記載されている。 `man` [コマンド](#コマンド)を使うことで、[コマンド](#コマンド)や[ファイル](../../../software/_/chapters/file_system.md#ファイル)、システムの概要を調べることができる。\n\n`man` [コマンド](#コマンド)の書式は以下の通り。\n\n```\nman [OPTION]... [COMMAND/FILE]\n```\n\n例えば、 `ls` [コマンド](#コマンド)のマニュアルページを表示したい場合は、次のように実行する。\n\n```sh\n$ man ls\n```\n\nマニュアルページを開いている間は、矢印キーや `Enter/BackSpace` 、 `j/k` でページ内を移動することができ、 `q` キーでマニュアルを閉じてインタラクティブシェルに復帰できる。また、操作がわからなくなった場合には `h` キーを入力することでヘルプを参照することができる。これらの操作が有効なのは、ページャとしてデフォルトの `less` を用いている場合に限られる。\n\n`OPTION` に指定することができる主要な[オプション](#オプション)は以下の通り。\n\n| オプション      | 概要                                                                                     |\n| --------------- | :--------------------------------------------------------------------------------------- |\n| `-f` `-k` `-i`  | 指定したキーワードに該当するコマンドを検索し、見つかったマニュアルページの一覧を出力する |\n| `-a`            | すべてのマニュアルページを表示する                                                       |\n| `-P` `--pager`  | マニュアルページの閲覧に用いるページャを指定する（デフォルトでは `less` ）               |\n\nまた、マニュアルは種類ごとに以下のようなセクション番号が割り振られており、番号を指定してマニュアルを調べることもできる。\n\n| セクション番号 | 内容                                   |\n| -------------- | :------------------------------------- |\n| `1`            | Linuxコマンド                          |\n| `2`            | システムコール（カーネル関数）         |\n| `3`            | ライブラリコール（Cライブラリの関数）  |\n| `4`            | スペシャルファイル（デバイスファイル） |\n| `5`            | ファイルのフォーマット                 |\n| `6`            | ゲームやデモ                           |\n| `7`            | マクロ                                 |\n| `8`            | その他                                 |\n| `9`            | システムコマンドとデーモン             |\n\n"},{"term":"ヘルプオプション","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ヘルプオプション","content":"\n**ヘルプオプション**は、[コマンド](#コマンド)の使い方や[オプション](#オプション)などの情報を表示するための[オプション](#オプション)で、多くの[コマンド](#コマンド)がこの[オプション](#オプション)を備えている。一般的にはヘルプオプションは `-h` 、 `--help` 、 `-?` といった形式で提供される。\n\nヘルプオプションを使用することで、[コマンド](#コマンド)の詳細な使用方法や[オプション](#オプション)の意味を知ることができる。ヘルプオプションを使用する場合、次のように[コマンド](#コマンド)を入力する。\n\n```sh\n$ [COMMAND] --help\n```\n\n例えば、 `ls` [コマンド](#コマンド)のヘルプを表示するには、次のように入力する。\n\n```sh\n$ ls --help\n```\n\n\n"},{"term":"exit","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ログアウト","content":"\n`exit` は、[Linux](./linux.md#linux)において[シェル](./shell_and_terminal.md#シェル)からログアウトするための[コマンド](#コマンド)。この[コマンド](#コマンド)の実行により現在使用している[シェル](./shell_and_terminal.md#シェル)[プロセス](./process_and_job.md#プロセス)を終了する。\n\n"},{"term":"shutdown","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"シャットダウン","content":"\n`shutdown` は、[Linux](./linux.md#linux)システムをシャットダウンするための[コマンド](#コマンド)。システムをシャットダウンする前に[ユーザ](./user_and_permission.md#ユーザ)に通知を行い、デフォルトではシャットダウンまで1分間の待ち時間が設定されている。\n\nまた、 `poweroff` もシャットダウンのための[コマンド](#コマンド)。ただし、 `shutdown` とは異なり、システムを直ちに停止するため、[アプリケーション](../../../software/_/chapters/software.md#応用ソフトウェア)が意図せず停止されてしまう恐れがある。\n\n"},{"term":"poweroff","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"シャットダウン","content":"\n`shutdown` は、[Linux](./linux.md#linux)システムをシャットダウンするための[コマンド](#コマンド)。システムをシャットダウンする前に[ユーザ](./user_and_permission.md#ユーザ)に通知を行い、デフォルトではシャットダウンまで1分間の待ち時間が設定されている。\n\nまた、 `poweroff` もシャットダウンのための[コマンド](#コマンド)。ただし、 `shutdown` とは異なり、システムを直ちに停止するため、[アプリケーション](../../../software/_/chapters/software.md#応用ソフトウェア)が意図せず停止されてしまう恐れがある。\n\n"},{"term":"reboot","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"再起動","content":"\n`reboot` は、[Linux](./linux.md#linux)システムを再起動するための[コマンド](#コマンド)。 `reboot` を実行すると、システムはシャットダウンして再起動する。 `shutdown` コマンドのように再起動時刻を指定して実行することもできる。例えば、5分後にシステムを再起動したい場合、以下の[コマンド](#コマンド)を実行する。\n\n```sh\n$ reboot +5\n```\n\n"},{"term":"suspend","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"スリープモード","content":"\n`suspend` は、[Linux](./linux.md#linux)システムをスリープモードにするための[コマンド](#コマンド)。 `suspend` を実行すると、[コンピュータ](../../../_/chapters/computer.md#コンピュータ)の電源はOFFにならず、[CPU](../../../hardware/_/chapters/processor.md#cpu)や[メモリ](../../../hardware/_/chapters/memory.md#メモリ)などの一部の機能が停止して、省エネモードになる。また、この[コマンド](#コマンド)から復帰すると、停止前の状態から作業を再開することができる。\n\n\n"},{"term":"ls","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの一覧表示","content":"\n`ls` は、[Linux](./linux.md#linux)及び[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の一覧表示を行う[コマンド](#コマンド)。 `ls` は\"list\"の略語。[ファイル](../../../software/_/chapters/file_system.md#ファイル)名や[パーミッション](./user_and_permission.md#パーミッション)、[所有者](./user_and_permission.md#所有者)、更新日時、ファイルサイズなどの情報を表示することができる。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nls [OPTION]... [FILE]...\n```\n\n`ls` [コマンド](#コマンド)を単体で使用すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を一覧表示する。また、 `ls` [コマンド](#コマンド)の主要な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                                                                  |\n| ---------- | :------------------------------------------------------------------------------------ |\n| `-l`       | パーミッションや所有者、グループ、ファイルサイズ、更新日時など、詳細な情報を表示する  |\n| `-a`       | 隠しファイルも含めたすべてのファイルを表示する                                        |\n| `-h`       | ファイルサイズを人間が読みやすい形式で表示する                                        |\n| `-t`       | 更新日時の新しい順に並べ替えて表示する                                                |\n| `-r`       | 結果を逆順で表示する                                                                  |\n| `-R`       | サブディレクトリ以下のファイルやディレクトリを再帰的に表示する                        |\n| `-F`       | ファイル名の後ろにファイルの種類を表す記号を追加して表示する                          |\n\n`-F` [オプション](#オプション)を指定した場合、ファイル名の後ろに次のような記号が追加で表示される。\n\n| 種別               | 記号 |\n| ------------------ | ---- |\n| 通常ファイル       | なし |\n| ディレクトリ       | `/`  |\n| 実行可能ファイル   | `*`  |\n| シンボリックリンク | `@`  |\n\n"},{"term":"touch","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの作成","content":"\n`touch` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティグシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、空の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を作成したり、既存の[ファイル](../../../software/_/chapters/file_system.md#ファイル)の更新日時を変更する[コマンド](#コマンド)です。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\ntouch [OPTION]... FILE...\n```\n\n`touch` [コマンド](#コマンド)を単独で使用すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)に空の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を作成する。例えば次の[コマンド](#コマンド)は、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)に `test.txt` という名前のから[ファイル](../../../software/_/chapters/file_system.md#ファイル)を作成する。\n\n```sh\n$ touch test.txt\n```\n\nまた、既存の[ファイル](../../../software/_/chapters/file_system.md#ファイル)の更新日時を変更する場合は、ファイル名を指定して `touch` [コマンド](#コマンド)を実行する。 `touch` [コマンド](#コマンド)の代表的な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                                                    |\n| ---------- | :---------------------------------------------------------------------- |\n| `-c`       | ファイルが存在しない場合に、ファイルを新規作成せずにコマンドを終了する  |\n| `-d`       | ファイルの更新日時を指定した日時に変更する                              |\n| `-m`       | ファイルの更新日時だけを変更する（最終アクセス日時は更新しない）        |\n| `-r`       | 指定したファイルと同じ更新日時にする                                    |\n\n"},{"term":"rm","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの削除","content":"\n`rm` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#オペレーティングシステム)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を削除するための[コマンド](#コマンド)。 `rm` は\"remove\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nls [OPTION]... [FILE]...\n```\n\n`rm` [コマンド](#コマンド)を単独で使用すると、指定した[ファイル](../../../software/_/chapters/file_system.md#ファイル)を削除する。例えば次の[コマンド](#コマンド)は、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある `test.txt` という名前の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を削除する。\n\n```sh\n$ rm test.txt\n```\n\n`rm` [コマンド](#コマンド)によって削除された[ファイル](../../../software/_/chapters/file_system.md#ファイル)は元に戻すことができないので、注意が必要。 `rm` [コマンド](#コマンド)の代表的な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                                                                                  |\n| ---------- | :---------------------------------------------------------------------------------------------------- |\n| `-r`       | サブディレクトリを削除するためのオプションで、サブディレクトリ内のファイルやディレクトリもすべて削除 |\n| `-i`       | 削除時に確認を求める                                                                                  |\n| `-f`       | 警告を表示せずに、強制的にファイルを削除する                                                          |\n\n`rm` は強力な[コマンド](#コマンド)であり、誤って重要な[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を削除しないように十分に注意が必要。\n\n"},{"term":"cp","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルのコピー","content":"\n`cp` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)をコピーするための[コマンド](#コマンド)。 `cp` は\"copy\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\ncp [OPTION]... [-T] SOURCE DEST\ncp [OPTION]... SOURCE... DIRECTORY\ncp [OPTION]... -t DIRECTORY SOURCE...\n```\n\n`cp` [コマンド](#コマンド)にコピー元[ファイル](../../../software/_/chapters/file_system.md#ファイル)とコピー先[ファイル](../../../software/_/chapters/file_system.md#ファイル)の[パス](../../../software/_/chapters/file_system.md#パス)を指定することで、[ファイル](../../../software/_/chapters/file_system.md#ファイル)をコピーすることができる。例えば次の[コマンド](#コマンド)は、 `/home/user/src/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)を `/home/user/dest/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)にコピーする。\n\n```sh\ncp /home/user/src/test.txt /home/user/dest/test.txt\n```\n\n`cp` [コマンド](#コマンド)の代表的な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                             |\n| ---------- | :----------------------------------------------- |\n| `-r`       | 指定したディレクトリの中身を再帰的にコピーする   |\n| `-p`       | コピー元ファイルの属性やパーミッションを維持する |\n| `-i`       | 上書き確認を求める                               |\n\n`cp` [コマンド](#コマンド)は[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を簡単にコピーすることができるが、コピー先に同名の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が存在する場合には、内容が上書きされるため注意が必要。\n\n"},{"term":"mv","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの移動","content":"\n`mv` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を移動するための[コマンド](#コマンド)。また、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の名前を変更するためにも用いられる。 `mv` は\"move\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nmv [OPTION]... [-T] SOURCE DEST\nmv [OPTION]... SOURCE... DIRECTORY\nmv [OPTION]... -t DIRECTORY SOURCE...\n```\n\n`mv` [コマンド](#コマンド)に移動元[ファイル](../../../software/_/chapters/file_system.md#ファイル)または[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[パス](../../../software/_/chapters/file_system.md#パス)と移動先の[パス](../../../software/_/chapters/file_system.md#パス)を指定することで、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を移動することができる。例えば次の[コマンド](#コマンド)は、 `/home/user/src/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)を `/home/user/dest/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)に移動する。\n\n```sh\n$ mv /home/user/src/test.txt /home/user/dest/test.txt\n```\n\nまた、 `mv` [コマンド](#コマンド)を使用して[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)をリネームすることもできる。例えば次の[コマンド](#コマンド)は、 `/home/user/src/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)を `/home/user/src/test2.txt` という名前に変更する。\n\n```sh\n$ mv /home/user/src/test.txt /home/user/src/test2.txt\n```\n\n`mv` [コマンド](#コマンド)に `-i` [オプション](#オプション)を指定すると、移動先に同じ名前の[ファイル](../../../software/_/chapters/file_system.md#ファイル)があった場合に上書き確認を行う。\n\n"},{"term":"cat","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの内容確認","content":"\n`cat` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、テキストファイルの内容を表示するための[コマンド](#コマンド)。 `cat` は\"concatenate\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\ncat [OPTION]... [FILE]...\n```\n\n基本的に、`cat` [コマンド](#コマンド)は1つ以上の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を引数として受け取り、それらの[ファイル](../../../software/_/chapters/file_system.md#ファイル)の内容を順番に連結して[標準出力](./stdio_and_pipeline.md#標準出力)に表示する。例えば次の[コマンド](#コマンド)を実行すると、[ファイル](../../../software/_/chapters/file_system.md#ファイル) `file1.txt` と `file2.txt` の内容が順番に表示される。\n\n```sh\n$ cat test1.txt test2.txt\n```\n\n`cat` [コマンド](#コマンド)にファイル名を指定しなかった場合、[標準入力](./stdio_and_pipeline.md#標準出力)を待ち受ける状態となり、受け取った入力をそのまま[標準出力](./stdio_and_pipeline.md#標準出力)に表示する。\n\n`cat` [コマンド](#コマンド)の代表的な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                         |\n| ---------- | :------------------------------------------- |\n| `-n`       | 行番号を表示する                             |\n| `-b`       | 行番号を表示する（空行には行番号を付けない） |\n| `-s`       | 空行をまとめる                               |\n| `-E`       | 各行の末尾に `$` を表示する                  |\n\n`cat` はテキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)の内容を素早く表示することができるが、大きな[ファイル](../../../software/_/chapters/file_system.md#ファイル)を扱う場合には `less` や `more` といった[ページャコマンド](#ファイルのページャ表示)の方が向いている。\n\n"},{"term":"less","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルのページャ表示","content":"\n`less` や `more` [コマンド](#コマンド)は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、テキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)を閲覧するための[コマンド](#コマンド)。 `less` は `more` よりも高度な機能を持っている。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nless [OPTION]... [FILE]...\n```\n\n`less` [コマンド](#コマンド)を使用すると、指定した[ファイル](../../../software/_/chapters/file_system.md#ファイル)の内容が先頭から表示される。 `Space` キーを入力すると1ページ分のテキストをスクロールダウンし、 `b` キーを入力すると1ページ分のテキストをスクロールアップする。また、 `q` キーを入力すると `less` [コマンド](#コマンド)を終了する。\n\nまた、 `less` [コマンド](#コマンド)は `more` [コマンド](#コマンド)にはない以下のような機能を提供する。\n\n- テキスト内の文字列を検索する機能（ `/` キーを押して、検索したい文字列を入力する）\n- [ファイル](../../../software/_/chapters/file_system.md#ファイル)内の行数を表示する（ `=` キーを入力する）\n- [ファイル](../../../software/_/chapters/file_system.md#ファイル)内の任意の行に移動する（ `g` キーを入力すると[ファイル](../../../software/_/chapters/file_system.md#ファイル)の先頭に、 `G` キーを入力すると[ファイル](../../../software/_/chapters/file_system.md#ファイル)の末尾にジャンプする）\n\n例えば次の[コマンド](#コマンド)を実行すると、 `less` ページャ内に `/var/log/syslog` [ファイル](../../../software/_/chapters/file_system.md#ファイル)を表示する。\n\n```sh\n$ less /var/log/syslog\n```\n\n"},{"term":"more","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルのページャ表示","content":"\n`less` や `more` [コマンド](#コマンド)は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、テキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)を閲覧するための[コマンド](#コマンド)。 `less` は `more` よりも高度な機能を持っている。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nless [OPTION]... [FILE]...\n```\n\n`less` [コマンド](#コマンド)を使用すると、指定した[ファイル](../../../software/_/chapters/file_system.md#ファイル)の内容が先頭から表示される。 `Space` キーを入力すると1ページ分のテキストをスクロールダウンし、 `b` キーを入力すると1ページ分のテキストをスクロールアップする。また、 `q` キーを入力すると `less` [コマンド](#コマンド)を終了する。\n\nまた、 `less` [コマンド](#コマンド)は `more` [コマンド](#コマンド)にはない以下のような機能を提供する。\n\n- テキスト内の文字列を検索する機能（ `/` キーを押して、検索したい文字列を入力する）\n- [ファイル](../../../software/_/chapters/file_system.md#ファイル)内の行数を表示する（ `=` キーを入力する）\n- [ファイル](../../../software/_/chapters/file_system.md#ファイル)内の任意の行に移動する（ `g` キーを入力すると[ファイル](../../../software/_/chapters/file_system.md#ファイル)の先頭に、 `G` キーを入力すると[ファイル](../../../software/_/chapters/file_system.md#ファイル)の末尾にジャンプする）\n\n例えば次の[コマンド](#コマンド)を実行すると、 `less` ページャ内に `/var/log/syslog` [ファイル](../../../software/_/chapters/file_system.md#ファイル)を表示する。\n\n```sh\n$ less /var/log/syslog\n```\n\n"},{"term":"head","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの先頭表示","content":"\n`head` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、テキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)の先頭から指定された行数分の内容を表示する[コマンド](#コマンド)。 `tail` [コマンド](#コマンド)と同様に、ログ[ファイル](../../../software/_/chapters/file_system.md#ファイル)や大容量テキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)の処理に便利なツール。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nhead [OPTION]... [FILE]...\n```\n\nデフォルトでは、 `head` [コマンド](#コマンド)は指定された[ファイル](../../../software/_/chapters/file_system.md#ファイル)の先頭10行を表示する。 `-n` オプションを使用することで、表示する行数を変更することができる。例えば次の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある `test.txt` の先頭5行が表示される。\n\n```sh\n$ head -n 5 test.txt\n```\n\nまた、複数の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を指定して、それぞれの[ファイル](../../../software/_/chapters/file_system.md#ファイル)の先頭を表示することもできる。例えば次の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある `test1.txt` と `test2.txt` の先頭10行がそれぞれ表示される。\n\n```sh\n$ head test1.txt test2.txt\n```\n\n"},{"term":"tail","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの末尾表示","content":"\n`tail` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、テキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)の末尾から指定された行数分の内容を表示するための[コマンド](#コマンド)。主にログ[ファイル](../../../software/_/chapters/file_system.md#ファイル)や大容量のテキスト[ファイル](../../../software/_/chapters/file_system.md#ファイル)の処理や解析に便利なツール。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\ntail [OPTION]... [FILE]...\n```\n\nデフォルトでは、 `tail` [コマンド](#コマンド)は指定された[ファイル](../../../software/_/chapters/file_system.md#ファイル)の末尾10行を表示する。 `-n` [オプション](#オプション)を使用することで、表示する行数を変更することができる。例えば次の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある `test.txt` の末尾5行が表示される。\n\n```sh\n$ tail -n 5 test.txt\n```\n\nまた、複数の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を指定して、それぞれの[ファイル](../../../software/_/chapters/file_system.md#ファイル)の末尾を表示することもできる。例えば次の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある `test1.txt` と `test2.txt` の末尾10行がそれぞれ表示される。\n\n```sh\n$ tail test1.txt test2.txt\n```\n\n`-f` [オプション](#オプション)を使用すると、[ファイル](../../../software/_/chapters/file_system.md#ファイル)の変更をリアルタイムに追跡するとこができる。これは、ログ[ファイル](../../../software/_/chapters/file_system.md#ファイル)の解析などにおいて非常に便利な[オプション](#オプション)で、以下の例では `access.log` の変更をリアルタイムに追跡する。\n\n```sh\n$ tail -f access.log\n```\n\n\n"},{"term":"pwd","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"カレントディレクトリの確認","content":"\n`pwd` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、現在の作業[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を表示するための[コマンド](#コマンド)。 `pwd` は\"print working directory\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\npwd [OPTION]...\n```\n\n基本的に `pwd` は現在の作業[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[絶対パス](../../../software/_/chapters/file_system.md#絶対パス)を表示する。例えば、現在の作業[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)が `~/docs` である場合、 `pwd` [コマンド](#コマンド)を実行すると、 `/home/user/docs` という出力が得られる。\n\n`pwd` [コマンド](#コマンド)に `-P` [オプション](#オプション)を指定すると、[シンボリックリンク](./file.md#シンボリックリンク)を解決した[パス](../../../software/_/chapters/file_system.md#パス)を表示する。\n\n"},{"term":"cd","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ディレクトリの移動","content":"\n`cd` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)を変更するための[コマンド](#コマンド)。 `cd` は\"change directory\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\ncd [PATH]\n```\n\n`cd` に移動先の[パス](../../../software/_/chapters/file_system.md#パス)を指定すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)を指定した[パス](../../../software/_/chapters/file_system.md#パス)に変更する。例えば以下の[コマンド](#コマンド)を実行すると、 `/home/user/docs` [ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に移動する。\n\n```sh\n$ cd /home/user/docs\n```\n\n`..` を使用することで、1つ上の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を指定することができる。例えば以下の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)から見て1つ上の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)移動する。\n\n```sh\n$ cd ..\n```\n\n"},{"term":"mkdir","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ディレクトリの作成","content":"\n`mkdir` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、新しい[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を作成するための[コマンド](#コマンド)。 `mkdir` は\"make directory\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nmkdir [OPTION]... DIRECTORY...\n```\n\n`mkdir` [コマンド](#コマンド)に[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)名を指定すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)に指定した名前の[サブディレクトリ](../../../software/_/chapters/file_system.md#サブディレクトリ)が作成される。例えば以下の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)に `docs` という名前の新しい[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)が作成される。\n\n```sh\n$ mkdir docs\n```\n\n`mkdir` [コマンド](#コマンド)は一度に複数の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を作成することもできる。例えば以下の[コマンド](#コマンド)を実行すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)に `docs` と `music` と `pictures` という3つの新しい[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を同時に作成する。\n\n```sh\n$ mkdir docs music pictures\n```\n\n"},{"term":"rmdir","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ディレクトリの削除","content":"\n`rmdir` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、空の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を削除するための[コマンド](#コマンド)。 `rmdir` は\"remove directory\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nrmdir [OPTION]... DIRECTORY...\n```\n\n`rmdir` に[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)名を指定すると、[カレントディレクトリ](../../../software/_/chapters/file_system.md#カレントディレクトリ)にある指定した名前の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を削除する。例えば以下の[コマンド](#コマンド)を実行すると、 `docs` という名前の空の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を削除する。\n\n```sh\n$ rmdir docs\n```\n\n\n"},{"term":"ln","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"リンクの作成","content":"\n`ln` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[リンク](./file.md#リンク)を作成するために使用される[コマンド](#コマンド)。 `ln` は\"link\"の略語。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nln [OPTION]... [-T] TARGET LINK_NAME\nln [OPTION]... TARGET\nln [OPTION]... TARGET... DIRECTORY\nln [OPTION]... -t DIRECTORY TARGET...\n```\n\n例えば、 `/home/user/test.txt` という[ファイル](../../../software/_/chapters/file_system.md#ファイル)に対して `/home/user/test_link.txt` という[ハードリンク](./file.md#ハードリンク)を作成するには、次のような[コマンド](#コマンド)を実行する。\n\n```sh\n$ ln /home/user/test.txt /home/user/test_link.txt\n```\n\nまた、 `/home/user/docs` という[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対して `/home/user/docs_link` という[シンボリックリンク](./file.md#シンボリックリンク)を作成するには、次のような[コマンド](#コマンド)を実行する。\n\n```sh\n$ ln -s /home/user/docs /home/user/docs_link\n```\n\n`-s` [オプション](#オプション)を使用することで、[シンボリックリンク](./file.md#シンボリックリンク)を作成することができる。\n\n\n"},{"term":"find","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイルの検索","content":"\n`find` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、指定された[ディレクトリツリー](../../../software/_/chapters/file_system.md#ツリー構造)内で[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を検索するための[コマンド](#コマンド)。条件に合致する[ファイル](../../../software/_/chapters/file_system.md#ファイル)を見つけ出して、指定されたアクションを実行することができる。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nfind [OPTION]... [PATH] [EXPRESSION]...\n```\n\n`PATH` には検索を開始する[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[パス](../../../software/_/chapters/file_system.md#パス)を指定し、 `EXPRESSION` には検索条件を指定する。検索条件は、 `-name` や `-type` などの[オプション](#オプション)を指定することができる。例えば次の[コマンド](#コマンド)を実行すると、現在の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)以下で名前が `test.txt` である[ファイル](../../../software/_/chapters/file_system.md#ファイル)を検索する。\n\n```sh\n$ find . -name \"test.txt\"\n```\n\n`find` [コマンド](#コマンド)の主要な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                                                                                                                              |\n| ---------- | :------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `-name`    | ファイル名が指定したパターンに一致するファイルを検索する                                                                                          |\n| `-type`    | 指定したファイルタイプに一致するファイルを検索する（ `-type f` は通常ファイル、 `-type d` はディレクトリ、 `-type l` はシンボリックリンク）      |\n| `-mtime`   | ファイルの最終更新日時が指定した日数前（正）または後（負）であるファイルを検索する                                                                |\n| `-size`    | ファイルサイズが指定したサイズに一致したファイルを検索する（単位として `c` （バイト）、 `k` （キロバイト）、 `M` （メガバイト）などを指定できる） |\n| `-exec`    | 検索されたファイルに対して指定されたコマンドを実行する                                                                                            |\n\n"},{"term":"locate","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"データベースを利用したファイルの検索","content":"\n`locate` は、[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)内で指定した文字列にマッチする[ファイル](../../../software/_/chapters/file_system.md#ファイル)を高速に検索するための[コマンド](#コマンド)。 `find` [コマンド](#コマンド)よりも効率的で、パターンマッチングにも対応している。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nlocate [OPTION]... PATTERN\n```\n\n例えば以下の[コマンド](#コマンド)を実行すると、 `/etc` [ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)以下の `ssh` という名前を含む[ファイル](../../../software/_/chapters/file_system.md#ファイル)を検索する。\n\n```sh\n$ locate /etc/*ssh*\n```\n\n`locate` は、[ディスク](../../../hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)をスキャンすることなく、専用の[データベース](../../../../development/database/_/chapters/database.md#データベース)を利用するため、高速に動作する。ただし、[ファイルパス](../../../software/_/chapters/file_system.md#パス)の[データベース](../../../../development/database/_/chapters/database.md#データベース)が更新されていない可能性があるため、既に存在しない[ファイル](../../../software/_/chapters/file_system.md#ファイル)が表示されたり、存在する[ファイル](../../../software/_/chapters/file_system.md#ファイル)が表示されない可能性がある。最新の情報を手動で更新するには、 `updatedb` [コマンド](#コマンド)を実行する。主要な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                           |\n| ---------- | :----------------------------- |\n| `-i`       | 大文字と小文字を区別しない     |\n| `-l [NUM]` | 最大の検索結果数を指定する     |\n| `-c`       | 該当するファイルの数を表示する |\n\nパターンに複数のパターンを指定するとOR検索になり、 `-A | --alll` [オプション](#オプション)を指定するとAND検索になる。\n\n"},{"term":"updatedb","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"データベースを利用したファイルの検索","content":"\n`locate` は、[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)内で指定した文字列にマッチする[ファイル](../../../software/_/chapters/file_system.md#ファイル)を高速に検索するための[コマンド](#コマンド)。 `find` [コマンド](#コマンド)よりも効率的で、パターンマッチングにも対応している。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nlocate [OPTION]... PATTERN\n```\n\n例えば以下の[コマンド](#コマンド)を実行すると、 `/etc` [ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)以下の `ssh` という名前を含む[ファイル](../../../software/_/chapters/file_system.md#ファイル)を検索する。\n\n```sh\n$ locate /etc/*ssh*\n```\n\n`locate` は、[ディスク](../../../hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)をスキャンすることなく、専用の[データベース](../../../../development/database/_/chapters/database.md#データベース)を利用するため、高速に動作する。ただし、[ファイルパス](../../../software/_/chapters/file_system.md#パス)の[データベース](../../../../development/database/_/chapters/database.md#データベース)が更新されていない可能性があるため、既に存在しない[ファイル](../../../software/_/chapters/file_system.md#ファイル)が表示されたり、存在する[ファイル](../../../software/_/chapters/file_system.md#ファイル)が表示されない可能性がある。最新の情報を手動で更新するには、 `updatedb` [コマンド](#コマンド)を実行する。主要な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                           |\n| ---------- | :----------------------------- |\n| `-i`       | 大文字と小文字を区別しない     |\n| `-l [NUM]` | 最大の検索結果数を指定する     |\n| `-c`       | 該当するファイルの数を表示する |\n\nパターンに複数のパターンを指定するとOR検索になり、 `-A | --alll` [オプション](#オプション)を指定するとAND検索になる。\n\n"},{"term":"grep","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"ファイル内のパターン検索","content":"\n`grep` は、指定したパターンに一致する行を[ファイル](../../../software/_/chapters/file_system.md#ファイル)から検索し、マッチする行を出力するための[コマンド](#コマンド)。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```sh\ngrep [OPTION]... PATTERNS [FILE]...\ngrep [OPTION]... -e PATTERNS ... [FILE]...\ngrep [OPTION]... -f PATTERN_FILE ... [FILE]...\n```\n\n例えば以下の[コマンド](#コマンド)を実行すると、 `test.txt` [ファイル](../../../software/_/chapters/file_system.md#ファイル)内から `hello` という文字列を検索し、それが含まれる行を表示する。\n\n```sh\ngrep \"hello\" test.txt\n```\n\nまた以下の例では、現在の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)内の全ての[ファイル](../../../software/_/chapters/file_system.md#ディレクトリ)から、[正規表現](./text_processing_and_regex.md#正規表現)を用いて該当箇所を検索する。\n\n```sh\ngrep \"*.png\" *\n```\n\n主要な[オプション](#オプション)は以下の通り。\n\n| オプション | 概要                                             |\n| ---------- | :----------------------------------------------- |\n| `-i`       | 大文字小文字を区別せずに検索する                 |\n| `-v`       | パターンと一致しない行を検索する                 |\n| `-c`       | パターンと一致する行の数を表示する               |\n| `-n`       | パターンと一致する行の行番号を表示する           |\n| `-r`       | ディレクトリを再帰的に検索する                   |\n| `-l`       | ファイル名のみを表示する                         |\n| `-w`       | パターンと完全一致する行のみを検索する           |\n| `-E`       | 拡張正規表現を使用する                           |\n| `-F`       | パターンを正規表現ではなく、固定文字列として扱う |\n\n\n"},{"term":"which","link":"./note/ja/./computer/linux/_/chapters/basic_command.md","flagment":"コマンドの検索","content":"\n`which` は、[Linux](./linux.md#linux)および[UNIX系](../../../software/_/chapters/operating_system.md#unix)[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)で使用される、[コマンド](#コマンド)がどの場所にインストールされているかを特定するための[コマンド](#コマンド)。\n\n[コマンド](#コマンド)の書式は以下の通り。\n\n```\nwhich [OPTION] [--] PROGRAMNAME...\n```\n\n例えば以下の[コマンド](#コマンド)を実行すると、 `python` [コマンド](#コマンド)がインストールされている[パス](../../../software/_/chapters/file_system.md#パス)が表示される。\n\n```sh\n$ which python\n```\n\nデフォルトでは、 `PATH` [環境変数](./shell_and_terminal.md#環境変数)に定義された場所で[コマンド](#コマンド)を検索する。\n"},{"term":"/bin","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/boot","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/dev","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/etc","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/home","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/lib","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/lost+found","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/media","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/mnt","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/opt","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/proc","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/root","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/run","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/sbin","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/srv","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/sys","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/tmp","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/bin","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/include","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/lib","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/share","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/src","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/usr/local","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/cache","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/log","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/mail","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/spool","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/tmp","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"/var/www","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"fhs","content":"\n**FHS**(Filesystem Hierarchy Standard)は、[Linux](./linux.md#linux)の[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成の標準化仕様。[ディストリビューション](./linux.md#ディストリビューション)によって[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)構成に多少の違いはあるが、基本的にはFHSに準拠している。\n\n| ディレクトリ    | 説明                                                                                                  |\n| --------------- | :---------------------------------------------------------------------------------------------------- |\n| `/`             | ファイルシステムのルートディレクトリ                                                                  |\n| `├ bin/`        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      |\n| `├ boot/`       | ブートローダ関連のファイルを格納するディレクトリ                                                      |\n| `├ dev/`        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            |\n| `├ etc/`        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    |\n| `├ home/`       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                |\n| `├ lib/`        | `/bin` や `/sbin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                |\n| `├ lost+found/` | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  |\n| `├ media/`      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  |\n| `├ mnt/`        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            |\n| `├ opt/`        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            |\n| `├ proc/`       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            |\n| `├ root/`       | rootユーザのホームディレクトリ                                                                        |\n| `├ run/`        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             |\n| `├ sbin/`       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          |\n| `├ srv/`        | サービスを提供する際のデータを格納するディレクトリ                                                    |\n| `├ sys/`        | デバイスやドライバについての情報を格納するディレクトリ                                                |\n| `├ tmp/`        | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `├ usr/`        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  |\n| `│ ├ bin/`      | ユーザが利用するコマンドを格納するディレクトリ                                                        |\n| `│ ├ include/`  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                |\n| `│ ├ lib/`      | `/usr/bin` にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       |\n| `│ ├ share/`    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          |\n| `│ ├ src/`      | ソースコードを格納するためのディレクトリ                                                              |\n| `│ └ local/`    | ホスト固有のローカルデータを格納する第三階層（ `bin` や `lib` 、 `share` などを持つ）                 |\n| `└ var/`        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              |\n| `  ├ cache/`    | キャッシュファイルを格納するディレクトリ                                                              |\n| `  ├ log/`      | 各種ログファイルを格納するディレクトリ                                                                |\n| `  ├ mail/`     | ユーザのメールボックスとして利用されるディレクトリ                                                    |\n| `  ├ spool/`    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  |\n| `  ├ tmp/`      | 一時ファイルの置き場として利用されるディレクトリ                                                      |\n| `  └ www/`      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |\n\n\n"},{"term":"リンク","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"リンク","content":"\n**リンク**は、[ファイル](../../../software/_/chapters/file_system.md#ファイル)に別名をつける機能。リンクを利用することで、長い[パス](../../../software/_/chapters/file_system.md#パス)名を省略したり、複数[バージョン](../../../software/_/chapters/package.md#バージョン)の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を共存させたりすることができる。\n\n"},{"term":"シンボリックリンク（ソフトリンク）","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"シンボリックリンク","content":"\n**シンボリックリンク**（**ソフトリンク**）は、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[パス](../../../software/_/chapters/file_system.md#パス)を記憶する方法で、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されると無効な[リンク](../../../software/_/chapters/file_system.md#リンク)となる。[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[リンク](#リンク)や、別の[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)に対する[リンク](#リンク)を作成することができる。[Windows](../../../software/_/chapters/operating_system.md#windows)における**ショートカット**や、[macOS](../../../software/_/chapters/operating_system.md#macos)における**エイリアス**と似た機能。\n\n"},{"term":"ショートカット","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"シンボリックリンク","content":"\n**シンボリックリンク**（**ソフトリンク**）は、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[パス](../../../software/_/chapters/file_system.md#パス)を記憶する方法で、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されると無効な[リンク](../../../software/_/chapters/file_system.md#リンク)となる。[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[リンク](#リンク)や、別の[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)に対する[リンク](#リンク)を作成することができる。[Windows](../../../software/_/chapters/operating_system.md#windows)における**ショートカット**や、[macOS](../../../software/_/chapters/operating_system.md#macos)における**エイリアス**と似た機能。\n\n"},{"term":"エイリアス","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"シンボリックリンク","content":"\n**シンボリックリンク**（**ソフトリンク**）は、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[パス](../../../software/_/chapters/file_system.md#パス)を記憶する方法で、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されると無効な[リンク](../../../software/_/chapters/file_system.md#リンク)となる。[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[リンク](#リンク)や、別の[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)に対する[リンク](#リンク)を作成することができる。[Windows](../../../software/_/chapters/operating_system.md#windows)における**ショートカット**や、[macOS](../../../software/_/chapters/operating_system.md#macos)における**エイリアス**と似た機能。\n\n"},{"term":"ハードリンク","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"ハードリンク","content":"\n**ハードリンク**は、[ファイル](../../../software/_/chapters/file_system.md#ファイル)の実体を直接指し示して共有する[リンク](#リンク)。[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)上では[ファイル](../../../software/_/chapters/file_system.md#ファイル)のメタデータを**iノード**で管理しており、**iノード番号**という固有の番号で実体のデータと紐付けられている。ハードリンクは元の[ファイル](../../../software/_/chapters/file_system.md#ファイル)と同じiノード番号を指す参照カウントとなっているため、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されても実体にアクセスできる。\n\n\n"},{"term":"iノード","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"ハードリンク","content":"\n**ハードリンク**は、[ファイル](../../../software/_/chapters/file_system.md#ファイル)の実体を直接指し示して共有する[リンク](#リンク)。[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)上では[ファイル](../../../software/_/chapters/file_system.md#ファイル)のメタデータを**iノード**で管理しており、**iノード番号**という固有の番号で実体のデータと紐付けられている。ハードリンクは元の[ファイル](../../../software/_/chapters/file_system.md#ファイル)と同じiノード番号を指す参照カウントとなっているため、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されても実体にアクセスできる。\n\n\n"},{"term":"iノード番号","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"ハードリンク","content":"\n**ハードリンク**は、[ファイル](../../../software/_/chapters/file_system.md#ファイル)の実体を直接指し示して共有する[リンク](#リンク)。[ファイルシステム](../../../software/_/chapters/file_system.md#ファイルシステム)上では[ファイル](../../../software/_/chapters/file_system.md#ファイル)のメタデータを**iノード**で管理しており、**iノード番号**という固有の番号で実体のデータと紐付けられている。ハードリンクは元の[ファイル](../../../software/_/chapters/file_system.md#ファイル)と同じiノード番号を指す参照カウントとなっているため、[リンク](#リンク)先の[ファイル](../../../software/_/chapters/file_system.md#ファイル)が削除されても実体にアクセスできる。\n\n\n"},{"term":"ファイルディスクリプタ","link":"./note/ja/./computer/linux/_/chapters/file.md","flagment":"ファイルディスクリプタ","content":"\n**ファイルディスクリプタ**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)がアクセスする[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[標準入出力](./stdio_and_pipeline.md#標準入出力)などを[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)が識別するために用いる識別子。 $0$ から順番に整数の値が割り当てられる。\n\nファイルディスクリプタには、識別子とともに[ファイル](../../../software/_/chapters/file_system.md#ファイル)名、[ファイル](../../../software/_/chapters/file_system.md#ファイル)サイズ、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が操作中の[ファイル](../../../software/_/chapters/file_system.md#ファイル)内の位置、作成日時、更新日時などの情報が含まれている。\n\n通常は、 $0$ に[標準入力](./stdio_and_pipeline.md#標準入力)、 $1$ に[標準出力](./stdio_and_pipeline.md#標準出力)、 $2$ に[標準エラー出力](./stdio_and_pipeline.md#標準エラー出力)が[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)によって最初に用意されるため、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が[ファイル](../../../software/_/chapters/file_system.md#ファイル)をオープンすると $3$ から順番にディスクリプタが割り当てられる。\n\n\n"},{"term":"ユーザ","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザ","content":"\n**ユーザ**は、[Linux](./linux.md#linux)システムにログインしてシステムを使用するためのアカウント。各ユーザには一意のユーザ名が割り当てられており、各ユーザはそれぞれの[ホームディレクトリ](../../../software/_/chapters/file_system.md#ホームディレクトリ)を持つ。ユーザはシステム上で一意の**UID**によって識別される。\n\nユーザが作成した[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の所有者は、そのユーザ自身となる。\n\n[Linux](./linux.md#linux)では、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[アクセス権](#権限)を、ユーザごとにコントロールできる。\n\n"},{"term":"UID","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザ","content":"\n**ユーザ**は、[Linux](./linux.md#linux)システムにログインしてシステムを使用するためのアカウント。各ユーザには一意のユーザ名が割り当てられており、各ユーザはそれぞれの[ホームディレクトリ](../../../software/_/chapters/file_system.md#ホームディレクトリ)を持つ。ユーザはシステム上で一意の**UID**によって識別される。\n\nユーザが作成した[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の所有者は、そのユーザ自身となる。\n\n[Linux](./linux.md#linux)では、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[アクセス権](#権限)を、ユーザごとにコントロールできる。\n\n"},{"term":"whoami","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザ名の確認","content":"\n`whoami` は、[Linux](./linux.md#linux)上で現在ログインしている[ユーザ](#ユーザ)の[ユーザ](#ユーザ)名を確認するための[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nwhoami [OPTION]...\n```\n\n"},{"term":"useradd","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザの作成","content":"\n`useradd` は、[Linux](./linux.md#linux)上で新しい[ユーザ](#ユーザ)を作成するための[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nuseradd [OPTION]... LOGIN\nuseradd -D\nuseradd -D [OPTION]...\n```\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、新しい[ユーザ](#ユーザ)アカウント `foo` を作成できる。\n\n```sh\n$ useradd foo\n```\n\nまた、上記の[コマンド](./basic_command.md#コマンド)を実行すると、 `/home/foo` [ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)が作成され、 `foo` [ユーザ](#ユーザ)がこの[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を所有する。ただし、この時点ではパスワードが設定されていないため、[ユーザ](#ユーザ)はログインできない。パスワードを設定するには、以下の[コマンド](./basic_command.md#コマンド)を実行する必要がある。\n\n```sh\n$ passwd foo\n```\n\n"},{"term":"usermod","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザの変更","content":"\n`usermod` は、[Linux](./linux.md#linux)上で既存の[ユーザ](./user_and_permission.md#ユーザ)アカウントを変更するための[コマンド](./basic_command.md#コマンド)。主に以下のようなユーザアカウント情報を変更するために使用される。\n\n- [ユーザ](#ユーザ)名\n- [ユーザ](#ユーザ)パスワード\n- [ユーザ](#ユーザ)の所属する[グループ](#グループ)\n- [ユーザ](#ユーザ)アカウントの有効期限\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nusermod [OPTION]... LOGIN\n```\n\n例えば、[ユーザ](#ユーザ) `foo` の[ホームディレクトリ](../../../software/_/chapters/file_system.md#ホームディレクトリ)を `/home/bar` に変更する場合は、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ usermod --home /home/bar foo\n```\n\n[ユーザ](#ユーザ) `foo` の[メイングループ](#メイングループ)を `foo` から `bar` に変更する場合は、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ usermod -g bar foo\n```\n\n[ユーザ](#ユーザ) `foo` を[サブグループ](#サブグループ) `hoge` に追加する場合は、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ usermod -aG hoge foo\n```\n\n`usermod` [コマンド](./basic_command.md#コマンド)は[root権限](#rootユーザ)を持つ[ユーザ](#ユーザ)が実行する必要がある。\n\n"},{"term":"userdel","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザの削除","content":"\n`userdel` は、[Linux](./linux.md#linux)上で[ユーザ](#ユーザ)を削除するための[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nuserdel [OPTION]... LOGIN\n```\n\n例えば、[ユーザ](#ユーザ)名が `foo` の[ユーザ](#ユーザ)を削除するには、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ userdel foo\n```\n\nこの[コマンド](./basic_command.md#コマンド)の実行により、 `foo` はシステムから完全に削除されるが、[ホームディレクトリ](../../../software/_/chapters/file_system.md#ホームディレクトリ)やメールボックスといった[ユーザ](#ユーザ)データは削除されない。これらのデータを削除するには、 `-r` [オプション](./basic_command.md#オプション)を指定する。\n\n`userdel` [コマンド](./basic_command.md#コマンド)は[root権限](#rootユーザ)を持つ[ユーザ](#ユーザ)が実行する必要がある。\n\n"},{"term":"passwd","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ユーザパスワードの変更","content":"\n`passwd` は、[Linux](./linux.md#linux)で[ユーザ](#ユーザ)のパスワードを変更するために使用される[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\npasswd [OPTION]... LOGIN\n```\n\n例えば、[ユーザ](#ユーザ)名が `foo` の[ユーザ](#ユーザ)のパスワードを変更するには、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ passwd foo\n```\n\n`passwd` [コマンド](./basic_command.md#コマンド)を実行すると、[プロンプト](./shell_and_terminal.md#プロンプト)でパスワードの入力が要求される。\n\n`passwd` [コマンド](./basic_command.md#コマンド)は[root権限](#rootユーザ)を持つ[ユーザ](#ユーザ)が実行する必要がある。\n\n\n"},{"term":"グループ","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"グループ","content":"\n**グループ**は、複数の[ユーザ](#ユーザ)をひとまとめにする機能で、[アクセス権限](#権限)の設定や[ファイル](../../../software/_/chapters/file_system.md#ファイル)の[所有権](#所有権)管理などに利用される。グループを利用することで、[Linux](./linux.md#linux)上の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[アクセス権](#権限)をまとめてコントロールすることができる。グループはシステム上で一意の**GID**によって識別される。\n\n[ユーザ](#ユーザ)は必ずひとつの[メイングループ](#メイングループ)に所属しており、任意の数の[サブグループ](#サブグループ)に所属することができる。また、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)も必ずひとつのグループに所属している。\n\n"},{"term":"GID","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"グループ","content":"\n**グループ**は、複数の[ユーザ](#ユーザ)をひとまとめにする機能で、[アクセス権限](#権限)の設定や[ファイル](../../../software/_/chapters/file_system.md#ファイル)の[所有権](#所有権)管理などに利用される。グループを利用することで、[Linux](./linux.md#linux)上の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[アクセス権](#権限)をまとめてコントロールすることができる。グループはシステム上で一意の**GID**によって識別される。\n\n[ユーザ](#ユーザ)は必ずひとつの[メイングループ](#メイングループ)に所属しており、任意の数の[サブグループ](#サブグループ)に所属することができる。また、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)も必ずひとつのグループに所属している。\n\n"},{"term":"メイングループ","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"メイングループ","content":"\n**メイングループ**は、[ユーザ](#ユーザ)が必ずひとつ所属する[グループ](#グループ)で、通常は[ユーザ](#ユーザ)名と同名の[グループ](#グループ)が自動的に作成され、その[グループ](#グループ)がメイングループとして割り当てられる。例えば、 `foo` という[ユーザ](#ユーザ)を作成した時、その[ユーザ](#ユーザ)は `foo` というメイングループに所属する。\n\n[ユーザ](#ユーザ)が作成した[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の所有[グループ](#グループ)には、その[ユーザ](#ユーザ)のメイングループがデフォルトで割り当てられる。\n\n"},{"term":"サブグループ","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"サブグループ","content":"\n**サブグループ**は、[ユーザ](#ユーザ)が任意の数所属することができる[グループ](#グループ)。複数の[ユーザ](#ユーザ)が同じサブグループに所属することで、その[グループ](#グループ)が[所有者](#所有者)となっている[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に対する[アクセス権](#権限)をまとめて設定できる。\n\n"},{"term":"groups","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所属グループの確認","content":"\n`groups` は、[Linux](./linux.md#linux)上の[ユーザ](#ユーザ)の所属[グループ](#グループ)リストを確認するための[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\ngroups [USER]\n```\n\n"},{"term":"groupadd","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所属グループの作成","content":""},{"term":"groupmod","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所属グループの変更","content":""},{"term":"groupdel","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所属グループの削除","content":""},{"term":"所有者（オーナー）","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所有者","content":"\n**所有者**（**オーナー**）は、[Linux](./linux.md#linux)において[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)に割り当てられる、その[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の持ち主。また、[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)は必ずひとつの[グループ](#グループ)に所属している。通常は、その[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)を作成した[ユーザ](#ユーザ)が所有者となり、その[ユーザ](#ユーザ)の[メイングループ](#メイングループ)が[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[グループ]()となる。\n\n"},{"term":"chown","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"所有者の変更","content":"\n`chown` は、[Linux](./linux.md#linux)上で[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[所有者](#所有者)を変更するための[コマンド](./basic_command.md#コマンド)。 `chown` は \"change owner\"の略語。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\nchown [OPTION]... --reference=RFILE FILE...\n```\n\n例えば、[ファイル](../../../software/_/chapters/file_system.md#ファイル) `test.txt` の[所有者](#所有者)を `foo` に変更する場合は、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chown foo test.txt\n```\n\nまた、[所有者](#所有者)と[グループ](#グループ)を同時に変更する場合は、 `-R` [オプション](./basic_command.md#オプション)を付与して次のように[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chown -R foo:group test.txt\n```\n\n"},{"term":"chgrp","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"ファイルのグループの変更","content":"\n`chgrp` は、[Linux](./linux.md#linux)上で[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の所属[グループ](#グループ)を変更する[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nchgrp [OPTION]... GROUP FILE...\nchgrp [OPTION]... --reference=RFILE FILE...\n```\n\n例えば、 `test.txt` の所属[グループ](#グループ)を `hoge` に変更する場合は、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chgrp hoge test.txt\n```\n\n\n"},{"term":"権限（パーミッション）","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"権限","content":"\n**権限**（**パーミッション**）は、[Linux](./linux.md#linux)において[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)などのアクセス制御を行うための機能。[Linux](./linux.md3linux)の権限管理では、誰にどのような操作を許可するかを設定する。\n\n各[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)には、以下の3つの対象に対して権限を設定できる。\n\n| 権限           | シンボル | 概要                                                |\n| -------------- | -------- | :-------------------------------------------------- |\n| 所有者         | `u`      | ファイルやディレクトリの所有者が持つ権限            |\n| グループ       | `g`      | ファイルやディレクトリの所属するグループが持つ権限  |\n| その他のユーザ | `o`      | それ以外の第三者が持つ権限                          |\n\n通常、[所有者](#所有者)や[グループ](#グループ)には高い権限を設定しておき、その他の[ユーザ](#ユーザ)に与える権限は最低限に抑える。全ての[ユーザ](#ユーザ)を指し示す場合、シンボルとして `a` を用いる。\n\nまた、これらの対象に対して次の3つのアクションに対する許可設定を行う。\n\n| アクション          | ファイル               | ディレクトリ                       |\n| ------------------- | :--------------------- | :--------------------------------- |\n| 読み取り権限(read)  | ファイルの内容を表示   | ディレクトリ内のリスト表示         |\n| 書き込み権限(write) | ファイルの上書き、変更 | ディレクトリ内にファイル作成、削除 |\n| 実行権限(execute)   | 実行ファイルの実行     | そのディレクトリに移動             |\n\nまた、これらのアクションにはそれぞれ以下のようなシンボルと数値が割り当てられている。\n\n| アクション   | シンボル | 数値 |\n| ------------ | -------- | ---- |\n| 読み取り権限 | `r`      | `4`  |\n| 書き込み権限 | `w`      | `2`  |\n| 実行権限     | `x`      | `1`  |\n\n例えば、 `ls -l` を実行したときのある[ファイル](../../../software/_/chapters/file_system.md#ファイル)の権限が `-rwxr-x---` であった場合、最初の `-` は[ファイル](../../../software/_/chapters/file_system.md#ファイル)が通常ファイルであることを表し、その後ろの9文字は3文字区切りでそれぞれの対象に対する権限を表す。つまり、[所有者](#所有者)には読み取り権限と書き込み権限と実行権限が、[グループ](#グループ)には読み取り権限と実行権限が、その他の[ユーザ](#ユーザ)には何も権限が与えられていないという意味になる。また、これを数値で表現すると、 `750` となる。これは、与えられている権限の数値を足し合わせたものをそれぞれの対象に対して横に並べたものである（[所有者](#所有者)であれば `4+2+1` 、[グループ](#グループ)であれば `4+1` ）。\n\n"},{"term":"chmod","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"権限の変更","content":"\n`chmod` は、[Linux](./linux.md#linux)上の[ファイル](../../../software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../software/_/chapters/file_system.md#ディレクトリ)の[権限](#権限)を変更するための[コマンド](./basic_command.md#コマンド)。 `chmod` では、3桁の数字や記号により[権限](#権限)を操作することができる。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nchmod [OPTION]... MODE[,MODE]... FILE...\nchmod [OPTION]... OCTAL-MODE FILE...\nchmod [OPTION]... --reference=RFILE FILE...\n```\n\n数値を用いて[ファイル](../../../software/_/chapters/file_system.md#ファイル)の[権限](#権限)を変更する場合、次のような[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chmod 650 filename\n```\n\n[所有者](#所有者)に[書き込み権限](#権限)を与える場合、次のような[コマンド](#コマンド)を実行する。\n\n```sh\n$ chmod u+w filename\n```\n\n[グループ](#グループ)とその他の[ユーザ](#ユーザ)の[権限](#権限)を[読み取り権限](#権限)と[実行権限](#権限)にする場合、次のような[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chmod go=rx filename\n```\n\n全ての[ユーザ](#ユーザ)の[実行権限](#権限)を削除する場合、次のような[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ chmod a-x filename\n```\n\n\n"},{"term":"rootユーザ（スーパーユーザ）","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"rootユーザ","content":"\n**rootユーザ**（**スーパーユーザ**）は、あらゆる操作が許可されたシステム上で最高の特権を持つ[ユーザ](#ユーザ)。rootユーザに対して通常の作業に利用する[ユーザ](#ユーザ)は一般ユーザという。すべての[ファイル](../../../software/_/chapters/file_system.md#ファイル)やシステムリソースにアクセスすることができ、システム管理者として、[ユーザ](#ユーザ)や[グループ](#グループ)の管理、システムの設定や保守、[パッケージ](./linux.md#パッケージ)管理などを行う。\n\n一般的には、rootユーザはセキュリティ上の理由から普段は使用せず、必要な場合にのみログインして作業を行う。また、rootユーザは[Linux](./linux.md#linux)システムを動作させるのに必須の[ファイル](../../../software/_/chapters/file_system.md#ファイル)を削除するといった危険な操作も可能なため、慎重に作業する必要がある。\n\n"},{"term":"su","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"rootユーザへの切り替え","content":"\n`su` は、[Linux](./linux.md#linux)で一時的に別の[ユーザ](#ユーザ)に切り替えて作業するための[コマンド](./basic_command.md#コマンド)。[ユーザ](#ユーザ)を指定しなかった場合は[rootユーザ](#rootユーザ)に切り替える。 `su` は\"substitute user\"の略語。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nsu [OPTION]... [-] [USER [ARGUMENT...]]\n```\n\n一般的には[ユーザ](#ユーザ)名を省略して、[rootユーザ](#rootユーザ)に切り替える目的で用いられることが多い。[コマンド](./basic_command.md#コマンド)を実行すると、[プロンプト](./shell_and_terminal.md#プロンプト)で、切り替えたい対象[ユーザ](#ユーザ)のパスワード入力を求められる。例えば、[ユーザ](#ユーザ)名が `foo` の[ユーザ](#ユーザ)としてログイン中、一時的に[rootユーザ](#rootユーザ)に切り替えたい場合、次の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ su\n```\n\nまた、[rootユーザ](#rootユーザ)からログアウトして `foo` [ユーザ](#ユーザ)に復帰するには、 `exit` [コマンド](#コマンド)を実行する。\n\n"},{"term":"sudo","link":"./note/ja/./computer/linux/_/chapters/user_and_permission.md","flagment":"rootユーザとしてコマンド実行","content":"\n`sudo` は、[Linux](./linux.md#linux)で別の[ユーザ](#ユーザ)として[コマンド](./basic_command.md#コマンド)を実行するために利用される[コマンド](./basic_command.md#コマンド)。[ユーザ](#ユーザ)名を指定しなかった場合は[rootユーザ](#rootユーザ)として[コマンド](./basic_command.md#コマンド)を実行する。\n\n一般的には[ユーザ](#ユーザ)名を省略して、[rootユーザ](#rootユーザ)に切り替える目的で用いられることが多い。[コマンド](./basic_command.md#コマンド)を実行すると、[プロンプト](./shell_and_terminal.md#プロンプト)で、ログイン中の[ユーザ](#ユーザ)のパスワード入力を求められる。例えば、[ユーザ](#ユーザ)名が `foo` の[ユーザ](#ユーザ)としてログイン中、[rootユーザ](#rootユーザ)として `cat` [コマンド](./basic_command.md#コマンド)を使用し `test.txt` を閲覧したい場合、以下の[コマンド](./basic_command.md#コマンド)を実行する。\n\n```sh\n$ sudo cat test.txt\n```\n\nsudoの設定を変更するには、以下の[コマンド](./basic_command.md#コマンド)で設定ファイルを開いて編集する（通常の[テキストエディタ](./text_editor.md)で開いて編集して、書き方を誤ると、 `sudo` が使えなくなる可能性があるため）。\n\n```sh\n$ visudo\n```\n\n`sudo` の許可設定は次のように記述される。\n\n```\n%wheel ALL=(ALL) NOPASSWD: ALL\n```\n\nこれは、 `wheel` [グループ](#グループ)に所属する[ユーザ](#ユーザ)が、パスワードの入力無しで `sudo` が利用できることを意味する。\n\n```\nfoo ALL=(ALL) ALL\n```\n\nこれは、 `foo` [ユーザ](#ユーザ)が `sudo` を利用できることを意味する。\n"},{"term":"vi","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vi","content":"\n**vi**は、[Linux](./linux.md#linux)に標準で搭載されているテキストエディタのひとつ。viは[コマンドライン](../../../software/_/chapters/software.md#cui)から実行され、[ターミナル](./shell_and_terminal.md#ターミナル)上で動作する。viには高度な機能が多く搭載されており、モードを切り替えながら操作を行う。\n\nviでは全ての操作がキーボードで行われ、[GUI](../../../software/_/chapters/software.md#gui)[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に慣れたユーザにとっては扱いにくい場合もある。\n\n"},{"term":"vim","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"ノーマルモード","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"インサートモード","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"ビジュアルモード","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"セレクションモード（矩形選択モード）","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"コマンドラインモード","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"vim","content":"\n**Vim**は、[Linux](./linux.md#linux)の中でも非常に一般的なテキストエディタで、[vi](#vi)を拡張したもの。Vimは標準で多くの機能を持っており、拡張性も高いため多数のプラグインが存在する。\n\n以下の[コマンド](./basic_command.md#コマンド)を実行することで、Vimを起動することができる。\n\n```sh\n$ vim\n```\n\nVimには次のようなモードがある。\n\n**ノーマルモード**は、Vim上でコマンドを入力するモードで、Vimエディタを起動したときのデフォルトのモード。テキスト[ファイル](../../../software/_/chapters/file_system.md3ファイル)を編集するための各種コマンドを実行することができる。テキストの移動やコピー、貼り付け、削除、検索などのコマンドがある。ノーマルモードでの基本的な操作方法は以下の通り。\n\n| キー                  | 概要                                                                 |\n| --------------------- | :------------------------------------------------------------------- |\n| `:`                   | コマンドラインモードに移行する                                       |\n| `k` `j` `h` `l`       | カーソルを上下左右にひとつ移動する                                   |\n| `i`                   | カーソルの後方からインサートモードに移行する                         |\n| `a`                   | カーソルの前方からインサートモードに移行する                         |\n| `I`                   | カーソルを行頭に移動してインサートモードに移行する                   |\n| `A`                   | カーソルを行末に移動してインサートモードに移行する                   |\n| `o`                   | カーソルのある行の下に新しい行を追加してインサートモードに移行する   |\n| `O`                   | カーソルのある行の上に新しい行を追加してインサートモードに移行する   |\n| `v`                   | ビジュアルモードに移行する                                           |\n| `Ctrl + v`            | セレクションモードに移行する                                         |\n| `gg`                  | 最初の行に移動する                                                   |\n| `G`                   | 最後の行に移動する                                                   |\n| `w`                   | 次の単語の先頭に移動する                                             |\n| `W`                   | 次の単語の末尾に移動する                                             |\n| `b`                   | 前の単語の先頭に移動する                                             |\n| `B`                   | 前の単語の末尾に移動する                                             |\n| `f + (文字)`          | カーソルの後方の文字を行内検索し、見つかった場所に移動する           |\n| `F + (文字)`          | カーソルの前方の文字を行内検索し、見つかった場所に移動する           |\n| `0` `^`               | 行頭に移動する（ `0` はインデントを無視する）                        |\n| `$`                   | 行末に移動する                                                       |\n| `Ctrl + u` `Ctrl + d` | 半画面スクロールアップ、スクロールダウンする                         |\n| `Ctrl + b` `Ctrl + f` | 全画面スクロールアップ、スクロールダウンする                         |\n| `/ + (検索パターン)`  | 順方向にファイル内検索する（ `n` で次の候補、 `N` 出前の候補に移動） |\n| `u`                   | Undo（直前の変更を取り消す）                                         |\n| `Ctrl + r`            | Redo（直前の変更の取り消しを戻す）                                   |\n| `>>`                  | インデントを追加する                                                 |\n| `>>`                  | インデントを削除する                                                 |\n| `r + (文字)`          | カーソルの下の文字を置換する                                         |\n| `x`                   | カーソルの下の文字を削除する                                         |\n| `dd`                  | カーソルのある行を削除する                                           |\n| `y`                   | カーソルの下の文字をヤンク（コピー）                                 |\n| `yy`                  | カーソルのある行をヤンク（コピー）                                   |\n| `p`                   | クリップボードの中身をペースト                                       |\n\n**インサートモード**は、テキストを入力するモード。ノーマルモードからインサートモードに移行するには、 `i` キーか `a` キーを入力する。インサートモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**ビジュアルモード**は、テキストを選択するモード。ノーマルモードからビジュアルモードに移行するには、 `v` キーを入力する。ビジュアルモードでは、テキストを選択して、コピーや削除、置換などの操作を実行することができる。ビジュアルモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**セレクションモード**（**矩形選択モード**）は、テキストの矩形選択を行うモード。ノーマルモードからセレクションモードに移行するには、 `Ctrl + v` キーを入力する。セレクションモードでは、テキストの矩形領域を選択して、コピーや削除、置換などの操作を実行することができる。セレクションモードからノーマルモードに復帰するには、 `Esc` キーを入力する。\n\n**コマンドラインモード**は、[ファイル](../../../software/_/chapters/file_system.md3ファイル)の保存や終了、設定変更などのコマンドを入力するモード。ノーマルモードからコマンドラインモードに移行するには、 `:` キーを入力する。コマンドを入力して実行するには、 `Enter` キーを入力する。コマンド実行後は自動でノーマルモードに移行する。基本的なコマンドは以下の通り。\n\n| コマンド           | 概要                          |\n| ------------------ | :---------------------------- |\n| `w`                | 内容を保存                    |\n| `q`                | Vimを終了する                 |\n| `q!`               | Vimを強制終了する             |\n| `wq`               | 内容を保存して、Vimを終了する |\n| `e + (ファイル名)` | ファイルを開く                |\n| `nohlsearch`       | 検索ハイライトを解除する      |\n| `set number`       | 行数表示を有効にする          |\n\n\n"},{"term":"Emacs","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"emacs","content":"\n**Emacs**は、[Linux](./linux.md#linux)で一般的に利用されるテキストエディタの一種で、GNUプロジェクトの一部として開発されたフリー[ソフトウェア](../../../software/_/chapters/software.md#ソフトウェア)。拡張性やカスタマイズ性が高いのが特徴で、[GUI](../../../software/_/chapters/software.md#gui)[コンピュータ](../../../_/chapters/computer.md#コンピュータ)に慣れたユーザにとっては扱いにくい場合もある。Emacsにおける基本操作は以下の通り。\n\n| キー       | 概要                     |\n| ---------- | :----------------------- |\n| `Ctrl + p` | カーソルを上に移動する   |\n| `Ctrl + n` | カーソルを下に移動する   |\n| `Ctrl + f` | カーソルを右に移動する   |\n| `Ctrl + b` | カーソルを左に移動する   |\n| `Ctrl + a` | カーソルを行頭に移動する |\n| `Ctrl + e` | カーソルを行末に移動する |\n| `Ctrl + s` | 前方検索を行う           |\n| `Ctrl + r` | 後方検索を行う           |\n\n\n"},{"term":"nano","link":"./note/ja/./computer/linux/_/chapters/text_editor.md","flagment":"nano","content":"\n**nano**は、[Linux](./linux.md#linux)におけるテキストエディタのひとつで、[vi](#vi)や[Emacs](#emacs)よりもシンプルで使いやすく、初心者にも親しみやすい。\n"},{"term":"プロセス","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセス","content":"\n**プロセス**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上で[実行状態](../../../software/_/chapters/operating_system.md#実行状態)にある[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。[Linux](./linux.md#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)は[ストレージ](../../../hardware/_/chapters/hardware.md#記憶装置)装置から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を読み出し、その[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容に従って[CPU](../../../hardware/_/chapters/processor.md#cpu)が[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行する。プロセスはシステム上で一意の**PID**によって識別される。\n\nひとつの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や[コマンド](./basic_command.md#コマンド)が複数のプロセスを生成したり、プロセスがさらにプロセスを生成することもある。あるプロセスによって生み出された別のプロセスは、そのプロセスの子プロセスとなる。\n\nプロセスは[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)の[タスクスケジューラ](../../../software/_/chapters/operating_system.md#タスク管理システム)によって制御され、[実行可能状態](../../../software/_/chapters/operating_system.md#実行可能状態)、[実行状態](../../../software/_/chapters/operating_system.md#実行状態)、[待ち状態](../../../software/_/chapters/operating_system.md#待ち状態)といった状態を遷移しながら処理が進められる。\n\n"},{"term":"PID","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセス","content":"\n**プロセス**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上で[実行状態](../../../software/_/chapters/operating_system.md#実行状態)にある[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。[Linux](./linux.md#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)は[ストレージ](../../../hardware/_/chapters/hardware.md#記憶装置)装置から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を読み出し、その[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容に従って[CPU](../../../hardware/_/chapters/processor.md#cpu)が[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行する。プロセスはシステム上で一意の**PID**によって識別される。\n\nひとつの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や[コマンド](./basic_command.md#コマンド)が複数のプロセスを生成したり、プロセスがさらにプロセスを生成することもある。あるプロセスによって生み出された別のプロセスは、そのプロセスの子プロセスとなる。\n\nプロセスは[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)の[タスクスケジューラ](../../../software/_/chapters/operating_system.md#タスク管理システム)によって制御され、[実行可能状態](../../../software/_/chapters/operating_system.md#実行可能状態)、[実行状態](../../../software/_/chapters/operating_system.md#実行状態)、[待ち状態](../../../software/_/chapters/operating_system.md#待ち状態)といった状態を遷移しながら処理が進められる。\n\n"},{"term":"fork","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"fork","content":"\n**fork**は、親[プロセス](#プロセス)から子[プロセス](#プロセス)を生成する[システムコール](../../../software/_/chapters/operating_system.md#システムコール)のひとつ。親[プロセス](#プロセス)からforkが呼び出されると、システムは親[プロセス](#プロセス)の複製を作成し、それが子[プロセス](#プロセス)となる。子[プロセス](#プロセス)は親[プロセス](#プロセス)の状態を複製することによって生成されるため、実行される[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は親[プロセス](#プロセス)と共通となる。子[プロセス](#プロセス)は親[プロセス](#プロセス)とは独立して動作し、親[プロセス](#プロセス)と異なる[PID](#プロセス)を持つ。\n\n"},{"term":"clone","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"clone","content":"\n**clone**は、親[プロセス](#プロセス)から子[プロセス](#プロセス)を生成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)のひとつ。[fork](#fork)と同様に、親[プロセス](#プロセス)の複製を子[プロセス](#プロセス)として生成する。cloneでは、親[プロセス](#プロセス)と子[プロセス](#プロセス)の間で共有されるリソースを指定することができ、複数の[プロセス](#プロセス)を協調させることができる。\n\n"},{"term":"exec","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"exec","content":"\n**exec**は、現在の[プロセス](#プロセス)を新しい[プロセス](#プロセス)に置き換える[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。execを使用することで、[プロセス](#プロセス)の実行中に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を切り替えたり[プロセス](#プロセス)の状態を維持したまま[プログラム](../../../../programming/_/chapters/programming.md#プログラム)をリロードしたりすることができる。\n\n"},{"term":"ps","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセスの確認","content":"\n`ps` は、[プロセス](#プロセス)の状態を表示するための[コマンド](./basic_command.md#コマンド)。 `ps` は\"process status\"の略語。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nps [OPTION]...\n```\n\n`ps` [コマンド](./basic_command.md#コマンド)を実行すると、この[コマンド](./basic_command.md#コマンド)を実行した[ユーザ](./user_and_permission.md#ユーザ)が起動している[プロセス](#プロセス)のリストが表示される。\n\n```sh\n$ ps\n    PID TTY          TIME CMD\n    425 pts/0    00:00:00 zsh\n    689 pts/0    00:00:00 ps\n```\n\n`ps` の主要な[オプション](./basic_command.md#オプション)は以下の通り。\n\n| オプション | 概要                                               |\n| ---------- | :------------------------------------------------- |\n| `a`        | 全てのユーザのプロセスの状態を表示する             |\n| `f`        | プロセスの親子関係をツリー上にして表示する         |\n| `u`        | プロセスのユーザ名と開始時刻を表示内容に付加する   |\n| `x`        | 制御端末を持たないデーモンなどのプロセスも表示する |\n| `l`        | 詳細情報を表示する                                 |\n| `-e`       | 全プロセスの情報を表示する　                       |\n\n[オプション](./basic_command.md#オプション)は、以下の例のように複数個まとめて指定することもできる。\n\n```sh\n$ ps aux\n```\n\n"},{"term":"pstree","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセスツリーの確認","content":"\n`pstree` は、[プロセス](#プロセス)の親子関係をツリー形式で表示するための[コマンド](./basic_command.md#コマンド)。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\npstree [OPTION]...\n```\n\n`pstree` の主要な[オプション](./basic_command.md#オプション)は以下の通り。\n\n| オプション | 概要                                            |\n| ---------- | :---------------------------------------------- |\n| `-p`       | 各プロセスのPIDを表示する                       |\n| `-u`       | 各プロセスの実行ユーザ名を表示する              |\n| `-h`       | ルートプロセスを表示しない                      |\n| `-a`       | 各プロセスのコマンドライン引数も表示する        |\n| `-n`       | 各プロセスの名前をソートせず、PIDの順に表示する |\n| `-c`       | 同じ名前のプロセスをまとめて表示する            |\n| `-G`       | 指定したグループIDを持つプロセスのみ表示する    |\n| `-U`       | 指定したユーザIDを持つプロセスのみ表示する      |\n\n"},{"term":"top","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセスのリアルタイム監視","content":"\n`top` は、[Linux](./linux.md#linux)システムで実行されている[プロセス](#プロセス)をリアルタイムで監視するための[コマンド](./basic_command.md#コマンド)。 `top` [コマンド](./basic_command.md#コマンド)で確認できる情報は以下の通り。\n\n| ラベル | 概要                                                                                        |\n| ------ | :------------------------------------------------------------------------------------------ |\n| PID    | 各プロセスのPID                                                                             |\n| USER   | 各プロセスを発行しているユーザ                                                              |\n| PR     | プロセスの優先度                                                                            |\n| NI     | プロセスの優先度を調整するために使用されるニース値                                          |\n| VIRT   | プロセスが使用している仮想メモリサイズ                                                      |\n| RES    | プロセスが使用している物理メモリサイズ                                                      |\n| SHR    | プロセスが使用している共有メモリサイズ                                                      |\n| S      | プロセスの現在の状態（D: 割込み不能、R: 実行中、S: スリープ、T: 停止中、Z: ゾンビプロセス） |\n| %CPU   | プロセスが使用しているCPUの割合                                                             |\n| %MEM   | プロセスが使用している物理メモリの割合                                                      |\n| TIME+  | プロセスが起動している時間                                                                  |\n\n"},{"term":"kill","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"プロセスの強制終了","content":"\n`kill` は、実行中の[プロセス](#プロセス)に[シグナル](#シグナル)を送信する[コマンド](./basic_command.md#コマンド)。[プロセス](#プロセス)を強制終了する場合などによく用いられる。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nkill [SIGNAL] PID\n```\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、[PID](#プロセス)が1234の[プロセス](#プロセス)に `TERM` [シグナル](#シグナル)を送信する。\n\n```sh\n$ kill -TERM 1234\n```\n\n`kill` は[プロセス](#プロセス)を強制終了するために用いられることが多いが、[プロセス](#プロセス)を停止したり再開したりするための他の[オプション](./basic_command.md#オプション)もある。\n\nまた、 `pkill` は[プロセス](#プロセス)名指定で[プロセス](#プロセス)を強制終了する[コマンド](./basic_command.md#コマンド)、 `killall` は[プロセス](#プロセス)名指定で全ての[プロセス](#プロセス)を強制終了する[コマンド](./basic_command.md#コマンド)となっている。\n\n"},{"term":"free","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"メモリの監視","content":"\n`free` は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の使用状況を表示するための[コマンド](./basic_command.md#コマンド)。主に以下の情報を表示する。\n\n| ラベル       | 概要                                           |\n| ------------ | :--------------------------------------------- |\n| `total`      | システム全体の物理メモリ量                     |\n| `useed`      | 使用中の物理メモリ量                           |\n| `free`       | 空き物理メモリ量                               |\n| `shared`     | 共有メモリ量                                   |\n| `buff/cache` | バッファやキャッシュに使われている物理メモリ量 |\n| `available`  | アプリケーションに使用可能な物理メモリ量       |\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nfree [OPTION]...\n```\n\n`free` の主要な[オプション](./basic_command.md#オプション)は以下の通り。\n\n| オプション       | 概要                                         |\n| ---------------- | :------------------------------------------- |\n| `-b` `--bytes`   | 結果をバイト単位で表示する                   |\n| `-k` `--kilo`    | 結果をキロバイト単位で表示する（デフォルト） |\n| `-m` `--mega`    | 結果をメガバイト単位で表示する               |\n| `-g` `--giga`    | 結果をギガバイト単位で表示する               |\n| `-h` `--human`   | より読みやすい形式で表示する                 |\n| `-t` `--total`   | 全体のメモリ使用量のみを表示する             |\n| `-s` `--seconds` | 指定した秒数ごとに繰り返し表示する           |\n| `-c` `--count`   | 指定した回数繰り返し表示する                 |\n\n\n"},{"term":"ジョブ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ジョブ","content":"\n**ジョブ**は、1つの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や[コマンド](./basic_command.md#コマンド)といった実行単位のことで、1つ以上の[プロセス](#プロセス)をまとめたもの。[シェル](./shell_and_terminal.md#シェル)に入力された1行分が1つのジョブに対応し、ジョブは必要に応じて[プロセス](#プロセス)に分解されて処理される。\n\n"},{"term":"フォアグラウンドジョブ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"フォアグラウンドジョブ","content":"\n**フォアグラウンドジョブ**は、[シェル](./shell_and_terminal.md#シェル)によって起動される[ジョブ](#ジョブ)。通常、[コマンド](./basic_command.md#コマンド)を実行するとフォアグラウンドで[ジョブ](#ジョブ)が生成され、その[ジョブ](#ジョブ)が終了するまでは[シェル](./shell_and_terminal.md#シェル)は[プロンプト](./shell_and_terminal.md#プロンプト)を返さない。フォアグラウンドジョブは[シェル](./shell_and_terminal.md#シェル)への入力を受け付ける状態となり、[ユーザ](./user_and_permission.md#ユーザ)は対話的に[プロセス](#プロセス)に対して[シグナル](#シグナル)を送信することができる。\n\n"},{"term":"バックグラウンドジョブ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"バックグラウンドジョブ","content":"\n**バックグラウンドジョブ**は、[シェル](./shell_and_terminal.md#シェル)とは切り離して実行される[ジョブ](#ジョブ)。[コマンド](./basic_command.md#コマンド)の末尾に `&` を追加して実行すると、その[コマンド](./basic_command.md#コマンド)はバックグラウンドジョブとして実行される。バックグラウンドジョブ（[プロセス](#プロセス)）に[シグナル](#シグナル)を送信するには、 `kill` [コマンド](./basic_command.md#コマンド)を使用する。\n\n"},{"term":"ジョブコントロール","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ジョブコントロール","content":"\n[フォアグラウンドジョブ](#フォアグラウンドジョブ)のコントロールに用いられるキーは以下の通り。\n\n| キー         | 概要                                                   |\n| ------------ | :----------------------------------------------------- |\n| `Ctrl` + `c` | `SIGINT` シグナルを送出し、プロセスを終了する          |\n| `Ctrl` + `z` | ジョブの実行を中断し、バックグラウンドジョブに退避する |\n\n"},{"term":"jobs","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ジョブの確認","content":"\n`jobs` は、アクティブな[ジョブ](#ジョブ)の一覧を確認するための[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の例では、バックグラウンドで実行中の `sleep` [コマンド](./basic_command.md#コマンド)の状態を `jobs` によって確認している。[バックグラウンドジョブ](#バックグラウンドジョブ)の処理が終わると、[プロンプト](./shell_and_terminal.md#プロンプト)にその旨が表示される。\n\n```sh\n$ sleep 60 &\n[1] 2400\n\n$ jobs\n[1]  + running    sleep 10\n\n$\n[1]  + done       sleep 10\n```\n\n"},{"term":"fg","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"フォアグラウンドジョブとして実行","content":"\n`fg` は、[ジョブ](#ジョブ)を[フォアグラウンドジョブ](#フォアグラウンドジョブ)として実行する[コマンド](./basic_command.md#コマンド)。\n\n以下の例では、バックグラウンドで実行中の `sleep` をフォアグラウンドに切り替えている。\n\n```sh\n$ sleep 60 &\n[1] 2744\n\n$ jobs\n[1]    running    sleep 20\n\n$ fg %1\n[1]    running    sleep 20\n```\n\n"},{"term":"bg","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"バックグラウンドジョブとして実行","content":"\n`bg` は、[ジョブ](#ジョブ)を[バックグラウンドジョブ](#バックグラウンドジョブ)として実行する[コマンド](./basic_command.md#コマンド)。\n\n以下の例では、フォアグラウンドで実行していた `sleep` を `Ctrl` + `z` で一度バックグラウンドにサスペンドし、それを改めて[バックグラウンドジョブ](#バックグラウンドジョブ)として再開している。\n\n```sh\n$ sleep 60\n\n"},{"term":"スレッド","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"スレッド","content":"\n**スレッド**は、1つの[プロセス](#プロセス)から生成される実行単位で、[プロセス](#プロセス)内で複数のタスクを並行して実行するなどの目的で使用される。複数のスレッドは同じ[プログラム](../../../../programming/_/chapters/programming.md#プログラム)コード、データ、[ヒープ](../../../hardware/_/chapters/memory.md#ヒープ領域)などを共有している。スレッドは[プロセス](#プロセス)よりも軽量で、[プロセス間通信](#プロセス間通信)に比べてスレッド通信は高速である。\n\n\n"},{"term":"デーモン","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"デーモン","content":"\n**デーモン**は、メイン[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上に常駐して特定の機能を提供する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。デーモンは[initプロセス](#initプロセス)や[systemd](#systemd)によってシステムの起動時に実行され、バックグラウンドで動作しながら処理要求があったときに処理を実行する。[Web](../../../../network/_/chapters/web.md#web)[サーバ](../../../_/chapters/computer.md#サーバ)やバッチ[プログラム](../../../../programming/_/chapters/programming.md#プログラム)などがこれに該当し、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)名の末尾に `d` がつくのが慣例となっている（ `httpd` 、 `crond` など）。\n\n\n"},{"term":"initプロセス","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"initプロセス","content":"\n**initプロセス**は、[Linux](./linux.md#linux)システムが起動された時に最初に実行され、システムの全ての[プロセス](#プロセス)の親[プロセス](#プロセス)として機能する[プロセス](#プロセス)。システムのランレベルの設定や各種[サービス](#サービス)、[デーモン](#デーモン)の起動などを行う。initプロセスの[PID](#プロセス)は必ず1となる。\n\ninitプロセスは `/sbin/init` [ファイル](../../../software/_/chapters/file_system.md#ファイル)から起動され、起動時に設定されたランレベルに応じて必要な[サービス](#サービス)や[プロセス](#プロセス)を開始する。通常は、ランレベルは `０` から `6` までの7段階があり、ランレベル `0` はシャットダウン、ランレベル `6` は再起動を表す。管理者はそれぞれのランレベルに合わせた[スクリプト](./shell_script.md#シェルスクリプト)を用意して、必要な[デーモン](#デーモン)の起動処理などを記述する。\n\n新しい[Linuxディストリビューション](./linux.md#ディストリビューション)の多くでは、initプロセスに代わって[systemd](#systemd)が利用される場合が多い。\n\n\n"},{"term":"systemd","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"systemd","content":"\n**systemd**は、[Linux](./linux.md#linux)システムが起動された時に最初に実行される[プロセス](#プロセス)で、システムのブートプロセスや[サービス](#サービス)管理を行うシステム管理[デーモン](#デーモン)。従来の[initプロセス](#initプロセス)の代替として設計されており、[プロセス](#プロセス)の開始、監視、制御、終了等を行うことができる。systemdでは、[デーモン](#デーモン)や[サービス](#サービス)の依存関係や起動順序、停止順序などを管理することができる。systemdの[PID](#プロセス)は必ず1となる。\n\nsystemdでは各[サービス](#サービス)がユニットファイルとして定義され、systemdによって自動的に管理される。また、 `systemctl` [コマンド](./basic_command.md#コマンド)を利用して[サービス](#サービス)のステータス確認や起動、停止、再起動、有効化、無効化などを行うことができる。\n\n"},{"term":"サービス","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービス","content":"\n**サービス**は、[Linux](./linux.md#linux)システムが起動された時に開始される[デーモン](#デーモン)[プロセス](#プロセス)。[デーモン](#デーモン)と同じ意味で使用される場合も多い。\n\n"},{"term":"systemctl","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの管理","content":"\n`systemctl` は、[systemd](#systemd)を制御するために使用される[コマンド](./basic_command.md#コマンド)。[サービス](#サービス)の起動や停止、有効化、無効化などを行う[サービス](#サービス)マネージャであり、システムの管理に必要な[サブコマンド](./basic_command.md#サブコマンド)が用意されている。\n\n[コマンド](./basic_command.md#コマンド)の書式は以下の通り。\n\n```\nsystemctl [OPTIONS...] COMMAND [UNIT...]\n```\n\n"},{"term":"systemctl start","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの開始","content":"\n`systemct start` は、[systemd](#systemd)を使用して[Linux](./linux.md#linux)システム上の[サービス](#サービス)を開始する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)を開始する。\n\n```sh\n$ systemctl start httpd\n```\n\nただし、システムを再起動した際には開始した[サービス](#サービス)は起動されないので、自動で開始したい場合は `systemctl enable` を使用する。\n\n"},{"term":"systemctl stop","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの停止","content":"\n`systemctl stop` は、[systemd](#systemd)を使用して[Linux](./linux.md#linux)システム上の[サービス](#サービス)を停止する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)を停止する。\n\n```sh\n$ systemctl stop httpd\n```\n\nただし、自動的に開始されるように設定されている[サービス](#サービス)は、システムを再起動したときに開始されてしまうので、完全に停止したい場合は `systemctl disable` を使用する。\n\n"},{"term":"systemctl restart","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの再起動","content":"\n`systemctl restart` は、[systemd](#systemd)を使用して[Linux](./linux.md#linux)システム上の[サービス](#サービス)を再起動する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)を再起動する。\n\n```sh\n$ systemctl restart httpd\n```\n\nこれは、[サービス](#サービス)の設定ファイルを変更して、再度その内容を読み込みたい場合などによく用いられる。\n\n"},{"term":"systemctl status","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの状態確認","content":"\n`systemctl status` は、[systemd](#systemd)を使用して[Linux](#linux.md#linux)システム上の[サービス](#サービス)の状態を確認する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)の状態を表示する。\n\n```sh\n$ systemctl status httpd\n```\n\n"},{"term":"systemctl enable","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの登録","content":"\n`systemctl enable` は、[systemd](#systemd)を使用して[Linux](./linux.md#linux)システム上の[サービス](#サービス)が起動時に自動的に開始されるように登録する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)が次回のシステムの起動時に自動的に開始される。\n\n```sh\n$ systemctl enable httpd\n```\n\n"},{"term":"systemctl disable","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの登録解除","content":"\n`systemctl disable` は、[systemd](#systemd)を使用して[Linux](./linux.md#linux)システム上で自動的に起動されるように登録された[サービス](#サービス)を解除する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](#コマンド)を実行すると、 `httpd` [サービス](#サービス)が次回のシステムの起動時に自動的に開始されないようにする。\n\n```sh\n$ systemctl disable httpd\n```\n\n"},{"term":"systemctl is-enable","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"サービスの登録確認","content":"\n`systemctl is-enabled` は、[systemd](#systemd)を使用して指定した[サービス](#サービス)が自動起動に登録されているかを確認する[コマンド](./basic_command.md#コマンド)。\n\n例えば以下の[コマンド](./basic_command.md#コマンド)を実行すると、 `httpd` [サービス](#サービス)が登録されているかを表示する。\n\n```sh\n$ systemctl is-enabled httpd\n```\n\n\n"},{"term":"シグナル","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"シグナル","content":"\n**シグナル**は、[プロセス](#プロセス)へ様々なイベントを通知するための[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の機能（[ソフトウェア割込み](../../../hardware/_/chapters/processor.md#内部割込み)）。イベントの通知は[プロセス](#プロセス)自身や他[プロセス](#プロセス)、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)など様々な場所から行うことが可能で、次のような目的で用いられる。\n\n- [プロセス](#プロセス)にシグナルを送信して強制終了させる\n- シグナルを送信して[プロセス](#プロセス)の処理を一時停止、再開させる\n- シグナル受信時に[ユーザ](./user_and_permission.md#ユーザ)定義の処理（**シグナルハンドラ**）を実行する\n\n主なシグナルは以下の通り。\n\n| シグナル番号 | シグナル名            | 概要                                                                                      |\n| ------------ | --------------------- | :---------------------------------------------------------------------------------------- |\n| `1`          | `HUP` (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                 |\n| `2`          | `INT` (Interrupt)     | キーボードからの割込み( `Ctrl + C` )                                                      |\n| `9`          | `KILL`                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。 |\n| `15`         | `TERM` (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        |\n| `18`         | `CONT` (Continue)     | 一時停止のプロセスを再開するシグナル。                                                    |\n| `19`         | `STOP`                | プロセスを一時停止するシグナル。                                                          |\n| `20`         | `TSTP` (Teminal stop) | プロセスを中断するシグナル。                                                              |\n\n\n"},{"term":"シグナルハンドラ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"シグナル","content":"\n**シグナル**は、[プロセス](#プロセス)へ様々なイベントを通知するための[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の機能（[ソフトウェア割込み](../../../hardware/_/chapters/processor.md#内部割込み)）。イベントの通知は[プロセス](#プロセス)自身や他[プロセス](#プロセス)、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)など様々な場所から行うことが可能で、次のような目的で用いられる。\n\n- [プロセス](#プロセス)にシグナルを送信して強制終了させる\n- シグナルを送信して[プロセス](#プロセス)の処理を一時停止、再開させる\n- シグナル受信時に[ユーザ](./user_and_permission.md#ユーザ)定義の処理（**シグナルハンドラ**）を実行する\n\n主なシグナルは以下の通り。\n\n| シグナル番号 | シグナル名            | 概要                                                                                      |\n| ------------ | --------------------- | :---------------------------------------------------------------------------------------- |\n| `1`          | `HUP` (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                 |\n| `2`          | `INT` (Interrupt)     | キーボードからの割込み( `Ctrl + C` )                                                      |\n| `9`          | `KILL`                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。 |\n| `15`         | `TERM` (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        |\n| `18`         | `CONT` (Continue)     | 一時停止のプロセスを再開するシグナル。                                                    |\n| `19`         | `STOP`                | プロセスを一時停止するシグナル。                                                          |\n| `20`         | `TSTP` (Teminal stop) | プロセスを中断するシグナル。                                                              |\n\n\n"},{"term":"KILL","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"シグナル","content":"\n**シグナル**は、[プロセス](#プロセス)へ様々なイベントを通知するための[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の機能（[ソフトウェア割込み](../../../hardware/_/chapters/processor.md#内部割込み)）。イベントの通知は[プロセス](#プロセス)自身や他[プロセス](#プロセス)、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)など様々な場所から行うことが可能で、次のような目的で用いられる。\n\n- [プロセス](#プロセス)にシグナルを送信して強制終了させる\n- シグナルを送信して[プロセス](#プロセス)の処理を一時停止、再開させる\n- シグナル受信時に[ユーザ](./user_and_permission.md#ユーザ)定義の処理（**シグナルハンドラ**）を実行する\n\n主なシグナルは以下の通り。\n\n| シグナル番号 | シグナル名            | 概要                                                                                      |\n| ------------ | --------------------- | :---------------------------------------------------------------------------------------- |\n| `1`          | `HUP` (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                 |\n| `2`          | `INT` (Interrupt)     | キーボードからの割込み( `Ctrl + C` )                                                      |\n| `9`          | `KILL`                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。 |\n| `15`         | `TERM` (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        |\n| `18`         | `CONT` (Continue)     | 一時停止のプロセスを再開するシグナル。                                                    |\n| `19`         | `STOP`                | プロセスを一時停止するシグナル。                                                          |\n| `20`         | `TSTP` (Teminal stop) | プロセスを中断するシグナル。                                                              |\n\n\n"},{"term":"STOP","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"シグナル","content":"\n**シグナル**は、[プロセス](#プロセス)へ様々なイベントを通知するための[カーネル](../../../software/_/chapters/operating_system.md#カーネル)の機能（[ソフトウェア割込み](../../../hardware/_/chapters/processor.md#内部割込み)）。イベントの通知は[プロセス](#プロセス)自身や他[プロセス](#プロセス)、[カーネル](../../../software/_/chapters/operating_system.md#カーネル)など様々な場所から行うことが可能で、次のような目的で用いられる。\n\n- [プロセス](#プロセス)にシグナルを送信して強制終了させる\n- シグナルを送信して[プロセス](#プロセス)の処理を一時停止、再開させる\n- シグナル受信時に[ユーザ](./user_and_permission.md#ユーザ)定義の処理（**シグナルハンドラ**）を実行する\n\n主なシグナルは以下の通り。\n\n| シグナル番号 | シグナル名            | 概要                                                                                      |\n| ------------ | --------------------- | :---------------------------------------------------------------------------------------- |\n| `1`          | `HUP` (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                 |\n| `2`          | `INT` (Interrupt)     | キーボードからの割込み( `Ctrl + C` )                                                      |\n| `9`          | `KILL`                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。 |\n| `15`         | `TERM` (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        |\n| `18`         | `CONT` (Continue)     | 一時停止のプロセスを再開するシグナル。                                                    |\n| `19`         | `STOP`                | プロセスを一時停止するシグナル。                                                          |\n| `20`         | `TSTP` (Teminal stop) | プロセスを中断するシグナル。                                                              |\n\n\n"},{"term":"socket","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"bind","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"listen","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"accept","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"read/write","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"connect","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ソケット","content":"\n**ソケット**(Socket)は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を介して[プロセス間通信](#プロセス間通信)を行うための[API](../../../software/_/chapters/operating_system.md#api)。ソケットには、[TCP](../../../../network/_/chapters/transport_layer.md#tcp)や[UDP](../../../../network/_/chapters/transport_layer.md#udp)などの[プロトコル](../../../../network/_/chapters/network_architecture.md#プロトコル)に対応した種類がある。\n\n[サーバ](../../../_/chapters/computer.md#サーバ)は以下のような手順で通信を行う。\n\n1. socket: 待ち受け用のソケットを作成する\n1. bind: 待ち受ける[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)や[ポート番号](../../../../network/_/chapters/address_on_network.md#ポート番号)といった情報をソケットに紐づける\n1. listen: クライアントからの通信を待ち受ける\n1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する\n1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う\n\nクライアントは以下のような手順で通信を行う。\n\n1. socket: [サーバ](../../../_/chapters/computer.md#サーバ)との通信用のソケットを作成する\n1. connect: [サーバ](../../../_/chapters/computer.md#サーバ)が待ち受けている[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)に対して接続を試みる\n1. read/write: 接続が確立したら、ソケットを介して[サーバ](../../../_/chapters/computer.md#サーバ)とのデータのやり取りを行う\n\n"},{"term":"shmget","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"共有メモリ","content":"\n**共有メモリ**(Shared memory)は、[IPC](#プロセス間通信)の一種で、複数の[プロセス](#プロセス)が同じ[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域を共有する仕組み。複数の[プロセス](#プロセス)が同じデータを更新する必要がある場合、共有メモリを使用することで高速な処理が可能となる。\n\n共有メモリは、システム上に特定の領域を[プロセス](#プロセス)とは独立して確保しておき、[プロセス](#プロセス)と共有メモリを紐づけることで利用できる。共有メモリを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `shmget` : 共有メモリ領域を作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリのサイズや[アクセス権限](./user_and_permission.md#権限)を指定することができる。\n- `shmat` : 共有メモリ領域にアタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリの識別子を指定して、その共有メモリ領域を[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間にマッピングする。\n- `shmdt` : 共有メモリ領域をデタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。[プロセス](#プロセス)が共有メモリが不要になったときに呼び出し、[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間から共有メモリが解放される。\n\n"},{"term":"shmat","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"共有メモリ","content":"\n**共有メモリ**(Shared memory)は、[IPC](#プロセス間通信)の一種で、複数の[プロセス](#プロセス)が同じ[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域を共有する仕組み。複数の[プロセス](#プロセス)が同じデータを更新する必要がある場合、共有メモリを使用することで高速な処理が可能となる。\n\n共有メモリは、システム上に特定の領域を[プロセス](#プロセス)とは独立して確保しておき、[プロセス](#プロセス)と共有メモリを紐づけることで利用できる。共有メモリを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `shmget` : 共有メモリ領域を作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリのサイズや[アクセス権限](./user_and_permission.md#権限)を指定することができる。\n- `shmat` : 共有メモリ領域にアタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリの識別子を指定して、その共有メモリ領域を[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間にマッピングする。\n- `shmdt` : 共有メモリ領域をデタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。[プロセス](#プロセス)が共有メモリが不要になったときに呼び出し、[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間から共有メモリが解放される。\n\n"},{"term":"shmdt","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"共有メモリ","content":"\n**共有メモリ**(Shared memory)は、[IPC](#プロセス間通信)の一種で、複数の[プロセス](#プロセス)が同じ[メモリ](../../../hardware/_/chapters/memory.md#メモリ)領域を共有する仕組み。複数の[プロセス](#プロセス)が同じデータを更新する必要がある場合、共有メモリを使用することで高速な処理が可能となる。\n\n共有メモリは、システム上に特定の領域を[プロセス](#プロセス)とは独立して確保しておき、[プロセス](#プロセス)と共有メモリを紐づけることで利用できる。共有メモリを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `shmget` : 共有メモリ領域を作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリのサイズや[アクセス権限](./user_and_permission.md#権限)を指定することができる。\n- `shmat` : 共有メモリ領域にアタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。共有メモリの識別子を指定して、その共有メモリ領域を[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間にマッピングする。\n- `shmdt` : 共有メモリ領域をデタッチするための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。[プロセス](#プロセス)が共有メモリが不要になったときに呼び出し、[プロセス](#プロセス)の[アドレス](../../../hardware/_/chapters/memory.md#アドレス)空間から共有メモリが解放される。\n\n"},{"term":"msgget","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"メッセージキュー","content":"\n**メッセージキュー**(Message Queue)は、[IPC](#プロセス間通信)の一種で、[プロセス](#プロセス)間でデータを送受信するための仕組み。メッセージキューでは、[キュー](../../../../programming/_/chapters/data_type.md#キュー)にデータを送信したり、[キュー](../../../../programming/_/chapters/data_type.md#キュー)からデータを取り出したりすることができる。\n\nメッセージキューを用いると、非同期的にデータを送受信することが可能。メッセージキューを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `msgget` : メッセージキューを作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。作成されたメッセージキューには、一意のキーが割り当てられる。\n- `msgsnd` : メッセージキューにメッセージを送信するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。送信されるメッセージには、メッセージタイプを指定する必要がある。\n- `msgrcv` : メッセージキューからメッセージを取り出すための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。受信されるメッセージは、指定されたメッセージタイプに一致する場合に受信される。メッセージがない場合は、指定された待ち時間が経過するか、別の[プロセス](#プロセス)がメッセージを送信するまで待機する。\n\n"},{"term":"msgsnd","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"メッセージキュー","content":"\n**メッセージキュー**(Message Queue)は、[IPC](#プロセス間通信)の一種で、[プロセス](#プロセス)間でデータを送受信するための仕組み。メッセージキューでは、[キュー](../../../../programming/_/chapters/data_type.md#キュー)にデータを送信したり、[キュー](../../../../programming/_/chapters/data_type.md#キュー)からデータを取り出したりすることができる。\n\nメッセージキューを用いると、非同期的にデータを送受信することが可能。メッセージキューを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `msgget` : メッセージキューを作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。作成されたメッセージキューには、一意のキーが割り当てられる。\n- `msgsnd` : メッセージキューにメッセージを送信するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。送信されるメッセージには、メッセージタイプを指定する必要がある。\n- `msgrcv` : メッセージキューからメッセージを取り出すための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。受信されるメッセージは、指定されたメッセージタイプに一致する場合に受信される。メッセージがない場合は、指定された待ち時間が経過するか、別の[プロセス](#プロセス)がメッセージを送信するまで待機する。\n\n"},{"term":"msgrcv","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"メッセージキュー","content":"\n**メッセージキュー**(Message Queue)は、[IPC](#プロセス間通信)の一種で、[プロセス](#プロセス)間でデータを送受信するための仕組み。メッセージキューでは、[キュー](../../../../programming/_/chapters/data_type.md#キュー)にデータを送信したり、[キュー](../../../../programming/_/chapters/data_type.md#キュー)からデータを取り出したりすることができる。\n\nメッセージキューを用いると、非同期的にデータを送受信することが可能。メッセージキューを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `msgget` : メッセージキューを作成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。作成されたメッセージキューには、一意のキーが割り当てられる。\n- `msgsnd` : メッセージキューにメッセージを送信するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。送信されるメッセージには、メッセージタイプを指定する必要がある。\n- `msgrcv` : メッセージキューからメッセージを取り出すための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。受信されるメッセージは、指定されたメッセージタイプに一致する場合に受信される。メッセージがない場合は、指定された待ち時間が経過するか、別の[プロセス](#プロセス)がメッセージを送信するまで待機する。\n\n"},{"term":"セマフォ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"セマフォ","content":"\n**セマフォ**(semaphore)は、[プロセス](#プロセス)間の同期や競合状態を解決するために使用される同期プリミティブ。セマフォは、[プロセス](#プロセス)が特定のリソースにアクセスできるかどうかを制御するために使用される。具体的には、セマフォはカウンタ[変数](../../../../programming/_/chapters/variable.md#変数)とフラグ[変数](../../../../programming/_/chapters/variable.md#変数)によって[プロセス](#プロセス)のアクセス制御を行う。\n\nセマフォを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `semget` : セマフォを作成するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォを取得する場合にも使用される。\n- `semop` : セマフォを操作するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を[インクリメント](../../../../programming/_/chapters/operation.md#インクリメント)したり、[デクリメント](../../../../programming/_/chapters/operation.md#デクリメント)したりすることができる。\n- `semctl` : セマフォの制御を行うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を取得したり、設定したり、削除したりすることができる。\n"},{"term":"semget","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"セマフォ","content":"\n**セマフォ**(semaphore)は、[プロセス](#プロセス)間の同期や競合状態を解決するために使用される同期プリミティブ。セマフォは、[プロセス](#プロセス)が特定のリソースにアクセスできるかどうかを制御するために使用される。具体的には、セマフォはカウンタ[変数](../../../../programming/_/chapters/variable.md#変数)とフラグ[変数](../../../../programming/_/chapters/variable.md#変数)によって[プロセス](#プロセス)のアクセス制御を行う。\n\nセマフォを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `semget` : セマフォを作成するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォを取得する場合にも使用される。\n- `semop` : セマフォを操作するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を[インクリメント](../../../../programming/_/chapters/operation.md#インクリメント)したり、[デクリメント](../../../../programming/_/chapters/operation.md#デクリメント)したりすることができる。\n- `semctl` : セマフォの制御を行うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を取得したり、設定したり、削除したりすることができる。\n"},{"term":"semop","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"セマフォ","content":"\n**セマフォ**(semaphore)は、[プロセス](#プロセス)間の同期や競合状態を解決するために使用される同期プリミティブ。セマフォは、[プロセス](#プロセス)が特定のリソースにアクセスできるかどうかを制御するために使用される。具体的には、セマフォはカウンタ[変数](../../../../programming/_/chapters/variable.md#変数)とフラグ[変数](../../../../programming/_/chapters/variable.md#変数)によって[プロセス](#プロセス)のアクセス制御を行う。\n\nセマフォを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `semget` : セマフォを作成するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォを取得する場合にも使用される。\n- `semop` : セマフォを操作するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を[インクリメント](../../../../programming/_/chapters/operation.md#インクリメント)したり、[デクリメント](../../../../programming/_/chapters/operation.md#デクリメント)したりすることができる。\n- `semctl` : セマフォの制御を行うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を取得したり、設定したり、削除したりすることができる。\n"},{"term":"semctl","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"セマフォ","content":"\n**セマフォ**(semaphore)は、[プロセス](#プロセス)間の同期や競合状態を解決するために使用される同期プリミティブ。セマフォは、[プロセス](#プロセス)が特定のリソースにアクセスできるかどうかを制御するために使用される。具体的には、セマフォはカウンタ[変数](../../../../programming/_/chapters/variable.md#変数)とフラグ[変数](../../../../programming/_/chapters/variable.md#変数)によって[プロセス](#プロセス)のアクセス制御を行う。\n\nセマフォを扱うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)は以下の通り。\n\n- `semget` : セマフォを作成するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォを取得する場合にも使用される。\n- `semop` : セマフォを操作するために使用される[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を[インクリメント](../../../../programming/_/chapters/operation.md#インクリメント)したり、[デクリメント](../../../../programming/_/chapters/operation.md#デクリメント)したりすることができる。\n- `semctl` : セマフォの制御を行うための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。セマフォの値を取得したり、設定したり、削除したりすることができる。\n"},{"term":"リダイレクト","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"リダイレクト","content":""},{"term":"パイプライン","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"パイプライン","content":""},{"term":"フィルタ","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"フィルタ","content":""},{"term":"wc","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ファイルサイズの確認","content":""},{"term":"sort","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ファイル行のソート","content":""},{"term":"cut","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"テキストの切り出し","content":""},{"term":"tr","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"テキストの変換と削除","content":""},{"term":"diff","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ファイルの差分の確認","content":""},{"term":"patch","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"ファイルの差分の適用","content":""},{"term":"sed","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"文字列の処理","content":""},{"term":"正規表現","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"正規表現","content":""},{"term":"リテラル","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"正規表現","content":""},{"term":"メタ文字","link":"./note/ja/./computer/linux/_/chapters/process_and_job.md","flagment":"正規表現","content":""},{"term":"シェルスクリプト","link":"./note/ja/./computer/linux/_/chapters/shell_script.md","flagment":"シェルスクリプト","content":"\n**シェルスクリプト**は、[OS](../../../software/_/chapters/operating_system.md#オペレーティングシステム)に対して実行したい一連の[コマンド](./basic_command.md#コマンド)を並べ、まとめて実行できるようにした[ファイル](../../../software/_/chapters/file_system.md#ファイル)、あるいはそれを記述するための[スクリプト言語](../../../../programming/_/chapters/programming.md#スクリプト言語)。[シェル](./shell_and_terminal.md#シェル)では通常、[コマンド](./basic_command.md#コマンド)の実行と結果の表示を対話的に繰り返すが、シェルスクリプトを使用すると、[コマンド](./basic_command.md#コマンド)の打ち間違いを減らしたり、再利用性や再現性を高めることができる。\n\nシェルスクリプトは他の[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)とは書き方や性質が異なる部分が多いので注意する。\n\nシェルスクリプトが記述された[ファイル](../../../software/_/chapters/file_system.md#ファイル)は、[拡張子](../../../software/_/chapters/file_system.md#拡張子)を `.sh` とするのが一般的で、[実行権限](./user_and_permission.md#権限)を付けておく必要がある。\n\n例えば、以下のシェルスクリプトは、[ホームディレクトリ](../../../software/_/chapters/file_system.md#ホームディレクトリ)の合計[ディスク](../../../hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)容量を出力する。\n\n```sh\n"},{"term":"シバン","link":"./note/ja/./computer/linux/_/chapters/shell_script.md","flagment":"シバン","content":"\n**シバン**(Shebang)は、[シェルスクリプト](#シェルスクリプト)[ファイル](../../../software/_/chapters/file_system.md#ファイル)をどの[シェル](./shell_and_terminal.md#シェル)で実行するかを宣言する部分で、先頭行に記述する。 `#!` に続けて、 `/bin/bash` のように使用する[シェル](./shell_and_terminal.md#シェル)の[パス](../../../software/_/chapters/file_system.md#パス)を記述する。\n\n例えば、以下のようなシバンが記述された[シェルスクリプト](#シェルスクリプト)を実行すると、[bash](./shell_and_terminal.md#bash)[シェル](./shell_and_terminal.md#シェル)を使用して[スクリプト](#シェルスクリプト)を実行する。\n\n```sh\n"},{"term":"source","link":"./note/ja/./computer/linux/_/chapters/shell_script.md","flagment":"シェルスクリプトの実行","content":"\n`source` は、指定した[ファイル](../../../software/_/chapters/file_system.md#ファイル)を現在の[シェル](./shell_and_terminal.md#シェル)で実行する[コマンド](./basic_command.md#コマンド)。 `./` を用いる場合とは異なり、現在の[シェル](./shell_and_terminal.md#シェル)にそのまま[コマンド](./basic_command.md#コマンド)を流し込むかたちとなるので、[ファイル](../../../software/_/chapters/file_system.md#ファイル)に[シバン](#シバン)を記述する必要はない。また、[ファイル](../../../software/_/chapters/file_system.md#ファイル)自体に[実行権限](./user_and_permission.md#権限)を付与しなくてもよい。\n\n以下は、 `homesize.sh` という[シェルスクリプト](#シェルスクリプト)を `source` を用いてカレントシェルで実行する例。\n\n```sh\n$ source homesize.sh\n```\n\n`source` [コマンド](./basic_command.md#コマンド)はカレントシェルにより[コマンド](./basic_command.md#コマンド)を実行した場合と同じ動作になるため、カレントシェルの環境の影響を受けたり、実行後にカレントシェルに影響を及ぼすことに注意が必要。\n\n\n"},{"term":"コマンド置換","link":"./note/ja/./computer/linux/_/chapters/shell_script.md","flagment":"コマンド置換","content":"\n**コマンド置換**は、[コマンド](./basic_command.md#コマンド)の結果を文字列として取得する機能。 `$()` という形式が用いられ、[コマンド](./basic_command.md#コマンド)の出力結果を[シェルスクリプト](#シェルスクリプト)内で利用したい場合に用いられる。\n\n```sh\n"},{"term":"位置パラメータ","link":"./note/ja/./computer/linux/_/chapters/shell_script.md","flagment":"位置パラメータ","content":"\n**位置パラメータ**は、[シェルスクリプト](#シェルスクリプト)からコマンドライン[引数](../../../../programming/_/chapters/function.md#引数)を扱うための[シェル変数](./shell_and_terminal.md#シェル変数)。\n\n例えば、以下のように[シェルスクリプト](#シェルスクリプト)を実行したとする。\n\n```sh\n$ ./backup.sh ./src ./src.bak\n```\n\nこのとき、[シェルスクリプト](#シェルスクリプト)の中ではこれらの[引数](../../../../programming/_/chapters/function.md#引数)を次のように受け取ることができる。\n\n```sh\n"},{"term":"システム","link":"./note/ja/./system/_/chapters/system.md","flagment":"システム","content":"\n**システム**は、個々の要素が互いに影響し合いながら、全体として機能するまとまりや仕組み。\n\n"},{"term":"サブシステム","link":"./note/ja/./system/_/chapters/system.md","flagment":"サブシステム","content":"\n**サブシステム**は、[システム](#システム)を構成する要素の中の、より小さな単位の[システム](#システム)。\n\n\n"},{"term":"ビジネスロジック","link":"./note/ja/./system/_/chapters/system.md","flagment":"ビジネスロジック","content":"\n**ビジネスロジック**は、[システム](#システム)のコアとなる機能や、[システム](#システム)が目的とする処理を行う部分。\n"},{"term":"集中処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"集中処理","content":"\n**集中処理**は、データや情報を1か所にまとめてホスト[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)で処理する[システム](./system.md#システム)の形態。データの更新やセキュリティを一括で管理できる一方で、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)がダウンすると[システム](./system.md#システム)全体が機能しなくなってしまう。\n\n"},{"term":"バッチ処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"バッチ処理","content":"\n**バッチ処理**は、データを一定期間蓄積しておき、一括して処理する形態。データ量の多い処理に適している。\n\n"},{"term":"リアルタイム処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"リアルタイム処理","content":"\n**リアルタイム処理**は、処理要求が発生してから即座に処理を行い、決められた時間までに完了する形態。\n\n"},{"term":"対話型処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"対話型処理","content":"\n**対話型処理**は、利用者と[システム](./system.md#システム)がやり取りしながら処理を進めていく形態。速い応答が期待される[システム](./system.md#システム)などで採用される場合が多く、[プログラム](../../../programming/_/chapters/programming.md#プラグラム)の開発にも適している（対話型[インタプリタ](../../../basics/information_theory/_/chapters/compiler_theory.md#インタプリタ)、対話型[シェル](../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)）。\n\n"},{"term":"リアルタイム制御処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"リアルタイム制御処理","content":"\n**リアルタイム制御処理**は、[制御システム](../../../basics/measurement_and_control/_/chapters/control_theory.md#制御システム)で刻々と変化する情報を元に即座に計算処理を行い、その結果を[制御システム](../../../basics/measurement_and_control/_/chapters/control_theory.md#制御システム)に出力する形態。制御結果を[システム](./system.md#システム)にフィードバックして次の制御を決めるPID制御などが代表的。\n\n"},{"term":"トランザクション処理（オンライントランザクション処理、OLTP）","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"トランザクション処理","content":"\n**トランザクション処理**（**オンライントランザクション処理**、**OLTP**）は、発生したデータを処理し、その都度確定しながら進めていく形態。一連の処理をまとめておき、その処理全体が成功するか失敗するかの2つの結果しか起こりえない。トランザクション処理は[ACID特性](#acid特性)を保証している必要がある。\n\n"},{"term":"強整合性","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"acid特性","content":"\n**ACID特性**(Atomicity, Consistency, Isolation, Durability)は[トランザクション処理](#トランザクション処理)が保証するべき4つの性質を合わせた用語。\n\n**原始性・不可分性**(Atomicity)はある操作がそれ以上細かい単位や要素に分割されない性質。原始性を持つ操作は、「実行される」か「実行されない」かのどちらかしか起きないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)の**トランザクション**（複数の操作をひとつにまとめ上げて管理すること）は原始性を持つ操作となっている。トランザクションは「全て成功」か「全て失敗」のいずれかとなることが保障されている。\n\n**一貫性・整合性**(Consistency)はあるデータが更新された場合に必ず変更後の状態を取得できる性質。変更中のデータを別の操作により取得しようとした場合、古いデータが参照されることなく最新のデータが取得できることが保障される（**強整合性**）。トランザクションの前後ではデータの整合性が保たれ、矛盾が発生しないことが保障されている。\n\n**独立性・隔離性**(Isolation)はある操作の処理中はその内容が他の操作から隠蔽される性質。独立性を持つ操作は別の処理が並行して実行されたとしても影響を受けないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは独立性を持つ操作となっている。トランザクションを複数同時に実行しても、単独で実行した場合と同じ結果を得られることが保障されている。\n\n**永続性・持続性**(Durability)は操作結果が失われない確率あるいは性質。数値としての永続性は、1から**AFR**（年間故障率）を引いた確率で表される。また、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは永続性を持つ操作となっており、トランザクションの結果は障害が発生しても失われてはいけない。トランザクションにおけるデータ操作はログに記録され、障害発生時にはログをもとに更新を反映させるといった対策が施される。\n\nまた強整合性と比較して用いられる**結果整合性**は、更新が反映されるまでに時間がかかる場合に保存前や変更前の状態が見える可能性がある性質のこと。一貫性を保とうとした場合、あるユーザが操作中のデータに他のユーザが一時的にアクセスできなくなるため、[可用性](./system_performance_evaluation.md#可用性)を犠牲にすることとなる。強整合性が必要となるか結果整合性がとれていれば問題ないかは[システム](./system.md#システム)や処理に応じて判断する必要がある。\n\n\n"},{"term":"AFR（年間故障率）","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"acid特性","content":"\n**ACID特性**(Atomicity, Consistency, Isolation, Durability)は[トランザクション処理](#トランザクション処理)が保証するべき4つの性質を合わせた用語。\n\n**原始性・不可分性**(Atomicity)はある操作がそれ以上細かい単位や要素に分割されない性質。原始性を持つ操作は、「実行される」か「実行されない」かのどちらかしか起きないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)の**トランザクション**（複数の操作をひとつにまとめ上げて管理すること）は原始性を持つ操作となっている。トランザクションは「全て成功」か「全て失敗」のいずれかとなることが保障されている。\n\n**一貫性・整合性**(Consistency)はあるデータが更新された場合に必ず変更後の状態を取得できる性質。変更中のデータを別の操作により取得しようとした場合、古いデータが参照されることなく最新のデータが取得できることが保障される（**強整合性**）。トランザクションの前後ではデータの整合性が保たれ、矛盾が発生しないことが保障されている。\n\n**独立性・隔離性**(Isolation)はある操作の処理中はその内容が他の操作から隠蔽される性質。独立性を持つ操作は別の処理が並行して実行されたとしても影響を受けないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは独立性を持つ操作となっている。トランザクションを複数同時に実行しても、単独で実行した場合と同じ結果を得られることが保障されている。\n\n**永続性・持続性**(Durability)は操作結果が失われない確率あるいは性質。数値としての永続性は、1から**AFR**（年間故障率）を引いた確率で表される。また、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは永続性を持つ操作となっており、トランザクションの結果は障害が発生しても失われてはいけない。トランザクションにおけるデータ操作はログに記録され、障害発生時にはログをもとに更新を反映させるといった対策が施される。\n\nまた強整合性と比較して用いられる**結果整合性**は、更新が反映されるまでに時間がかかる場合に保存前や変更前の状態が見える可能性がある性質のこと。一貫性を保とうとした場合、あるユーザが操作中のデータに他のユーザが一時的にアクセスできなくなるため、[可用性](./system_performance_evaluation.md#可用性)を犠牲にすることとなる。強整合性が必要となるか結果整合性がとれていれば問題ないかは[システム](./system.md#システム)や処理に応じて判断する必要がある。\n\n\n"},{"term":"結果整合性","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"acid特性","content":"\n**ACID特性**(Atomicity, Consistency, Isolation, Durability)は[トランザクション処理](#トランザクション処理)が保証するべき4つの性質を合わせた用語。\n\n**原始性・不可分性**(Atomicity)はある操作がそれ以上細かい単位や要素に分割されない性質。原始性を持つ操作は、「実行される」か「実行されない」かのどちらかしか起きないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)の**トランザクション**（複数の操作をひとつにまとめ上げて管理すること）は原始性を持つ操作となっている。トランザクションは「全て成功」か「全て失敗」のいずれかとなることが保障されている。\n\n**一貫性・整合性**(Consistency)はあるデータが更新された場合に必ず変更後の状態を取得できる性質。変更中のデータを別の操作により取得しようとした場合、古いデータが参照されることなく最新のデータが取得できることが保障される（**強整合性**）。トランザクションの前後ではデータの整合性が保たれ、矛盾が発生しないことが保障されている。\n\n**独立性・隔離性**(Isolation)はある操作の処理中はその内容が他の操作から隠蔽される性質。独立性を持つ操作は別の処理が並行して実行されたとしても影響を受けないことが保障されており、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは独立性を持つ操作となっている。トランザクションを複数同時に実行しても、単独で実行した場合と同じ結果を得られることが保障されている。\n\n**永続性・持続性**(Durability)は操作結果が失われない確率あるいは性質。数値としての永続性は、1から**AFR**（年間故障率）を引いた確率で表される。また、[データベース](../../../development/database/_/chapters/database.md#データベース)のトランザクションは永続性を持つ操作となっており、トランザクションの結果は障害が発生しても失われてはいけない。トランザクションにおけるデータ操作はログに記録され、障害発生時にはログをもとに更新を反映させるといった対策が施される。\n\nまた強整合性と比較して用いられる**結果整合性**は、更新が反映されるまでに時間がかかる場合に保存前や変更前の状態が見える可能性がある性質のこと。一貫性を保とうとした場合、あるユーザが操作中のデータに他のユーザが一時的にアクセスできなくなるため、[可用性](./system_performance_evaluation.md#可用性)を犠牲にすることとなる。強整合性が必要となるか結果整合性がとれていれば問題ないかは[システム](./system.md#システム)や処理に応じて判断する必要がある。\n\n\n"},{"term":"分散処理","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"分散処理","content":"\n**分散処理**は、複数の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)で接続し、処理能力や資源を共有しあって効率の良い処理を実現する処理形態。1台の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が停止しても[システム](./system.md#システム)への影響が少なく、拡張性も高い。また、[システム](./system.md#システム)の利用者が場所を選ばずに機能にアクセスできるという利点もあり、このような性質を**アクセス透過性**という。一方で、データの不整合が発生してしまったり、保守が複雑になるといったデメリットもある。\n\n"},{"term":"アクセス透過性","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"分散処理","content":"\n**分散処理**は、複数の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)で接続し、処理能力や資源を共有しあって効率の良い処理を実現する処理形態。1台の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が停止しても[システム](./system.md#システム)への影響が少なく、拡張性も高い。また、[システム](./system.md#システム)の利用者が場所を選ばずに機能にアクセスできるという利点もあり、このような性質を**アクセス透過性**という。一方で、データの不整合が発生してしまったり、保守が複雑になるといったデメリットもある。\n\n"},{"term":"RPC（遠隔手続き読み出し: Remote Procedure Call）","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"rpc","content":"\n**RPC**（**遠隔手続き呼び出し**: Remote Procedure Call）は、[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)によって繋がれた他の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上の[プログラム](../../../programming/_/chapters/prgramming.md#プログラミング)を実行する仕組みで、[分散処理](#分散処理)実行の基盤となる。\n\n有名なRPC[システム](./system.md#システム)としては、Sun Microsystemsの**SunRPC**(ONC RPC)や**アポロ**、IBMとDECが共同開発した**DCE**(Distributed Computing Environment)がある。\n\n"},{"term":"アポロ","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"rpc","content":"\n**RPC**（**遠隔手続き呼び出し**: Remote Procedure Call）は、[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)によって繋がれた他の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上の[プログラム](../../../programming/_/chapters/prgramming.md#プログラミング)を実行する仕組みで、[分散処理](#分散処理)実行の基盤となる。\n\n有名なRPC[システム](./system.md#システム)としては、Sun Microsystemsの**SunRPC**(ONC RPC)や**アポロ**、IBMとDECが共同開発した**DCE**(Distributed Computing Environment)がある。\n\n"},{"term":"ロードシェアリングシステム","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"ロードシェアリングシステム","content":"\n**ロードシェアリングシステム**は、同じ機材などを複数用意して、処理を振り分けることで負荷を分散する処理形態。\n\n"},{"term":"P2P（ピアツーピア: peer to peer）","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"p2p","content":"\n**P2P**（**ピアツーピア**: peer to peer）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)同士の接続形態のひとつで、処理が集中しないよう特定の[サーバ](#クライアントサーバシステム)を置かず、上下関係も持たない。単純に接続する**ピュア型**や、検索用の[サーバ](#クライアントサーバシステム)を置く**ハイブリット型**、処理の高いノードが検索と管理を担う**スーパーノード型**がある。\n\n"},{"term":"ピュア型","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"p2p","content":"\n**P2P**（**ピアツーピア**: peer to peer）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)同士の接続形態のひとつで、処理が集中しないよう特定の[サーバ](#クライアントサーバシステム)を置かず、上下関係も持たない。単純に接続する**ピュア型**や、検索用の[サーバ](#クライアントサーバシステム)を置く**ハイブリット型**、処理の高いノードが検索と管理を担う**スーパーノード型**がある。\n\n"},{"term":"ハイブリット型","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"p2p","content":"\n**P2P**（**ピアツーピア**: peer to peer）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)同士の接続形態のひとつで、処理が集中しないよう特定の[サーバ](#クライアントサーバシステム)を置かず、上下関係も持たない。単純に接続する**ピュア型**や、検索用の[サーバ](#クライアントサーバシステム)を置く**ハイブリット型**、処理の高いノードが検索と管理を担う**スーパーノード型**がある。\n\n"},{"term":"スーパーノード型","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"p2p","content":"\n**P2P**（**ピアツーピア**: peer to peer）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)同士の接続形態のひとつで、処理が集中しないよう特定の[サーバ](#クライアントサーバシステム)を置かず、上下関係も持たない。単純に接続する**ピュア型**や、検索用の[サーバ](#クライアントサーバシステム)を置く**ハイブリット型**、処理の高いノードが検索と管理を担う**スーパーノード型**がある。\n\n"},{"term":"クライアントサーバシステム","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"クライアントサーバシステム","content":"\n**クライアントサーバシステム**は、サービスを提供する**サーバ**と、サービスを要求する**クライアント**で役割を分担する[システム](./system.md#システム)の形態。クライアントとサーバで負荷を分散できるほか、互いの実装が独立しているため、クライアントを[マルチプラットフォーム](../../../computer/software/_/chapters/software.md#マルチプラットフォーム)にしたり、サーバの実装に用いる[プログラミング言語](../../../programming/_/chapters/programming.md#プログラミング言語)を自由に選択できるといった利点がある。\n\nサーバに対してクライアントの数が多くなるため、サーバの負荷を減らす工夫が必要となる。\n\n"},{"term":"サーバ","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"クライアントサーバシステム","content":"\n**クライアントサーバシステム**は、サービスを提供する**サーバ**と、サービスを要求する**クライアント**で役割を分担する[システム](./system.md#システム)の形態。クライアントとサーバで負荷を分散できるほか、互いの実装が独立しているため、クライアントを[マルチプラットフォーム](../../../computer/software/_/chapters/software.md#マルチプラットフォーム)にしたり、サーバの実装に用いる[プログラミング言語](../../../programming/_/chapters/programming.md#プログラミング言語)を自由に選択できるといった利点がある。\n\nサーバに対してクライアントの数が多くなるため、サーバの負荷を減らす工夫が必要となる。\n\n"},{"term":"クライアント","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"クライアントサーバシステム","content":"\n**クライアントサーバシステム**は、サービスを提供する**サーバ**と、サービスを要求する**クライアント**で役割を分担する[システム](./system.md#システム)の形態。クライアントとサーバで負荷を分散できるほか、互いの実装が独立しているため、クライアントを[マルチプラットフォーム](../../../computer/software/_/chapters/software.md#マルチプラットフォーム)にしたり、サーバの実装に用いる[プログラミング言語](../../../programming/_/chapters/programming.md#プログラミング言語)を自由に選択できるといった利点がある。\n\nサーバに対してクライアントの数が多くなるため、サーバの負荷を減らす工夫が必要となる。\n\n"},{"term":"リクエスト","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"リクエスト","content":"\n**リクエスト**は、[クライアントサーバシステム](#クライアントサーバシステム)において、[クライアント](#クライアントサーバシステム)が[サーバ](#クライアントサーバシステム)に対してサービスを要求すること。\n\n"},{"term":"レスポンス","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"レスポンス","content":"\n**レスポンス**は、[クライアントサーバシステム](#クライアントサーバシステム)において、[サーバ](#クライアントサーバシステム)が[クライアント](#クライアントサーバシステム)の[リクエスト](#リクエスト)を受けてサービスを提供すること。\n\n"},{"term":"2層クライアントサーバシステム","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"2層クライアントサーバシステム","content":"\n**2層クライアントサーバシステム**は、[クライアント](#クライアントサーバシステム)が[ユーザインタフェース](../../../computer/software/_/chapters/software.md#ui)とデータの加工処理を行い、[サーバ](#クライアントサーバシステム)は[データベース](../../../development/database/_/chapters/database.md#データベース)へのアクセスのみを行うような[クライアントサーバシステム](#クライアントサーバシステム)。サービスを要求する[クライアント](#クライアントサーバシステム)と依頼された処理を提供する[サーバ](#クライアントサーバシステム)との組み合わせからなる構成。\n\n"},{"term":"3層クライアントサーバシステム","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"3層クライアントサーバシステム","content":"\n**3層クライアントサーバシステム**は、[ユーザインタフェース](../../../computer/software/_/chapters/software.md#ui)（プレゼンテーション層）、データの加工処理（ファンクション層）、[データベース](../../../development/database/_/chapters/database.md#データベース)へのアクセス（データベース層）、という3つのレイヤで構成された[クライアントサーバシステム](#クライアントサーバシステム)。それぞれの役割は[クライアント](#クライアントサーバシステム)、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)[サーバ](#クライアントサーバシステム)、[データベース管理システム](../../../development/database/_/chapters/database.md#dbms)が担う。\n\n- **プレゼンテーション層**（[クライアント](#クライアントサーバシステム)側）: ユーザからの入力を受け取り、[サーバ](#クライアントサーバシステム)から受け取った情報を提供する\n- **ファンクション層**（[サーバ](#クライアントサーバシステム)側）: データの加工や取得、その他[システム](./system.md#システム)に必要な処理を行う\n- **データベース層**（[サーバ](#クライアントサーバシステム)側）: [データベース](../../../development/database/_/chapters/database.md#データベース)にアクセスし、データを管理する\n\n"},{"term":"プレゼンテーション層","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"3層クライアントサーバシステム","content":"\n**3層クライアントサーバシステム**は、[ユーザインタフェース](../../../computer/software/_/chapters/software.md#ui)（プレゼンテーション層）、データの加工処理（ファンクション層）、[データベース](../../../development/database/_/chapters/database.md#データベース)へのアクセス（データベース層）、という3つのレイヤで構成された[クライアントサーバシステム](#クライアントサーバシステム)。それぞれの役割は[クライアント](#クライアントサーバシステム)、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)[サーバ](#クライアントサーバシステム)、[データベース管理システム](../../../development/database/_/chapters/database.md#dbms)が担う。\n\n- **プレゼンテーション層**（[クライアント](#クライアントサーバシステム)側）: ユーザからの入力を受け取り、[サーバ](#クライアントサーバシステム)から受け取った情報を提供する\n- **ファンクション層**（[サーバ](#クライアントサーバシステム)側）: データの加工や取得、その他[システム](./system.md#システム)に必要な処理を行う\n- **データベース層**（[サーバ](#クライアントサーバシステム)側）: [データベース](../../../development/database/_/chapters/database.md#データベース)にアクセスし、データを管理する\n\n"},{"term":"ファンクション層","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"3層クライアントサーバシステム","content":"\n**3層クライアントサーバシステム**は、[ユーザインタフェース](../../../computer/software/_/chapters/software.md#ui)（プレゼンテーション層）、データの加工処理（ファンクション層）、[データベース](../../../development/database/_/chapters/database.md#データベース)へのアクセス（データベース層）、という3つのレイヤで構成された[クライアントサーバシステム](#クライアントサーバシステム)。それぞれの役割は[クライアント](#クライアントサーバシステム)、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)[サーバ](#クライアントサーバシステム)、[データベース管理システム](../../../development/database/_/chapters/database.md#dbms)が担う。\n\n- **プレゼンテーション層**（[クライアント](#クライアントサーバシステム)側）: ユーザからの入力を受け取り、[サーバ](#クライアントサーバシステム)から受け取った情報を提供する\n- **ファンクション層**（[サーバ](#クライアントサーバシステム)側）: データの加工や取得、その他[システム](./system.md#システム)に必要な処理を行う\n- **データベース層**（[サーバ](#クライアントサーバシステム)側）: [データベース](../../../development/database/_/chapters/database.md#データベース)にアクセスし、データを管理する\n\n"},{"term":"データベース層","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"3層クライアントサーバシステム","content":"\n**3層クライアントサーバシステム**は、[ユーザインタフェース](../../../computer/software/_/chapters/software.md#ui)（プレゼンテーション層）、データの加工処理（ファンクション層）、[データベース](../../../development/database/_/chapters/database.md#データベース)へのアクセス（データベース層）、という3つのレイヤで構成された[クライアントサーバシステム](#クライアントサーバシステム)。それぞれの役割は[クライアント](#クライアントサーバシステム)、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)[サーバ](#クライアントサーバシステム)、[データベース管理システム](../../../development/database/_/chapters/database.md#dbms)が担う。\n\n- **プレゼンテーション層**（[クライアント](#クライアントサーバシステム)側）: ユーザからの入力を受け取り、[サーバ](#クライアントサーバシステム)から受け取った情報を提供する\n- **ファンクション層**（[サーバ](#クライアントサーバシステム)側）: データの加工や取得、その他[システム](./system.md#システム)に必要な処理を行う\n- **データベース層**（[サーバ](#クライアントサーバシステム)側）: [データベース](../../../development/database/_/chapters/database.md#データベース)にアクセスし、データを管理する\n\n"},{"term":"ストアドプロシージャ","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"ストアドプロシージャ","content":"\n**ストアドプロシージャ**は、[データベース](../../../development/database/_/chapters/database.md#データベース)に対する一連の処理の流れを1つの[プログラム](../../../programming/_/chapters/programming.md#プログラム)にまとめておき（[プロシージャ](../../../programming/_/chapters/function.md#関数)）、それを[データベース管理システム](../../../development/database/_/chapters/database.md#dbms)に保存したもの。複雑な[SQL](../../../development/database/_/chapters/sql.md#sql)文の呼び出しを簡易化することができる。\n\n"},{"term":"シンクライアントシステム","link":"./note/ja/./system/_/chapters/system_processing_model.md","flagment":"シンクライアントシステム","content":"\n**シンクライアントシステム**は、[クライアント](#クライアントサーバシステム)側の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に最低限の機能のみを持たせ、実際の処理やデータの蓄積を[サーバ](#クライアントサーバシステム)側で行う[システム](./system.md#システム)。[クライアント](#クライアントサーバシステム)側にデータを残さないことで情報漏洩を防ぐことができる。ただし、[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)に接続できない環境においては全く機能しないという欠点もある。\n\n\n"},{"term":"冗長化","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"冗長化","content":"\n**冗長性**(Redundancy)あるいは**多重性**は[システム](./system.md#システム)に障害が発生した場合に備えて冗長な予備装置を運用する仕組み。[システム](./system.md#システム)に冗長性を持たせることを**冗長化**という。メインの[サーバ](./system_processing_model.md#クライアントサーバシステム)（運用系）に加えて障害時に備えた予備の[サーバ](./system_processing_model.md#クライアントサーバシステム)（待機系）を常に運用しておくのは、冗長化の例である。\n\n\n"},{"term":"TSS（タイムシェアリングシステム）","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"tss","content":"\n**TSS**（**タイムシェアリングシステム**）は、1台の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を複数人で同時に使用するための構成。一定時間ごとに[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)の使用権を切り替えながら処理を実行する。\n\n\n"},{"term":"シンプレックスシステム","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"シンプレックスシステム","content":"\n**シンプレックスシステム**は、オンラインシステムにおいて、予備機を持たずに1つの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)で処理を行う構成。処理能力や信頼性は劣るが、運用コストが低くなる。\n\n\n"},{"term":"デュアルシステム","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"デュアルシステム","content":"\n**デュアルシステム**は、オンラインシステムにおいて、処理するための機器を二重化した構成で、2つの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)は同じ処理を行う。2系統の演算結果をクロスチェックしながら処理を進めるため信頼性が高く、一方の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が故障した場合でももう一方で処理を継続できる。\n\n\n"},{"term":"デュプレックスシステム","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"デュプレックスシステム","content":"\n**デュプレックスシステム**は、処理系を2つ用意しておき、一方をメインのオンライン処理用、もう一方を[バッチ処理](./system_processing_model.md#バッチ処理)や待機系として用いる構成。信頼性は[デュアルシステム](#デュアルシステム)に比べると劣るが、コスト面では有利である。\n\n"},{"term":"ホットスタンバイ","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ホットスタンバイ","content":"\n**ホットスタンバイ**は、運用系の[システム](./system.md#システム)と全く同じ環境にデータを常に同期し続け、障害発生時に即座に待機系（予備の[サーバ](./system_processing_model.md#クライアントサーバシステム)など）を運用系と切り替える手法。保守性を高めることができる一方でコストが大きくなる。\n\n"},{"term":"ウォームスタンバイ","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ウォームスタンバイ","content":"\n**ウォームスタンバイ**は、待機系の[システム](./system.md#システム)を最小限のリソースで起動しておき、障害発生時に運用系と切り換える手法。切り替えの際には運用系に比べてスペックが落ちるため、切り替え時にリソースを追加する必要がある場合もある。\n\n"},{"term":"コールドスタンバイ","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"コールドスタンバイ","content":"\n**コールドスタンバイ**は、通常時は待機系の[システム](./system.md#システム)に電源を供給せず、障害発生時に待機系の[システム](./system.md#システム)を起動してリソースなどを用意した後に運用系と切り換える手法。最もコストが低いが復旧までに時間がかかり、保守性が下がってしまう。\n\n\n"},{"term":"バックアップサイト","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"バックアップサイト","content":"\n**バックアップサイト**は、[システム](./system.md#システム)が稼働不可能な状態となった場合などに備えておくための機器や場所。障害や災害が発生した際に、復旧作業を行うための場所として用いられる。\n\n\n"},{"term":"マルチプロセッサシステム","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"マルチプロセッサシステム","content":"\n**マルチプロセッサシステム**は、複数の[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)を同時に使用することで、[システム](./system.md#システム)全体の処理能力と[耐障害性](./reliability_design.md#フォールトトレランス)を向上させる構成。\n\n"},{"term":"マルチコアプロセッサ","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"密結合マルチプロセッサシステム","content":"\n**密結合マルチプロセッサシステム**(**TCMP**: Tightly Coupled Multiprocessor)は、[主記憶](../../hardware/_/chapters/hardware.md#主記憶装置)を共有しながら1つの[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)によって制御されるような構成。1つの[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)パッケージに複数の独立した[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)コアが搭載されている**マルチコアプロセッサ**は代表的なTCMPのひとつ。\n\n"},{"term":"クラスタコンピューティング（クラスタ、クラスタリング）","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"クラスタコンピューティング","content":"\n**クラスタコンピューティング**は、複数の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を接続して単一の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)として使用する方式で、単に**クラスタ**、**クラスタリング**とも呼ばれる。負荷分散やHPCの手法として用いられる場合が多い。\n\n\n"},{"term":"ダンデムシステム","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ダンデムシステム","content":"\n**ダンデムシステム**は、それぞれ機能の異なる複数の専用[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ)を直列に接続した構成。メッセージ処理専用のフロントエンドプロセッサ、[データベース](../../../development/database/_/chapters/database.md#データベース)管理専用のバックエンドプロセッサなどからなる。\n\n\n"},{"term":"オンプレミス","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"オンプレミス","content":"\n**オンプレミス**は、各企業や個人が独自に[サーバ](./system_processing_model.md#クライアントサーバシステム)などのインフラ環境を構築し、利用・運用する方式。\n\n\n"},{"term":"クラウドコンピューティング","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"クラウドコンピューティング","content":"\n**クラウドコンピューティング**は、[インターネット](../../../network/_/chapters/network_architecture.md#インターネット)を介して、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)や[データベース](../../../development/database/_/chapters/database.md#データベース)、[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)などを利用する形態やサービス。場所や端末を選ばずに[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に接続することができる。クラウドは[仮想化技術](#仮想化技術)により資源を自動的に提供する仕組みの応用である。\n\n"},{"term":"オーケストレーション","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"オーケストレーション","content":"\n**オーケストレーション**は、[仮想化](#仮想化技術)された[システム](./system.md#システム)全体を必要に応じて自動的に制御する仕組み。\n\n"},{"term":"グリッドコンピューティング","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"グリッドコンピューティング","content":"\n**グリッドコンピューティング**は、[インターネット](../../../network/_/chapters/network.md#インターネット)などを介して[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を結び付け、高い処理能力を得る構成。\n\n\n"},{"term":"エッジコンピューティング","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"エッジコンピューティング","content":"\n**エッジコンピューティング**は、サービスを提供する[サーバ](./system_processing_model.md#クライアントサーバシステム)とサービスの利用者の距離が物理的に近くなるような構成。ユーザの使用するIoTデバイスやモバイル端末といった**エッジ**に処理を集中させることで、[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)の[オーバヘッド](./system_performance_evaluation.md#オーバヘッド)を減らすことができる。\n\n"},{"term":"仮想化技術","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"仮想化技術","content":"\n**仮想化技術**は、仮想[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)を用いて1台の物理[サーバ](./system_processing_model.md#クライアントサーバシステム)上で複数の[仮想マシン](#仮想マシン)を走らせ、それを1台の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)として利用したり、[クラスタリング](#クラスタリング)により複数台のマシンをひとつにまとめたりする技術。[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)を使って仮想的に必要な資源を割り当てる。\n\n[システム](./system.md#システム)によっては、平日は利用者数が少ないが休日は利用者数が増える、一日の中でアクセスが多い時間帯と少ない時間帯がある、といった負荷のムラがある。仮想化技術は、こういった[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)資源の無駄を減らすために生まれた。\n\n"},{"term":"ホストOS型","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ホストos型","content":"\n**ホストOS型**の[仮想マシン](#仮想マシン)は、[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)上に[仮想化](#仮想化技術)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)をインストールし、その上に**ゲストOS**を導入する。ひとつの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上に複数の[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が存在する状態となるので[オーバヘッド](./system_performance_evaluation.md#オーバヘッド)は大きいが、ゲストOSのカスタマイズが自由にできる利点がある。**VMWare**や**VirtualBox**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"ゲストOS","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ホストos型","content":"\n**ホストOS型**の[仮想マシン](#仮想マシン)は、[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)上に[仮想化](#仮想化技術)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)をインストールし、その上に**ゲストOS**を導入する。ひとつの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上に複数の[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が存在する状態となるので[オーバヘッド](./system_performance_evaluation.md#オーバヘッド)は大きいが、ゲストOSのカスタマイズが自由にできる利点がある。**VMWare**や**VirtualBox**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"VMWare","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ホストos型","content":"\n**ホストOS型**の[仮想マシン](#仮想マシン)は、[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)上に[仮想化](#仮想化技術)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)をインストールし、その上に**ゲストOS**を導入する。ひとつの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上に複数の[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が存在する状態となるので[オーバヘッド](./system_performance_evaluation.md#オーバヘッド)は大きいが、ゲストOSのカスタマイズが自由にできる利点がある。**VMWare**や**VirtualBox**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"VirtualBox","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ホストos型","content":"\n**ホストOS型**の[仮想マシン](#仮想マシン)は、[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)上に[仮想化](#仮想化技術)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)をインストールし、その上に**ゲストOS**を導入する。ひとつの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)上に複数の[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が存在する状態となるので[オーバヘッド](./system_performance_evaluation.md#オーバヘッド)は大きいが、ゲストOSのカスタマイズが自由にできる利点がある。**VMWare**や**VirtualBox**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"ハイパーバイザ型","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ハイパーバイザ型","content":"\n**ハイパーバイザ型**の[仮想マシン](#仮想マシン)は、[サーバ](./system_processing_model.md#クライアントサーバシステム)などに直接ハイパーバイザと呼ばれる管理用の[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)をインストールし、その上でゲストOSを動作させる。ホストOSが不要なため処理速度の低下を最低限に抑えられ、複数の[仮想マシン](#仮想マシン)をリソースの無駄なく効率的に動かすことができる。\n\n"},{"term":"コンテナ型","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"コンテナ型","content":"\n**コンテナ型**の[仮想マシン](#仮想マシン)は、ホストOS上で**コンテナエンジン**を起動しておき、**コンテナイメージ**を作成して独立したコンテナ環境で[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を動作させる。コンテナ型はゲストOSを必要とせず、それぞれの[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)に対して個別のリソース領域を割り当てる。[ホストOS型](#ホストos型)や[ハイパーバイザ型](#ハイパーバイザ型)に比べてリソースの消費が抑えられ、高速に動作するというメリットがある。[Docker](../../../development/docker/_/chapters/docker.md#docker)や**Podman**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"コンテナエンジン","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"コンテナ型","content":"\n**コンテナ型**の[仮想マシン](#仮想マシン)は、ホストOS上で**コンテナエンジン**を起動しておき、**コンテナイメージ**を作成して独立したコンテナ環境で[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を動作させる。コンテナ型はゲストOSを必要とせず、それぞれの[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)に対して個別のリソース領域を割り当てる。[ホストOS型](#ホストos型)や[ハイパーバイザ型](#ハイパーバイザ型)に比べてリソースの消費が抑えられ、高速に動作するというメリットがある。[Docker](../../../development/docker/_/chapters/docker.md#docker)や**Podman**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"コンテナイメージ","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"コンテナ型","content":"\n**コンテナ型**の[仮想マシン](#仮想マシン)は、ホストOS上で**コンテナエンジン**を起動しておき、**コンテナイメージ**を作成して独立したコンテナ環境で[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を動作させる。コンテナ型はゲストOSを必要とせず、それぞれの[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)に対して個別のリソース領域を割り当てる。[ホストOS型](#ホストos型)や[ハイパーバイザ型](#ハイパーバイザ型)に比べてリソースの消費が抑えられ、高速に動作するというメリットがある。[Docker](../../../development/docker/_/chapters/docker.md#docker)や**Podman**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"Podman","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"コンテナ型","content":"\n**コンテナ型**の[仮想マシン](#仮想マシン)は、ホストOS上で**コンテナエンジン**を起動しておき、**コンテナイメージ**を作成して独立したコンテナ環境で[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)を動作させる。コンテナ型はゲストOSを必要とせず、それぞれの[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)に対して個別のリソース領域を割り当てる。[ホストOS型](#ホストos型)や[ハイパーバイザ型](#ハイパーバイザ型)に比べてリソースの消費が抑えられ、高速に動作するというメリットがある。[Docker](../../../development/docker/_/chapters/docker.md#docker)や**Podman**といった[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)が有名。\n\n"},{"term":"シンプロビジョニング","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"シンプロビジョニング","content":"\n**シンプロビジョニング**は、[サーバ](./system_processing_model.md#クライアントサーバシステム)ではなく[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)などの[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)を[仮想化](#仮想化技術)する方法。仮想的なディスクドライブを設定することで、[サーバ](./system_processing_model.md#クライアントサーバシステム)は実際の物理的な容量を意識せずに大容量が割り当てられているものとして運用することができる。\n\n"},{"term":"ライブマイグレーション","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"ライブマイグレーション","content":"\n**ライブマイグレーション**は、仮想サーバで稼働している[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)や[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)を停止することなく、他の物理[サーバ](./system_processing_model.md#クライアントサーバシステム)へ差し替える技術。[サーバ](./system_processing_model.md#クライアントサーバシステム)障害時に切り替えることで処理を継続することができる。\n\n\n"},{"term":"VDI（デスクトップ仮想化: Virtual Desktop Infrastructure）","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"vdi","content":"\n**VDI**（**デスクトップ仮想化**: Virtual Desktop Infrastructure）は、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)やデータをVDI[サーバ](./system_processing_model.md#クライアントサーバシステム)で管理しておき、[クライアント](./system_processing_model.md#クライアントサーバシステム)から接続して利用する方式。\n\n\n"},{"term":"サーバコンソリデーション","link":"./note/ja/./system/_/chapters/system_architecture.md","flagment":"サーバコンソリデーション","content":"\n**サーバコンソリデーション**は、[サーバ](./system_processing_model.md#クライアントサーバシステム)の[仮想化](#仮想化技術)を行うことで物理[サーバ](./system_processing_model.md#クライアントサーバシステム)を統合する方法。[仮想化](#仮想化技術)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)を利用して、複数の物理[サーバ](./system_processing_model.md#クライアントサーバシステム)を[仮想化](#仮想化技術)し、マイグレーションなどによって1台の物理[サーバ](./system_processing_model.md#クライアントサーバシステム)に統合する。\n\n\n"},{"term":"RAID0","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid0","content":"\n**RAID0**は、複数の[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にデータを分散することで高速化する[RAID](#raid)の方式。これを**ストライピング**といい、性能は上がるものの[信頼性](./system_performance_evaluation.md#信頼性)は1台の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)に比べて低下する。\n\n"},{"term":"ストライピング","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid0","content":"\n**RAID0**は、複数の[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にデータを分散することで高速化する[RAID](#raid)の方式。これを**ストライピング**といい、性能は上がるものの[信頼性](./system_performance_evaluation.md#信頼性)は1台の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)に比べて低下する。\n\n"},{"term":"RAID1","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid1","content":"\n**RAID1**は、複数の[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)に同時に同じデータを書き込むことで[信頼性](./system_performance_evaluation.md#信頼性)を向上させた[RAID](#raid)の方式。これを**ミラーリング**といい、2台の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)はお互いに完全なバックアップとなっているため、性能は特に上がらない。\n\n"},{"term":"ミラーリング","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid1","content":"\n**RAID1**は、複数の[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)に同時に同じデータを書き込むことで[信頼性](./system_performance_evaluation.md#信頼性)を向上させた[RAID](#raid)の方式。これを**ミラーリング**といい、2台の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)はお互いに完全なバックアップとなっているため、性能は特に上がらない。\n\n"},{"term":"RAID0+1、RAID1+0","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid01raid10","content":""},{"term":"RAID3","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid3","content":"\n**RAID3**は、複数の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)のうち1台を[誤り訂正](../../../basics/communication_theory/_/chapters/transmission_theory.md#誤り訂正)用の[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にし、誤りが発生した場合に復元する[RAID](#raid)の方式。[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にほかの[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)の偶数[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)を計算したものを格納しておく。データの復元は[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)ごとに行う。\n\n"},{"term":"RAID4","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid4","content":"\n**RAID4**は、複数の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)のうち1台を[誤り訂正](../../../basics/communication_theory/_/chapters/transmission_theory.md#誤り訂正)用の[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にし、誤りが発生した場合に復元する[RAID](#raid)の方式。[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)にほかの[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)の偶数[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)を計算したものを格納しておく。データの復元はブロックごとにまとめて行う。\n\n"},{"term":"RAID5","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid5","content":"\n**RAID5**は、データへのアクセス効率を上げるために[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)をブロックごとに分散し、通常時にもすべての[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)を用いるようにした[RAID](#raid)の方式。[RAID3](#raid3)や[RAID4](#raid4)と比べて[信頼性](./system_performance_evaluation.md#信頼性)は同等だが、性能面では優れている。ひとつの[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)が故障しても、他の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)の[排他的論理和](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#xor演算)を計算することで復元できる。\n\n"},{"term":"RAID6","link":"./note/ja/./system/_/chapters/raid.md","flagment":"raid6","content":"\n**RAID6**は、冗長データを2種類作成することで、2台の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)が故障しても支障をきたさないようにした[RAID](#raid)の方式。[RAID3](#raid3)、[RAID4](#raid4)、[RAID5](#raid5)は[パリティ](../../../basics/communication_theory/_/chapters/transmission_theory.md#パリティ)用の[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)も含めて最低でも[ディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)が3台必要となるが、RAID6では4台必要となる。\n\n\n\n"},{"term":"ファイバチャネル","link":"./note/ja/./system/_/chapters/raid.md","flagment":"san","content":"\n**SAN**(Storage Area Network)は、[サーバ](./system_processing_model.md#クライアントサーバシステム)と[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)を接続するために専用の[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)を使用する方法。ファイバチャネルや[IP](../../../network/_/chapters/internet_layer.md#ip)[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)を使って、あたかも内蔵した[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)のように使用することができる。**ファイバチャネル**とは、主に[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)用に使用される高速[ネットワーク](../../../network/_/chapters/network.md#ネットワーク)を構築する技術のひとつ。\n\n"},{"term":"フォールトトレランス（耐障害性: Fault tolerance）","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フォールトトレランス","content":"\n**フォールトトレランス**（**耐障害性**: Fault tolerance）は、[システム](./system.md#システム)の一部で障害が発生しても全体でカバーして機能停止を防ぐ設計手法。[単一障害点](./system_architecture.md#単一障害点)を排除することで、耐障害性を向上させることができる。復旧後に復旧前よりも[システム](./system.md#システム)が使いづらくなるようであれば、耐障害性はないと言える。\n\n\n"},{"term":"フォールトアボイダンス（障害回避: Fault avoidance）","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フォールトアボイダンス","content":"\n**フォールトアボイダンス**（**障害回避**: Fault avoidance）は、個々の機能の障害が起こる確率を下げて、全体として[信頼性](./system_performance_evaluation.md#信頼性)を上げるという考え方。\n\n\n"},{"term":"フェールセーフ","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フェールセーフ","content":"\n**フェールセーフ**は、[システム](./system.md#システム)に障害が発生したとき、安全な方に制御する方法。障害が新たな障害を生まない制御をしたり、場合によっては処理を停止させる。\n\n\n"},{"term":"フェールソフト","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フェールソフト","content":"\n**フェールソフト**は、[システム](./system.md#システム)に障害が発生したとき、障害が起こった部分を切り離すなどして最低限の[システム](./system.md#システム)の稼働を続ける方法。このとき、機能を限定的にして稼働を続ける操作を**フォールバック**（縮退運転）という。\n\n\n"},{"term":"フォールバック（縮退運転）","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フェールソフト","content":"\n**フェールソフト**は、[システム](./system.md#システム)に障害が発生したとき、障害が起こった部分を切り離すなどして最低限の[システム](./system.md#システム)の稼働を続ける方法。このとき、機能を限定的にして稼働を続ける操作を**フォールバック**（縮退運転）という。\n\n\n"},{"term":"フォールトマスキング","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フォールトマスキング","content":"\n**フォールトマスキング**は、機器などに障害が発生した時、その影響が外部に出ないようにする方法。[システム](./system.md#システム)の[冗長化](./system_architecture.md#冗長化)などによって、1台が故障しても全体に影響が出ないようにするなど。\n\n\n"},{"term":"フールプルーフ","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フールプルーフ","content":"\n**フールプルーフ**は、利用者が誤った操作を行っても危険な状態にならないようにする設計手法。押せてはいけないボタンを押せないようにしたり、危険な操作に対しては確認を行うなど。\n\n\n"},{"term":"フェールオーバ","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"フェールオーバ","content":"\n**フェールオーバ**は、障害発生時に運用系の[システム](./system.md#システム)から待機系の[システム](./system.md#システム)に自動的に切り替える機能や設計。[サーバ](./system_processing_model.md#クライアントサーバシステム)をフェールオーバにするには、**仮想IPアドレス**(**VIP**: Virtual IP Address)を用いて障害発生時にVIPの引き継ぎを行う。\n\n"},{"term":"ヘルスチェック","link":"./note/ja/./system/_/chapters/reliability_design.md","flagment":"ヘルスチェック","content":"\n**ヘルスチェック**は、[フェールオーバ](#フェールオーバ)の実現や[システム](./system.md#システム)の監視のために、運用系の[システム](./system.md#システム)に異常が発生していないかを定期的にチェックする仕組みのこと。[IP](../../../network/_/chapters/internet_layer.md#ip)のレイヤでは[ICMP](../../../network/_/chapters/internet_layer.md#icmp)監視、[TCP](../../../network/_/chapters/transport_layer.md#tcp)のレイヤでは[ポート](../../../network/_/chapters/address_on_network.md#ポート番号)監視、[アプリケーション](../../../computer/software/_/chapters/software.md#アプリケーション)のレイヤでは[HTTP](../../../network/_/chapters/application_layer.md#http)[リクエスト](./system_processing_model.md#クライアントサーバシステム)などによるサービス監視が行われる。\n\n\n"},{"term":"レスポンスタイム（応答時間）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"レスポンスタイム","content":"\n**レスポンスタイム**（**応答時間**）は、[システム](./system.md#システム)にデータを入力してからデータの応答が開始されるまでの時間。[クライアントサーバシステム](./system_processing_model.md#クライアントサーバシステム)においては、[クライアント](./system_processing_model.md#クライアントサーバシステム)が処理の要求をしてから[サーバ](./system_processing_model.md#クライアントサーバシステム)からのデータの到着が開始するまでの時間のことをレスポンスタイムという。\n\n"},{"term":"ターンアラウンドタイム（ラウンドトリップタイム、往復時間）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ターンアラウンドタイム","content":"\n**ターンアラウンドタイム**（**ラウンドトリップタイム**、往復時間）は、[システム](./system.md#システム)にデータを入力してからデータの応答が完了するまでの時間。[クライアントサーバシステム](./system_processing_model.md#クライアントサーバシステム)においては、[クライアント](./system_processing_model.md#クライアントサーバシステム)が処理の要求をしてから[サーバ](./system_processing_model.md#クライアントサーバシステム)からのデータがすべて到着するまでの時間のことをターンアラウンドタイムという。\n\n"},{"term":"ジッタ（揺らぎ）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ジッタ","content":"\n**ジッタ**（**揺らぎ**）は、[ラウンドトリップタイム](#ターンアラウンドタイム)の[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)。\n\n"},{"term":"レイテンシ","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"レイテンシ","content":"\n**レイテンシ**は、ユーザが[サーバ](./system_processing_model.md#クライアントサーバシステム)にデータを要求してから実際にデータが転送され始めるまでの通信の遅延時間。レイテンシが小さいほど[ユーザエクスペリエンス](../../../computer/software/_/chapters/software.md#ux)が向上する。[ラウンドトリップタイム](#ターンアラウンドタイム)と同様の意味で用いられる。\n\n"},{"term":"スループット","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"スループット","content":"\n**スループット**は、単位時間あたりに[システム](./system.md#システム)が処理できる処理数。\n\n"},{"term":"オーバヘッド","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"オーバヘッド","content":"\n**オーバヘッド**は、目的の処理以外のところでかかる時間。\n\n"},{"term":"ベンチマーク","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ベンチマーク","content":"\n**ベンチマーク**は、[システム](./system.md#システム)の処理速度を計測するための指標で、特定の[プログラム](../../../programming/_/chapters/programming.md#プログラム)を実行したときの実行結果をもとに性能を比較する。**TPC**（Transaction Processing Performance Council: トランザクション処理性能評議会）が作成している**TPC-C**(オンライントランザクション処理のベンチマーク）や、**SPEC**（Standard Performance Evaluation Corporation: 標準性能評価法人）が作成している**SPECfp**（浮動小数点演算の評価）などが有名。\n\n\n"},{"term":"TPC（Transaction Processing Performance Council: トランザクション処理性能評議会）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ベンチマーク","content":"\n**ベンチマーク**は、[システム](./system.md#システム)の処理速度を計測するための指標で、特定の[プログラム](../../../programming/_/chapters/programming.md#プログラム)を実行したときの実行結果をもとに性能を比較する。**TPC**（Transaction Processing Performance Council: トランザクション処理性能評議会）が作成している**TPC-C**(オンライントランザクション処理のベンチマーク）や、**SPEC**（Standard Performance Evaluation Corporation: 標準性能評価法人）が作成している**SPECfp**（浮動小数点演算の評価）などが有名。\n\n\n"},{"term":"SPEC（Standard Performance Evaluation Corporation: 標準性能評価法人）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ベンチマーク","content":"\n**ベンチマーク**は、[システム](./system.md#システム)の処理速度を計測するための指標で、特定の[プログラム](../../../programming/_/chapters/programming.md#プログラム)を実行したときの実行結果をもとに性能を比較する。**TPC**（Transaction Processing Performance Council: トランザクション処理性能評議会）が作成している**TPC-C**(オンライントランザクション処理のベンチマーク）や、**SPEC**（Standard Performance Evaluation Corporation: 標準性能評価法人）が作成している**SPECfp**（浮動小数点演算の評価）などが有名。\n\n\n"},{"term":"SPECfp（浮動小数点演算の評価）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ベンチマーク","content":"\n**ベンチマーク**は、[システム](./system.md#システム)の処理速度を計測するための指標で、特定の[プログラム](../../../programming/_/chapters/programming.md#プログラム)を実行したときの実行結果をもとに性能を比較する。**TPC**（Transaction Processing Performance Council: トランザクション処理性能評議会）が作成している**TPC-C**(オンライントランザクション処理のベンチマーク）や、**SPEC**（Standard Performance Evaluation Corporation: 標準性能評価法人）が作成している**SPECfp**（浮動小数点演算の評価）などが有名。\n\n\n"},{"term":"キャパシティブランニング","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"キャパシティブランニング","content":"\n**キャパシティブランニング**は、[システム](./system.md#システム)に求められるサービスレベルから、[システム](./system.md#システム)に必要なリソースの処理能力や容量、数量などを見積もり、[システム](./system.md#システム)構成を計画すること。\n\n"},{"term":"ワークロード","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"ワークロード","content":"\n**ワークロード**は、[コンピュータ](../../../computer/_/chapters/compuser.md#コンピュータ)資源の利用状況や負荷状況。[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)利用率などで現行[システム](./system.md#システム)の測定を行い、ヒアリングなどで関係者の意見を聞くなどして見積もる。\n\n"},{"term":"サイジング","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"サイジング","content":"\n**サイジング**は、[システム](./system.md#システム)に必要な規模や性能を見極めて構成要素を用意する工程。[サーバ](./system_processing_model.md#クライアントサーバシステム)の台数や[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)の性能、[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)の容量などを見積もる。\n\n"},{"term":"チューニング","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"チューニング","content":"\n**チューニング**は、テスト環境などで、[サイジング](#サイジング)で用意した[システム](./system.md#システム)構成要素が適切であるかどうかを評価し、必要に応じて拡張・縮小すること。[ベンチマーク](#ベンチマーク)を参考にしてチューニングする場合もある。\n\n\n"},{"term":"インテグリティ","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"完全性保全性","content":""},{"term":"信頼性指標","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"信頼性指標","content":"\n"},{"term":"MTBF（平均故障時間: Mean Time Between Failures）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"mtbf","content":"\n**MTBF**（**平均故障間隔**: Mean Time Between Failures）は、故障が復旧してから次の故障までにかかる時間の平均。 $MTBF = \\frac{コンピュータが正常に稼働している時間の累計}{故障回数}$ で求めることができる。\n\n"},{"term":"MTTR（平均修復時間: Mean Time to Repair）","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"mttr","content":"\n**MTTR**（**平均修復時間**: Mean Time to Repair）は、故障した[システム](./system.md#システム)が復旧にかかる時間の平均。 $MTTR = \\frac{修理に要した時間の累計}{故障回数}$ で求めることができる。\n\n"},{"term":"稼働率","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"稼働率","content":"\n**稼働率**は、ある特定の時間に[システム](./system.md#システム)が稼働している[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)。 $稼働率 = \\frac{コンピュータが正常に稼働した時間の累計}{コンピュータ通電時間の累計} = \\frac{MTBF}{MTBF + MTTR}$ で求めることができる。\n\n"},{"term":"故障率","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"故障率","content":"\n**故障率**は、[稼働率](#稼働率)の反対、もしくはある特定の時間に[システム](./system.md#システム)が稼働していない[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)。 $故障率 = 1 - 稼働率$ で求めることができ、この値を**不稼働率**とも呼ぶ。また、単位時間内にどの程度の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で故障するかを指す場合の故障率は、 $故障率 = \\frac{1}{MTBF}$ で求めることができる。\n\n\n"},{"term":"不故障率","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"故障率","content":"\n**故障率**は、[稼働率](#稼働率)の反対、もしくはある特定の時間に[システム](./system.md#システム)が稼働していない[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)。 $故障率 = 1 - 稼働率$ で求めることができ、この値を**不稼働率**とも呼ぶ。また、単位時間内にどの程度の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で故障するかを指す場合の故障率は、 $故障率 = \\frac{1}{MTBF}$ で求めることができる。\n\n\n"},{"term":"スケールアップ","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"スケールアップ","content":"\n**スケールアップ**は、[サーバ](./system_processing_model.md#クライアントサーバシステム)の性能を上げる方法のひとつで、[サーバ](./system_processing_model.md#クライアントサーバシステム)の[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)を物理的に性能の高いものに置き換えるという方法。[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)を高性能なものにしたり、[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)の容量を大きくしたりする。\n\n"},{"term":"スケールアウト","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"スケールアウト","content":"\n**スケールアウト**は、[サーバ](./system_processing_model.md#クライアントサーバシステム)の性能を上げる方法のひとつで、[サーバ](./system_processing_model.md#クライアントサーバシステム)の数を増やすという方法。[スケールアップ](#スケールアップ)と比べても大幅に[サーバ](./system_processing_model.md#クライアントサーバシステム)への負荷を減らすことができる。\n\n"},{"term":"スケールイン","link":"./note/ja/./system/_/chapters/system_performance_evaluation.md","flagment":"スケールイン","content":"\n**スケールイン**は、[システム](./system.md#システム)を構成する[サーバ](./system_processing_model.md#クライアントサーバシステム)の数を減らすことで、リソースの無駄を減らす方法。[スケールアウト](#スケールアウト)とは反対の操作となる。\n\n\n"},{"term":"セキュリティ（情報セキュリティ）","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"セキュリティ","content":"\n**セキュリティ**（情報セキュリティ）は、情報の[機密性](#機密性)、[完全性](#完全性)および[可用性](#可用性)を維持するための対策や手法。これら3つの要素の頭文字を取り、**CIA**とも呼ばれる。\n\n"},{"term":"CIA","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"セキュリティ","content":"\n**セキュリティ**（情報セキュリティ）は、情報の[機密性](#機密性)、[完全性](#完全性)および[可用性](#可用性)を維持するための対策や手法。これら3つの要素の頭文字を取り、**CIA**とも呼ばれる。\n\n"},{"term":"ISMS（情報セキュリティマネジメントシステム: Information Security Management System）","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"isms","content":"\n**ISMS**（**情報セキュリティマネジメントシステム**: Information Security Management System）は、組織の[情報セキュリティ](#セキュリティ)を管理するための仕組み。自社内の[情報資産](#情報資産)やリスクを適切に管理することで、利害関係者に信頼を与える。\n\n"},{"term":"インシデント","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"インシデント","content":"\n**インシデント**は、重大な事件や事故に発展する可能性のある出来事。ITサービスにおいては[システム](../../../_/chapters/system.md#システム)の利用者が本来できるはずの業務や操作を正常に遂行できない状態や事象を指し、情報[セキュリティ](#セキュリティ)においては情報管理や[システム](../../../_/chapters/system.md#システム)運用に関して保安上の驚異となる人為的な事象を指す。\n\n\n"},{"term":"情報資産","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"情報資産","content":"\n**情報資産**は、企業やサービスの運用者が持つ、業務に必要な価値のある情報。顧客情報や技術情報といったものが該当し、これらの情報資産にとっての驚異を洗い出したり、脆弱性を考慮することによって、最適な[セキュリティ](#セキュリティ)対策を考える必要がある。\n\n\n"},{"term":"不正のトライアングル理論","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"不正のトライアングル理論","content":"\n**不正のトライアングル理論**は、アメリカの犯罪学者D.R.クレッシーが提唱している、機会・動機・正当化の3つの要素が揃うことで不正行為が起こるという考え方。\n\n"},{"term":"状況的犯罪予防論","link":"./note/ja/./system/security/_/chapters/security.md","flagment":"状況的犯罪予防論","content":"\n**状況的犯罪予防論**は、[不正のトライアングル理論](#不正のトライアングル理論)を考慮して、不正を起こしにくい状況を作ることで犯罪を抑制するという考え方。\n"},{"term":"サイバー攻撃","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"サイバー攻撃","content":"\n**サイバー攻撃**は、[インターネット](../../../../network/_/chapters/network.md#インターネット)やデジタル機器を絡めた手口で、[システム](../../../_/chapters/system.md#システム)の破壊や情報の改ざん、窃取などをする行為。サイバー攻撃は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)や[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)、データなどの様々なレベルで実行される。\n\n\n"},{"term":"ハッカー（クラッカー）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ハッカー","content":"\n**ハッカー**（**クラッカー**）は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)[システム](../../../_/chapters/system.md#システム)や[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に対して、技術的な知識やスキルを駆使して不正な行為を行う攻撃者。ハッカーは[セキュリティ](./security.md#セキュリティ)の脆弱性を研究し、これを悪用して攻撃を行う。一方で、[セキュリティ](./security.md#セキュリティ)向上のために善意で活動するハッカー（**ホワイトハッカー**）も存在する。\n\n"},{"term":"ホワイトハッカー","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ハッカー","content":"\n**ハッカー**（**クラッカー**）は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)[システム](../../../_/chapters/system.md#システム)や[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に対して、技術的な知識やスキルを駆使して不正な行為を行う攻撃者。ハッカーは[セキュリティ](./security.md#セキュリティ)の脆弱性を研究し、これを悪用して攻撃を行う。一方で、[セキュリティ](./security.md#セキュリティ)向上のために善意で活動するハッカー（**ホワイトハッカー**）も存在する。\n\n"},{"term":"スクリプトキディ","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"スクリプトキディ","content":"\n**スクリプトキディ**は、既成のクラッキングツールを利用して不正アクセスを試みる攻撃者。[ハッカー](#ハッカー)と比べるとスキルや知識は限定的で、自身で新しい攻撃技術を開発したり、複雑な[セキュリティ](./security.md#セキュリティ)の脆弱性を解析することはできない場合が多い。悪戯目的で攻撃を行うことが多いため、[セキュリティ](./security.md#セキュリティ)対策は比較的容易。\n\n"},{"term":"ボットハーダー","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ボットハーダー","content":"\n**ボットハーダー**は、[ボットネット](#ボットネット)と呼ばれるボットコンピュータを利用することで[サイバー攻撃](#サイバー攻撃)を実行する攻撃者。不正に侵入した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)[システム](../../../../chapters/system.md#システム)に[マルウェア](#マルウェア)やボットコードを送り込み、その[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を制御して[ボットネット](#ボットネット)を形成する。こうして築いた[ボットネット](#ボットネット)を、[マルウェア](#マルウェア)の配信やスパム[メール](../../../../network/_/chapters/application_layer.md#電子メール)の送信、[DDoS攻撃](#ddos攻撃)などの悪意のある活動に利用する。\n\n"},{"term":"ハクティビスト","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ハクティビスト","content":"\n**ハクティビスト**は、特定の政治的、社会的な目的のために[サイバー攻撃](#サイバー攻撃)を行う攻撃者。[Web](../../../../network/_/chapters/web.md#web)サイトの改ざんや、機密情報の公開、オンライン上での抗議活動などを通じてメッセージの発信を試みる。ハクティビストは[ハッカー](#ハッカー)とアクティビスト（活動家）を合わせた言葉。\n\n\n"},{"term":"マルウェア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"マルウェア","content":"\n**マルウェア**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)や[プログラム](../../../../programming/_/chapters/programming.md#プログラム)に対して被害を加えることを目的とした、悪意のある[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の総称。[コンピュータウイルス](#コンピュータウイルス)や[ワーム](#ワーム)、[トロイの木馬](#トロイの木馬)、[ランサムウェア](#ランサムウェア)などはマルウェアの一種である。\n\n"},{"term":"コンピュータウイルス","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"コンピュータウイルス","content":"\n**コンピュータウイルス**は、自己複製機能を有する、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)や[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を害することを目的として作成された[マルウェア](#マルウェア)。コンピュータウイルスは多くの場合、[Web](../../../../network/_/chapters/web.md#web)サイトの閲覧や[メール](../../../../network/_/chapters/application_layer.md#電子メール)の添付[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[USB](../../../../computer/hardware/_/chapters/bus.md#usb)メモリなどの外部記憶媒体を通じて感染する。コンピュータウイルスは、以下のような特徴を持つ。\n\n- **自己増殖機能**: 感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を書き換えたり、[システム](../../../_/chapters/system.md#システム)上の機能を利用することで、他の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にウイルス自身をインストールする機能\n- **潜伏機能**（**休眠機能**）: 発病機能が実行されるまで、不正な挙動を示さないようにするための機能\n- **発病機能**: ユーザの意図しない動作を行う悪性機能\n\n"},{"term":"自己増殖機能","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"コンピュータウイルス","content":"\n**コンピュータウイルス**は、自己複製機能を有する、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)や[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を害することを目的として作成された[マルウェア](#マルウェア)。コンピュータウイルスは多くの場合、[Web](../../../../network/_/chapters/web.md#web)サイトの閲覧や[メール](../../../../network/_/chapters/application_layer.md#電子メール)の添付[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[USB](../../../../computer/hardware/_/chapters/bus.md#usb)メモリなどの外部記憶媒体を通じて感染する。コンピュータウイルスは、以下のような特徴を持つ。\n\n- **自己増殖機能**: 感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を書き換えたり、[システム](../../../_/chapters/system.md#システム)上の機能を利用することで、他の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にウイルス自身をインストールする機能\n- **潜伏機能**（**休眠機能**）: 発病機能が実行されるまで、不正な挙動を示さないようにするための機能\n- **発病機能**: ユーザの意図しない動作を行う悪性機能\n\n"},{"term":"潜伏機能（休眠機能）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"コンピュータウイルス","content":"\n**コンピュータウイルス**は、自己複製機能を有する、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)や[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を害することを目的として作成された[マルウェア](#マルウェア)。コンピュータウイルスは多くの場合、[Web](../../../../network/_/chapters/web.md#web)サイトの閲覧や[メール](../../../../network/_/chapters/application_layer.md#電子メール)の添付[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[USB](../../../../computer/hardware/_/chapters/bus.md#usb)メモリなどの外部記憶媒体を通じて感染する。コンピュータウイルスは、以下のような特徴を持つ。\n\n- **自己増殖機能**: 感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を書き換えたり、[システム](../../../_/chapters/system.md#システム)上の機能を利用することで、他の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にウイルス自身をインストールする機能\n- **潜伏機能**（**休眠機能**）: 発病機能が実行されるまで、不正な挙動を示さないようにするための機能\n- **発病機能**: ユーザの意図しない動作を行う悪性機能\n\n"},{"term":"発病機能","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"コンピュータウイルス","content":"\n**コンピュータウイルス**は、自己複製機能を有する、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)や[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を害することを目的として作成された[マルウェア](#マルウェア)。コンピュータウイルスは多くの場合、[Web](../../../../network/_/chapters/web.md#web)サイトの閲覧や[メール](../../../../network/_/chapters/application_layer.md#電子メール)の添付[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[USB](../../../../computer/hardware/_/chapters/bus.md#usb)メモリなどの外部記憶媒体を通じて感染する。コンピュータウイルスは、以下のような特徴を持つ。\n\n- **自己増殖機能**: 感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を書き換えたり、[システム](../../../_/chapters/system.md#システム)上の機能を利用することで、他の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にウイルス自身をインストールする機能\n- **潜伏機能**（**休眠機能**）: 発病機能が実行されるまで、不正な挙動を示さないようにするための機能\n- **発病機能**: ユーザの意図しない動作を行う悪性機能\n\n"},{"term":"ワーム","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ワーム","content":"\n**ワーム**は、[自己増殖](#コンピュータウイルス)するために感染活動を自ら行う[マルウェア](#マルウェア)。[コンピュータウイルス](#コンピュータウイルス)は宿主となる[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が必要となるが、ワームはユーザの関与を必要とせず自動的に[増殖活動](#コンピュータウイルス)を行う。また、[ウイルス](#コンピュータウイルス)は感染した[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)が存在する範囲内で影響を及ぼすが、ワームは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)全体に迅速に広がり広範な影響を与える可能性がある。\n\n"},{"term":"ゾンビPC","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"トロイの木馬","content":"\n**トロイの木馬**(**RAT**: Remote Administrator Tools/Remote Access Trojan)は、標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に潜伏し、攻撃者からの遠隔操作による破壊活動や情報窃取を行う[マルウェア](#マルウェア)。[コンピュータウイルス](#コンピュータウイルス)とは異なり[自己増殖機能](#コンピュータウイルス)はない。トロイの木馬は[クライアントサーバシステム](../../../_/chapters/system_processing_model.md#クライアントサーバシステム)によって構成されており、攻撃対象の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を[サーバ](../../../_/chapters/system_processing_model.md#クライアントサーバシステム)として、攻撃者は[クライアント](../../../_/chapters/system_processing_model.md#クライアントサーバシステム)を経由して攻撃を行う。トロイの木馬に感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)のことを**ゾンビPC**という。\n\n"},{"term":"ランサムウェア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ランサムウェア","content":"\n**ランサムウェア**は、標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上の[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[システム](../../../_/chapters/system.md#システム)を強制的に暗号化するなどして、ユーザに身代金を要求することを目的とした不正[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の表示の変更や、[システム](../../../_/chapters/system.md#システム)のアクセス権の変更、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の暗号化などを行い、身代金を支払わない場合はデータを永久に失うと脅迫する。\n\n"},{"term":"ダウンローダ","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ダウンローダ","content":"\n**ダウンローダ**は、[インターネット](../../../../network/_/chapters/network.md#インターネット)上で他の[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)をダウンロードするための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)やスクリプト。[マルウェア](#マルウェア)の本体[プログラム](../../../../programming/_/chapters/programming.md#プログラム)はファイルサイズが大きい場合が多く、標的ユーザに発見されてしまう可能性があるため、ウイルス対策ソフトでの検出が難しいダウンローダを通じて外部から[マルウェア](#マルウェア)を取得する。また、ダウンロードしてくる[マルウェア](#マルウェア)を都度変更したり、[マルウェア](#マルウェア)の機能追加や更新といった拡張を支援することができる。\n\n"},{"term":"ドロッパ","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ドロッパ","content":"\n**ドロッパ**は、不正[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の本体を標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内に生成するための[プログラム](../../../../programming/_/chapters/programming.md#プログラム)で、ステルス機能を備えているものが多いため、ウイルス対策ソフトでの検出が難しい。また、[ダウンローダ](#ダウンローダ)との組み合わせによって攻撃が行われる場合もある。\n\n"},{"term":"ルートキット","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ルートキット","content":"\n**ルートキット**は、標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に侵入して攻撃の手助けをするツールを[パッケージ](../../../../computer/software/_/chapters/package.md#パッケージ)化したものの総称。直接的な被害を加えるのではなく、他の[マルウェア](#マルウェア)がウイルス対策ソフトに検知されることを防止するといった機能がある。\n\nルートキットは最初に、[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)と[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の間に介入し、[マルウェア](#マルウェア)に関する情報を削除することで存在を隠蔽する。そして、**DKOM**(Direct kernel Object Modification)と呼ばれる手法で、[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が管理する内部情報そのものを削除するなどして、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)に情報を渡さないように細工する。\n\nまた、[マルウェア](#マルウェア)の権限を不正に昇格する、[プロセス](../../../../computer/linux/_/chapters/process_and_job.md#プロセス)を隠蔽する、追加の[マルウェア](#マルウェア)をインストールする、といった機能を備えているものもある。\n\n"},{"term":"バックドア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"バックドア","content":"\n**バックドア**は、標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の[システム](../../../_/chapters/system.md#システム)や[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)などに不正侵入するためのアクセスポイント。バックドアを仕掛けると、攻撃者は[認証](./security_technology.md#認証)を回避して[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に侵入することができるようになる。バックドアは、一度攻撃のために侵入した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に再度侵入しやすくするために設置される場合が多い。\n\n"},{"term":"キーロガー","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"キーロガー","content":"\n**キーロガー**は、標的[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)の情報を窃取するために、[キーボード](../../../../computer/hardware/_/chapters/io_unit.md#キーボード)の操作内容を記録して攻撃者に送信する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。また、[マウス](../../../../computer/hardware/_/chapters/io_unit.md#マウス)の動きを追跡するための**マウスロガー**もある。\n\n\n"},{"term":"マウスロガー","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"マウスロガー","content":""},{"term":"C2サーバ（C&Cサーバ: Command and Control Server）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"c2サーバ","content":"\n**C2サーバ**（C&Cサーバ: Command and Control Server）は、[サイバー攻撃](#サイバー攻撃)において攻撃者が操作や私事を送るために使用される[サーバ](../../../_/chapters/system_processing_model.md#クライアントサーバシステム)。攻撃者が[マルウェア](#マルウェア)や[ボットネット](#ボットネット)に対して命令を行うための拠点で、攻撃活動の重要な要素となる。\n\n\n"},{"term":"ボットネット","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ボットネット","content":"\n**ボットネット**は、[マルウェア](#マルウェア)に感染した[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)（ボット）などで構成される[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)で、攻撃者（[ボットハーダ](#ボットハーダ)、マスタ）の指示で作動する。[トロイの木馬](#トロイの木馬)に感染した[ゾンビPC](#トロイの木馬)で構成された[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)のことをボットネットということもある。[DDoS攻撃](#ddos攻撃)を用いたサイバー犯罪やスパム[メール](../../../../network/_/chapters/application_layer.md#電子メール)、[スパイウェア](#スパイウェア)などに利用される。\n\n\n"},{"term":"スパイウェア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"スパイウェア","content":"\n**スパイウェア**は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)やモバイルデバイスに侵入し、ユーザのプライバシーや[セキュリティ](./security.md#セキュリティ)を侵害する悪意のある[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)。ユーザ情報の収集や行動の監視、不正なデータ送信などによって悪影響を及ぼす。\n\n"},{"term":"アドウェア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"アドウェア","content":"\n**アドウェア**は、不正な広告を表示することで、ユーザのプライバシや[セキュリティ](./security.md#セキュリティ)を侵害する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。広告を表示して有料の[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)のインストールを促したり、[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)に保存された情報を窃取したりする。\n\n"},{"term":"マルバタイジング（不正広告）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"マルバタイジング","content":"\n**マルバタイジング**（**不正広告**）は、オンライン広告を介して[マルウェア](#マルウェア)配布や不正[Web](../../../../network/_/chapters/web.md#web)サイトへの誘導などを行う攻撃手口。[Web](../../../../network/_/chapters/web.md#web)広告に悪性コード（[JavaScript](../../../../programming/_/chapters/programming_language.md#javascript)など）を混入し、ユーザが広告をクリックしたときに悪意のあるサイトに[リダイレクト](../../../../network/_/chapters/web.md#リダイレクト)させたり、[マルウェア](#マルウェア)がインストールさせたりする。\n\n"},{"term":"トラッキングCookie","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"トラッキングcookie","content":"\n**トラッキングCookie**は、ユーザの閲覧履歴などの窃取を目的として仕掛けられる[Cookie](../../../../network/_/chapters/web.md#cookie)。ユーザの[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に[Cookie](../../../../network/_/chapters/web.md#cookie)を送信することで、[Web](../../../../network/_/chapters/web.md#web)サイトの閲覧履歴や傾向を取得し、統計的にマーケティングなどに利用する。必ずしも悪質なものとは言い切れないので、削除するか否かはユーザの判断に委ねられる。\n\n"},{"term":"パスワードスティーラ","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"パスワードスティーラ","content":"\n**パスワードスティーラ**は、パスワード情報を窃取することを目的とした[スパイウェア](#スパイウェア)。[キーロギング](#キーロガー)や[フィッシング](#フィッシング)、[ソーシャルエンジニアリング](#ソーシャルエンジニアリング)などの手口によってユーザアカウントの乗っ取りなどを行う。\n\n\n"},{"term":"偽セキュリティソフトウェア","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"偽セキュリティソフトウェア","content":"\n**偽セキュリティソフトウェア**は、実際のセキュリティソフトウェアのように見せかけて、ユーザを騙して悪意のある[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)をインストールさせる詐欺的な[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。存在しない脅威や[ウイルス](#コンピュータウイルス)感染などの虚偽の報告を行い、ユーザに有料[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の購入を強要するという手口が一般的。さらに、このようにして購入させる[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)が[マルウェア](#マルウェア)である可能性もあるため、追加の被害にも注意が必要。\n\n\n"},{"term":"不正ドキュメント","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"不正ドキュメント","content":"\n**不正ドキュメント**は、不正[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や悪性コードを含むドキュメント[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の総称。Microsoft OfficeやPDF[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)などに不正[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を忍び込ませるのがその典型で、[ダウンローダ](#ダウンローダ)や[ドロッパ](#ドロッパ)といった[マルウェア](#マルウェア)本体をインストールする前段階の機能を持つものや、エクスプロイトコード（[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の脆弱性を悪用して、意図しない動作をさせるための悪性コード）などがある。\n\n\n"},{"term":"フィッシング","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"フィッシング","content":"\n**フィッシング**は、信頼された組織やサービスを詐称して、ユーザの個人情報や機密データを窃取しようとする手口。金融機関などを騙った[メール](../../../../network/_/chapters/application_layer.md#電子メール)などから、偽の[Web](../../../../network/_/chapters/web.md#web)サイトに誘導し、銀行口座のパスワードを入力させて情報を盗み出す、といった手口が用いられる。また、[メール](../../../../network/_/chapters/application_layer.md#電子メール)ではなくSMSを利用した**スミッシング**もある。\n\n\n"},{"term":"スミッシング","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"フィッシング","content":"\n**フィッシング**は、信頼された組織やサービスを詐称して、ユーザの個人情報や機密データを窃取しようとする手口。金融機関などを騙った[メール](../../../../network/_/chapters/application_layer.md#電子メール)などから、偽の[Web](../../../../network/_/chapters/web.md#web)サイトに誘導し、銀行口座のパスワードを入力させて情報を盗み出す、といった手口が用いられる。また、[メール](../../../../network/_/chapters/application_layer.md#電子メール)ではなくSMSを利用した**スミッシング**もある。\n\n\n"},{"term":"ドライブバイダウンロード","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ドライブバイダウンロード","content":"\n**ドライブバイダウンロード**は、[インターネット](../../../../network/_/chapters/network.md#インターネット)経由で標的ユーザの意図しないダウンロードを行わせる攻撃方法。[Web](../../../../network/_/chapters/web.md#web)サイトの脆弱性や[セキュリティ](./security.md#セキュリティ)の欠陥を悪用して行われ、ユーザは意図せず[マルウェア](#マルウェア)を[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にダウンロードしてしまう。\n\n\n"},{"term":"水飲み場攻撃","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"水飲み場攻撃","content":"\n**水飲み場攻撃**は、[Web](../../../../network/_/chapters/web.md#web)サイトに[マルウェア](#マルウェア)などを仕込み、標的ユーザのアクセスを待ち伏せる手法。標的ユーザがアクセスする可能性の高い[Web](../../../../network/_/chapters/web.md#web)サイトを調査し、[セキュリティ](./security.md#セキュリティ)に欠陥のある[Web](../../../../network/_/chapters/web.md#web)サイトに侵入して悪意のあるコードを埋め込むなどして、再度標的ユーザがその[Web](../../../../network/_/chapters/web.md#web)サイトにアクセスすることを待ち伏せする。\n\n\n"},{"term":"ブルートフォース攻撃（総当たり攻撃）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ブルートフォース攻撃","content":"\n**ブルートフォース攻撃**（**総当たり攻撃**）は、すべての可能な組み合わせを試行することによって、パスワードや暗号鍵を推測する攻撃手法。攻撃者は自動化されたツールやスクリプトを使用して、連続的にパスワードや鍵を試し続ける。正しい組み合わせを推測するのには非常に多くの時間がかかる可能性があるため、よく用いられるパスワードや単語を使用する**辞書攻撃**や、予め計算された[ハッシュ値](./encryption_technology.md#ハッシュ)を用いて元のパスワードを逆引きする**レインボーテーブル**などで、攻撃を効率化する。\n\n強力なパスワードを設定する、ログイン試行回数に制限を設ける、[二要素認証](./security_technology.md#多要素認証)を使用する、といった対策方法がある。\n\n\n"},{"term":"辞書攻撃","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ブルートフォース攻撃","content":"\n**ブルートフォース攻撃**（**総当たり攻撃**）は、すべての可能な組み合わせを試行することによって、パスワードや暗号鍵を推測する攻撃手法。攻撃者は自動化されたツールやスクリプトを使用して、連続的にパスワードや鍵を試し続ける。正しい組み合わせを推測するのには非常に多くの時間がかかる可能性があるため、よく用いられるパスワードや単語を使用する**辞書攻撃**や、予め計算された[ハッシュ値](./encryption_technology.md#ハッシュ)を用いて元のパスワードを逆引きする**レインボーテーブル**などで、攻撃を効率化する。\n\n強力なパスワードを設定する、ログイン試行回数に制限を設ける、[二要素認証](./security_technology.md#多要素認証)を使用する、といった対策方法がある。\n\n\n"},{"term":"レインボーテーブル","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ブルートフォース攻撃","content":"\n**ブルートフォース攻撃**（**総当たり攻撃**）は、すべての可能な組み合わせを試行することによって、パスワードや暗号鍵を推測する攻撃手法。攻撃者は自動化されたツールやスクリプトを使用して、連続的にパスワードや鍵を試し続ける。正しい組み合わせを推測するのには非常に多くの時間がかかる可能性があるため、よく用いられるパスワードや単語を使用する**辞書攻撃**や、予め計算された[ハッシュ値](./encryption_technology.md#ハッシュ)を用いて元のパスワードを逆引きする**レインボーテーブル**などで、攻撃を効率化する。\n\n強力なパスワードを設定する、ログイン試行回数に制限を設ける、[二要素認証](./security_technology.md#多要素認証)を使用する、といった対策方法がある。\n\n\n"},{"term":"XSS（クロスサイトスクリプティング）","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"xss","content":"\n**XSS**（**クロスサイトスクリプティング**）は、[Web](../../../../network/_/chapters/web.md#web)[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の脆弱性を悪用して攻撃者がスクリプトを挿入し、ユーザの[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)上で実行される攻撃手法。攻撃者は入力フィールドや[URL](../../../../network/_/chapters/web.md#url)パラメータなどにスクリプトを埋め込み、ユーザがそのページにアクセスした際にスクリプトが実行されるようにする。\n\n\n"},{"term":"SQLインジェクション","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"sqlインジェクション","content":"\n**SQLインジェクション**は、[システム](../../../_/chapters/system.md#システム)で利用される[SQL](../../../../development/database/_/chapters/sql.md#sql)[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)に悪意のあるコードを挿入する攻撃手法。攻撃者は[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の入力フィールドやパラメータに対して[SQL](../../../../development/database/_/chapters/sql.md#sql)分の一部として解釈されるコードを挿入することで、[データベース](../../../../development/database/_/chapters/database.md#データベース)に対する不正なアクセスや操作を行うことができる。\n\nSQLインジェクションの一般的な攻撃例として、入力フィールドに以下のような文字列を入力して[リクエスト](../../../_/chapters/system_processing_model.md#リクエスト)を行うことで、その[テーブル](../../../../development/database/_/chapters/rdb.md#テーブル)で取得可能なすべてのデータを取得できる。\n\n```sql\n' OR '1' = 1\n```\n\nまた、以下のように[SQL](../../../../development/database/_/chapters/sql.md#sql)の終わりを表す `;` に続けて[SQL](../../../../development/database/_/chapters/sql.md#sql)を記述することで、不正な[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を実行することができる可能性もある。\n\n```sql\n'; DROP TABLE users --\n```\n\n\n"},{"term":"バッファオーバフロー","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"バッファオーバフロー","content":"\n**バッファオーバフロー**は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が確保された[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)領域を超えてデータを書き込むことにより、攻撃者が不正な[コード](../../../../programming/_/chapters/programming.md#ソースコード)を実行させる攻撃手法。主に[C](../../../../programming/_/chapters/programming_language.md#c言語)や[C++](../../../../programming/_/chapters/programming_language.md#c)などの[低水準言語](../../../../programming/_/chapters/programming.md#低水準言語)で記述された[プログラム](../../../../programming/_/chapters/programming.md#プログラム)で発生しやすい。攻撃者はバッファの範囲を越えるデータを書き込むことで、[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)の隣接領域や[スタック](../../../../computer/hardware/_/chapters/memory.md#スタック領域)上の重要なデータを上書きしようとする。\n\n\n"},{"term":"ゼロデイ攻撃","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ゼロデイ攻撃","content":"\n**ゼロデイ攻撃**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の脆弱性が公開されてから修正パッチが提供されていない状態で行われる攻撃手法。攻撃者は[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の脆弱性を見つけ、セキュリティベンダーや[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の開発者が認識しておらず、防御策が存在してない状態で攻撃が行われる。\n\n\n"},{"term":"ソーシャルエンジニアリング","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ソーシャルエンジニアリング","content":"\n**ソーシャルエンジニアリング**は、人々の心理的な弱点や信頼を悪用して情報やアクセス権限を入手するための攻撃方法。技術的な脆弱性を突くのではなく、人間の誤解や信頼に漬け込むことで攻撃を行う。\n\n\n"},{"term":"パスザハッシュ","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"パスザハッシュ","content":"\n**パスザハッシュ**は、主に[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)の[認証](./security_technology.md#認証)[システム](../../../_/chapters/system.md#システム)に対して行われる攻撃で、攻撃者はパスワードハッシュを窃取することで標的ユーザのパスワードを推測することなく認証をバイパスする。[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)はNTLM認証を用いており、入力されたパスワードを[ハッシュ](./encryption_technology.md#ハッシュ)化して[システム](../../../_/chapters/system.md#システム)の特定領域に保存している。攻撃者はこの[ハッシュ値](./encryption_technology.md#ハッシュ)を摂取することで、[システム](../../../_/chapters/system.md#システム)の認証を突破する。\n\nまた、[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)のよりセキュアな認証方式であるKerberos認証を採用しているが、パスザハッシュで得た権限をもとにKerberos認証を破る手法として**パスザチケット**攻撃も生み出されている。\n\n\n"},{"term":"パスザチケット","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"パスザチケット","content":""},{"term":"ディレクトリトラバーサル","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"ディレクトリトラバーサル","content":"\n**ディレクトリトラバーサル**は、[Web](../../../../network/_/chapters/web.md#web)[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の[パス](../../../../computer/software/_/chapters/file_system.md#パス)名として `../` や `..\\` といった親[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)を表す文字列を使用して、[サーバ](../../../_/chapters/system_processing_model.md#クライアントサーバシステム)内の公開が予定されていない[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を指定する攻撃。機密[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の情報漏えいや設定ファイルの改ざんなどに利用される恐れがある。\n\n\n"},{"term":"テンペスト","link":"./note/ja/./system/security/_/chapters/cyber_attack.md","flagment":"テンペスト","content":"\n**テンペスト**は、電子機器から発生する電磁波を盗聴する攻撃手法、あるいはこれを防ぐために電磁波の放射を制御する手法。電子機器が発する電磁波は周囲に漏れ出しており、他の電磁波受信機によって機密情報などが傍受される可能性がある。特に軍事や政府機関、重要な機密情報を扱う組織などで重要視され、対策が行われている。\n\n電磁波を吸収する材料や導電性の材料で作られたシールドを用いたり、電磁波の発生や伝搬を制御するためのフィルター（電磁波を特定の周波数帯域で遮断・減衰するなど）を使用するといった対策が行われる。\n"},{"term":"共通鍵暗号方式","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"共通鍵暗号方式","content":"\n**共通鍵暗号方式**は、同じ鍵を使用してデータを暗号化および復号化する暗号化方式。送信者と受信者が事前に同じ鍵を共有する必要がある。共通鍵暗号方式は、高速性と効率性に優れており、暗号化や復号化のプロセスが簡単で[計算量](../../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)が少ないため、処理が迅速に行われる。ただし、共通鍵を安全に共有する必要があり、第三者から鍵を守るためにセキュアな方法で鍵を伝達しなければならない。\n\n"},{"term":"公開鍵暗号方式","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"公開鍵暗号方式","content":"\n**公開鍵暗号方式**は、異なる鍵のペアである公開鍵と秘密鍵を使用してデータを暗号化および復号化する暗号化方式。公開鍵は一般的に公開され、秘密鍵はセキュアに保護される。公開鍵暗号方式は、[セキュリティ](./security.md#セキュリティ)と鍵共有の容易さの点で優れている。\n\n"},{"term":"ECC（楕円曲線暗号: Elliptic Curve Cryptography）","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"ecc","content":"\n**ECC**（**楕円曲線暗号**: Elliptic Curve Cryptography）は、[公開鍵暗号方式](#公開鍵暗号方式)のひとつで、[RSA](#rsa)と同じレベルの[セキュリティ](./security.md#セキュリティ)を実現するためにより短い鍵長を使用できるという特徴がある。ECCは、楕円曲線上の数学的な操作を元に暗号化を行う。鍵長が短いため、高いセキュリティレベルを維持しながら、処理速度の向上やリソース使用量の削減が可能となる。\n\n"},{"term":"ハッシュ","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"ハッシュ","content":"\n**ハッシュ**は、任意長の入力データを固定長のデジタル指紋（ハッシュ値）に変換する数学的な関数。ハッシュ関数は入力データからハッシュ値を生成することは容易であるが、ハッシュ値から入力データを復元することは困難であり、異なる入力に対しては異なるハッシュ値が、同じ入力に対しては同じハッシュ値が生成される、という特徴がある。パスワード保存時にハッシュ値を保存したり、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)のダウンロード時にハッシュ値を提供してその[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の正当性を証明したりする、といった目的で使用される。\n\n"},{"term":"衝突","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"衝突","content":"\n**衝突**は、[ハッシュ関数](#ハッシュ)において、異なる入力値に対して同じ[ハッシュ値](#ハッシュ)を出力してしまう問題。強力な[ハッシュ関数](#ハッシュ)は衝突が非常に低い[確率](../../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で起こるように設計されている。\n\n"},{"term":"デジタル署名","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"デジタル署名","content":"\n**デジタル署名**は、[公開鍵暗号方式](#公開鍵暗号方式)を利用して、電子的な文書やデータが改ざんされることを防止し、送信者の身元を証明する技術。\n\nデジタル署名の流れは以下の通り。\n\n- 署名者はキーペアを作成し、公開鍵を公開する\n- 暗号化データの圧縮のため、[ハッシュ関数](#ハッシュ)を用いてデータの[ハッシュ値](#ハッシュ)を算出する\n- 秘密鍵を用いて、[ハッシュ値](#ハッシュ)を暗号化する\n- 暗号化した[ハッシュ値](#ハッシュ)とデータを受信者に送信する\n- 受信者は公開鍵を使用して[ハッシュ値](#ハッシュ)を復号する\n- 受信者は[ハッシュ関数](#ハッシュ)を使用して受信したデータを[ハッシュ](#ハッシュ)化し、受け取った[ハッシュ値](#ハッシュ)と同じ値になるか照合することで、データに改ざんがないことを確認する\n\n"},{"term":"タイムスタンプ認証","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"タイムスタンプ認証","content":"\n**タイムスタンプ認証**は、公的な**タイムスタンプサービス**(Trusted Timestamp Authority)によって提供される、信頼できるタイムスタンプの署名。[デジタル署名](#デジタル署名)は、他者による改ざんは検出できるものの、本人による改ざんは検出できない。タイムスタンプを付与することによって、そのタイムスタンプが付与された時点において、ドキュメントが確かに存在しており、改ざんされていないことを証明できるようになる。\n\n\n"},{"term":"PKI（公開鍵基盤: Public Key Infrastructure）","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"デジタル署名","content":"\n**デジタル署名**は、[公開鍵暗号方式](#公開鍵暗号方式)を利用して、電子的な文書やデータが改ざんされることを防止し、送信者の身元を証明する技術。\n\nデジタル署名の流れは以下の通り。\n\n- 署名者はキーペアを作成し、公開鍵を公開する\n- 暗号化データの圧縮のため、[ハッシュ関数](#ハッシュ)を用いてデータの[ハッシュ値](#ハッシュ)を算出する\n- 秘密鍵を用いて、[ハッシュ値](#ハッシュ)を暗号化する\n- 暗号化した[ハッシュ値](#ハッシュ)とデータを受信者に送信する\n- 受信者は公開鍵を使用して[ハッシュ値](#ハッシュ)を復号する\n- 受信者は[ハッシュ関数](#ハッシュ)を使用して受信したデータを[ハッシュ](#ハッシュ)化し、受け取った[ハッシュ値](#ハッシュ)と同じ値になるか照合することで、データに改ざんがないことを確認する\n\n"},{"term":"ドメイン認証","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"ドメイン認証","content":"\n**ドメイン認証**(DV)は、SSL証明書の中でも最も簡単に取得できる認証方法で、申請者が[ドメイン](../../../../network/_/chapters/internet_layer.md#ドメイン名)の所有者であることを保証する。低価格でスピーディに取得できるため、個人の[Web](../../../../network/_/chapters/web.md#web)サイトや期間限定ページなどに広く使用されている。\n\n"},{"term":"企業実在認証","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"企業実在認証","content":"\n**企業実在認証**(OV)は、法人向けの認証方法で、[ドメイン認証](#ドメイン認証)に加え、[Web](../../../../network/_/chapters/web.md#web)サイトの運用組織の存在を確認する。第三者機関に情報登録している法人しか申請することができず、運営組織の実在性を情報紹介や電話確認などで認証するため、[ドメイン認証](#ドメイン認証)よりも信頼性の高い認証方法といえる。主に決済情報や個人情報を扱う法人サイトで用いられる。\n\n"},{"term":"EV認証","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"ev認証","content":"\n**EV認証**は、SSL証明書の中で最も厳格な認証方法で、[ドメイン](../../../../network/_/chapters/internet_layer.md#ドメイン名)の所有者確認と運営組織の実在性を確認するが、[企業実在認証](#企業実在認証)よりも実在性を厳しくチェックする。第三者機関に法人情報があるだけでは審査は通らず、企業の活動実績も評価対象となる。最も厳格な認証であるため、大手企業や公的機関などの[ホームページ](../../../../network/_/chapters/web.md#web)に利用されることが多い。\n\n\n"},{"term":"ステガノグラフィ","link":"./note/ja/./system/security/_/chapters/encryption_technology.md","flagment":"ステガノグラフィ","content":"\n**ステガノグラフィ**は、機密情報を他のデータ（画像や音声、ビデオなど）の中に隠匿する技術。あくまで情報を隠すための手法であり、暗号化ではない。\n"},{"term":"ファイアウォール","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ファイアウォール","content":"\n**ファイアウォール**は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)トラフィックの監視と制御を行い、不正なアクセスや悪意のあるトラフィックを遮断することで、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)の[セキュリティ](./security.md#セキュリティ)を強化するデバイスや[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)。[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上を流れる[パケット](../../../../network/_/chapters/network.md#パケット)を監視し、特定の条件に基づいてフィルタリングを行う（**パケットフィルタリング**）。\n\n"},{"term":"パケットフィルタリング","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ファイアウォール","content":"\n**ファイアウォール**は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)トラフィックの監視と制御を行い、不正なアクセスや悪意のあるトラフィックを遮断することで、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)の[セキュリティ](./security.md#セキュリティ)を強化するデバイスや[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)。[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上を流れる[パケット](../../../../network/_/chapters/network.md#パケット)を監視し、特定の条件に基づいてフィルタリングを行う（**パケットフィルタリング**）。\n\n"},{"term":"IDS（侵入検知システム: Intrusion Detectino System）","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ids","content":"\n**IDS**（**侵入検知システム**: Intrusion Detectino System）は、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)や[システム](../../../_/chapters/system.md#システム)における侵入や攻撃を検知するための[セキュリティ](./security.md#セキュリティ)[システム](../../../_/chapters/system.md#システム)。[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)トラフィックや[システム](../../../_/chapters/system.md#システム)のログを監視し、異常なアクティビティや攻撃パターンを特定することで、潜在的な[セキュリティ](./security.md#セキュリティ)侵害を検知する。\n\n"},{"term":"IPS（侵入防御システム: Intrusion Prevention System）","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ips","content":"\n**IPS**（侵入防御システム: Intrusion Prevention System）は、[IDS](ids)の機能に加えて、攻撃を防止するためのアクションを実行するための[セキュリティ](./security.md#セキュリティ)[システム](../../../_/chapters/system.md#システム)。[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)トラフィックや[システム](../../../_/chapters/system.md#システム)のログを監視し、悪意のある侵入や攻撃を検知して即座に対応を講じることで、[セキュリティ](./security.md#セキュリティ)の強化を図る。\n\n\n"},{"term":"ブロックチェーン","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ブロックチェーン","content":"\n**ブロックチェーン**は、分散型の[データベース](../../../../development/database/_/chapters/database.md#データベース)技術であり、複数の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)間で共有されるデータの連鎖（チェーン）を指す用語。オンライン取引の記録やデータの透明性・信頼性・[セキュリティ](./security.md#セキュリティ)を確保するために使用される。\n\nブロックチェーンは複数のノード（[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)）で分散された[データベース](../../../../development/database/_/chapters/database.md#データベース)で、各ノードは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に参加し、取引やデータの承認を行う。この分散構造により、信頼性や[可用性](../../../_/chapters/system_performance_evaluation.md#可用性)が高まり、[単一障害点](../../../_/chapters/system_architecture.md#単一障害点)のリスクが低減される。新しいデータは前のブロックに追加される形で連続的に追跡され、一度追加されたデータは改ざんや削除ができないため不変性が保たれる。また、ブロックチェーンは公開型であり、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上のすべての参加者が同じ情報を共有するため、透明性が確保される。\n\n\n"},{"term":"認証","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"認証","content":"\n**認証**は、ユーザが正当な権限を持っていることを確認するための手段。パスワードや[多要素認証](#多要素認証)、[生体認証](#生体認証)などにより、ユーザの身元を確認する。\n\n"},{"term":"デジタルフォレンジック","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"デジタルフォレンジック","content":"\n**デジタルフォレンジック**は、サイバー[セキュリティ](./security.md#セキュリティ)における[インシデント](./security.md#インシデント)対応を含めた、被害及び加害[システム](../../../_/chapters/system.md#システム)の調査全般を指す用語。サイバー犯罪の捜査や企業の内部調査、[セキュリティ](./security.md#セキュリティ)[インシデント](./security.md#インシデント)調査といった分野で活用される。\n\n"},{"term":"ハニーポット","link":"./note/ja/./system/security/_/chapters/security_technology.md","flagment":"ハニーポット","content":"\n**ハニーポット**は、攻撃者を誘い込み、行動や目的などを観測するための[システム](../../../_/chapters/system.md#システム)。[セキュリティ](./security.md#セキュリティ)研究や[インシデント](./security.md#インシデント)対応の一環として使用されることが多く、対話型ハニーポットや仮想ハニーポット、分散型ハニーポットなどの種類がある。ただし、攻撃者の攻撃を受けることを前提としているため、十分な[セキュリティ](./security.md#セキュリティ)知識を持ち、慎重な計画や設計を行う必要がある。\n"},{"term":"ネットワーク（コンピュータネットワーク）","link":"./note/ja/./network/_/chapters/network.md","flagment":"ネットワーク","content":"\n**ネットワーク**（**コンピュータネットワーク**）は、通信機能を有する複数の[パソコン](../../../computer/_/chapters/computer.md#パーソナルコンピュータ)やモバイル端末などを接続し、情報のやり取りを行うための仕組み。\n\n"},{"term":"キャリア（電気通信事業者）","link":"./note/ja/./network/_/chapters/network.md","flagment":"キャリア","content":"\n**キャリア**（電気通信事業者）は、通信サービスを提供する企業。\n\n"},{"term":"帯域","link":"./note/ja/./network/_/chapters/network.md","flagment":"帯域","content":"\n**帯域**は、電気信号などの通信に使用される周波数における、最も高い周波数と最も低い周波数の範囲。帯域が広いと一度に送信できる[情報量](../../../basics/information_theory/_/chapters/information_theory.md#情報量)が多くなり、狭いと少なくなる。\n\n\n"},{"term":"回線交換","link":"./note/ja/./network/_/chapters/network.md","flagment":"回線交換","content":"\n**回線交換**は、固定電話の回線などで使用されている方式で、[帯域](#帯域)を使用する端末を交換機で切り替えることで、その[帯域](#帯域)を占有して使用する仕組み。\n\n\n"},{"term":"パケット交換","link":"./note/ja/./network/_/chapters/network.md","flagment":"パケット交換","content":"\n**パケット交換**は、[ネットワーク](#ネットワーク)を流れるデータを分割してやり取りする方式で、[帯域](#帯域)を占有することなく共有して使用する仕組み。[インターネット](#インターネット)ではパケット交換が用いられており、通信速度は状況によって変わる。\n\n"},{"term":"パケット","link":"./note/ja/./network/_/chapters/network.md","flagment":"パケット","content":"\n**パケット交換**は、[ネットワーク](#ネットワーク)を流れるデータを分割してやり取りする方式で、[帯域](#帯域)を占有することなく共有して使用する仕組み。[インターネット](#インターネット)ではパケット交換が用いられており、通信速度は状況によって変わる。\n\n"},{"term":"データグラム","link":"./note/ja/./network/_/chapters/network.md","flagment":"パケット","content":"\n**パケット交換**は、[ネットワーク](#ネットワーク)を流れるデータを分割してやり取りする方式で、[帯域](#帯域)を占有することなく共有して使用する仕組み。[インターネット](#インターネット)ではパケット交換が用いられており、通信速度は状況によって変わる。\n\n"},{"term":"ヘッダー","link":"./note/ja/./network/_/chapters/network.md","flagment":"ヘッダー","content":"\n**ヘッダー**は、[パケット](#パケット)自体に関する制御情報やメタデータを含む部分。各[レイヤ](./network_architecture.md#レイヤ)の処理に必要な情報が含まれており、上位の[レイヤ](./network_architecture.md#レイヤ)のヘッダーは下位の[レイヤ](./network_architecture.md#レイヤ)の[パケット](#パケット)の[ペイロード](#ペイロード)に含まれている。\n\n"},{"term":"ペイロード","link":"./note/ja/./network/_/chapters/network.md","flagment":"ペイロード","content":"\n**ペイロード**は、[パケット](#パケット)の本体部分であり、実際に転送されるデータを含む。下位の[レイヤ](./network_architecture.md#レイヤ)のペイロードには、上位の[レイヤ](./network_architecture.md#レイヤ)の[パケット](#パケット)（[ヘッダー](#ヘッダー)とペイロード）が含まれており、[アプリケーション層](./network_architecture.md#アプリケーション層)のペイロードにはユーザデータやアプリケーションデータ、ファイル、動画、メッセージなど特定の[プロトコル](./network_architecture.md#プロトコル)や[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)で処理されるデータが含まれる。\n\n\n"},{"term":"ネットワークトポロジ","link":"./note/ja/./network/_/chapters/network.md","flagment":"ネットワークトポロジ","content":"\n**ネットワークトポロジ**は、[ネットワーク](#ネットワーク)の接続形態や構成形態のこと。\n\n"},{"term":"半二重通信","link":"./note/ja/./network/_/chapters/network.md","flagment":"半二重通信","content":"\n**半二重通信**は、送信と受信を同時に行えない通信。\n\n"},{"term":"全二重通信","link":"./note/ja/./network/_/chapters/network.md","flagment":"全二重通信","content":"\n**全二重通信**は、送信と受信を同時に行える通信。\n\n"},{"term":"媒体共有型","link":"./note/ja/./network/_/chapters/network.md","flagment":"媒体共有型","content":"\n**媒体共有型**の[ネットワーク](#ネットワーク)は、通信媒体を複数のノードで共有する方式で、[半二重通信](#半二重通信)となる。同じ通信路を用いてデータの送受信を制御する仕組みが必要となる。\n\n"},{"term":"媒体非共有型","link":"./note/ja/./network/_/chapters/network.md","flagment":"媒体非共有型","content":"\n**媒体非共有型**の[ネットワーク](#ネットワーク)は、通信媒体を共有せずに占有する方式で、[全二重通信](#全二重通信)となる。中央装置である[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)に高度な機能を持たせることで、仮想的な[ネットワーク](#ネットワーク)の構築やデータ流量の制御なども可能になる。\n\n"},{"term":"ポイントツーポイント方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"ポイントツーポイント方式","content":"\n**ポイントツーポイント方式**は、2つの機器を物理的または論理的に直接つなげる接続形態。\n\n"},{"term":"バス型","link":"./note/ja/./network/_/chapters/network.md","flagment":"バス型","content":"\n**バス型**は、1本の伝送路に多数のノードを接続する接続形態。配線のコストが小さく、あるノードが故障しても他のノードに与える影響が小さい。バス型は、[媒体共有型](#媒体共有型)の[ネットワーク](#ネットワーク)である。\n\n"},{"term":"スター型","link":"./note/ja/./network/_/chapters/network.md","flagment":"スター型","content":"\n**スター型**は、個々のノードを中央となる制御局（[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)）に接続した形態。ノードに障害が発生した場合に検出が容易であるが、[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)に障害が発生すると全体がダウンする。スター型は、[媒体非共有型](#媒体非共有型)の[ネットワーク](#ネットワーク)である。\n\n"},{"term":"ツリー型","link":"./note/ja/./network/_/chapters/network.md","flagment":"ツリー型","content":"\n**ツリー型**は、[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)を使用した[スター型](#スター型)の接続を多段階にした形態。このような接続を**カスケード接続**という。\n\n"},{"term":"カスケード接続","link":"./note/ja/./network/_/chapters/network.md","flagment":"ツリー型","content":"\n**ツリー型**は、[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)を使用した[スター型](#スター型)の接続を多段階にした形態。このような接続を**カスケード接続**という。\n\n"},{"term":"リング型","link":"./note/ja/./network/_/chapters/network.md","flagment":"リング型","content":"\n**リング型**は、両隣のノードを接続して、全体としてループ状に構成した形態。伝送路に障害が発生した場合に備えてリングを二重化しておくのが一般的。リング型は、[媒体共有型](#媒体共有型)の[ネットワーク](#ネットワーク)である。\n\n\n"},{"term":"アクセス制御方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"アクセス制御方式","content":"\n**アクセス制御方式**は、複数の端末が接続された[媒体共有型](#媒体共有型)の通信路において、[衝突](#衝突)を回避するための仕組み。\n\n"},{"term":"衝突（コリジョン）","link":"./note/ja/./network/_/chapters/network.md","flagment":"衝突","content":"\n**衝突**（**コリジョン**）は、複数の端末が接続された[媒体共有型](#媒体共有型)の通信路において、ある端末がデータを伝送中に、別の端末からのデータの伝送が行われることで、データが破損する障害。\n\n"},{"term":"CSMA方式（コンテンション方式: Carrier Sense Multiple Access）","link":"./note/ja/./network/_/chapters/network.md","flagment":"csma方式","content":"\n**CSMA方式**（**コンテンション方式**: Carrier Sense Multiple Access）は、主に[バス型](#バス型)の[LAN](#lan)に採用される[アクセス制御方式](#アクセス制御方式)。複数のノードが同時に伝送路にデータを送出してしまうと、[衝突](#衝突)が発生してデータが破壊される。\n\n"},{"term":"CSMA/CD方式（CSMA with Collision Detection）","link":"./note/ja/./network/_/chapters/network.md","flagment":"csmacd方式","content":""},{"term":"CSMA/CA方式（CSMA with Collision Avoidance）","link":"./note/ja/./network/_/chapters/network.md","flagment":"csmaca方式","content":""},{"term":"トークンパッシング方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"トークンパッシング方式","content":"\n**トークンパッシング方式**は、主に[リング型](#リング型)の[LAN](#lan)に採用されている[アクセス制御方式](#アクセス制御方式)。伝送路上に**トークン**と呼ぶ特別な[フレーム](./datalink_layer.md#フレーム)を巡回させ、トークンを保有しているノードだけに送信権を与えるという仕組み。通信路が混雑していない場合には伝送路の使用効率が悪くなってしまう。\n\nどのノードも送信要求を行っていない状態のとき、ただ巡回しているだけのトークンを**フリートークン**という。ノードがフリートークンを捕まえてデータの送信を行っている状態のとき、このトークのことを**ビジートークン**という。宛先のノードがビジートークンを受け取り、再び送信元に戻ると、送信元はフリートークンを送出して送信が完了する。\n\n"},{"term":"トークン","link":"./note/ja/./network/_/chapters/network.md","flagment":"トークンパッシング方式","content":"\n**トークンパッシング方式**は、主に[リング型](#リング型)の[LAN](#lan)に採用されている[アクセス制御方式](#アクセス制御方式)。伝送路上に**トークン**と呼ぶ特別な[フレーム](./datalink_layer.md#フレーム)を巡回させ、トークンを保有しているノードだけに送信権を与えるという仕組み。通信路が混雑していない場合には伝送路の使用効率が悪くなってしまう。\n\nどのノードも送信要求を行っていない状態のとき、ただ巡回しているだけのトークンを**フリートークン**という。ノードがフリートークンを捕まえてデータの送信を行っている状態のとき、このトークのことを**ビジートークン**という。宛先のノードがビジートークンを受け取り、再び送信元に戻ると、送信元はフリートークンを送出して送信が完了する。\n\n"},{"term":"フリートークン","link":"./note/ja/./network/_/chapters/network.md","flagment":"トークンパッシング方式","content":"\n**トークンパッシング方式**は、主に[リング型](#リング型)の[LAN](#lan)に採用されている[アクセス制御方式](#アクセス制御方式)。伝送路上に**トークン**と呼ぶ特別な[フレーム](./datalink_layer.md#フレーム)を巡回させ、トークンを保有しているノードだけに送信権を与えるという仕組み。通信路が混雑していない場合には伝送路の使用効率が悪くなってしまう。\n\nどのノードも送信要求を行っていない状態のとき、ただ巡回しているだけのトークンを**フリートークン**という。ノードがフリートークンを捕まえてデータの送信を行っている状態のとき、このトークのことを**ビジートークン**という。宛先のノードがビジートークンを受け取り、再び送信元に戻ると、送信元はフリートークンを送出して送信が完了する。\n\n"},{"term":"ビジートークン","link":"./note/ja/./network/_/chapters/network.md","flagment":"トークンパッシング方式","content":"\n**トークンパッシング方式**は、主に[リング型](#リング型)の[LAN](#lan)に採用されている[アクセス制御方式](#アクセス制御方式)。伝送路上に**トークン**と呼ぶ特別な[フレーム](./datalink_layer.md#フレーム)を巡回させ、トークンを保有しているノードだけに送信権を与えるという仕組み。通信路が混雑していない場合には伝送路の使用効率が悪くなってしまう。\n\nどのノードも送信要求を行っていない状態のとき、ただ巡回しているだけのトークンを**フリートークン**という。ノードがフリートークンを捕まえてデータの送信を行っている状態のとき、このトークのことを**ビジートークン**という。宛先のノードがビジートークンを受け取り、再び送信元に戻ると、送信元はフリートークンを送出して送信が完了する。\n\n"},{"term":"TDMA方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"tdma方式","content":"\n**TDMA方式**は、時間を**タイムスロット**に分割して、各端末に送信権を与える[アクセス制御方式](#アクセス制御方式)。2つの端末に同じタイムスロットを与えることで、[ポイントツーポイント通信](#ポイントツーポイント方式)が可能になる。\n\n\n"},{"term":"タイムスロット","link":"./note/ja/./network/_/chapters/network.md","flagment":"tdma方式","content":"\n**TDMA方式**は、時間を**タイムスロット**に分割して、各端末に送信権を与える[アクセス制御方式](#アクセス制御方式)。2つの端末に同じタイムスロットを与えることで、[ポイントツーポイント通信](#ポイントツーポイント方式)が可能になる。\n\n\n"},{"term":"フレーム転送方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"フレーム転送方式","content":"\n"},{"term":"ストア&フォワード方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"ストアフォワード方式","content":""},{"term":"カットスルー方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"カットスルー方式","content":"\n**カットスルー方式**は、[フレーム](./datalink_layer.md#フレーム)の先頭に記された[MACアドレス](./address_on_network.md#macアドレス)を受信後、すぐにその[アドレス](./address_on_network.md#macアドレス)に対して[フレーム](./datalink_layer.md#フレーム)の転送を開始する方式。高速な転送が行える一方で、エラーチェックができない。\n\n\n"},{"term":"ネットワークループの回避","link":"./note/ja/./network/_/chapters/network.md","flagment":"ネットワークループの回避","content":"\n[ブリッジ](./network_architecture.md#ブリッジ)で[ネットワーク](#ネットワーク)を接続する際にループが発生すると、最悪の場合には[フレーム](./datalink_layer.md#フレーム)がループ内を巡回し続けることで[ネットワーク](#ネットワーク)が[メルトダウン](#メルトダウン)してしまう。\n\n"},{"term":"メルトダウン","link":"./note/ja/./network/_/chapters/network.md","flagment":"メルトダウン","content":"\n**メルトダウン**は、[ネットワーク](#ネットワーク)内を異常な[パケット](#パケット)が埋め尽くして、通信不能な状態になる現象。\n\n"},{"term":"スパニングツリー方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"スパニングツリー方式","content":"\n**スパニングツリー方式**は、各[ブリッジ](./network_architecture.md#ブリッジ)が定期的に**BPDU**(Bridge Protocol Data Unit)と呼ばれる[パケット](#パケット)を交換し、使用する[ポート](./address_on_network.md#ポート番号)と使用しない[ポート](./address_on_network.md#ポート番号)を切り替える方式。これにより、通信路が自動的に切り替わり、ループの発生を防ぐことができる。\n\nスパニングツリー方式を改良したものとして、**RSTP**(Rapid Spanning Tree Protocol)や、**リンクアグリゲーション**、**LLDP**(Link Layer Discovery Protocol)といった方式がある。\n\n\n"},{"term":"リンクアグリゲーション","link":"./note/ja/./network/_/chapters/network.md","flagment":"スパニングツリー方式","content":"\n**スパニングツリー方式**は、各[ブリッジ](./network_architecture.md#ブリッジ)が定期的に**BPDU**(Bridge Protocol Data Unit)と呼ばれる[パケット](#パケット)を交換し、使用する[ポート](./address_on_network.md#ポート番号)と使用しない[ポート](./address_on_network.md#ポート番号)を切り替える方式。これにより、通信路が自動的に切り替わり、ループの発生を防ぐことができる。\n\nスパニングツリー方式を改良したものとして、**RSTP**(Rapid Spanning Tree Protocol)や、**リンクアグリゲーション**、**LLDP**(Link Layer Discovery Protocol)といった方式がある。\n\n\n"},{"term":"アクセスポイント（基地局）","link":"./note/ja/./network/_/chapters/network.md","flagment":"アクセスポイント","content":"\n**アクセスポイント**（基地局）は、[無線LAN](#無線lan)を通じて各機器を[ネットワーク](#ネットワーク)に接続するための機器。\n\n"},{"term":"Wi-Fi","link":"./note/ja/./network/_/chapters/network.md","flagment":"wi-fi","content":"\n**Wi-Fi**は、[無線LAN](#無線lan)の相互接続性の検証を行っている団体が、互換性を確認した製品の証明。\n\n"},{"term":"アドホックモード","link":"./note/ja/./network/_/chapters/network.md","flagment":"アドホックモード","content":"\n**アドホックモード**は、無線端末同士が直接通信する方式。\n\n"},{"term":"インフラストラクチャモード","link":"./note/ja/./network/_/chapters/network.md","flagment":"インフラストラクチャモード","content":"\n**インフラストラクチャモード**は、[ネットワーク](#ネットワーク)型の[アクセスポイント](#アクセスポイント)を経由して無線接続する方式。\n\n"},{"term":"ステルス機能","link":"./note/ja/./network/_/chapters/network.md","flagment":"ステルス機能","content":"\n**ステルス機能**は、[アクセスポイント](#アクセスポイント)が発信する[ESSID](#essid)の情報を端末から読み取れないようにする機能。これにより、接続が許可されている端末だけが[ネットワーク](#ネットワーク)に接続できるようになる。\n\n"},{"term":"ノード","link":"./note/ja/./network/_/chapters/network.md","flagment":"ノード","content":"\n**ノード**は、[ネットワーク](#ネットワーク)に接続された機器や[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)。\n\n"},{"term":"ホスト","link":"./note/ja/./network/_/chapters/network.md","flagment":"ホスト","content":"\n**ホスト**は、[経路制御](./internet_layer.md#ルーティング)を行わない[ノード](#ノード)。\n\n"},{"term":"ルータ","link":"./note/ja/./network/_/chapters/network.md","flagment":"ルータ","content":"\n**ルータ**は、[経路制御](./internet_layer.md#ルーティング)を行う[ノード](#ノード)。\n\n"},{"term":"エンドノード（終点ノード）","link":"./note/ja/./network/_/chapters/network.md","flagment":"エンドノード","content":"\n**エンドノード**（**終点ノード**）は、通信を行う目的で[ネットワーク](#ネットワーク)の末端に接続される装置。\n\n\n"},{"term":"ネットワークの構成","link":"./note/ja/./network/_/chapters/network.md","flagment":"ネットワークの構成","content":"\n"},{"term":"バックボーン","link":"./note/ja/./network/_/chapters/network.md","flagment":"バックボーン","content":"\n**バックボーン**は、大量のデータを高速に送受信することを目的に構築された根幹[ネットワーク](#ネットワーク)。異なるエリアの[ネットワーク](#ネットワーク)をつなぐ役割を果たしている。\n\n"},{"term":"エッジ","link":"./note/ja/./network/_/chapters/network.md","flagment":"エッジ","content":"\n**エッジ**は、[バックボーン](#バックボーン)と、あるエリアの[ネットワーク](#ネットワーク)をつなぐ部分。エッジでは多機能[ルータ](#ルータ)などが利用されている。\n\n"},{"term":"アグリゲーション（アクセス）","link":"./note/ja/./network/_/chapters/network.md","flagment":"アグリゲーション","content":"\n**アグリゲーション**（**アクセス**）は、エリア内の[ネットワーク](#ネットワーク)のうち[エッジ](#エッジ)に接続されている部分。[LAN](#lan)や[ルータ](#ルータ)で集約された回線はアグリゲーションに接続され、[エッジ](#エッジ)や[バックボーン](#バックボーン)を経て通信相手へと接続される。\n\n"},{"term":"アドレス","link":"./note/ja/./network/_/chapters/network.md","flagment":"アドレス","content":"\n**アドレス**は、通信相手の唯一性を保証する識別子。[TCP/IP](./communication_protocol.md#tcpip)においては、[IPアドレス](./address_on_network.md#ipアドレス)や[MACアドレス](./address_on_network.md#macアドレス)、[ポート番号](./address_on_network.md#ポート番号)が用いられている。\n\n\n"},{"term":"携帯端末による通信","link":"./note/ja/./network/_/chapters/network.md","flagment":"携帯端末による通信","content":"\n"},{"term":"基地局","link":"./note/ja/./network/_/chapters/network.md","flagment":"基地局","content":"\n**基地局**は、モバイルオペレータ（携帯電話提供会社）のアンテナが設置されており、[ネットワーク](#ネットワーク)の[アグリゲーション](#アグリゲーション)としての役割を持っている。携帯端末の電源を入れると、自動的に基地局に電波が発信され、最寄りの基地局と通信が行われる。\n\n"},{"term":"局舎","link":"./note/ja/./network/_/chapters/network.md","flagment":"局舎","content":"\n**局舎**は、[基地局](#基地局)に集められた情報を集約するポイントで、[ネットワーク](#ネットワーク)の[エッジ](#エッジ)としての役割を持っている。局舎は[バックボーン](#バックボーン)に接続されている。\n\n"},{"term":"ローミング","link":"./note/ja/./network/_/chapters/network.md","flagment":"ローミング","content":"\n**ローミング**は、携帯端末が物理的に移動した際に、自動的に[基地局](#基地局)間で情報を交換して、接続を引き継いていく仕組み。乗り物などで移動しているユーザが、継続して[インターネット](#インターネット)を利用できるのはローミングのおかげ。\n\n"},{"term":"データセンタ","link":"./note/ja/./network/_/chapters/network.md","flagment":"データセンタ","content":"\n**データセンタ**は、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)や[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)、高速な通信回線などを備えた施設。また、大規模なデータセンタは直接[バックボーン](#バックボーン)に接続されている。\n\nSNSサイトなどにおいては世界中の大量のトラフィックを瞬時に処理する必要があるため、多くの[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)機器や[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を複数個所のデータセンタに設置し、高速な[ネットワーク](#ネットワーク)で接続する必要がある。\n\n\n"},{"term":"インターネットの構造","link":"./note/ja/./network/_/chapters/network.md","flagment":"インターネットの構造","content":"\n"},{"term":"バックボーン","link":"./note/ja/./network/_/chapters/network.md","flagment":"バックボーン","content":"\n**バックボーン**は、大量のデータを高速に送受信することを目的に構築された根幹[ネットワーク](#ネットワーク)。異なるエリアの[ネットワーク](#ネットワーク)をつなぐ役割を果たしている。\n\n"},{"term":"スタブ","link":"./note/ja/./network/_/chapters/network.md","flagment":"スタブ","content":"\n**スタブ**は、[インターネット](#インターネット)の階層構造における末端[ネットワーク](#ネットワーク)。\n\n"},{"term":"通信の確立方式","link":"./note/ja/./network/_/chapters/network.md","flagment":"通信の確立方式","content":"\n"},{"term":"コネクション（バーチャルサーキット（仮想回線））","link":"./note/ja/./network/_/chapters/network.md","flagment":"コネクション","content":"\n**コネクション**は、通信を行う機器や[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)の間に確立された仮想的な専用通信路。**バーチャルサーキット**（**仮想回線**）とも呼ばれる。\n\n"},{"term":"コネクション型","link":"./note/ja/./network/_/chapters/network.md","flagment":"コネクション型","content":"\n**コネクション型**は、通信をする前に[コネクション](#コネクション)を確立する方式。通信相手が確実にわかっている状態となるので、通信の信頼性が担保される一方で、無駄な[パケット](#パケット)のやり取りが発生するため、リアルタイム性を重視する通信には向いていない。\n\n"},{"term":"コネクションレス型","link":"./note/ja/./network/_/chapters/network.md","flagment":"コネクションレス型","content":"\n**コネクションレス型**は、相手がいるかどうかを確認せずに送信者の都合でデータを送りつける方式。通信の信頼性は[コネクション型](#コネクション型)に劣るが、不特定多数に対する配信やリアルタイム性を重視する通信に向いている。\n\n\n"},{"term":"通信相手の数による通信方式の分類","link":"./note/ja/./network/_/chapters/network.md","flagment":"通信相手の数による通信方式の分類","content":"\n"},{"term":"ユニキャスト","link":"./note/ja/./network/_/chapters/network.md","flagment":"ユニキャスト","content":"\n**ユニキャスト**は、2つの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)間の一対一の通信。1を意味する「Uni」と、投げるを意味する「Cast」を組み合わせた言葉。従来の電話が代表例。\n\n"},{"term":"ブロードキャスト","link":"./note/ja/./network/_/chapters/network.md","flagment":"ブロードキャスト","content":"\n**ブロードキャスト**は、ある範囲内のすべての[ホスト](#ホスト)を対象としてデータを送信するような通信。不特定多数に向かって一斉配信を行うテレビ放送が代表例。\n\n"},{"term":"マルチキャスト","link":"./note/ja/./network/_/chapters/network.md","flagment":"マルチキャスト","content":"\n**マルチキャスト**は、特定のグループ内での通信。限定された複数の[ホスト](#ホスト)が接続するビデオ会議が代表例。\n\n"},{"term":"エニーキャスト","link":"./note/ja/./network/_/chapters/network.md","flagment":"エニーキャスト","content":"\n**エニーキャスト**は、特定のグループ内のいずれか1つの機器との通信。[ネットワーク](#ネットワーク)上で、条件を満たした[ホスト](#ホスト)の中からどれか1つとの通信を行う。\n"},{"term":"ダウンサイジング","link":"./note/ja/./network/_/chapters/history.md","flagment":"コンピュータとネットワークの発展","content":"\n| 年代     | 概要                                                                                                                                                                                                                              |\n|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1950年代 | バッチ処理の登場。コンピュータが高価だったこの当時は、プログラムやデータを打ち込んだカードやテープを計算機センターに持って行って、後日実行結果を取りに行くようなことをしていた。                                                |\n| 1960年代 | タイムシェアリングシステム(TSS)の登場。それまでとは違い、インタラクティブ（対話的）にコンピュータを操作することが可能となった。この当時利用されていたプログラミング言語としては、**BASIC**や**COBOL**、**FORTRAN**などがある。 |\n| 1970年代 | コンピュータ間通信の登場。利用者の目的や規模にあわせた柔軟なシステムの構築・運用が可能となった。                                                                                                                                  |\n| 1980年代 | パケット交換技術によるコンピュータネットワークの実験が行われる。また、この当時登場した**ウィンドウシステム**（コンピュータ画面上で複数のウィンドウを開くことができる仕組み）により、ネットワークの利便性が劇的に向上した。      |\n| 1990年代 | コンピュータの利用が一般的になり、**ダウンサイジング**や**マルチベンダ接続**（異機種間接続）といった言葉が流行した。マルチベンダ接続に用いられたのがインターネット通信技術であった。                                            |\n\n**閉域網**（**クローズドネットワーク**）の制御ネットワークから[インターネット](./network.md#インターネット)への移行が進んだことで、**サプライチェーンマネジメント**（取引先との間で需要や在庫量の情報を共有して、効率の良い物流を目指すこと）などが流行した。\n\n\n"},{"term":"マルチベンダ接続（異機種接続）","link":"./note/ja/./network/_/chapters/history.md","flagment":"コンピュータとネットワークの発展","content":"\n| 年代     | 概要                                                                                                                                                                                                                              |\n|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1950年代 | バッチ処理の登場。コンピュータが高価だったこの当時は、プログラムやデータを打ち込んだカードやテープを計算機センターに持って行って、後日実行結果を取りに行くようなことをしていた。                                                |\n| 1960年代 | タイムシェアリングシステム(TSS)の登場。それまでとは違い、インタラクティブ（対話的）にコンピュータを操作することが可能となった。この当時利用されていたプログラミング言語としては、**BASIC**や**COBOL**、**FORTRAN**などがある。 |\n| 1970年代 | コンピュータ間通信の登場。利用者の目的や規模にあわせた柔軟なシステムの構築・運用が可能となった。                                                                                                                                  |\n| 1980年代 | パケット交換技術によるコンピュータネットワークの実験が行われる。また、この当時登場した**ウィンドウシステム**（コンピュータ画面上で複数のウィンドウを開くことができる仕組み）により、ネットワークの利便性が劇的に向上した。      |\n| 1990年代 | コンピュータの利用が一般的になり、**ダウンサイジング**や**マルチベンダ接続**（異機種間接続）といった言葉が流行した。マルチベンダ接続に用いられたのがインターネット通信技術であった。                                            |\n\n**閉域網**（**クローズドネットワーク**）の制御ネットワークから[インターネット](./network.md#インターネット)への移行が進んだことで、**サプライチェーンマネジメント**（取引先との間で需要や在庫量の情報を共有して、効率の良い物流を目指すこと）などが流行した。\n\n\n"},{"term":"閉域網（クローズドネットワーク）","link":"./note/ja/./network/_/chapters/history.md","flagment":"コンピュータとネットワークの発展","content":"\n| 年代     | 概要                                                                                                                                                                                                                              |\n|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1950年代 | バッチ処理の登場。コンピュータが高価だったこの当時は、プログラムやデータを打ち込んだカードやテープを計算機センターに持って行って、後日実行結果を取りに行くようなことをしていた。                                                |\n| 1960年代 | タイムシェアリングシステム(TSS)の登場。それまでとは違い、インタラクティブ（対話的）にコンピュータを操作することが可能となった。この当時利用されていたプログラミング言語としては、**BASIC**や**COBOL**、**FORTRAN**などがある。 |\n| 1970年代 | コンピュータ間通信の登場。利用者の目的や規模にあわせた柔軟なシステムの構築・運用が可能となった。                                                                                                                                  |\n| 1980年代 | パケット交換技術によるコンピュータネットワークの実験が行われる。また、この当時登場した**ウィンドウシステム**（コンピュータ画面上で複数のウィンドウを開くことができる仕組み）により、ネットワークの利便性が劇的に向上した。      |\n| 1990年代 | コンピュータの利用が一般的になり、**ダウンサイジング**や**マルチベンダ接続**（異機種間接続）といった言葉が流行した。マルチベンダ接続に用いられたのがインターネット通信技術であった。                                            |\n\n**閉域網**（**クローズドネットワーク**）の制御ネットワークから[インターネット](./network.md#インターネット)への移行が進んだことで、**サプライチェーンマネジメント**（取引先との間で需要や在庫量の情報を共有して、効率の良い物流を目指すこと）などが流行した。\n\n\n"},{"term":"サプライチェーンマネジメント","link":"./note/ja/./network/_/chapters/history.md","flagment":"コンピュータとネットワークの発展","content":"\n| 年代     | 概要                                                                                                                                                                                                                              |\n|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1950年代 | バッチ処理の登場。コンピュータが高価だったこの当時は、プログラムやデータを打ち込んだカードやテープを計算機センターに持って行って、後日実行結果を取りに行くようなことをしていた。                                                |\n| 1960年代 | タイムシェアリングシステム(TSS)の登場。それまでとは違い、インタラクティブ（対話的）にコンピュータを操作することが可能となった。この当時利用されていたプログラミング言語としては、**BASIC**や**COBOL**、**FORTRAN**などがある。 |\n| 1970年代 | コンピュータ間通信の登場。利用者の目的や規模にあわせた柔軟なシステムの構築・運用が可能となった。                                                                                                                                  |\n| 1980年代 | パケット交換技術によるコンピュータネットワークの実験が行われる。また、この当時登場した**ウィンドウシステム**（コンピュータ画面上で複数のウィンドウを開くことができる仕組み）により、ネットワークの利便性が劇的に向上した。      |\n| 1990年代 | コンピュータの利用が一般的になり、**ダウンサイジング**や**マルチベンダ接続**（異機種間接続）といった言葉が流行した。マルチベンダ接続に用いられたのがインターネット通信技術であった。                                            |\n\n**閉域網**（**クローズドネットワーク**）の制御ネットワークから[インターネット](./network.md#インターネット)への移行が進んだことで、**サプライチェーンマネジメント**（取引先との間で需要や在庫量の情報を共有して、効率の良い物流を目指すこと）などが流行した。\n\n\n"},{"term":"TCP/IPの歴史","link":"./note/ja/./network/_/chapters/history.md","flagment":"tcpipの歴史","content":""},{"term":"NSFnet","link":"./note/ja/./network/_/chapters/history.md","flagment":"unixの普及とインターネットの拡大","content":"\n1980年代前後の大学や研究所では、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)の[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)として[BSD UNIX](../../../computer/software/_/chapters/operating_system.md#unix)が広く使用されていた。この[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)の内部には[TCP/IP](./communication_protocol.md#tcpip)が実装されていた。\n\nまた、[LAN](./network.md#lan)の発達により、大学や企業の研究所などが徐々に[ARPANET](#arpanetの誕生)やその後継である**NSFnet**に接続するようになった。この頃から、[TCP/IP](./communication_protocol.md#tcpip)による世界的な[ネットワーク](./network.md#ネットワーク)を[インターネット](./network.md#インターネット)と呼ぶようになった。\n\n"},{"term":"ネットワークアーキテクチャ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ネットワークアーキテクチャ","content":"\n**ネットワークアーキテクチャ**は、通信のデータ形式や[ハードウェア](../../../computer/hardware/_/chapters/hardware.md#ハードウェア)の構成などを論理的に捉えて体系化したもの。ネットワークアーキテクチャには、各メーカが独自に用意しているものもあるが、異なる機種間の通信を実現するための標準的なネットワークアーキテクチャとして[OSI基本参照モデル](#osi基本参照モデル)が提唱されている。\n\n"},{"term":"レイヤ（層）","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"レイヤ","content":"\n**レイヤ**（層）は、役割ごとに階層化された[ネットワークアーキテクチャ](#ネットワークアーキテクチャ)の各階層。\n\n"},{"term":"プロトコル","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"プロトコル","content":"\n**プロトコル**は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)同士が通信を行う際の決まりごと（手順、規約）。階層化された[ネットワークアーキテクチャ](#ネットワークアーキテクチャ)においては、特に通信相手の同じ階層とやり取りする際の規約のことを言う。デファクトスタンダードとなっているプロトコルの実装として、[TCP/IP](./communication_protocol.md#tcpip)がある。\n\n"},{"term":"インタフェース","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"インタフェース","content":"\n**インタフェース**は、階層化された[ネットワークアーキテクチャ](#ネットワークアーキテクチャ)において、上位層と下位層の間でやり取りを行う際の決まりごと。\n\n\n"},{"term":"ISO（国際標準化機構: International Organization for Standardization）","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"iso","content":"\n**ISO**（国際標準化機構: International Organization for Standardization）は、国際的な規模で規格の標準化を行うことを目的とした団体。\n\n"},{"term":"アプリケーション層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"アプリケーション層","content":"\n**アプリケーション層**は、[OSI基本参照モデル](#osi基本参照モデル)において、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)の中で通信に関係する規約を取り決めた[レイヤ](#レイヤ)。[Web](./web.md#web)や[ファイル転送](./application_layer.md#ファイル転送)、[電子メール](./application_layer.md#電子メール)、[遠隔ログイン](./application_layer.md#遠隔ログイン)（仮想端末）等がある。\n\n"},{"term":"プレゼンテーション層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"プレゼンテーション層","content":"\n**プレゼンテーション層**は、[OSI基本参照モデル](#osi基本参照モデル)において、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)が扱う情報を通信に適したデータ形式に変換したり、下位層から来たデータを上位層が処理できるデータ形式にしたりと、データフォーマットに関する責任を負う[レイヤ](#レイヤ)。\n\n例として、[コンピュータ](../../../computer/_/chapters/compuer.md#コンピュータ)内部でデータを[メモリ](../../../computer/hardware/_/chapters/memory.md#メモリ)上に配置する際の方式に、[ビッグエンディアン](../../../basics/information_theory/_/chapters/coding_theory.md#ビッグエンディアン)方式と[リトルエンディアン](../../../basics/information_theory/_/chapters/coding_theory.md#リトルエンディアン)方式という異なる表現方式がある。このような[コンピュータ](../../../computer/_/chapters/compuer.md#コンピュータ)内部での表現と、[ネットワーク](./network.md#ネットワーク)全体での共通表現を変換するのは、プレゼンテーション層の役割。\n\nまた、文字コードも同様で、[UTF-8](../../../basics/information_theory/_/chapters/character_representation.md#unicode)や[Shift_JIS](../../../basics/information_theory/_/chapters/character_representation.md#シフトjisコード)、EUP-JPなど多くの符号化形式がある。\n\n"},{"term":"セッション層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"セッション層","content":"\n**セッション層**は、[OSI基本参照モデル](#osi基本参照モデル)において、[コネクション](./network.md#コネクション)の確立や切断、転送するデータの切れ目の設定など、データの転送に関する管理を担う[レイヤ](#レイヤ)。\n\nセッション層よりも下位の層が実際に[ネットワーク](./network.md#ネットワーク)を使ってデータの送信処理を行っている。\n\n"},{"term":"トランスポート層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"トランスポート層","content":"\n**トランスポート層**は、[OSI基本参照モデル](#osi基本参照モデル)において、通信相手の[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)に対して、確実にデータを届ける責任を負う[レイヤ](#レイヤ)。データが正しく届いているかを確認したり、届かなかったデータを再送したりする。\n\n"},{"term":"ネットワーク層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ネットワーク層","content":"\n**ネットワーク層**は、[OSI基本参照モデル](#osi基本参照モデル)において、通信相手までデータを届ける役割を担う[レイヤ](#レイヤ)。この[レイヤ](#レイヤ)では、どの[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)にデータを送ったらよいのかを決定する。\n\n"},{"term":"データリンク層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"データリンク層","content":"\n**データリンク層**は、[OSI基本参照モデル](#osi基本参照モデル)において、[物理層](#物理層)で直接接続された[ノード](./network.md#ノード)間での通信を可能にする[レイヤ](#レイヤ)。直接接続された機器間でのデータのやり取りを実現する。\n\n"},{"term":"物理層","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"物理層","content":"\n**物理層**は、[OSI基本参照モデル](#osi基本参照モデル)において、[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列と電圧の高低や光の点滅との相互変換などを行う[レイヤ](#レイヤ)。通信回線に流れる電気信号の取り決めや、接続用のケーブルやコネクタのピン形状などを規定する。\n\n\n"},{"term":"LAN間接続装置","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"lan間接続装置","content":"\n**LAN間接続装置**は、[LAN](./network.md#lan)を延長したり[LAN](./network.md#lan)同士を接続するために用いる装置。LAN間接続装置は、[OSI基本参照モデル](#osi基本参照モデル)のどの[レイヤ](#レイヤ)でデータを中継するのかによって各種装置がある。\n\n"},{"term":"スイッチ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"スイッチ","content":"\n**スイッチ**は、[ネットワーク](./network.md#ネットワーク)間の接続を行う機器で、受信したデータの宛先を見て接続された各機器への転送の可否を判断する機能を内蔵する。どの[レイヤ](#レイヤ)までの転送を制御するかによって、レイヤ2スイッチ、レイヤ3スイッチのように呼ばれる。\n\n"},{"term":"リピータ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"リピータ","content":"\n**リピータ**は、[OSI基本参照モデル](#osi基本参照モデル)の[物理層](#物理層)レベルで伝送路を接続し、単純に電気信号を増幅・整形することで伝送距離を延ばす[LAN間接続装置](#lan間接続装置)。複数の[ポート](./address_on_network.md#ポート番号)を持つリピータを[ハブ](../../../computer/hardware/_/chapters/bus.md#ハブ)といい、受け取ったデータをすべての[ポート](./address_on_network.md#ポート番号)へ送出する。\n\n"},{"term":"ブリッジ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ブリッジ","content":"\n**ブリッジ**は、[OSI基本参照モデル](#osi基本参照モデル)の[データリンク層](#データリンク層)レベルで[セグメント](./datalink_layer.md#セグメント)を接続する[LAN間接続装置](#lan間接続装置)。接続されている機器の[MACアドレス](./address_on_network.md#macアドレス)を自動的に学習し、送信データに含まれる宛先[MACアドレス](./address_on_network.md#macアドレス)の機器が接続されている[ポート](./address_on_network.md#ポート番号)にだけデータを中継する。\n\n"},{"term":"ルータ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ルータ","content":"\n**ルータ**は、[OSI基本参照モデル](#osi基本参照モデル)の[ネットワーク層](#ネットワーク層)レベルで[パケット](./network.md#ネットワーク)を中継する[LAN間接続装置](#lan間接続装置)。[ルーティング](./internet_layer.md#ルーティング)機能や、パケットフィルタリングなどのセキュリティ機能、[OSI基本参照モデル](#osi基本参照モデル)の[ネットワーク層](#ネットワーク層)以下の[プロトコル](#プロトコル)変換などの機能を備えたものがある。\n\n"},{"term":"レイヤ4-7スイッチ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"レイヤ4-7スイッチ","content":"\n**レイヤ4-7スイッチ**は、[OSI基本参照モデル](#osi基本参照モデル)の[トランスポート層](#トランスポート層)から[アプリケーション層](#アプリケーション層)までの情報に基づいた中継を行う[LAN間接続装置](#lan間接続装置)。負荷分散を行うためのロードバランサや、外部からのアクセスを制御するためのファイアウォールはレイヤ4-7スイッチである。\n\n"},{"term":"ゲートウェイ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ゲートウェイ","content":"\n**ゲートウェイ**は、[OSI基本参照モデル](#osi基本参照モデル)の[トランスポート層](#トランスポート層)から[アプリケーション層](#アプリケーション層)の間でデータの変換をして中継する[LAN間接続装置](#lan間接続装置)。2つの異なる[プロトコル](#プロトコル)間での翻訳作業を行う。また、[ネットワーク](./network.md#ネットワーク)トラフィックの軽減やセキュリティ強化のために利用されるプロキシサーバは、**アプリケーションゲートウェイ**とも呼ばれる。\n"},{"term":"アプリケーションゲートウェイ","link":"./note/ja/./network/_/chapters/network_architecture.md","flagment":"ゲートウェイ","content":"\n**ゲートウェイ**は、[OSI基本参照モデル](#osi基本参照モデル)の[トランスポート層](#トランスポート層)から[アプリケーション層](#アプリケーション層)の間でデータの変換をして中継する[LAN間接続装置](#lan間接続装置)。2つの異なる[プロトコル](#プロトコル)間での翻訳作業を行う。また、[ネットワーク](./network.md#ネットワーク)トラフィックの軽減やセキュリティ強化のために利用されるプロキシサーバは、**アプリケーションゲートウェイ**とも呼ばれる。\n"},{"term":"プロトコルスイート","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"プロトコルスイート","content":"\n**プロトコルスイート**は、複数の[プロトコル](./network_architecture.md#プロトコル)を一式で提供した[パッケージ](../../../computer/software/_/chapters/package.md#パッケージ)。\n\n"},{"term":"アプリケーション層","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"アプリケーション層","content":"\n**アプリケーション層**は、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)同士の通信に関する規約を取り決めた[レイヤ](#レイヤ)。標準で様々な[プロトコル](./network_architecture.md#プロトコル)が規定されており、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)ごとに独自の[プロトコル](./network_architecture.md#プロトコル)を実装することも可能。[TCP/IP](#tcpip)の[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)の多くは、[クライアント/サーバモデル](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)で作られている。サービスを提供する[プログラム](../../../programming/_/chapters/programming.md#プログラム)を[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)、サービスを受ける[プログラム](../../../programming/_/chapters/programming.md#プログラム)を[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)として、[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)はいつでも[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)の要求を受け取れるように常に起動しておく（このような常に起動して用いる[プログラム](../../../programming/_/chapters/programming.md#プログラム)を[デーモン](../../../computer/linux/_/chapters/process_and_job.md#デーモン)と呼ぶ）。\n\n[WWW](./application_layer.md#www)は、[インターネット](./network.md#インターネット)が一般に普及する原動力となった[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)で、[Webブラウザ](./web.md#webブラウザ)と呼ばれる[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)を通して、[ネットワーク](./network.md#ネットワーク)の中にある様々な情報を閲覧することができる。ここで、[ブラウザ](./web.md#webブラウザ)と[サーバ](./web.md#webサーバ)の間の通信に用いられる[プロトコル](./network_architecture.md#プロトコル)は[HTTP](./application_layer.md#http)で、送信に用いられる主なデータフォーマットは[HTML](./web.md#html)である。\n\n[電子メール](./application_layer.md#電子メール)は、[ネットワーク](./network.md#ネットワーク)上で郵便の仕組みを再現したもの。[SMTP](./application_layer.md#smtp)や[POP](./application_layer.md#pop)といった[プロトコル](./network_architecture.md#プロトコル)が用いられている。もともとはテキスト形式での[電子メール](./application_layer.md#電子メール)が一般的であったが、現在は[電子メール](./application_layer.md#電子メール)で送信できるデータ形式を拡張する[MIME](./application_layer.md#mime)の仕様が整えられた。\n\n[ファイル転送](./application_layer.md#ファイル転送)は、異なる[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)の[ハードディスク](../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)上に存在する[ファイル](../../../computer/software/_/chapters/file_system.md#ファイル)を相互に転送することができる[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)。[FTP](./application_layer.md#ftp)という[プロトコル](./network_architecture.md#プロトコル)が用いられ、[ファイル](../../../computer/software/_/chapters/file_system.md#ファイル)の転送を指示するための制御コネクションと、実際にデータを転送するためのデータコネクションという2つの[TCP](./transport_layer.md#tcp)[コネクション](./network.md#コネクション)を確立する。\n\n[遠隔ログイン](./application_layer.md#遠隔ログイン)は、物理的に離れた場所にある[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)にログインして、その[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)で[プログラム](../../../programming/_/chapters/programming.md#プログラム)を走らせることができるようにするための機能。[TELNET](./application_layer.md#telnet)や[SSH](./application_layer.md#ssh)といった[プロトコル](./network_architecture.md#プロトコル)がよく用いられる。また、リモートデスクトップなどを用いる際はRDPが[プロトコル](./network_architecture.md#プロトコル)として用いられる。\n\n[ネットワーク管理](./application_layer.md#ネットワーク管理)には、[SNMP](./application_layer.md#snmp)が用いられる。[SNMP](./application_layer.md#snmp)で管理される[ルータ](./network_architecture.md#ルータ)や[ブリッジ](./network_architecture.md#ブリッジ)、[ホスト](./network.md#ホスト)などを[エージェント](./application_layer.md#snmp)といい、これらを管理する[プログラム](../../../programming/_/chapters/programming.md#プログラム)を[マネージャ](./application_layer.md#snmp)という。[エージェント](./application_layer.md#snmp)は様々な情報を[MIB](./application_layer.md#mib)という構造によって管理する。\n\n"},{"term":"トランスポート層","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"トランスポート層","content":"\n**トランスポート層**は、[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)[プログラム](../../../programming/_/chapters/programming.md#プログラム)間の通信を実現する役割がある[レイヤ](./network_architecture.md#レイヤ)。そのため、どの[プログラム](../../../programming/_/chapters/programming.md#プログラム)がどの[プログラム](../../../programming/_/chapters/programming.md#プログラム)と通信しているかを識別するために、[ポート番号](./address_on_network.md#ポート番号)と呼ばれる識別子を用いる。トランスポート層では以下の2つの代表的な[プロトコル](./network_architecture.md#プロトコル)が用いられる。\n\n[TCP](./transport_layer.md#tcp)は、[コネクション型](./network.md#コネクション型)で信頼性のある通信を実現するために用いられる。両端の[ホスト](./network.md#ホスト)間でのデータの到達性を保証する。経路の途中で[パケット](./network.md#パケット)が失われたり順番が入れ替わったりしても、[TCP](./transport_layer.md#tcp)がそれを解決する。[コネクション](./network.md#コネクション)の確立・切断をするだけで制御のために7回も[パケット](./network.md#パケット)をやり取りするため、データの転送量が少ない場合は無駄が多くなる。\n\n[UDP](./transport_layer.md#udp)は、[コネクションレス型](./network.md#コネクションレス型)でデータの到達に関して信頼性のない[プロトコル](./network_architecture.md#プロトコル)である。送信したデータが相手に届いているかどうかの確認は行わない。[パケット](./network.md#パケット)数が少ない通信や、[ブロードキャスト](./network.md#ブロードキャスト)や[マルチキャスト](./network.md#マルチキャスト)通信、ビデオや音声などの[マルチメディア](../../../computer/software/_/chapters/multimedia.md#マルチメディア)通信に向いている。\n\n"},{"term":"インターネット層（ネットワーク層）","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"インターネット層","content":"\n**インターネット層**（**ネットワーク層**）の代表的な[プロトコル](./network_architecture.md#プロトコル)は[IP](./internet_layer.md#ip)で、[IPアドレス](./address_on_network.md#ipアドレス)をもとにして[パケット](./network.md#パケット)を転送する役割を担う。\n\n[IP](./internet_layer.md#ip)は、[ネットワーク](./network.md#ネットワーク)をまたいで[パケット](./network.md#パケット)を配送し、[インターネット](./network.md#インターネット)全体に[パケット](./network.md#パケット)を送り届けるための[プロトコル](./network_architecture.md#プロトコル)。それぞれの[ホスト](./network.md#ホスト)を識別するために、[IPアドレス](./address_on_network.md#ipアドレス)と呼ばれる識別子を用いる。\n\n[ICMP](./internet_layer.md#icmp)は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)の配送中に何らかの異常が発生して[パケット](./network.md#パケット)を転送できなくなったときに、送信元に異常を知らせるために用いられる[プロトコル](./network_architecture.md#プロトコル)。\n\n[ARP](./internet_layer.md#arp)は、[パケット](./network.md#パケット)の送り先の[MACアドレス](./address_on_network.md#macアドレス)を[IPアドレス](./address_on_network.md#ipアドレス)から取得する[プロトコル](./network_architecture.md#プロトコル)。\n\n"},{"term":"データリンク層（ネットワークインタフェース層）","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"データリンク層","content":"\n**データリンク層**（**ネットワークインタフェース層**）は、[データフレーム](./datalink_layer.md#フレーム)を[ネットワーク](./network.md#ネットワーク)上で隣接する[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に転送する役割をもつ[レイヤ](./network_architecture.md#レイヤ)。\n\n具体的には、[NIC](./network.md#nic)を動かすための[デバイスドライバ](../../../computer/hardware/_/chapters/io_unit.md#デバイスドライバ)のこと。[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が[NIC](./network.md#nic)を認識して、そのカードを利用できるように設定する必要がある。\n\n\n"},{"term":"TCP/IPの標準化","link":"./note/ja/./network/_/chapters/communication_protocol.md","flagment":"tcpipの標準化","content":""},{"term":"ベンダ識別子","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"macアドレス","content":"\n**MACアドレス**(Media Access Control)は、[データリンク](./datalink_layer.md#データリンク)に接続している[ノード](./network.md#ノード)を識別する際に利用される識別子で、48[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の長さを持つ。[ネットワーク](./network.md#ネットワーク)機器が出荷される時点で割り当てられた固有のアドレスとなっている。\n\n一般的な[NIC](./network.md#nic)では、MACアドレスは[ROM](../../../computer/hardware/_/chapters/memory.md#rom)に焼き込まれており、同じMACアドレスを持つ[NIC](./network.md#nic)は世界中にひとつしかない。MACアドレスには、[NIC](./network.md#nic)の製造メーカを特定する**ベンダ識別子**と、メーカが決定する[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列である**製造番号**が含まれている。ベンダ識別子はIEEEが割り当てる番号で、従来は**OUI**(Organizationally Unique Identifier)と呼ばれていたが、**MA-L**(MAC Address Block Large)に改称された。\n\n\n"},{"term":"製造番号","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"macアドレス","content":"\n**MACアドレス**(Media Access Control)は、[データリンク](./datalink_layer.md#データリンク)に接続している[ノード](./network.md#ノード)を識別する際に利用される識別子で、48[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の長さを持つ。[ネットワーク](./network.md#ネットワーク)機器が出荷される時点で割り当てられた固有のアドレスとなっている。\n\n一般的な[NIC](./network.md#nic)では、MACアドレスは[ROM](../../../computer/hardware/_/chapters/memory.md#rom)に焼き込まれており、同じMACアドレスを持つ[NIC](./network.md#nic)は世界中にひとつしかない。MACアドレスには、[NIC](./network.md#nic)の製造メーカを特定する**ベンダ識別子**と、メーカが決定する[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)列である**製造番号**が含まれている。ベンダ識別子はIEEEが割り当てる番号で、従来は**OUI**(Organizationally Unique Identifier)と呼ばれていたが、**MA-L**(MAC Address Block Large)に改称された。\n\n\n"},{"term":"IPアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ipアドレス","content":"\n**IPアドレス**は、個々の[ホスト](./network.md#ホスト)を特定するための識別子で、32[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)で表される。人間がわかりやすいように8[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)ずつに区切り境目にドットを入れた**ドット・デシマル・ノーテーション**や、[10進数](../../../basics/discrete_mathematics/_/chapters/radix.md#10進数)に置き換えた記法がよく用いられる。\n\n"},{"term":"ドット・デシマル・ノーテーション","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ipアドレス","content":"\n**IPアドレス**は、個々の[ホスト](./network.md#ホスト)を特定するための識別子で、32[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)で表される。人間がわかりやすいように8[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)ずつに区切り境目にドットを入れた**ドット・デシマル・ノーテーション**や、[10進数](../../../basics/discrete_mathematics/_/chapters/radix.md#10進数)に置き換えた記法がよく用いられる。\n\n"},{"term":"ネットワーク部","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ネットワーク部","content":"\n**ネットワーク部**は、[IPアドレス](#ipアドレス)中で[データリンク](./datalink_layer.md#データリンク)の[セグメント](./datalink_layer.md#セグメント)ごとに割り当てられた固有の値。世界中の[ネットワーク](./network.md#ネットワーク)からどの[ネットワーク](./network.md#ネットワーク)[セグメント](./datalink_layer.md#セグメント)であるかを特定するために用いられる。\n\n"},{"term":"ホスト部","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ホスト部","content":"\n**ホスト部**は、[データリンク](./datalink_layer.md#データリンク)が属する[セグメント](./datalink_layer.md#セグメント)内で、各機器に割り当てられた固有の値。[セグメント](./datalink_layer.md#セグメント)内の[ホスト](./network.md#ホスト)を特定するために用いられる。\n\n"},{"term":"ネットワークアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ネットワークアドレス","content":"\n**ネットワークアドレス**は、[IPアドレス](#ipアドレス)の[ホスト部](#ホスト部)をすべて0にしたアドレスで、その[セグメント](./datalink_layer.md#セグメント)の[ネットワーク](./network.md#ネットワーク)自体を表す。\n\n"},{"term":"ブロードキャストアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ブロードキャストアドレス","content":"\n**ブロードキャストアドレス**は、[ホスト部](#ホスト部)をすべて1とし、その[ネットワーク](./network.md#ネットワーク)に属しているすべての[ホスト](./network.md#ホスト)に[パケット](./network.md#パケット)を送信するためのアドレス。その[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)自身が属している[セグメント](./datalink_layer.md#セグメント)内への[ブロードキャスト](./network.md#ブロードキャスト)を**ローカルブロードキャスト**、異なる[IP](./internet_layer.md#ip)[ネットワーク](./network.md#ネットワーク)への[ブロードキャスト](./network.md#ブロードキャスト)を**ダイレクトブロードキャスト**という。\n\n"},{"term":"ローカルブロードキャスト","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ブロードキャストアドレス","content":"\n**ブロードキャストアドレス**は、[ホスト部](#ホスト部)をすべて1とし、その[ネットワーク](./network.md#ネットワーク)に属しているすべての[ホスト](./network.md#ホスト)に[パケット](./network.md#パケット)を送信するためのアドレス。その[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)自身が属している[セグメント](./datalink_layer.md#セグメント)内への[ブロードキャスト](./network.md#ブロードキャスト)を**ローカルブロードキャスト**、異なる[IP](./internet_layer.md#ip)[ネットワーク](./network.md#ネットワーク)への[ブロードキャスト](./network.md#ブロードキャスト)を**ダイレクトブロードキャスト**という。\n\n"},{"term":"ダイレクトブロードキャスト","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ブロードキャストアドレス","content":"\n**ブロードキャストアドレス**は、[ホスト部](#ホスト部)をすべて1とし、その[ネットワーク](./network.md#ネットワーク)に属しているすべての[ホスト](./network.md#ホスト)に[パケット](./network.md#パケット)を送信するためのアドレス。その[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)自身が属している[セグメント](./datalink_layer.md#セグメント)内への[ブロードキャスト](./network.md#ブロードキャスト)を**ローカルブロードキャスト**、異なる[IP](./internet_layer.md#ip)[ネットワーク](./network.md#ネットワーク)への[ブロードキャスト](./network.md#ブロードキャスト)を**ダイレクトブロードキャスト**という。\n\n"},{"term":"クラス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"クラス","content":"\n**クラス**は、[IPアドレス](#ipアドレス)の[ネットワーク部](#ネットワーク部)と[ホスト部](#ホスト部)を識別するために用いられていた概念。[IPアドレス](#ipアドレス)をクラスA〜クラスDの4つのグループに分類し、[IPアドレス](#ipアドレス)の先頭8[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)によってどのクラスに属するかを判断する。同一[ネットワーク](./network.md#ネットワーク)内の接続可能台数は[ホスト部](#ホスト部)が表せる範囲となるので、例えばクラスCの[ネットワーク](./network.md#ネットワーク)では $2^8 - 2 = 254$ 台となる。\n\nクラス単位での[IPアドレス](#ipアドレス)の割当は、利用されないアドレスが発生しやすく、限られたアドレス空間を有効に利用できないため、[CIDR](#cidr)方式を用いるのが一般的。\n\n"},{"term":"サブネットワーク","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"サブネットワーク","content":"\n**サブネットワーク**は、[クラス](#クラス)で区切られた[ネットワーク](./network.md#ネットワーク)空間をさらに細かい[ネットワーク](./network.md#ネットワーク)に分割したもの。[クラス](#クラス)を用いた方法よりも柔軟に接続可能な[ホスト](./network.md#ホスト)の台数を制御できる。\n\n"},{"term":"サブネットマスク","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"サブネットマスク","content":"\n**サブネットマスク**は、[IPアドレス](#ipアドレス)の[ネットワーク部](#ネットワーク部)と[ホスト部](#ホスト部)を識別するために用いるアドレス。[ネットワーク部](#ネットワーク部)がすべて1、[ホスト部](#ホスト部)がすべて0のアドレスとなっており、[IPアドレス](#ipアドレス)に対してマスクする（[論理積](../../../basics/discrete_mathematics/_/chapters/logical_operation.md#and演算)を取る）ことでそれぞれの部分を抽出することができる。\n\n先頭から何[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)が[ネットワーク部](#ネットワーク部)であるか（サブネットマスクが1である[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)数）は、 `172.10.0.1/32` のように[IPアドレス](#ipアドレス)の末尾に付けて表現される。\n\n"},{"term":"グローバルIPアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"グローバルipアドレス","content":"\n**グローバルIPアドレス**は、[インターネット](./network.md#インターネット)に接続された機器に割り当てられている[IPアドレス](#ipアドレス)。グローバルIPアドレスの割り当ては、**ICANN**(Internet Corporation for Assigned Names and Numbers)で一元管理されており、日本国内では**JPNIC**(Japan Network Information Center)がグローバルIPアドレスの割り当てを行っている。\n\n"},{"term":"プライベートIPアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"プライベートipアドレス","content":"\n**プライベートIPアドレス**は、[インターネット](./network.md#インターネット)に直接接続されない、組織内などで固有の[IPアドレス](#ipアドレス)。[インターネット](./network.md#インターネット)に接続する際は、[インターネット](./network.md#インターネット)との接点となる[ルータ](./network_architecture.md#ルータ)や公開[サーバ](../../../computer/_/chapters/computer.md#サーバ)にだけ[グローバルIPアドレス](#グローバルipアドレス)を割り当てて、プロキシサーバや、[NAT](./internet_layer.md#nat)などの[ネットワーク](./network.md#ネットワーク)変換機能を用いるのが一般的。\n\n"},{"term":"WHOIS","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"whois","content":"\n**WHOIS**は、[IPアドレス](#ipアドレス)を管理している組織や管理者の連絡先情報。[インターネット](./network.md#インターネット)の通信経路の途中で異常が発生している装置を突き止める目的などで設定する。\n\n"},{"term":"ループバックアドレス","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ループバックアドレス","content":"\n**ループバックアドレス**は、同じ[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部の[プログラム](../../../programming/_/chapters/programming.md#プログラム)間で通信したい場合などに利用される、その機器自身を表す[IPアドレス](#ipアドレス)。どの機器にも固定で `127.0.0.1` が割り当てられており、 `localhost` という[ホスト](./network.md#ホスト)名がエイリアスとして利用される。\n\n\n"},{"term":"ポート番号","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"ポート番号","content":"\n**ポート番号**は、同一の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内で通信を行っている[プログラム](../../../programming/_/chapters/programming.md#プログラム)を識別するときに利用される識別子。[アプリケーション層](./communication_protocol.md#アプリケーション層)で処理する[プログラム](../../../programming/_/chapters/programming.md#プログラム)を[トランスポート層](./communication_protocol.md#トランスポート層)で指定するために用いられる。\n\n"},{"term":"エフェメラルポート番号","link":"./note/ja/./network/_/chapters/address_on_network.md","flagment":"エフェメラルポート番号","content":"\n**エフェメラルポート番号**は、 $1024 \\sim 655354$ の[ポート番号](#ポート番号)のことで、[OS](../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)が動的に管理する[ポート番号](#ポート番号)。[サーバ](../../../computer/_/chapters/computer.md#サーバ)は[ポート番号](#ポート番号)が決まっている必要があるが、サービスを受ける側の[ポート番号](#ポート番号)は必ずしも決まっている必要はなく、エフェメラルポート番号を自由に割り当てることができる。\n"},{"term":"データリンク","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"データリンク","content":"\n**データリンク**では、[物理層](./network_architecture.md#物理層)の通信媒体の電圧の高低や光の点滅を、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)で処理できるように `0` と `1` の羅列に変換し、それを[フレーム](#フレーム)という意味のあるかたまりとして相手に届ける。\n\nデータリンクは、区間内の[ノード](./network.md#ノード)を結ぶ[プロトコル](./network_architecture.md#プロトコル)を持つ。\n\n"},{"term":"フレーム","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"フレーム","content":"\n**フレーム**は、[データリンク層](./communication_protocol.md#データリンク層)におけるデータのまとまり。\n\n"},{"term":"セグメント","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"セグメント","content":"\n**セグメント**は、[LAN](./network.md#lan)が構成する物理的に同じ信号が届く範囲の[ネットワーク](./network.md#ネットワーク)。\n\n"},{"term":"MTU（Maximum Transmission Unit: 最大転送単位）","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"mtu","content":"\n**MTU**（Maximum Transmission Unit: 最大転送単位）は、[データリンク](#データリンク)において一度に送信できる[パケット](./network.md#パケット)の大きさのことで、機器によって異なる。\n\n\n"},{"term":"プリアンブル","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"イーサネットのフレームフォーマット","content":"\n[イーサネット](./network.md#イーサネット)の[フレーム](#フレーム)の先頭には、[フレーム](#フレーム)本体の開始位置を表すために、 `1` と `0` を交互に並べた**プリアンブル**と呼ばれるフィールドが付けられる。IEEE仕様の[フレーム](#フレーム)では、プリアンブルの末尾は**SFD**(Start Frame Delimiter)という `11` のフィールドで終わり、それ以降が[イーサネット](./network.md#イーサネット)[フレーム](#フレーム)本体として扱われる。\n\n最後の**FCS**(Frame Check Sequence)は、[フレーム](#フレーム)が壊れていないかを確かめるためのフィールド。\n\n\n"},{"term":"VLAN（Virtual LAN: 仮想LAN）","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"vlan","content":"\n**VLAN**（Virtual LAN: 仮想LAN）は、1つの[スイッチ](./network_architecture.md#スイッチ)に接続されている[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を、論理的に複数の[ネットワーク](./network.md#ネットワーク)に分ける仕組み。部署ごとに接続するVLANを分けたり、セキュリティ対策レベルを分けたVLANを隔離して用いるといった使い方ができる。\n\n\n"},{"term":"セル","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"atm","content":"\n**ATM**(Asynchronous Transfer Mode)は、[コネクション型](./network.md#コネクション型)の[データリンク](#データリンク)で、「ヘッダ5オクテット + データ48オクテット」の**セル**と呼ばれる単位でデータを処理する。ATMは**AAL**(ATM Adaption Layer)とともに利用される。\n\nATMはセルが1つでも失われると最大192個のセルを再送しなければいけなくなるという問題がある。\n\n\n"},{"term":"トンネリング","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"トンネリング","content":"\n**トンネリング**は、不特定多数が使うような回線上で、データを互いにやり取りするための隔絶された[コネクション](./network.md#コネクション)を設ける技術。\n\n"},{"term":"カプセル化","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"カプセル化","content":"\n**カプセル化**は、[VPN](#vpn)上でやり取りされるデータを暗号化し、外部から隠蔽するための技術。\n\n"},{"term":"広域イーサネット","link":"./note/ja/./network/_/chapters/datalink_layer.md","flagment":"広域イーサネット","content":"\n**広域イーサネット**は、[通信事業者](./network.md#キャリア)が独自に用意した閉域網を利用する[VPN](#vpn)接続サービス。\n\n\n"},{"term":"最善努力型（ベストエフォート）のサービス","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ip","content":"\n**IP**(Internet Protocol)は、エンドノード間の通信を実現する役割を果たす[インターネット層](./communication_protocol.md#インターネット層)の[プロトコル](./network_architecture.md#プロトコル)。IPは[コネクションレス型](./network.md#コネクションレス型)の通信で、[パケット](./network.md#パケット)を送信する前に[コネクション](./network.md#コネクション)の確立を行わない。[パケット](./network.md#パケット)を宛先まで送り届けるために最大限努力を行うことから、**最善努力型（ベストエフォート）のサービス**と呼ばれている。接続の信頼性を高める役目を担うのはIPの上位層である[TCP](./transport_layer.md#tcp)で、これは[コネクション型](./network.md#コネクション型)である。\n\n\n"},{"term":"ルーティング（経路制御）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ルーティング","content":"\n**ルーティング**（**経路制御**）は、宛先[IPアドレス](./address_on_network.md#ipアドレス)の[ホスト](./network.md#ホスト)まで[パケット](./network.md#パケット)を届ける仕組み。[ルータ](./network_architecture.md#ルータ)は正しい方向へ[パケット](./network.md#パケット)を転送するために、[ルーティングテーブル](#ルーティングテーブル)を参照して[パケット](./network.md#パケット)の転送先を決定する。\n\n"},{"term":"ホップ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ホップ","content":"\n**ホップ**は、[TCP/IP](./communication_protocol.md#tcpip)において、[ネットワーク](./network.md#ネットワーク)の1区間を[IP](#ip)[パケット](./network.md#パケット)が移動すること。この1区間のことを**1ホップ**（**ワンホップ**）という。\n\n"},{"term":"1ホップ（ワンホップ）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ホップ","content":"\n**ホップ**は、[TCP/IP](./communication_protocol.md#tcpip)において、[ネットワーク](./network.md#ネットワーク)の1区間を[IP](#ip)[パケット](./network.md#パケット)が移動すること。この1区間のことを**1ホップ**（**ワンホップ**）という。\n\n"},{"term":"ルーティングテーブル（経路制御表）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ルーティングテーブル","content":"\n**ルーティングテーブル**（**経路制御表**）は、[IPアドレス](./address_on_network.md#ipアドレス)と対応する[ホスト](./network.md#ホスト)や[ルータ](./network_architecture.md#ルータ)の情報が書かれた表。[IP](#ip)では、ルーティングテーブルを元にして次の[ホップ](#ホップ)を決める。\n\n"},{"term":"ホップバイホップルーティング","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ホップバイホップルーティング","content":"\n**ホップバイホップルーティング**は、[IP](#ip)において用いられている[ルーティング](#ルーティング)の方式で、最終目的地に行くまでの経路を各中継点（[ホップ](#ホップ)）で決定する方法。このため、[パケット](./network.md#パケット)は行き当たりばったりに最終目的地に近づいていく。\n\n"},{"term":"デフォルトルート","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"デフォルトルート","content":"\n**デフォルトルート**は、[ルーティングテーブル](#ルーティングテーブル)に経路情報がない宛先[IP](#ip)との通信の際に選ばれる、次の[ホップ](#ホップ)。\n\n"},{"term":"スタティックルーティング（静的経路制御）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"スタティックルーティング","content":"\n**スタティックルーティング**（**静的経路制御**）は、[ルーティングテーブル](#ルーティングテーブル)を[ネットワーク](./network.md#ネットワーク)管理者が手動で作成する方法。\n\n"},{"term":"ダイナミックルーティング（動的経路制御）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ダイナミックルーティング","content":"\n**ダイナミックルーティング**（**動的経路制御**）は、他の[ルータ](./network_architecture.md#ルータ)との通信の際に、経路情報を交換することで、自動的に[ルーティングテーブル](#ルーティングテーブル)を作成する方法。[IP](#ip)自体には経路情報を交換する機能は備わっていないので、ダイナミックルーティングを行う場合には[ルーティングプロトコル](./routing_protocol.md#ルーティングプロトコル)が必要となる。\n\n"},{"term":"ネットワークACL","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ネットワークACL","content":""},{"term":"フラグメンテーション（分割処理）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"フラグメンテーション","content":"\n**フラグメンテーション**（**分割処理**）は、[データリンク](./datalink_layer.md#データリンク)の[MTU](./datalink_layer.md#mtu)に合わせて[パケット](./network.md#パケット)を分割する処理。[パケット](./network.md#パケット)は[ルータ](./network_architecture.md#ルータ)を経由するたびに必要に応じてフラグメンテーションされ、宛先[ホスト](./network.md#ホスト)にて復元される。経路の途中でフラグメンテーションが発生すると、分割されたデータの一部が失われただけで、全体の情報を再送する必要が出てきてしまうため、あらかじめ送信元[ホスト](./network.md#ホスト)で経路全体の[MTU](./datalink_layer.md#mtu)に[パケット](./network.md#パケット)を分割して送信することが多い。\n\n"},{"term":"経路MTU探索","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"経路mtu探索","content":"\n**経路MTU探索**は、[ICMP](#icmp)の[到達不能メッセージ](#icmp)を利用して、送信元の[ホスト](./network.md#ホスト)から宛先[ホスト](./network.md#ホスト)までの経路の[MTU](./datalink_layer.md#mtu)を探索する処理。これにより、[フラグメンテーション](#フラグメンテーション)の発生を防ぎながらも、最大効率で[パケット](./network.md#パケット)を送信することができる。\n\n\n"},{"term":"IPv4","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipv4","content":"\n**IPv4**は、[インターネット](./network.md#インターネット)の普及とともに広く使われるようになった[IP](#ip)の仕様で、[IPアドレス](./address_on_network.md#ipアドレス)を32[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)で表現する。[インターネット](./network.md#インターネット)の急速な普及によって[IPアドレス](./address_on_network.md#ipアドレス)が不足したため、[IPv6](#ipv6)への置き替えが進んでいる。\n\n"},{"term":"DSCPフィールド","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipv4のフレームフォーマット","content":"\n**DSCPフィールド**は、初期の頃はサービスタイプ(TOS: Type Of Service)として定義されていた部分で、[DiffServ](#diffserv)と呼ばれる品質制御に利用される。\n\n**ECNフィールド**も同様にサービスタイプに置き換わって利用されているフィールドで、[ネットワーク](./network.md#ネットワーク)が[ふくそう](#ふくそう)していることを通知するために用いられる。\n\n\n"},{"term":"ECNフィールド","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipv4のフレームフォーマット","content":"\n**DSCPフィールド**は、初期の頃はサービスタイプ(TOS: Type Of Service)として定義されていた部分で、[DiffServ](#diffserv)と呼ばれる品質制御に利用される。\n\n**ECNフィールド**も同様にサービスタイプに置き換わって利用されているフィールドで、[ネットワーク](./network.md#ネットワーク)が[ふくそう](#ふくそう)していることを通知するために用いられる。\n\n\n"},{"term":"IPv6","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipv6","content":"\n**IPv6**は、[IPv4](#ipv4)アドレスの枯渇問題を解決するために標準化された[IP](#ip)の仕様。[IPv4](#ipv4)の4倍の16オクテット（128[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)）の長さを持ち、[IPv4](#ipv4)との互換性を保つ努力が行われている。IPv6の特徴や目的は以下の通りである。\n\n- [IPアドレス](./address_on_network.md#ipアドレス)の拡大と経路制御表の集約\n- パフォーマンスの向上\n- [プラグアンドプレイ](../../../computer/hardware/_/chapters/bus.md#プラグアンドプレイ)機能を必須にする\n- 認証機能や暗号化機能の採用\n- [マルチキャスト](./network.md#マルチキャスト)、[Mobile IP](#mobile-ip)の機能を拡張機能として提供\n\n"},{"term":"ドメイン名","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ドメイン名","content":"\n**ドメイン名**は、[インターネット](./network.md#インターネット)上の特定の[ネットワーク](./network.md#ネットワーク)を指す識別子。[ネットワーク](./network.md#ネットワーク)だけでなく、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を指し示す場合もあり、この場合は[ホスト名](#ホスト名)や[FQDN](#fqdn)と同様の意味で用いられる。\n\n"},{"term":"ホスト名","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ホスト名","content":"\n**ホスト名**は、[ネットワーク](./network.md#ネットワーク)内の特定の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)を指す識別子。\n\n"},{"term":"ネームサーバ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ネームサーバ","content":"\n**ネームサーバ**は、[ドメイン名](#ドメイン名)を管理する[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)を動作させる[ホスト](./network.md#ホスト)のことで、そのネームサーバが設置された階層（ゾーン）の[ドメイン](#ドメイン名)に関する情報を管理している。**ルートネームサーバ**は、ネームサーバの階層のルート部分に設置されている[サーバ](../../../computer/_/chapters/computer.md#サーバ)。\n\n"},{"term":"ルートネームサーバ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ルートネームサーバ","content":""},{"term":"ラウンドロビンDNS","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ラウンドロビンdns","content":"\n**ラウンドロビンDNS**は、1つの[ドメイン名](#ドメイン名)に複数の[IPアドレス](./address_on_network.md#ipアドレス)を割り当てることができる[DNS](#dns)。\n\n"},{"term":"リゾルバ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"リゾルバ","content":"\n**リゾルバ**は、[DNS](#dns)に問い合わせをするための[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。リゾルバの[DNS](#dns)に対する問い合わせを**クエリ**という。\n\n"},{"term":"クエリ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"リゾルバ","content":"\n**リゾルバ**は、[DNS](#dns)に問い合わせをするための[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。リゾルバの[DNS](#dns)に対する問い合わせを**クエリ**という。\n\n"},{"term":"Aレコード","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"aレコード","content":"\n**Aレコード**は、[DNS](#dns)で管理される、[ドメイン名](#ドメイン名)と[IPアドレス](./address_on_network.md#ipアドレス)の対応レコード。\n\n"},{"term":"NSレコード","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"nsレコード","content":"\n**NSレコード**は、[DNS](#dns)で管理される、上位や下位の[ネームサーバ](#ネームサーバ)の[IPアドレス](./address_on_network.md#ipアドレス)のレコード。\n\n"},{"term":"MXレコード","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"mxレコード","content":"\n**MXレコード**は、[DNS](#dns)で管理される、メールアドレスとそのメールを受信する[メールサーバ](./application_layer.md#電子メール)の[ホスト名](#ホスト名)の対応レコード。\n\n\n"},{"term":"ICMPv6","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"icmpv6","content":"\n**ICMPv6**は、[IPv6](#ipv6)用の[ICMP](#icmp)で、[IPv6](#ipv6)の通信を行う上でなくてはならない[プロトコル](./network_architecture.md#プロトコル)。[ICMP](#icmp)は[IPv4](#ipv4)においては補助的な役割でしかなかったが、ICMPv6はその役割がより重要なものとなっている。\n\n特に近隣探索では、近隣探索メッセージを[ブロードキャスト](./network.md#ブロードキャスト)に対して送信し、近隣告知メッセージで[MACアドレス](./address_on_network.md#macアドレス)を通知する。\n\n\n"},{"term":"DHCPリレーエージェント","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"dhcp","content":"\n**DHCP**(Dynamic Host Configuration Protocol)は、[IPアドレス](./address_on_network.md#ipアドレス)などの[ネットワーク](./network.md#ネットワーク)への接続に必要な情報を一括管理する[プロトコル](./network_architecture.md#プロトコル)。特に、スマートフォンやラップトップPCなどの移動を伴う端末では、DHCPを用いることにより[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)の[プラグアンドプレイ](../../../computer/hardware/_/chapters/bus.md#プラグアンドプレイ)を実現している。\n\nまた、大規模な[ネットワーク](./network.md#ネットワーク)ではたくさんのDHCPを管理することになるため、これらを一元管理するために**DHCPリレーエージェント**を用いる。\n\n\n"},{"term":"NAT（Network Address Translator、ベーシックNAT）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"nat","content":"\n**NAT**(Network Address Translator)は、[グローバルIPアドレス](./address_on_network.md#グローバルipアドレス)と[プライベートIPアドレス](./address_on_network.md#プライベートipアドレス)を一対一で変換する機能。ローカルな[ネットワーク](./network.md#ネットワーク)で[プライベートIPアドレス](./address_on_network.md#プライベートipアドレス)を使用している機器が[インターネット](./network.md#インターネット)へ接続するときに、[プライベートIPアドレス](./address_on_network.md#プライベートipアドレス)を[グローバルIPアドレス](./address_on_network.md#グローバルipアドレス)に変換する。[インターネット](./network.md#インターネット)に同時に接続できる台数は、割り当てられている[グローバルIPアドレス](./address_on_network.md#グローバルipアドレス)の個数までとなる。\n\nNATには、次のような問題点がある。\n\n- NATの外側から内側の[サーバ](../../../computer/_/chapters/computer.md#サーバ)に接続することはできない\n- 変換テーブルの作成や変換処理に[オーバヘッド](../../../system/_/chapters/system_performance_evaluation.md#オーバヘッド)が生じる\n- 通信中にNATが異常動作して再起動した場合、すべての[TCP](./transport_layer.md#tcp)[コネクション](./network.md#コネクション)がリセットされる\n\n"},{"term":"NAPT（Network Address Ports Translator、IPマスカレード）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"napt","content":"\n**NAPT**（Network Address Ports Translator、**IPマスカレード**）は、[グローバルIPアドレス](./address_on_network.md#グローバルipアドレス)1つに対して複数の[プライベートIPアドレス](./address_on_network.md#プライベートipアドレス)を対応させる機能。[IPアドレス](./address_on_network.md#ipアドレス)と[ポート番号](./address_on_network.md#ポート番号)の組み合わせにより通信を識別するため、1つの[グローバルIPアドレス](./address_on_network.md#グローバルipアドレス)で複数の機器が同時に[インターネット](./network.md#インターネット)に接続できる。モバイルルータやスマートフォンのテザリングは、NAPTを利用している。\n\n現在では、NAPTのことを単に[NAT](#nat)、[NAT](#nat)のことをベーシックNATと呼ぶことが多い。\n\n"},{"term":"NAT65/DNS64","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"nat64dns64","content":""},{"term":"IPトンネリング","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipトンネリング","content":"\n**IPトンネリング**は、[IPv4](#ipv4)[パケット](./network.md#パケット)全体を1つのデータとして扱い、その前に[IPv6](#ipv6)ヘッダを付与することで、[IPv4](#ipv4)環境同士の通信の間に[IPv6](#ipv6)環境の[ネットワーク](./network.md#ネットワーク)が介在するさせる技術。\n\nIPトンネリングを使用すると、追加されるヘッダの分だけ[MTU](./datalink_layer.md#mtu)が小さくなるため、**ジャンボフレーム**（1500[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)以上のペイロードを持つ[Ethernet](./network.md#イーサネット)[フレーム](./network.md#フレーム)）の利用などの工夫が必要となる。\n\n\n"},{"term":"ジャンボフレーム","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipトンネリング","content":"\n**IPトンネリング**は、[IPv4](#ipv4)[パケット](./network.md#パケット)全体を1つのデータとして扱い、その前に[IPv6](#ipv6)ヘッダを付与することで、[IPv4](#ipv4)環境同士の通信の間に[IPv6](#ipv6)環境の[ネットワーク](./network.md#ネットワーク)が介在するさせる技術。\n\nIPトンネリングを使用すると、追加されるヘッダの分だけ[MTU](./datalink_layer.md#mtu)が小さくなるため、**ジャンボフレーム**（1500[バイト](../../../basics/_/chapters/computer_and_number.md#バイト)以上のペイロードを持つ[Ethernet](./network.md#イーサネット)[フレーム](./network.md#フレーム)）の利用などの工夫が必要となる。\n\n\n"},{"term":"IPエニーキャスト","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ipエニーキャスト","content":"\n**IPエニーキャスト**は、同じサービスを提供する[サーバ](../../../computer/_/chapters/computer.md#サーバ)に同じ[IPアドレス](./address_on_network.md#ipアドレス)を付け、クライアントの最寄りの[サーバ](../../../computer/_/chapters/computer.md#サーバ)と通信できるようにする方法。代表例として、[DNS](#dns)ルートサーバーが挙げられる。\n\nIPエニーキャストでは、1つ目の[パケット](./network.md#パケット)と2つ目の[パケット](./network.md#パケット)が同じ[ホスト](./network.md#ホスト)に届くという保証がない。そのため、最初の1[パケット](./network.md#パケット)のみ[エニーキャスト](./network.md#エニーキャスト)を用いて、それ以降は[ユニキャスト](./network.md#ユニキャスト)を使うといった処理が行われる。\n\n\n"},{"term":"ふくそう（輻輳）","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"ふくそう","content":"\n**ふくそう**（輻輳）は、ベストエフォートの通信において、通信回線が混雑すると性能が極端に低下するという問題。\n\n"},{"term":"IntServ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"intserv","content":"\n**IntServ**は、**RSVP**(Resource Reservation Protocol)エンドツーエンドできめ細かい優先制御を提供するための仕組み。必要な時にだけフローのセットアップを行って通信品質を制御する。RSVPは、[パケット](./network.md#パケット)を受信する側から送信する側に向けて制御[パケット](./network.md#パケット)を流し、その間に存在する[ルータ](./network_architecture.md#ルータ)に品質制御のための設定を行う。\n\n"},{"term":"DiffServ","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"diffserv","content":"\n**DiffServ**は、特定の[ネットワーク](./network.md#ネットワーク)内で大雑把に通信品質を制御することが目的で、DiffServ[ドメイン](#ドメイン名)の境界にある[ルータ](./network_architecture.md#ルータ)によって[IP](#ip)[パケット](./network.md#パケット)の[DSCPフィールド](#ipv4のフレームフォーマット)を書き換えることによって制御を行う。\n\n"},{"term":"Mobile IP","link":"./note/ja/./network/_/chapters/internet_layer.md","flagment":"mobile-ip","content":""},{"term":"ストリーム","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ストリーム","content":"\n**ストリーム**は、連続していて切れ目のないデータ構造。\n\n"},{"term":"スリーウェイハンドシェイク","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"スリーウェイハンドシェイク","content":"\n**スリーウェイハンドシェイク**は、[TCP](#tcp)における[コネクション](./network.md#コネクション)の確立方法で、合計で3回の[パケット](./network.md#パケット)をやり取りすることからこのような名前となっている。\n\n"},{"term":"シーケンス番号","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"シーケンス番号","content":"\n**シーケンス番号**は、[TCP](#tcp)で送信される[パケット](./network.md#パケット)につけられる通し番号。受信[ホスト](./network.md#ホスト)は、送信[ホスト](./network.md#ホスト)の再送処理などにより、重複したデータを受け取る可能性がある。シーケンス番号は、このような重複した[パケット](./network.md#パケット)を識別して破棄するためにも利用される。\n\n"},{"term":"タイムアウト","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"タイムアウト","content":"\n**タイムアウト**は、ある一定の時間が経過しても、受信[ホスト](./network.md#ホスト)から[確認応答](#確認応答)が返ってこずに、接続の確立に失敗するエラー。タイムアウトが発生した場合、送信[ホスト](./network.md#ホスト)はデータが喪失したと判断して再送処理を行う。[確認応答](#確認応答)の到着を待つ時間を**再送タイムアウト時間**という。再送タイムアウト時間を決めるため、[パケット](./network.md#パケット)を送信する度に通信の[ラウンドトリップタイム](../../../system/_/chapters/system_performance_evaluation.md#ターンアラウンドタイム)と[ジッタ](../../../system/_/chapters/system_performance_evaluation.md#ジッタ)を計算する。\n\n"},{"term":"再送タイムアウト時間","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"タイムアウト","content":"\n**タイムアウト**は、ある一定の時間が経過しても、受信[ホスト](./network.md#ホスト)から[確認応答](#確認応答)が返ってこずに、接続の確立に失敗するエラー。タイムアウトが発生した場合、送信[ホスト](./network.md#ホスト)はデータが喪失したと判断して再送処理を行う。[確認応答](#確認応答)の到着を待つ時間を**再送タイムアウト時間**という。再送タイムアウト時間を決めるため、[パケット](./network.md#パケット)を送信する度に通信の[ラウンドトリップタイム](../../../system/_/chapters/system_performance_evaluation.md#ターンアラウンドタイム)と[ジッタ](../../../system/_/chapters/system_performance_evaluation.md#ジッタ)を計算する。\n\n"},{"term":"ソケット","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ソケット","content":"\n**ソケット**は、[TCP](#tcp)や[UDP](#udp)を利用して通信を行うために広く使われている[API](../../../computer/software/_/chapters/operating_system.md#api)。[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)はソケットを利用して、通信相手の[IPアドレス](./address_on_network.md#ipアドレス)や[ポート番号](./address_on_network.md#ポート番号)の設定、データの送受信の要求を行う。\n\n\n"},{"term":"MSS（Maximum Segment Size: 最大セグメント長）","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"mss","content":"\n**MSS**（Maximum Segment Size: **最大セグメント長**）は、[TCP](#tcp)[パケット](./network.md#パケット)におけるペイロード（[TCP](#tcp)ヘッダは含まない）の最大長。MSSは、[コネクション](./network.md#コネクション)確立時に決定される。\n\n\n"},{"term":"ウィンドウ","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ウィンドウ","content":"\n**ウィンドウ**は、[TCP](#tcp)におけるデータ転送を[ウィンドウ制御](#ウィンドウ制御)によって行うときの、データ転送の単位。複数の[セグメント](./datalink_layer.md#セグメント)をひとつにまとめたもの。\n\n"},{"term":"ウィンドウサイズ","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ウィンドウサイズ","content":"\n**ウィンドウサイズ**は、[TCP](#tcp)におけるデータ転送を[ウィンドウ制御](#ウィンドウ制御)によって行うときに用いられる、[ウィンドウ](#ウィンドウ)の大きさ。\n\n"},{"term":"ウィンドウ制御","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ウィンドウ制御","content":"\n**ウィンドウ制御**は、[TCP](#tcp)において効率よく[パケット](./network.md#パケット)を伝送するための仕組み。複数の[セグメント](./datalink_layer.md#セグメント)をまとめた[ウィンドウ](#ウィンドウ)を送信することで、毎回[確認応答](#確認応答)を待たずに連続したデータを送信できる。\n\n"},{"term":"スライディングウィンドウ","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"スライディングウィンドウ","content":"\n**スライディングウィンドウ**は、[確認応答](#確認応答)を受け取った分だけ[ウィンドウ](#ウィンドウ)をずらして、次々とデータを転送していく方法。[ウィンドウ制御](#ウィンドウ制御)では複数の[セグメント](./datalink_layer.md#セグメント)に対してまとめて[確認応答](#確認応答)をしているが、スライディングウィンドウでは全ての[セグメント](./datalink_layer.md#セグメント)に対して[確認応答](#確認応答)が行われるため、信頼性を損なわない。\n\n\n"},{"term":"フロー制御","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"フロー制御","content":"\n**フロー制御**は、受信側の受信能力に合わせて[パケット](./network.md#パケット)送信量を制御する方式。\n\n受信[ホスト](./network.md#ホスト)は、受信可能なバッファサイズを[TCP](#tcp)ヘッダのフィールドに入れて送信[ホスト](#ホスト)に送る。このフィールドの値が大きいほど[スループット](../../../system/_/chapters/system_performance_evaluation.md#スループット)が大きく、高い効率での通信が可能になる。\n\n受信[ホスト](./network.md#ホスト)はバッファがいっぱいになると、送信[ホスト](./network.md#ホスト)に対してデータの送信停止を要求する。停止したデータのやり取りを再開するために、送信[ホスト](./network.md#ホスト)は[ウィンドウプローブ](#ウィンドウプローブ)と呼ばれる[セグメント](./datalink_layer.md#セグメント)を時々送信する。\n\n"},{"term":"ウィンドウプローブ","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ウィンドウプローブ","content":"\n**ウィンドウプローブ**は、一時停止したデータ送信を再開するため、受信[ホスト](./network.md#ホスト)のバッファに空きがあるかを確認する[セグメント](./datalink_layer.md#セグメント)。\n\n\n"},{"term":"ふくそう制御","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ふくそう制御","content":"\n**ふくそう制御**は、[ネットワーク](./network.md#ネットワーク)が混雑することを防ぐための制御。\n\n"},{"term":"バースト","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"バースト","content":"\n**バースト**は、連続的に[パケット](./network.md#パケット)が送信されることによって、トラフィックが混雑し、[ふくそう](./internet_layer.md#ふくそう)状態となる現象。\n\n"},{"term":"スロースタート","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"スロースタート","content":"\n**スロースタート**は、[TCP](#tcp)において、通信開始時は送信量を抑えておき、徐々に増やしていく方式。送信側でデータの送信量を調整するための**ふくそうウィンドウ**を定義しておき、最初はこの[ウィンドウ](#ウィンドウ)の大きさを1[セグメント](./datalink_layer.md#セグメント)に設定しておく。[確認応答](#確認応答)されるたびに1[セグメント](./datalink_layer.md#セグメント)ずつ[ウィンドウ](#ウィンドウ)を大きくしていき、[タイムアウト](#タイムアウト)が発生した際には、ふくそうウィンドウを1にして再度スロースタートをやり直す。\n\n\n"},{"term":"ふくそうウィンドウ","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"スロースタート","content":"\n**スロースタート**は、[TCP](#tcp)において、通信開始時は送信量を抑えておき、徐々に増やしていく方式。送信側でデータの送信量を調整するための**ふくそうウィンドウ**を定義しておき、最初はこの[ウィンドウ](#ウィンドウ)の大きさを1[セグメント](./datalink_layer.md#セグメント)に設定しておく。[確認応答](#確認応答)されるたびに1[セグメント](./datalink_layer.md#セグメント)ずつ[ウィンドウ](#ウィンドウ)を大きくしていき、[タイムアウト](#タイムアウト)が発生した際には、ふくそうウィンドウを1にして再度スロースタートをやり直す。\n\n\n"},{"term":"Nagleアルゴリズム","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"nagleアルゴリズム","content":"\n**Nagleアルゴリズム**は、[ネットワーク](./network.md#ネットワーク)の利用効率を高めるために[TCP](#tcp)で用いられている[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)。その瞬間に送信側に送信すべきデータがあったとしても、そのデータが少ない場合にはすぐに送信せずに遅延させる。通信が遅延してほしくないような場合には、この[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)を無効にする。\n\n\n"},{"term":"遅延確認応答","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"遅延確認応答","content":"\n**遅延確認応答**は、[シリーウィンドウシンドローム](#シリーウィンドウシンドローム)を防ぐため、[確認応答](#確認応答)のタイミングを遅延させる方法。\n\n\n"},{"term":"ピギーバック","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"ピギーバック","content":"\n**ピギーバック**は、[確認応答](#確認応答)と[レスポンス](../../../system/_/chapters/system_processing_model.md#レスポンス)のデータ[パケット](./network.md#パケット)を1つの[パケット](./network.md#パケット)として送る方法。\n\n\n"},{"term":"マルチホーミング機能","link":"./note/ja/./network/_/chapters/transport_layer.md","flagment":"マルチホーミング機能","content":"\n**マルチホーミング機能**は、複数の[NIC](./network.md#nic)がついている[ホスト](./network.md#ホスト)で、[NIC](./network.md#nic)が変わっても通信が継続できる機能。\n\n\n"},{"term":"遠隔ログイン","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"遠隔ログイン","content":"\n"},{"term":"TELNET","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"telnet","content":"\n**TELNET**は、[TCP](./transport_layer.md#tcp)の[コネクション](./network.md#コネクション)を1つ利用して、通信相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を文字列として送信し実行する[プロトコル](./network_architecture.md#プロトコル)。相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で動作している[シェル](../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)に接続しているような状態となる。\n\nTELNETでは、ユーザが入力した文字以外にもオプションをやり取りすることができる。**NVT**(Network Virtual Terminal)を実現するための画面制御情報はこのオプション機能を利用して送信される。\n\nまたTELNETには、改行キーが入力されるごとに1行分のデータをまとめて送る**行モード**と、入力された文字を1文字ごとに送る**透過モード**がある。\n\nTELNET[プロトコル](./network_architecture.md#プロトコル)を利用する[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[プログラム](../../../programming/_/chapters/programming.md#プログラム)を**TELNETクライアント**といい、TELNETクライアントは基本的に23番[ポート](./address_on_network.md#ポート番号)に接続することでtelnetdとやり取りをする。しかし、それ以外の[ポート](./address_on_network.md#ポート番号)に接続することで、キーボードから各[プロトコル](./network_architecture.md#プロトコル)の[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を直接入力することもできる。これを利用して、[TCP/IP](./communication_protocol.md#tcpip)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)開発時のデバッグに利用されることもある。\n\n"},{"term":"行モード","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"telnet","content":"\n**TELNET**は、[TCP](./transport_layer.md#tcp)の[コネクション](./network.md#コネクション)を1つ利用して、通信相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を文字列として送信し実行する[プロトコル](./network_architecture.md#プロトコル)。相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で動作している[シェル](../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)に接続しているような状態となる。\n\nTELNETでは、ユーザが入力した文字以外にもオプションをやり取りすることができる。**NVT**(Network Virtual Terminal)を実現するための画面制御情報はこのオプション機能を利用して送信される。\n\nまたTELNETには、改行キーが入力されるごとに1行分のデータをまとめて送る**行モード**と、入力された文字を1文字ごとに送る**透過モード**がある。\n\nTELNET[プロトコル](./network_architecture.md#プロトコル)を利用する[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[プログラム](../../../programming/_/chapters/programming.md#プログラム)を**TELNETクライアント**といい、TELNETクライアントは基本的に23番[ポート](./address_on_network.md#ポート番号)に接続することでtelnetdとやり取りをする。しかし、それ以外の[ポート](./address_on_network.md#ポート番号)に接続することで、キーボードから各[プロトコル](./network_architecture.md#プロトコル)の[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を直接入力することもできる。これを利用して、[TCP/IP](./communication_protocol.md#tcpip)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)開発時のデバッグに利用されることもある。\n\n"},{"term":"透過モード","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"telnet","content":"\n**TELNET**は、[TCP](./transport_layer.md#tcp)の[コネクション](./network.md#コネクション)を1つ利用して、通信相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を文字列として送信し実行する[プロトコル](./network_architecture.md#プロトコル)。相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で動作している[シェル](../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)に接続しているような状態となる。\n\nTELNETでは、ユーザが入力した文字以外にもオプションをやり取りすることができる。**NVT**(Network Virtual Terminal)を実現するための画面制御情報はこのオプション機能を利用して送信される。\n\nまたTELNETには、改行キーが入力されるごとに1行分のデータをまとめて送る**行モード**と、入力された文字を1文字ごとに送る**透過モード**がある。\n\nTELNET[プロトコル](./network_architecture.md#プロトコル)を利用する[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[プログラム](../../../programming/_/chapters/programming.md#プログラム)を**TELNETクライアント**といい、TELNETクライアントは基本的に23番[ポート](./address_on_network.md#ポート番号)に接続することでtelnetdとやり取りをする。しかし、それ以外の[ポート](./address_on_network.md#ポート番号)に接続することで、キーボードから各[プロトコル](./network_architecture.md#プロトコル)の[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を直接入力することもできる。これを利用して、[TCP/IP](./communication_protocol.md#tcpip)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)開発時のデバッグに利用されることもある。\n\n"},{"term":"TELNETクライアント","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"telnet","content":"\n**TELNET**は、[TCP](./transport_layer.md#tcp)の[コネクション](./network.md#コネクション)を1つ利用して、通信相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を文字列として送信し実行する[プロトコル](./network_architecture.md#プロトコル)。相手の[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)内部で動作している[シェル](../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)に接続しているような状態となる。\n\nTELNETでは、ユーザが入力した文字以外にもオプションをやり取りすることができる。**NVT**(Network Virtual Terminal)を実現するための画面制御情報はこのオプション機能を利用して送信される。\n\nまたTELNETには、改行キーが入力されるごとに1行分のデータをまとめて送る**行モード**と、入力された文字を1文字ごとに送る**透過モード**がある。\n\nTELNET[プロトコル](./network_architecture.md#プロトコル)を利用する[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[プログラム](../../../programming/_/chapters/programming.md#プログラム)を**TELNETクライアント**といい、TELNETクライアントは基本的に23番[ポート](./address_on_network.md#ポート番号)に接続することでtelnetdとやり取りをする。しかし、それ以外の[ポート](./address_on_network.md#ポート番号)に接続することで、キーボードから各[プロトコル](./network_architecture.md#プロトコル)の[コマンド](../../../computer/linux/_/chapters/basic_command.md#コマンド)を直接入力することもできる。これを利用して、[TCP/IP](./communication_protocol.md#tcpip)[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)開発時のデバッグに利用されることもある。\n\n"},{"term":"公開鍵認証","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ssh","content":"\n**SSH**(Secure SHell)は、[公開鍵暗号方式](../../../system/security/_/chapters/encryption_technology.md#公開鍵暗号方式)によって暗号化された遠隔ログインシステムで、一般的に22番[ポート](./address_on_network.md#ポート番号)が利用される。SSHの基本的な機能は以下の通り。\n\n- 通信内容の暗号化\n- ファイルの転送\n- ポートフォワード機能\n\nポートフォワード機能は、特定の[ポート](./address_on_network.md#ポート番号)に届けられたメッセージを、特定の[IPアドレス](./address_on_network.md#ipアドレス)、[ポート番号](./address_on_network.md#ポート番号)に転送する仕組み。\n\nSSHの認証には、パスワード認証の他にも**公開鍵認証**や**ワンタイムパスワード認証**が利用できる。\n\n\n"},{"term":"ワンタイムパスワード認証","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ssh","content":"\n**SSH**(Secure SHell)は、[公開鍵暗号方式](../../../system/security/_/chapters/encryption_technology.md#公開鍵暗号方式)によって暗号化された遠隔ログインシステムで、一般的に22番[ポート](./address_on_network.md#ポート番号)が利用される。SSHの基本的な機能は以下の通り。\n\n- 通信内容の暗号化\n- ファイルの転送\n- ポートフォワード機能\n\nポートフォワード機能は、特定の[ポート](./address_on_network.md#ポート番号)に届けられたメッセージを、特定の[IPアドレス](./address_on_network.md#ipアドレス)、[ポート番号](./address_on_network.md#ポート番号)に転送する仕組み。\n\nSSHの認証には、パスワード認証の他にも**公開鍵認証**や**ワンタイムパスワード認証**が利用できる。\n\n\n"},{"term":"ファイル転送","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ファイル転送","content":"\n"},{"term":"anonymous FTPサーバ","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ftp","content":"\n**FTP**(File Transfer Protcol)は、異なる[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)間で[ファイル](../../../computer/software/_/chapters/file_system.md#ファイル)を転送するときに使われる[プロトコル](./network_architecture.md#プロトコル)。[インターネット](./network.md#インターネット)上には、誰でもログインできる**anonymous FTPサーバ**があり、これらはanonymousかftpというユーザ名でログインできる。anonymous FTPサーバは不特定多数への[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)の公開などのために用いられる。\n\nFTPでは、2つの[TCP](./transport_layer.md#tcp)[コネクション](./network.md#コネクション)が利用され、1つは制御用（21番[ポート](./address_on_network.md#ポート番号)）で、もう1つはファイル転送用（20番[ポート](./address_on_network.md#ポート番号)）である。ファイル転送には、一般的に20番[ポート](./address_on_network.md#ポート番号)を用いるが、セキュリティ向上のために[ポート番号](./address_on_network.md#ポート番号)を乱数的に割り当てるのが一般的。\n\n\n"},{"term":"電子メール","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"電子メール","content":"\n電子メールサービスを提供するための[プロトコル](./network_architecture.md#プロトコル)は[SMTP](#smtp)で、[TCP](./transport_layer.md#tcp)を利用している。通常のユーザが利用する[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)は常に電源が入っているとは限らないので、常に起動している**メールサーバ**を経由してメッセージの送受信を行う。受信者がメールサーバから電子メールを受け取るための[プロトコル](./network_architecture.md#プロトコル)としては[POP](#pop)がある。\n\n"},{"term":"メールサーバ","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"電子メール","content":"\n電子メールサービスを提供するための[プロトコル](./network_architecture.md#プロトコル)は[SMTP](#smtp)で、[TCP](./transport_layer.md#tcp)を利用している。通常のユーザが利用する[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)は常に電源が入っているとは限らないので、常に起動している**メールサーバ**を経由してメッセージの送受信を行う。受信者がメールサーバから電子メールを受け取るための[プロトコル](./network_architecture.md#プロトコル)としては[POP](#pop)がある。\n\n"},{"term":"POP before SMTP","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"pop-before-smtp","content":""},{"term":"WebSocket","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"websocket","content":"\n**WebSocket**は、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)と[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)の間で双方向通信を実現するための[プロトコル](./network_architecture.md#プロトコル)。最初に[HTTP](#http)通信を行い、upgrade[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)によってWebSocket用の通信路を確立する。\n\n\n"},{"term":"ネットワーク管理","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ネットワーク管理","content":"\n"},{"term":"マネージャ（ネットワーク監視端末）","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"snmp","content":"\n**SNMP**(Simple Network Management Protocol)は、[ネットワーク](./network.md#ネットワーク)管理に用いられる[プロトコル](./network_architecture.md#プロトコル)で、[UDP](./transport_layer.md#udp)/[IP](./internet_layer.md#ip)上で動作する。\n\nSNMPでは、管理する側を**マネージャ**（ネットワーク監視端末）、管理される側を**エージェント**（[ルータ](./network_architecture.md#ルータ)、[スイッチ](./network_architecture.md#スイッチ)など）と呼ぶ。\n\nSNMPでの処理は機器へのデータの書き込みと読み込みに集約される。この方法を、**フェッチ/ストアパラダイム**と呼ぶ。\n\n"},{"term":"エージェント","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"snmp","content":"\n**SNMP**(Simple Network Management Protocol)は、[ネットワーク](./network.md#ネットワーク)管理に用いられる[プロトコル](./network_architecture.md#プロトコル)で、[UDP](./transport_layer.md#udp)/[IP](./internet_layer.md#ip)上で動作する。\n\nSNMPでは、管理する側を**マネージャ**（ネットワーク監視端末）、管理される側を**エージェント**（[ルータ](./network_architecture.md#ルータ)、[スイッチ](./network_architecture.md#スイッチ)など）と呼ぶ。\n\nSNMPでの処理は機器へのデータの書き込みと読み込みに集約される。この方法を、**フェッチ/ストアパラダイム**と呼ぶ。\n\n"},{"term":"フェッチ/ストアパラダイム","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"snmp","content":"\n**SNMP**(Simple Network Management Protocol)は、[ネットワーク](./network.md#ネットワーク)管理に用いられる[プロトコル](./network_architecture.md#プロトコル)で、[UDP](./transport_layer.md#udp)/[IP](./internet_layer.md#ip)上で動作する。\n\nSNMPでは、管理する側を**マネージャ**（ネットワーク監視端末）、管理される側を**エージェント**（[ルータ](./network_architecture.md#ルータ)、[スイッチ](./network_architecture.md#スイッチ)など）と呼ぶ。\n\nSNMPでの処理は機器へのデータの書き込みと読み込みに集約される。この方法を、**フェッチ/ストアパラダイム**と呼ぶ。\n\n"},{"term":"標準MIB","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"mib","content":"\n**MIB**(Management Information Base)は、[SNMP](#snmp)でやり取りされる情報で、ツリー型の構造をもった管理情報[データベース](../../../development/database/_/chapters/database.md#データベース)となっている。 MIBには、**標準MIB**と各メーカーが独自に作成した**拡張MIB**がある。\n\n"},{"term":"拡張MIB","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"mib","content":"\n**MIB**(Management Information Base)は、[SNMP](#snmp)でやり取りされる情報で、ツリー型の構造をもった管理情報[データベース](../../../development/database/_/chapters/database.md#データベース)となっている。 MIBには、**標準MIB**と各メーカーが独自に作成した**拡張MIB**がある。\n\n"},{"term":"H.323","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"h323","content":""},{"term":"SIP","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"sip","content":"\n**SIP**は、[H.323](#h323)より後に開発された、[インターネット](./network.md#インターネット)での利用によりマッチした[プロトコル](./network_architecture.md#プロトコル)。\n\n\n"},{"term":"ディレクトリサービス","link":"./note/ja/./network/_/chapters/application_layer.md","flagment":"ldap","content":"\n**LDAP**(Lightweight Directory Access Protocol)は、ユーザ名やパスワードなどの情報を一元管理する仕組みである、ディレクトリサービスへのアクセスに使われる[プロトコル](./network_architecture.md#プロトコル)。**ディレクトリサービス**は、ネットワーク上の資源に関してデータベース的な情報提供を行うサービスである。\n\n\n"},{"term":"Web","link":"./note/ja/./network/_/chapters/web.md","flagment":"web","content":"\n**Web**は、[TCP/IP](./communication_protocol.md#tcpip)の[アプリケーションレイヤ](./communication_protocol.md#アプリケーションレイヤ)の[システム](../../../system/_/chapters/system.md#システム)で、[インターネット](./network.md#インターネット)上で[HTTP](./application_layer.md#http)通信によりハイパーテキスト形式の情報をやり取りすることができる。世界最大の[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)であり、[ハイパーメディア](#ハイパーメディア)という情報システムの一種である。\n\n[Webブラウザ](#webブラウザ)の画面に表示されるイメージ全体を**Webページ**、Webページの見出しとなるページを**ホームページ**と呼ぶ。\n\n"},{"term":"Webページ","link":"./note/ja/./network/_/chapters/web.md","flagment":"web","content":"\n**Web**は、[TCP/IP](./communication_protocol.md#tcpip)の[アプリケーションレイヤ](./communication_protocol.md#アプリケーションレイヤ)の[システム](../../../system/_/chapters/system.md#システム)で、[インターネット](./network.md#インターネット)上で[HTTP](./application_layer.md#http)通信によりハイパーテキスト形式の情報をやり取りすることができる。世界最大の[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)であり、[ハイパーメディア](#ハイパーメディア)という情報システムの一種である。\n\n[Webブラウザ](#webブラウザ)の画面に表示されるイメージ全体を**Webページ**、Webページの見出しとなるページを**ホームページ**と呼ぶ。\n\n"},{"term":"ホームページ","link":"./note/ja/./network/_/chapters/web.md","flagment":"web","content":"\n**Web**は、[TCP/IP](./communication_protocol.md#tcpip)の[アプリケーションレイヤ](./communication_protocol.md#アプリケーションレイヤ)の[システム](../../../system/_/chapters/system.md#システム)で、[インターネット](./network.md#インターネット)上で[HTTP](./application_layer.md#http)通信によりハイパーテキスト形式の情報をやり取りすることができる。世界最大の[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)であり、[ハイパーメディア](#ハイパーメディア)という情報システムの一種である。\n\n[Webブラウザ](#webブラウザ)の画面に表示されるイメージ全体を**Webページ**、Webページの見出しとなるページを**ホームページ**と呼ぶ。\n\n"},{"term":"Webブラウザ","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Microsoft Edge","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Mozilla Firefox","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Google Chrome","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Opera","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Safari","link":"./note/ja/./network/_/chapters/web.md","flagment":"webブラウザ","content":"\n**Webブラウザ**は、[Web](#web)の情報を画面に表示するための[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)。代表的なブラウザとしてはMicrosoftのMicrosoft EdgeやMozilla FoundationのFirefox、GoogleのGoogle Chrome、Opera SoftwareのOpera、AppleのSafariなどがある。\n\n[HTML](#html)やCSS、JavaScriptをどのように解釈するかはブラウザの実装次第であるため、[Web](#web)コンテンツの表示や挙動が微妙に異なる場合がある。\n\n"},{"term":"Webサーバ","link":"./note/ja/./network/_/chapters/web.md","flagment":"webサーバ","content":"\n**Webサーバ**は、[インターネット](./network.md#インターネット)上で[Webブラウザ](#webブラウザ)にコンテンツを配信する[サーバ](../../../computer/_/chapters/computer.md#サーバ)。\n\n"},{"term":"CERN（European Organization for Nuclear Research: 欧州原子核研究機構）","link":"./note/ja/./network/_/chapters/web.md","flagment":"webの歴史","content":"\n1980年代までに[ハイパーメディア](#ハイパーメディア)の構想が成熟し、[インターネット](./network.md#インターネット)の技術が登場し、[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)の基盤が構築された。1990年11月、スイスの**CERN**（European Organization for Nuclear Research: 欧州原子核研究機構）のTim Berners-Leeが、[インターネット](./network.md#インターネット)ベースの分散情報管理システムとして[Web](#web)の提案書を書き、その年の年末には最初の[バージョン](../../../computer/software/_/chapters/package.md#バージョン)の[ブラウザ](#webブラウザ)と[サーバ](#webサーバ)を完成させた。\n\n1993年にイリノイ大学の**NCSA**（National Center for Supercomputing Application: 米国立スーパーコンピュータ応用研究所）が公開した**Mosaic**という[ブラウザ](#webブラウザ)は、それまでの[ブラウザ](#webブラウザ)がテキストのみを扱っていたのに対して、画像をインライン表示できるという機能を備えていた。\n\n様々な高機能[ブラウザ](#webブラウザ)が登場すると[Web](#web)は急速に普及し、[インターネット](./network.md#インターネット)の[標準化](./communication_protocol.md#標準化の流れ)を行う[IETF](./communication_protocol.md#ietf)の[RFC](./network/_/chapters/communication_protocol.md#rfc)の仕様策定が追いつかなくなった。そこで、1994年にBerners-Leeが中心となって[W3C](#w3c)を設立し、[IETF](./communication_protocol.md#ietf)に代わって[Web](#web)の[標準化](./communication_protocol.md#標準化の流れ)を進めた。\n\n\n"},{"term":"NCSA（National Center for SUpercomputing Application: 米国立スーパーコンピュータ応用研究所）","link":"./note/ja/./network/_/chapters/web.md","flagment":"webの歴史","content":"\n1980年代までに[ハイパーメディア](#ハイパーメディア)の構想が成熟し、[インターネット](./network.md#インターネット)の技術が登場し、[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)の基盤が構築された。1990年11月、スイスの**CERN**（European Organization for Nuclear Research: 欧州原子核研究機構）のTim Berners-Leeが、[インターネット](./network.md#インターネット)ベースの分散情報管理システムとして[Web](#web)の提案書を書き、その年の年末には最初の[バージョン](../../../computer/software/_/chapters/package.md#バージョン)の[ブラウザ](#webブラウザ)と[サーバ](#webサーバ)を完成させた。\n\n1993年にイリノイ大学の**NCSA**（National Center for Supercomputing Application: 米国立スーパーコンピュータ応用研究所）が公開した**Mosaic**という[ブラウザ](#webブラウザ)は、それまでの[ブラウザ](#webブラウザ)がテキストのみを扱っていたのに対して、画像をインライン表示できるという機能を備えていた。\n\n様々な高機能[ブラウザ](#webブラウザ)が登場すると[Web](#web)は急速に普及し、[インターネット](./network.md#インターネット)の[標準化](./communication_protocol.md#標準化の流れ)を行う[IETF](./communication_protocol.md#ietf)の[RFC](./network/_/chapters/communication_protocol.md#rfc)の仕様策定が追いつかなくなった。そこで、1994年にBerners-Leeが中心となって[W3C](#w3c)を設立し、[IETF](./communication_protocol.md#ietf)に代わって[Web](#web)の[標準化](./communication_protocol.md#標準化の流れ)を進めた。\n\n\n"},{"term":"Mosaic","link":"./note/ja/./network/_/chapters/web.md","flagment":"webの歴史","content":"\n1980年代までに[ハイパーメディア](#ハイパーメディア)の構想が成熟し、[インターネット](./network.md#インターネット)の技術が登場し、[分散システム](../../../system/_/chapters/system_processing_model.md#分散システム)の基盤が構築された。1990年11月、スイスの**CERN**（European Organization for Nuclear Research: 欧州原子核研究機構）のTim Berners-Leeが、[インターネット](./network.md#インターネット)ベースの分散情報管理システムとして[Web](#web)の提案書を書き、その年の年末には最初の[バージョン](../../../computer/software/_/chapters/package.md#バージョン)の[ブラウザ](#webブラウザ)と[サーバ](#webサーバ)を完成させた。\n\n1993年にイリノイ大学の**NCSA**（National Center for Supercomputing Application: 米国立スーパーコンピュータ応用研究所）が公開した**Mosaic**という[ブラウザ](#webブラウザ)は、それまでの[ブラウザ](#webブラウザ)がテキストのみを扱っていたのに対して、画像をインライン表示できるという機能を備えていた。\n\n様々な高機能[ブラウザ](#webブラウザ)が登場すると[Web](#web)は急速に普及し、[インターネット](./network.md#インターネット)の[標準化](./communication_protocol.md#標準化の流れ)を行う[IETF](./communication_protocol.md#ietf)の[RFC](./network/_/chapters/communication_protocol.md#rfc)の仕様策定が追いつかなくなった。そこで、1994年にBerners-Leeが中心となって[W3C](#w3c)を設立し、[IETF](./communication_protocol.md#ietf)に代わって[Web](#web)の[標準化](./communication_protocol.md#標準化の流れ)を進めた。\n\n\n"},{"term":"ハイパーメディア","link":"./note/ja/./network/_/chapters/web.md","flagment":"ハイパーメディア","content":"\n**ハイパーメディア**は、テキストや音声、映像などの様々なメディアを[リンク](#ハイパーリンク)で結び付けて構成した[システム](../../../system/_/chapters/system.md#システム)。\n\n"},{"term":"ハイパーリンク（リンク）","link":"./note/ja/./network/_/chapters/web.md","flagment":"ハイパーリンク","content":"\n**ハイパーリンク**（**リンク**）は、[ハイパーメディア](#ハイパーメディア)において情報同士を結びつける機能。\n\n"},{"term":"ハイパーテキスト","link":"./note/ja/./network/_/chapters/web.md","flagment":"ハイパーテキスト","content":"\n**ハイパーテキスト**は、[ハイパーリンク](#ハイパーリンク)を用いて情報を結びつけた文字情報中心の文書。[ハイパーメディア](#ハイパーメディア)はハイパーテキストを拡張した考え方。\n\n"},{"term":"Memex","link":"./note/ja/./network/_/chapters/web.md","flagment":"memex","content":"\n**Memex**は、1945年にアメリカの研究者Vannevar Bushが発表した情報検索システムについての論文で、[ハイパーメディア](#ハイパーメディア)の起源。[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が登場したばかりの頃の論文であるが、電気的に接続した本やフィルムなどを相互に[リンク](#ハイパーリンク)し、[リンク](#ハイパーリンク)をたどって情報を探索するという現在の[Web](#web)を予感させる[システム](../../../system/_/chapters/system.md#システム)が構想されていた。\n\n"},{"term":"Xanadu","link":"./note/ja/./network/_/chapters/web.md","flagment":"xanadu","content":"\n**Xanadu**は、[Memex](#memex)の構想に影響を受けたTed Nelsonによって構想された[ハイパーメディア](#ハイパーメディア)[システム](../../../system/_/chapters/system.md#システム)。現在の[Web](#web)よりもさらに高機能な理想の[ハイパーメディア](#ハイパーメディア)として開発されたが、あまりの複雑さから計画が頓挫し、[Web](#web)の圧倒的な普及速度に追いつけなかった。\n\n"},{"term":"HyperCard","link":"./note/ja/./network/_/chapters/web.md","flagment":"hypercard","content":"\n**HyperCard**は、1987年にAppleのBill Atkinsonが開発した[ハイパーメディア](#ハイパーメディア)で、カードと呼ばれる文書を単位に相互に[リンク](#ハイパーリンク)を張るという構成。当時Appleがよく利用していたスクリプト言語、HyperTalkにより実装されていた。\n\n\n"},{"term":"HyperTalk","link":"./note/ja/./network/_/chapters/web.md","flagment":"hypercard","content":"\n**HyperCard**は、1987年にAppleのBill Atkinsonが開発した[ハイパーメディア](#ハイパーメディア)で、カードと呼ばれる文書を単位に相互に[リンク](#ハイパーリンク)を張るという構成。当時Appleがよく利用していたスクリプト言語、HyperTalkにより実装されていた。\n\n\n"},{"term":"検索エンジン","link":"./note/ja/./network/_/chapters/web.md","flagment":"検索エンジン","content":"\n**検索エンジン**は、広大な[インターネット](./network.md#インターネット)上の情報から、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が求める情報を探し出すための[システム](../../../system/_/chapters/system.md#システム)。ユーザが[Webブラウザ](#webブラウザ)の検索ボックスに入力したキーワードを元に、最適な情報を探索する。現在使われている検索エンジンは、ほとんどがGoogleとなっているが、YahooやBingといった検索エンジンもよく用いられている。\n\n"},{"term":"Google","link":"./note/ja/./network/_/chapters/web.md","flagment":"検索エンジン","content":"\n**検索エンジン**は、広大な[インターネット](./network.md#インターネット)上の情報から、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が求める情報を探し出すための[システム](../../../system/_/chapters/system.md#システム)。ユーザが[Webブラウザ](#webブラウザ)の検索ボックスに入力したキーワードを元に、最適な情報を探索する。現在使われている検索エンジンは、ほとんどがGoogleとなっているが、YahooやBingといった検索エンジンもよく用いられている。\n\n"},{"term":"Yahoo","link":"./note/ja/./network/_/chapters/web.md","flagment":"検索エンジン","content":"\n**検索エンジン**は、広大な[インターネット](./network.md#インターネット)上の情報から、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が求める情報を探し出すための[システム](../../../system/_/chapters/system.md#システム)。ユーザが[Webブラウザ](#webブラウザ)の検索ボックスに入力したキーワードを元に、最適な情報を探索する。現在使われている検索エンジンは、ほとんどがGoogleとなっているが、YahooやBingといった検索エンジンもよく用いられている。\n\n"},{"term":"Bing","link":"./note/ja/./network/_/chapters/web.md","flagment":"検索エンジン","content":"\n**検索エンジン**は、広大な[インターネット](./network.md#インターネット)上の情報から、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が求める情報を探し出すための[システム](../../../system/_/chapters/system.md#システム)。ユーザが[Webブラウザ](#webブラウザ)の検索ボックスに入力したキーワードを元に、最適な情報を探索する。現在使われている検索エンジンは、ほとんどがGoogleとなっているが、YahooやBingといった検索エンジンもよく用いられている。\n\n"},{"term":"クローリング","link":"./note/ja/./network/_/chapters/web.md","flagment":"クローリング","content":"\n**クローリング**は、**クローラ**という[プログラム](../../../programming/_/chapters/programming.md#プログラム)によって[インターネット](./network.md#インターネット)上の[リンク](#ハイパーリンク)をたどり、[Web](#web)ページを巡回して情報を収集する処理。\n\n"},{"term":"クローラ","link":"./note/ja/./network/_/chapters/web.md","flagment":"クローリング","content":"\n**クローリング**は、**クローラ**という[プログラム](../../../programming/_/chapters/programming.md#プログラム)によって[インターネット](./network.md#インターネット)上の[リンク](#ハイパーリンク)をたどり、[Web](#web)ページを巡回して情報を収集する処理。\n\n"},{"term":"インデックス","link":"./note/ja/./network/_/chapters/web.md","flagment":"インデックス","content":"\n**インデックス**は、[クローリング](#クローリング)によって収集したデータを蓄積し、検索インデックスに[Web](#web)ページの情報を格納する処理。\n\n"},{"term":"ランキング","link":"./note/ja/./network/_/chapters/web.md","flagment":"ランキング","content":"\n**ランキング**は、[インデックス](#インデックス)された情報を検索[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)と照合して評価し、関連性の高い回答を検索結果として表示する処理。\n\n"},{"term":"ページランク","link":"./note/ja/./network/_/chapters/web.md","flagment":"ページランク","content":"\n**ページランク**は、Googleが採用している[検索エンジン](#検索エンジン)の[ランキング](#ランキング)[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)。\n\n\n"},{"term":"REST","link":"./note/ja/./network/_/chapters/web.md","flagment":"rest","content":"\n**REST**は、[ネットワーク](./network.md#ネットワーク)[システム](../../../system/_/chapters/system.md#システム)のアーキテクチャスタイルのひとつであり、[クライアントサーバシステム](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)に様々な制約を加えたものとなっている。RESTは[Web](#web)をソフトウェアアーキテクチャの観点から分析してまとめられている。\n\nRESTは、**ULCODC$SS**(Uniform Layered Code on Demand Client Cache Stateless Server)というアーキテクチャスタイルの通称。[Web](#web)サービスを実装する上ではRESTを構成するいくつかのアーキテクチャスタイルは除外してもよい。\n\n"},{"term":"SOAP","link":"./note/ja/./network/_/chapters/web.md","flagment":"soap","content":"\n**SOAP**は、[ネットワーク](./network.md#ネットワーク)[システム](../../../system/_/chapters/system.md#システム)のアーキテクチャスタイルのひとつであり、メッセージの転送方法を定めた仕様。1990年代後半から2000年代にかけて、[Web API](#web-api)の[標準化](./communication_protocol.md#標準化の流れ)をめぐって[REST](#rest)と争っていたが、多くのベンダがドラフトを持ち寄って実装を進めた結果、相互運用性に欠ける状態となったために[REST](#rest)に敗北した。\n\n"},{"term":"アプリケーション状態（セッション状態）","link":"./note/ja/./network/_/chapters/web.md","flagment":"ステートレスサーバ","content":"\n**ステートレスサーバ**(Stateless Server)は、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)の**アプリケーション状態**（**セッション状態**）を[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が管理しないアーキテクチャスタイル。しかし現実にはステートレスではない[Web](#web)サービスや[Web API](#web-api)がほとんどであり、[Cookie](#cookie)などのセッションを使ったステートフルな状態管理が多用されている。\n\nステートフルな[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)では、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)の数が増え、保持しなければいけないアプリケーション状態が増加した際に[スケールアウト](../../../system/_/chapters/system_performance_evaluation.md#スケールアウト)することが難しい。ステートフルな構成はステートレスサーバの利点をあえて捨てているということを理解した上で利用する必要がある。\n\n"},{"term":"コードオンデマンド","link":"./note/ja/./network/_/chapters/web.md","flagment":"コードオンデマンド","content":"\n**コードオンデマンド**は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)[コード](../../../programming/_/chapters/programming.md#ソースコード)を[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)からダウンロードして、それを[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側で実行するアーキテクチャスタイル。[JavaScript](../../../programming/_/chapters/programming_language.md#javascript)や**Flash**、**Javaアンプレット**がこれに該当する技術で、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側の拡張性が高くなるという利点がある。\n\n"},{"term":"Flash","link":"./note/ja/./network/_/chapters/web.md","flagment":"コードオンデマンド","content":"\n**コードオンデマンド**は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)[コード](../../../programming/_/chapters/programming.md#ソースコード)を[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)からダウンロードして、それを[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側で実行するアーキテクチャスタイル。[JavaScript](../../../programming/_/chapters/programming_language.md#javascript)や**Flash**、**Javaアンプレット**がこれに該当する技術で、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側の拡張性が高くなるという利点がある。\n\n"},{"term":"Javaアンプレット","link":"./note/ja/./network/_/chapters/web.md","flagment":"コードオンデマンド","content":"\n**コードオンデマンド**は、[プログラム](../../../programming/_/chapters/programming.md#プログラム)[コード](../../../programming/_/chapters/programming.md#ソースコード)を[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)からダウンロードして、それを[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側で実行するアーキテクチャスタイル。[JavaScript](../../../programming/_/chapters/programming_language.md#javascript)や**Flash**、**Javaアンプレット**がこれに該当する技術で、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側の拡張性が高くなるという利点がある。\n\n"},{"term":"RESTful","link":"./note/ja/./network/_/chapters/web.md","flagment":"restful","content":"\n**RESTful**は、[REST](#rest)の制約に従う[REST](#rest)らしいサービスのことを指す用語。個別の[Web](#web)サービスや[Web API](#web-api)がRESTfulになると、[Web](#web)は全体としてより良くなるため、開発者は[REST](#rest)を意識して個別の[システム](../../../system/_/chapters/system.md#システム)を設計する必要がある。\n\n\n"},{"term":"URI（Uniform Resource Identifier: 統一リソース識別子）","link":"./note/ja/./network/_/chapters/web.md","flagment":"uri","content":"\n**URI**（Uniform Resource Identifier: **統一リソース識別子**）は、[インターネット](./network.md#インターネット)上の資源（[リソース](#リソース)）を表す識別子。\n\nURIで表されるパスには[ASCII](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)文字のみ利用することができ、日本語などの[ASCII](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)以外の文字を使いたい場合は**%エンコーディング**という方式を用いて文字をエンコードする。\n\n"},{"term":"%エンコーディング","link":"./note/ja/./network/_/chapters/web.md","flagment":"uri","content":"\n**URI**（Uniform Resource Identifier: **統一リソース識別子**）は、[インターネット](./network.md#インターネット)上の資源（[リソース](#リソース)）を表す識別子。\n\nURIで表されるパスには[ASCII](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)文字のみ利用することができ、日本語などの[ASCII](../../../basics/information_theory/_/chapters/character_representation.md#asciiコード)以外の文字を使いたい場合は**%エンコーディング**という方式を用いて文字をエンコードする。\n\n"},{"term":"ISBN","link":"./note/ja/./network/_/chapters/web.md","flagment":"urn","content":"\n**URN**(Uniform Resource Name)は、[URI](#uri)よりも狭義の概念で、[リソース](#リソース)に恒久的なIDを振るための識別子。例えば、書籍には**ISBN**という世界的に統一されたURNが割り振られている。\n\n"},{"term":"クエリパラメータ（クエリ文字列）","link":"./note/ja/./network/_/chapters/web.md","flagment":"クエリパラメータ","content":"\n**クエリパラメータ**（**クエリ文字列**）は、[URI](#uri)中に指定することができるパラメータで、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)に対して情報を送信したい場合に用いられる。\n\n"},{"term":"URIフラグメント","link":"./note/ja/./network/_/chapters/web.md","flagment":"uriフラグメント","content":"\n**URIフラグメント**は、[URI](#uri)中で[リソース](#リソース)の内部のさらに細かい部分を指定するときに使用される部分。\n\n"},{"term":"リソース","link":"./note/ja/./network/_/chapters/web.md","flagment":"リソース","content":"\n**リソース**は、[Web](#web)上に存在する[URI](#uri)を持ったありとあらゆる情報を指す用語。ひとつのリソースが複数の名前を持つこともできる。\n\n実際に[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)と[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)がやり取りするデータのことを**リソースの表現**といい、リソースの表現は時間によって**状態**が変化する可能性がある。\n\n"},{"term":"リソースの表現、状態","link":"./note/ja/./network/_/chapters/web.md","flagment":"リソース","content":"\n**リソース**は、[Web](#web)上に存在する[URI](#uri)を持ったありとあらゆる情報を指す用語。ひとつのリソースが複数の名前を持つこともできる。\n\n実際に[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)と[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)がやり取りするデータのことを**リソースの表現**といい、リソースの表現は時間によって**状態**が変化する可能性がある。\n\n"},{"term":"アドレス可能性","link":"./note/ja/./network/_/chapters/web.md","flagment":"アドレス可能性","content":"\n**アドレス可能性**は、[URI](#uri)が持つ、[リソース](#リソース)を一意的に指し示すことができる性質。\n\n"},{"term":"クールURI","link":"./note/ja/./network/_/chapters/web.md","flagment":"クールuri","content":"\n**クールURI**は、良い[URI](#uri)や綺麗な[URI](#uri)を指す言葉で、Berners-Leeが1998年に発表した「Cool URIs don't change」という[Web](#web)ページが発祥となっている。Berners-Leeは、「[URI](#uri)は変わらないべきである。変わらない[URI](#uri)こそが最上のURIである」と主張した。\n\n"},{"term":"BASIC認証","link":"./note/ja/./network/_/chapters/web.md","flagment":"basic認証","content":"\n**Basic認証**は、base64でエンコードされたユーザIDとパスワードによる認証。平文で[ネットワーク](./network.md#ネットワーク)を流れるので、安全性は低く、HTTPSの暗号化通信と組み合わせて使用することが推奨されている。\n\n"},{"term":"Digest認証","link":"./note/ja/./network/_/chapters/web.md","flagment":"digest認証","content":"\n**Digest認証**は、[Basic認証](#basic認証)の欠点であった平文で認証情報が流れてしまうことを改善した認証方式。ユーザIDとパスワードをMD5でハッシュ化して送信する。ただし、Digest認証の暗号化方式も解析が可能となっているため、HTTPSと合わせて使用するなど安全性を高める対策は必要となる。\n\n\n"},{"term":"HTTPメッセージ","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメッセージ","content":"\n**HTTPメッセージ**は、[HTTP](./application_layer.md#http)通信において[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)や[レスポンス](../../../system/_/chapters/system_processing_model.md#レスポンス)の際にやり取りされるメッセージ。\n\n"},{"term":"HTTPヘッダ","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpヘッダ","content":"\n**HTTPヘッダ**は、[HTTPメッセージ](#httpメッセージ)において、[HTTP](./application_layer.md#http)通信のメタデータが格納された部分。\n\n"},{"term":"HTTPボディ","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpボディ","content":"\n**HTTPボディ**は、[HTTPメッセージ](#httpメッセージ)において様々な情報が格納される部分で、その扱いは[ソフトウェア](../../../computer/software/_/chapters/software.md#ソフトウェア)次第。HTTPボディは省略することも可能。通常の[Web](#web)ページの[レスポンス](../../../system/_/chapters/system_processing_model.md#レスポンス)ではHTTPボディに[HTML](#html)が格納され、[Web API](#web-api)では[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)のパラメータや[レスポンス](../../../system/_/chapters/system_processing_model.md#レスポンス)データとしてHTTPボディにXMLやJSONなどが格納されることが多い。\n\n"},{"term":"リクエストメッセージ","link":"./note/ja/./network/_/chapters/web.md","flagment":"リクエストメッセージ","content":"\n**リクエストメッセージ**は、[HTTP](./application_layer.md#http)通信において[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際にやり取りされる[HTTPメッセージ](#httpメッセージ)。\n\n```\n[リクエストメッセージの例]\nGET /test?q=test HTTP/1.1\nHost: example.jp\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9\n```\n\n"},{"term":"リクエストライン","link":"./note/ja/./network/_/chapters/web.md","flagment":"リクエストライン","content":"\n**リクエストライン**は、[リクエストメッセージ](#リクエストメッセージ)の1行目にあたる部分で、[HTTPメソッド](#httpメソッド)、[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)[URI](#uri)、[プロトコル](./network_architecture.md#プロトコル)[バージョン](../../../computer/software/_/chapters/package.md#バージョン)からなる。\n\n"},{"term":"レスポンスメッセージ","link":"./note/ja/./network/_/chapters/web.md","flagment":"レスポンスメッセージ","content":"\n**レスポンスメッセージ**は、[HTTP](./application_layer.md#http)通信において[レスポンス](../../../system/_/chapters/system_processing_model.md#レスポンス)の際にやり取りされる[HTTPメッセージ](#httpメッセージ)。\n\n```\n[レスポンスメッセージの例]\nHTTP/1.1 200 OK\nContent-Type: application/xhtml+xml; charset=utf-8\n\n<html>\n ...\n</html>\n```\n\n"},{"term":"ステータスライン","link":"./note/ja/./network/_/chapters/web.md","flagment":"ステータスライン","content":"\n**ステータスライン**は、[レスポンスメッセージ](#レスポンスメッセージ)の1行目にあたる部分で、[プロトコル](./network_architecture.md#プロトコル)[バージョン](../../../computer/software/_/chapters/package.md#バージョン)、[ステータスコード](#ステータスコード)、テキストフレーズからなる。\n\n\n"},{"term":"HTTPメソッド","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"GET","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"POST","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"PATCH","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"PUT","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"DELETE","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"HEAD","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"OPTIONS","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"TRACE","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"CONNECT","link":"./note/ja/./network/_/chapters/web.md","flagment":"httpメソッド","content":"\n**HTTPメソッド**は、[HTTP](./application_layer.md#http)[リクエスト](../../../system/_/chapters/system_processing_model.md#リクエスト)の際に、対象となる[リソース](#リソース)に対してどのような操作を行うかを表す命令。中でもGET、POST、PUT、DELETEは、これら4つでCRUDの性質を満たす。\n\n| メソッド | 意味                                                     |\n|----------|----------------------------------------------------------|\n| GET      | リソースの取得                                           |\n| POST     | 子リソースの作成、リソースへのデータの追加、その他の処理 |\n| PATCH    | リソースの部分的な更新                                   |\n| PUT      | リソースの更新、リソースの作成                           |\n| DELETE   | リソースの削除                                           |\n| HEAD     | リソースのヘッダの取得                                   |\n| OPTIONS  | リソースがサポートしているメソッドの取得                 |\n| TRACE    | 自分宛てにリクエストメッセージを返す（ループバック）試験 |\n| CONNECT  | プロキシ動作のトンネル接続への変更                       |\n\n\n"},{"term":"ステータスコード","link":"./note/ja/./network/_/chapters/web.md","flagment":"ステータスコード","content":"\n"},{"term":"セッション","link":"./note/ja/./network/_/chapters/web.md","flagment":"セッション","content":"\n**セッション**は、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)がある[Web](#web)サイトに訪問してから離脱するまでの通信。各[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)ごとのセッション情報は[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が利用する[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)に格納されており、[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)は自分のセッション情報を参照するためのキーを[Cookie](#cookie)などで保持する。\n\n[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)を[冗長化](../../../system/_/chapters/system_architecture.md#冗長化)する場合は、全ての[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が共有できる[ストレージ](../../../computer/hardware/_/chapters/hardware.md#記憶装置)（[DB](../../../development/database/_/chapters/database.md#データベース)や[キャッシュ](#キャッシュ)[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)など）でセッション情報を管理する必要がある。\n\n"},{"term":"Cookie","link":"./note/ja/./network/_/chapters/web.md","flagment":"cookie","content":"\n**Cookie**は、[ブラウザ](#webブラウザ)に情報を保存するための機能で、[セッション](#セッション)情報を参照するためのキーの管理などに用いられる。Cookieの情報をどれだけの期間保持しておくかは、[ブラウザ](#webブラウザ)の設定や[HTTPメッセージ](#httpメッセージ)内のメタ情報により制御する。\n\n"},{"term":"ローカルストレージ","link":"./note/ja/./network/_/chapters/web.md","flagment":"ローカルストレージ","content":"\n**ローカルストレージ**(Local Storage)は、[ブラウザ](#webブラウザ)に情報を保存するための機能で、[Cookie](#cookie)よりも情報の保存期間が長く、格納できるデータ量も大きい。[Cookie](#cookie)の情報は[HTTPメッセージ](#httpメッセージ)を介して[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)にも送信されるが、ローカルストレージの情報はブラウザのみで使用されるため、[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)側の[セッション](#セッション)の管理には向いていない。\n"},{"term":"ルーティングプロトコル","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ルーティングプロトコル","content":"\n**ルーティングプロトコル**は、[ダイナミックルーティング](./internet_layer.md#ダイナミックルーティング)により自動的に[ルーティングテーブル](./internet_layer.md#ルーティングテーブル)の情報を更新するための[プロトコル](./network_architecture.md#プロトコル)。\n\n"},{"term":"経路制御アルゴリズム","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"経路制御アルゴリズム","content":"\n"},{"term":"メトリック","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"メトリック","content":"\n**メトリック**は、[ルーティング](./internet_layer.md#ルーティング)の際に参考にされる、距離やコストといった転送の判断に用いられる指標。\n\n"},{"term":"RIP","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"rip","content":"\n**RIP**は、[距離ベクトル型](#距離ベクトル型)の[ルーティングプロトコル](#ルーティングプロトコル)で、[経路制御](./internet_layer.md#ルーティング)情報を定期的（30秒周期）に[ネットワーク](./network.md#ネットワーク)上に[ブロードキャスト](./network.md#ブロードキャスト)する。[メトリック](#メトリック)の単位は通過する[ルータ](./network_architecture.md#ルータ)の数（[ホップ](./internet_layer.md#ホップ)数）で、できる限り少ない[ホップ](./internet_layer.md#ホップ)数で目的の[IPアドレス](./address_on_network.md#ipアドレス)に到達できるように制御される。\n\n"},{"term":"RIP2","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"rip2","content":"\n**RIP2**は、[RIP](#rip)を改良した[プロトコル](./network_architecture.md#プロトコル)で、[マルチキャスト](./network.md#マルチキャスト)対応や[サブネットマスク](./address_on_network.md#サブネットマスク)対応などがされており、かなり実用的になっている。また、1つの[ネットワーク](./network.md#ネットワーク)上で論理的に独立した複数の[RIP](#rip)が使えるようになっており、認証キーにも対応している。\n\n\n"},{"term":"OSPF","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ospf","content":"\n**OSPF**は、[リンク状態型](#リンク状態型)の[ルーティングプロトコル](#ルーティングプロトコル)で、ループのある[ネットワーク](./network.md#ネットワーク)でも安定した[ルーティング](./internet_layer.md#ルーティング)を行うことができる。\n\n[RIP](#rip)では[ホップ](./internet_layer.md#ホップ)数が最も少なくなる方向に経路を設定するが、OSPFでは各リンクに重みをつけることができ、この重みが小さくなるように経路を選択する。この重みのことを**コスト**といい、[メトリック](#メトリック)として用いる。\n\n"},{"term":"コスト","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ospf","content":"\n**OSPF**は、[リンク状態型](#リンク状態型)の[ルーティングプロトコル](#ルーティングプロトコル)で、ループのある[ネットワーク](./network.md#ネットワーク)でも安定した[ルーティング](./internet_layer.md#ルーティング)を行うことができる。\n\n[RIP](#rip)では[ホップ](./internet_layer.md#ホップ)数が最も少なくなる方向に経路を設定するが、OSPFでは各リンクに重みをつけることができ、この重みが小さくなるように経路を選択する。この重みのことを**コスト**といい、[メトリック](#メトリック)として用いる。\n\n"},{"term":"HELLOプロトコル","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"helloプロトコル","content":"\n**HELLOプロトコル**は、[OSPF](#ospf)において接続の確認を行う[プロトコル](./network_architecture.md#プロトコル)。\n\n"},{"term":"リンク状態データベース","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"リンク状態データベース","content":"\n**リンク状態データベース**は、[OSPF](#ospf)において接続されている[ルータ](./network_architecture.md#ルータ)や[ネットワーク](./network.md#ネットワーク)の情報を格納したもの。これをもとに[ルーティングテーブル](./internet_layer.md#ルーティングテーブル)が作成される。\n\n"},{"term":"ネットワークLSA","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ネットワークLSA","content":""},{"term":"ルータLSA","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ルータLSA","content":""},{"term":"ダイクストラ法","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ダイクストラ法","content":"\n**ダイクストラ法**は、[OSPF](#ospf)の最短経路を求めるための[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、[ルーティングテーブル](./internet_layer.md#ルーティングテーブル)を作成する際に用いられる。\n\n"},{"term":"エリア","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"エリア","content":"\n**エリア**は、[OSPF](#ospf)において計算の負荷軽減のために用いられた概念で、[ネットワーク](./network.md#ネットワーク)同士や[ホスト](./network.md#ホスト)同士をまとめてグループ化したもの。\n\n"},{"term":"バックボーンエリア","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"バックボーンエリア","content":"\n**バックボーンエリア**は、[OSPF](#ospf)の各[エリア](#エリア)が接続されている、根幹となる[エリア](#エリア)。\n\n"},{"term":"エリア境界ルータ","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"エリア境界ルータ","content":"\n**エリア境界ルータ**は、[エリア](#エリア)と[バックボーンエリア](#バックボーンエリア)を結ぶ[ルータ](./network_architecture.md#ルータ)。\n\n"},{"term":"内部ルータ","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"内部ルータ","content":"\n**内部ルータ**は、[エリア](#エリア)内の[ルータ](./network_architecture.md#ルータ)。\n\n"},{"term":"バックボーンルータ","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"バックボーンルータ","content":"\n**バックボーンルータ**は、[バックボーンエリア](#バックボーンエリア)にのみ接続されている[ルータ](./network_architecture.md#ルータ)。\n\n"},{"term":"AS境界ルータ","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"as境界ルータ","content":"\n**AS境界ルータ**は、外部の[エリア](#エリア)と接続されている[ルータ](./network_architecture.md#ルータ)。\n\n"},{"term":"スタブエリア","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"スタブエリア","content":"\n**スタブエリア**は、[エリア境界ルータ](#エリア境界ルータ)を1つしか持たない[エリア](#エリア)のことで、スタブエリアを用いることで経路情報を減らすことができる。\n\n\n"},{"term":"BGP","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"bgp","content":"\n**BGP**は、組織間の[ネットワーク](./network.md#ネットワーク)を接続するときに利用される[経路ベクトル型](#経路ベクトル型)の[プロトコル](./network_architecture.md#プロトコル)で、[EGP](#egp)に分類される。\n\n[ISP](./network.md#isp)や地域[ネットワーク](./network.md#ネットワーク)などの組織を束ねる[ネットワーク](./network.md#ネットワーク)集団を1つの[自律システム](#自律システム)として扱い、それぞれの[自律システム](#自律システム)に16[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の**AS番号**を割り当てる。\n\nBGPにより[経路制御](./internet_layer.md#ルーティング)情報を交換する[ルータ](./network_architecture.md#ルータ)を**BGPスピーカ**という。目的とするネットワークアドレスに[パケット](./network.md#パケット)を送った場合に、そこに到達するまでのAS番号のリスト（**AS経路リスト**）が作られる。BGPの[メトリック](#メトリック)の単位は、通過する[AS](#自律システム)の数となる。\n\n\n"},{"term":"AS番号","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"bgp","content":"\n**BGP**は、組織間の[ネットワーク](./network.md#ネットワーク)を接続するときに利用される[経路ベクトル型](#経路ベクトル型)の[プロトコル](./network_architecture.md#プロトコル)で、[EGP](#egp)に分類される。\n\n[ISP](./network.md#isp)や地域[ネットワーク](./network.md#ネットワーク)などの組織を束ねる[ネットワーク](./network.md#ネットワーク)集団を1つの[自律システム](#自律システム)として扱い、それぞれの[自律システム](#自律システム)に16[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の**AS番号**を割り当てる。\n\nBGPにより[経路制御](./internet_layer.md#ルーティング)情報を交換する[ルータ](./network_architecture.md#ルータ)を**BGPスピーカ**という。目的とするネットワークアドレスに[パケット](./network.md#パケット)を送った場合に、そこに到達するまでのAS番号のリスト（**AS経路リスト**）が作られる。BGPの[メトリック](#メトリック)の単位は、通過する[AS](#自律システム)の数となる。\n\n\n"},{"term":"BGPスピーカ","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"bgp","content":"\n**BGP**は、組織間の[ネットワーク](./network.md#ネットワーク)を接続するときに利用される[経路ベクトル型](#経路ベクトル型)の[プロトコル](./network_architecture.md#プロトコル)で、[EGP](#egp)に分類される。\n\n[ISP](./network.md#isp)や地域[ネットワーク](./network.md#ネットワーク)などの組織を束ねる[ネットワーク](./network.md#ネットワーク)集団を1つの[自律システム](#自律システム)として扱い、それぞれの[自律システム](#自律システム)に16[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の**AS番号**を割り当てる。\n\nBGPにより[経路制御](./internet_layer.md#ルーティング)情報を交換する[ルータ](./network_architecture.md#ルータ)を**BGPスピーカ**という。目的とするネットワークアドレスに[パケット](./network.md#パケット)を送った場合に、そこに到達するまでのAS番号のリスト（**AS経路リスト**）が作られる。BGPの[メトリック](#メトリック)の単位は、通過する[AS](#自律システム)の数となる。\n\n\n"},{"term":"AS経路リスト","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"bgp","content":"\n**BGP**は、組織間の[ネットワーク](./network.md#ネットワーク)を接続するときに利用される[経路ベクトル型](#経路ベクトル型)の[プロトコル](./network_architecture.md#プロトコル)で、[EGP](#egp)に分類される。\n\n[ISP](./network.md#isp)や地域[ネットワーク](./network.md#ネットワーク)などの組織を束ねる[ネットワーク](./network.md#ネットワーク)集団を1つの[自律システム](#自律システム)として扱い、それぞれの[自律システム](#自律システム)に16[ビット](../../../basics/_/chapters/computer_and_number.md#ビット)の**AS番号**を割り当てる。\n\nBGPにより[経路制御](./internet_layer.md#ルーティング)情報を交換する[ルータ](./network_architecture.md#ルータ)を**BGPスピーカ**という。目的とするネットワークアドレスに[パケット](./network.md#パケット)を送った場合に、そこに到達するまでのAS番号のリスト（**AS経路リスト**）が作られる。BGPの[メトリック](#メトリック)の単位は、通過する[AS](#自律システム)の数となる。\n\n\n"},{"term":"MPLS","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"mpls","content":"\n**MPLS**は、代表的な[ラベルスイッチング](#ラベルスイッチング)機能。\n\n"},{"term":"ラベルスイッチング","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ラベルスイッチング","content":"\n**ラベルスイッチング**は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)に**ラベル**を設定し、そのラベルに基づいて転送を行う技術。\n\nラベルをつけてフォワーディングする**Push**、ラベルを付け替えてフォワーディングする**Swap**、ラベルを外してフォワーディングする**Pop**を基本動作とする。\n\n宛先が同じである[パケット](./network.md#パケット)(**FFC**: Forwarding Equivalence Class)は、どれもラベルによって決まる同一の経路を通る。この経路を**LSP**(Label Switching Path)という。\n\n"},{"term":"ラベル","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ラベルスイッチング","content":"\n**ラベルスイッチング**は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)に**ラベル**を設定し、そのラベルに基づいて転送を行う技術。\n\nラベルをつけてフォワーディングする**Push**、ラベルを付け替えてフォワーディングする**Swap**、ラベルを外してフォワーディングする**Pop**を基本動作とする。\n\n宛先が同じである[パケット](./network.md#パケット)(**FFC**: Forwarding Equivalence Class)は、どれもラベルによって決まる同一の経路を通る。この経路を**LSP**(Label Switching Path)という。\n\n"},{"term":"Push","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ラベルスイッチング","content":"\n**ラベルスイッチング**は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)に**ラベル**を設定し、そのラベルに基づいて転送を行う技術。\n\nラベルをつけてフォワーディングする**Push**、ラベルを付け替えてフォワーディングする**Swap**、ラベルを外してフォワーディングする**Pop**を基本動作とする。\n\n宛先が同じである[パケット](./network.md#パケット)(**FFC**: Forwarding Equivalence Class)は、どれもラベルによって決まる同一の経路を通る。この経路を**LSP**(Label Switching Path)という。\n\n"},{"term":"Swap","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ラベルスイッチング","content":"\n**ラベルスイッチング**は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)に**ラベル**を設定し、そのラベルに基づいて転送を行う技術。\n\nラベルをつけてフォワーディングする**Push**、ラベルを付け替えてフォワーディングする**Swap**、ラベルを外してフォワーディングする**Pop**を基本動作とする。\n\n宛先が同じである[パケット](./network.md#パケット)(**FFC**: Forwarding Equivalence Class)は、どれもラベルによって決まる同一の経路を通る。この経路を**LSP**(Label Switching Path)という。\n\n"},{"term":"Pop","link":"./note/ja/./network/_/chapters/routing_protocol.md","flagment":"ラベルスイッチング","content":"\n**ラベルスイッチング**は、[IP](./internet_layer.md#ip)[パケット](./network.md#パケット)に**ラベル**を設定し、そのラベルに基づいて転送を行う技術。\n\nラベルをつけてフォワーディングする**Push**、ラベルを付け替えてフォワーディングする**Swap**、ラベルを外してフォワーディングする**Pop**を基本動作とする。\n\n宛先が同じである[パケット](./network.md#パケット)(**FFC**: Forwarding Equivalence Class)は、どれもラベルによって決まる同一の経路を通る。この経路を**LSP**(Label Switching Path)という。\n\n"},{"term":"リージョン","link":"./note/ja/./network/aws/_/chapters/aws.md","flagment":"リージョン","content":"\n**リージョン**は、[AWS](#aws)の[データセンタ](../../../_/chapters/network.md#データセンタ)が設置されている地域。[AWS](#aws)は世界各国に多数のリージョンを保有している。各地域のリージョンは相互に高速回線で接続されている。\n\n"},{"term":"AZ（アベイラビリティゾーン、ゾーン）","link":"./note/ja/./network/aws/_/chapters/aws.md","flagment":"az","content":"\n**AZ**（**アベイラビリティゾーン**、**ゾーン**）は、1つの[リージョン](#リージョン)内で物理的に切り離された、冗長的な設備を備えた[データセンタ](../../../_/chapters/network.md#データセンタ)。1つの[リージョン](#リージョン)内には必ず複数のAZが用意されており、自然災害などでひとつのAZが機能停止に陥ったとしても、他のAZを利用しているサービスは引き続き運用することができる。\n\n"},{"term":"マルチAZ","link":"./note/ja/./network/aws/_/chapters/aws.md","flagment":"マルチaz","content":"\n**マルチAZ**は、[システム](../../../../system/_/chapters/system.md#システム)のインフラを構築する際に、同じ役割を持った[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を複数の[AZ](#az)に用意することで[冗長化](../../../../system/_/chapters/system_architecture.md#冗長化)する手法。マルチAZ構成を意識することで、高い[耐障害性](../../../../system/_/chapters/reliability_design.md#フォールトトレランス)や[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)を実現できる。\n"},{"term":"Amazon Kinesis","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"kinesis","content":"\n**Amazon Kinesis**は、[AWS](./aws.md#aws)が提供する[ストリーミング](../../../../computer/software/_/chapters/multimedia.md#ストリーミング)処理[プラットフォーム](../../../../computer/software/_/chapters/software.md#プラットフォーム)。センサやログなどのデータを、リアルタイム/準リアルタイムで処理するData StreamsとData Firehose、動画を処理するVideo Streams、収集したデータを可視化・分析するData Analyticsといった機能がある。\n\n\n"},{"term":"Data Streams","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"kinesis","content":"\n**Amazon Kinesis**は、[AWS](./aws.md#aws)が提供する[ストリーミング](../../../../computer/software/_/chapters/multimedia.md#ストリーミング)処理[プラットフォーム](../../../../computer/software/_/chapters/software.md#プラットフォーム)。センサやログなどのデータを、リアルタイム/準リアルタイムで処理するData StreamsとData Firehose、動画を処理するVideo Streams、収集したデータを可視化・分析するData Analyticsといった機能がある。\n\n\n"},{"term":"Data Firehose","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"kinesis","content":"\n**Amazon Kinesis**は、[AWS](./aws.md#aws)が提供する[ストリーミング](../../../../computer/software/_/chapters/multimedia.md#ストリーミング)処理[プラットフォーム](../../../../computer/software/_/chapters/software.md#プラットフォーム)。センサやログなどのデータを、リアルタイム/準リアルタイムで処理するData StreamsとData Firehose、動画を処理するVideo Streams、収集したデータを可視化・分析するData Analyticsといった機能がある。\n\n\n"},{"term":"Video Streams","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"kinesis","content":"\n**Amazon Kinesis**は、[AWS](./aws.md#aws)が提供する[ストリーミング](../../../../computer/software/_/chapters/multimedia.md#ストリーミング)処理[プラットフォーム](../../../../computer/software/_/chapters/software.md#プラットフォーム)。センサやログなどのデータを、リアルタイム/準リアルタイムで処理するData StreamsとData Firehose、動画を処理するVideo Streams、収集したデータを可視化・分析するData Analyticsといった機能がある。\n\n\n"},{"term":"Data Analytics","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"kinesis","content":"\n**Amazon Kinesis**は、[AWS](./aws.md#aws)が提供する[ストリーミング](../../../../computer/software/_/chapters/multimedia.md#ストリーミング)処理[プラットフォーム](../../../../computer/software/_/chapters/software.md#プラットフォーム)。センサやログなどのデータを、リアルタイム/準リアルタイムで処理するData StreamsとData Firehose、動画を処理するVideo Streams、収集したデータを可視化・分析するData Analyticsといった機能がある。\n\n\n"},{"term":"AWS Data Pipeline","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"data-pipeline","content":""},{"term":"AWS Glue","link":"./note/ja/./network/aws/_/chapters/analytics.md","flagment":"glue","content":"\n**AWS Glue**は、データレイクやデータウェアハウスとセットで使われることが多い、サーバレス型のELTツール。ビッグデータの解析などに使われることが多く、[S3](./storage.md#s3)のデータを管理して[Redshift](./database.md#redshift)などに変換して格納するといった用途によく利用される。\n\nデータソースのデータを探索するクローラ機能と、それをメタデータとして管理するデータカタログ機能がある。また、データの変換はジョブという単位で管理され、変換処理はPythonやSparkによって自分で実装することができる。\n"},{"term":"インスタンス","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ec2","content":"\n**EC2**(**Amazon Elastic Compute Cloud**)は、仮想[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を提供するコンピューティングサービス。[AMI](#ami)を元にして容易に新しい[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を構築することができ、**インスタンス**という単位で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が管理される。インスタンスには起動中(**Running**)、停止中(**Stopped**)、削除済み(**Terminated**)の3つの状態がある。\n\nEC2は**従量課金型**のサービスで、[インスタンスタイプ](#インスタンスタイプ)や[リージョン](./aws.md#リージョン)と、インスタンスがRunning状態だった時間でコストが決まる。\n\n"},{"term":"Running","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ec2","content":"\n**EC2**(**Amazon Elastic Compute Cloud**)は、仮想[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を提供するコンピューティングサービス。[AMI](#ami)を元にして容易に新しい[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を構築することができ、**インスタンス**という単位で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が管理される。インスタンスには起動中(**Running**)、停止中(**Stopped**)、削除済み(**Terminated**)の3つの状態がある。\n\nEC2は**従量課金型**のサービスで、[インスタンスタイプ](#インスタンスタイプ)や[リージョン](./aws.md#リージョン)と、インスタンスがRunning状態だった時間でコストが決まる。\n\n"},{"term":"Stopped","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ec2","content":"\n**EC2**(**Amazon Elastic Compute Cloud**)は、仮想[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を提供するコンピューティングサービス。[AMI](#ami)を元にして容易に新しい[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を構築することができ、**インスタンス**という単位で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が管理される。インスタンスには起動中(**Running**)、停止中(**Stopped**)、削除済み(**Terminated**)の3つの状態がある。\n\nEC2は**従量課金型**のサービスで、[インスタンスタイプ](#インスタンスタイプ)や[リージョン](./aws.md#リージョン)と、インスタンスがRunning状態だった時間でコストが決まる。\n\n"},{"term":"Terminated","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ec2","content":"\n**EC2**(**Amazon Elastic Compute Cloud**)は、仮想[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を提供するコンピューティングサービス。[AMI](#ami)を元にして容易に新しい[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を構築することができ、**インスタンス**という単位で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が管理される。インスタンスには起動中(**Running**)、停止中(**Stopped**)、削除済み(**Terminated**)の3つの状態がある。\n\nEC2は**従量課金型**のサービスで、[インスタンスタイプ](#インスタンスタイプ)や[リージョン](./aws.md#リージョン)と、インスタンスがRunning状態だった時間でコストが決まる。\n\n"},{"term":"従量課金型","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ec2","content":"\n**EC2**(**Amazon Elastic Compute Cloud**)は、仮想[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を提供するコンピューティングサービス。[AMI](#ami)を元にして容易に新しい[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)を構築することができ、**インスタンス**という単位で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が管理される。インスタンスには起動中(**Running**)、停止中(**Stopped**)、削除済み(**Terminated**)の3つの状態がある。\n\nEC2は**従量課金型**のサービスで、[インスタンスタイプ](#インスタンスタイプ)や[リージョン](./aws.md#リージョン)と、インスタンスがRunning状態だった時間でコストが決まる。\n\n"},{"term":"インスタンスタイプ","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスタイプ","content":"\n**インスタンスタイプ**は、[EC2インスタンス](#ec2)の性能を決定するもので、様々なユースケースに対応した[CPU](../../../../computer/hardware/_/chapters/processor.md#cpu)や[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)、[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)、[ネットワーク](../../../_/chapters/network.md#ネットワーク)キャパシティの組み合わせが用意されている。\n\n[インスタンス](#ec2)が何に最適化されているかを表す[インスタンスファミリー](#インスタンスファミリー)、そのインスタンスの**世代**、 `medium` や `xlarge` といった**インスタンスサイズ**の組み合わせで表現される。\n\n"},{"term":"インスタンスファミリー","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"汎用","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"コンピューティング最適化","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"メモリ最適化","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"高速コンピューティング","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"ストレージ最適化","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスファミリー","content":"\n**インスタンスファミリー**は、その[インスタンス](#ec2)が何に最適化された[インスタンス](#ec2)であるかという分類を表し、[インスタンスタイプ](#インスタンスタイプ)の先頭に付与される。\n\n| 種類                     | 特徴                                     | ファミリー       |\n|--------------------------|------------------------------------------|------------------|\n| 汎用                     | バランスの取れた汎用タイプで、比較的安価 | `T/M/A/Mac`      |\n| コンピューティング最適化 | 高い計算能力                             | `C`              |\n| メモリ最適化             | メモリを多く搭載                         | `R/X/z`          |\n| 高速コンピューティング   | グラフィック演算や推論処理などに最適化   | `P/DL/G/F/V/Inf` |\n| ストレージ最適化         | I/Oパフォーマンスが高く、大容量          | `I/D/H`          |\n\n"},{"term":"世代","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスタイプ","content":"\n**インスタンスタイプ**は、[EC2インスタンス](#ec2)の性能を決定するもので、様々なユースケースに対応した[CPU](../../../../computer/hardware/_/chapters/processor.md#cpu)や[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)、[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)、[ネットワーク](../../../_/chapters/network.md#ネットワーク)キャパシティの組み合わせが用意されている。\n\n[インスタンス](#ec2)が何に最適化されているかを表す[インスタンスファミリー](#インスタンスファミリー)、そのインスタンスの**世代**、 `medium` や `xlarge` といった**インスタンスサイズ**の組み合わせで表現される。\n\n"},{"term":"インスタンスサイズ","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"インスタンスタイプ","content":"\n**インスタンスタイプ**は、[EC2インスタンス](#ec2)の性能を決定するもので、様々なユースケースに対応した[CPU](../../../../computer/hardware/_/chapters/processor.md#cpu)や[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)、[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)、[ネットワーク](../../../_/chapters/network.md#ネットワーク)キャパシティの組み合わせが用意されている。\n\n[インスタンス](#ec2)が何に最適化されているかを表す[インスタンスファミリー](#インスタンスファミリー)、そのインスタンスの**世代**、 `medium` や `xlarge` といった**インスタンスサイズ**の組み合わせで表現される。\n\n"},{"term":"スポットインスタンス","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"スポットインスタンス","content":"\n**スポットインスタンス**は、[AWS](./aws.md#aws)が余らせている[EC2](#ec2)リソースを入札形式で安く利用する形式。ただし、他の利用者からの利用リクエストが増えて余剰なリソースがなくなってしまうと、自動的に[インスタンス](#ec2)が中断される。開発用や学習用に相性のよいオプションといえる。\n\n"},{"term":"リザーブドインスタンス","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"リザーブドインスタンス","content":"\n**リザーブドインスタンス**は、長期間利用することを約束することで割引を受けられるオプション。[インスタンスタイプ](#インスタンスタイプ)を固定してしまうことになるので、サービスのリリース後、安定してきてから購入することを検討するのがよい。\n\n"},{"term":"EBS最適化オプション","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ebs最適化オプション","content":"\n**EBS最適化オプション**は、通常の[ネットワーク](../../../_/chapters/network.md#ネットワーク)[帯域](../../../_/chapters/network.md#帯域)とは別に、[EBS](./storage.md#ebs)用の[帯域](../../../_/chapters/network.md#帯域)を確保する[EC2インスタンス](#ec2)のオプション。[EBS](./storage.md#ebs)は[AWS](./aws.md#aws)のディスク機能であり、ディスクIOが頻繁な[システム](../../../../system/_/chapters/system.md#システム)ではこのオプションを有効にすることで[帯域](../../../_/chapters/network.md#帯域)が足りなくなることを防げる。\n\n\n"},{"term":"Auto Scaling","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ebsauto-scaling","content":""},{"term":"スケーリングポリシー","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"スケーリングポリシー","content":"\n**スケーリングポリシー**は、[Auto Scaling](#auto-scaling)による自動スケーリングを行う際の方針。スケーリングポリシーには、動的なスケーリング、予測スケーリング、スケジュールスケーリングなどがあり、動的なスケーリングのポリシーは更に以下のように分けられる。\n\n- **簡易スケーリング** : 「CPU使用率が70%を超えたらスケールアウトする」といったように、1つのメトリクスに対して1つの閾値を設定してスケーリングを行う。\n- **ステップスケーリング** : 1つのメトリクスに対して複数の閾値を設定することで、段階的にスケーリングの設定を行う。\n- **ターゲット追跡スケーリング** : 1つのメトリクスに目標値を設定しておき、そのメトリクスを維持できるように動的にスケーリングする。\n\n"},{"term":"簡易スケーリング","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"スケーリングポリシー","content":"\n**スケーリングポリシー**は、[Auto Scaling](#auto-scaling)による自動スケーリングを行う際の方針。スケーリングポリシーには、動的なスケーリング、予測スケーリング、スケジュールスケーリングなどがあり、動的なスケーリングのポリシーは更に以下のように分けられる。\n\n- **簡易スケーリング** : 「CPU使用率が70%を超えたらスケールアウトする」といったように、1つのメトリクスに対して1つの閾値を設定してスケーリングを行う。\n- **ステップスケーリング** : 1つのメトリクスに対して複数の閾値を設定することで、段階的にスケーリングの設定を行う。\n- **ターゲット追跡スケーリング** : 1つのメトリクスに目標値を設定しておき、そのメトリクスを維持できるように動的にスケーリングする。\n\n"},{"term":"ステップスケーリング","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"スケーリングポリシー","content":"\n**スケーリングポリシー**は、[Auto Scaling](#auto-scaling)による自動スケーリングを行う際の方針。スケーリングポリシーには、動的なスケーリング、予測スケーリング、スケジュールスケーリングなどがあり、動的なスケーリングのポリシーは更に以下のように分けられる。\n\n- **簡易スケーリング** : 「CPU使用率が70%を超えたらスケールアウトする」といったように、1つのメトリクスに対して1つの閾値を設定してスケーリングを行う。\n- **ステップスケーリング** : 1つのメトリクスに対して複数の閾値を設定することで、段階的にスケーリングの設定を行う。\n- **ターゲット追跡スケーリング** : 1つのメトリクスに目標値を設定しておき、そのメトリクスを維持できるように動的にスケーリングする。\n\n"},{"term":"ターゲット追跡スケーリング","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"スケーリングポリシー","content":"\n**スケーリングポリシー**は、[Auto Scaling](#auto-scaling)による自動スケーリングを行う際の方針。スケーリングポリシーには、動的なスケーリング、予測スケーリング、スケジュールスケーリングなどがあり、動的なスケーリングのポリシーは更に以下のように分けられる。\n\n- **簡易スケーリング** : 「CPU使用率が70%を超えたらスケールアウトする」といったように、1つのメトリクスに対して1つの閾値を設定してスケーリングを行う。\n- **ステップスケーリング** : 1つのメトリクスに対して複数の閾値を設定することで、段階的にスケーリングの設定を行う。\n- **ターゲット追跡スケーリング** : 1つのメトリクスに目標値を設定しておき、そのメトリクスを維持できるように動的にスケーリングする。\n\n"},{"term":"猶予期間","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"猶予期間","content":"\n**猶予期間**は、[Auto Scaling](#auto-scaling)の[スケールアウト](../../../../system/_/chapters/system_performance_evaluation.md#スケールアウト)中に[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)を停止する機能。[スケールアウト](../../../../system/_/chapters/system_performance_evaluation.md#スケールアウト)による新しい[インスタンス](#ec2)の起動中に、別の新たな[インスタンス](#ec2)が起動されてしまうことを防ぐための仕組み。\n\n"},{"term":"ウォームアップ","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ウォームアップ","content":"\n**ウォームアップ**は、新しい[インスタンス](#ec2)がサービスを開始してからトラフィックを受信できるまでの期間を設定しておき、その期間中に別の[スケーリングポリシー](#スケーリングポリシー)が適用される場合は2つのポリシーの差分のみが起動されるようにする機能。\n\n[ステップスケーリング](#スケーリングポリシー)において、1つ目の[スケーリングポリシー](#スケーリングポリシー)によって[インスタンス](#ec2)が起動している途中で2つ目の[スケーリングポリシー](#スケーリングポリシー)によって更に[インスタンス](#インスタンス)が追加されるということが考えられる。例えば、1つ目の[スケーリングポリシー](#スケーリングポリシー)で[インスタンス](#ec2)が1台、2つ目の[スケーリングポリシー](#スケーリングポリシー)で[インスタンス](#ec2)が4台増える設定の場合、これらのポリシーが連続で適用された場合には5台の[インスタンス](#ec2)が起動される。しかし、最新の負荷状況を考えると、2つ目のポリシーのみを適用して4台の[インスタンス](#ec2)を起動したい。これを防ぐために、ウォームアップの機能を利用する。\n\n"},{"term":"クールダウン","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"クールダウン","content":"\n**クールダウン**は、[インスタンス](#ec2)の起動指示直後に待ち時間を設けることで、複数のアラートがきても次々に[インスタンス](#ec2)が立ち上がることを防ぐ機能。\n\n[Auto Scaling](#auto-scaling)により新しい[インスタンス](#ec2)が起動された直後、ブートストラップなどの処理によって準備が整うまでに数分かかる場合があり、準備が整うまでの間に新しいアラートがくると連鎖的に複数の[インスタンス](#ec2)が起動されてしまう。これを防ぐために、クールダウンの機能を利用する。\n\n"},{"term":"ライフサイクルフック","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ライフサイクルフック","content":"\n**ライフサイクルフック**は、[Auto Scaling](#auto-scaling)による[インスタンス](#ec2)の起動・削除時に、[インスタンス](#ec2)を一時停止してカスタムアクションを実行する機能。[インスタンス](#ec2)の削除時のログやデータの退避などに利用される。\n\n"},{"term":"終了ポリシー","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"終了ポリシー","content":"\n**終了ポリシー**は、負荷が下がったときに[インスタンス](#ec2)を減らす（[スケールイン](../../../../system/_/chapters/system_performance_evaluation.md#スケールイン)）設定。\n\n\n"},{"term":"Task","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ecs","content":"\n**ECS**(**Amazon Elastic Container Service**)は、[Docker](../../../../development/docker/_/chapters/docker.md#docker)[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)環境を提供するサービス。[EC2](#ec2)に[Docker](../../../../development/docker/_/chapters/docker.md#docker)[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の導入作業や継続したメンテナンス作業などを加えたもので、その管理を[AWS](./aws.md#aws)がサポートしてくれる。\n\n[EC2インスタンス](#ec2)上で実行される[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)のことを**Task**と呼び、[EC2インスタンス](#ec2)のことを**Cluster**と呼ぶ。1つのCluster上では複数のTaskを実行することができる。Cluster上で動作するTaskの定義は**Task Definition**で行う。**Service**は1つ以上の同じTaskをまとめたもので、[ELB](./networking_and_content_delivery.md#elb)によって負荷分散をする際には、[EC2](#ec2)の代わりにServiceを指定する。\n\nまた、セキュリティ面では、Taskごとに[IAMロール](./security_and_identity.md#iamロール)を割り当てられるという特徴がある。[EC2](#ec2)では[インスタンス](#ec2)単位でしか設定できない。\n\n\n"},{"term":"Cluster","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ecs","content":"\n**ECS**(**Amazon Elastic Container Service**)は、[Docker](../../../../development/docker/_/chapters/docker.md#docker)[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)環境を提供するサービス。[EC2](#ec2)に[Docker](../../../../development/docker/_/chapters/docker.md#docker)[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の導入作業や継続したメンテナンス作業などを加えたもので、その管理を[AWS](./aws.md#aws)がサポートしてくれる。\n\n[EC2インスタンス](#ec2)上で実行される[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)のことを**Task**と呼び、[EC2インスタンス](#ec2)のことを**Cluster**と呼ぶ。1つのCluster上では複数のTaskを実行することができる。Cluster上で動作するTaskの定義は**Task Definition**で行う。**Service**は1つ以上の同じTaskをまとめたもので、[ELB](./networking_and_content_delivery.md#elb)によって負荷分散をする際には、[EC2](#ec2)の代わりにServiceを指定する。\n\nまた、セキュリティ面では、Taskごとに[IAMロール](./security_and_identity.md#iamロール)を割り当てられるという特徴がある。[EC2](#ec2)では[インスタンス](#ec2)単位でしか設定できない。\n\n\n"},{"term":"Service","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ecs","content":"\n**ECS**(**Amazon Elastic Container Service**)は、[Docker](../../../../development/docker/_/chapters/docker.md#docker)[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)環境を提供するサービス。[EC2](#ec2)に[Docker](../../../../development/docker/_/chapters/docker.md#docker)[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の導入作業や継続したメンテナンス作業などを加えたもので、その管理を[AWS](./aws.md#aws)がサポートしてくれる。\n\n[EC2インスタンス](#ec2)上で実行される[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)のことを**Task**と呼び、[EC2インスタンス](#ec2)のことを**Cluster**と呼ぶ。1つのCluster上では複数のTaskを実行することができる。Cluster上で動作するTaskの定義は**Task Definition**で行う。**Service**は1つ以上の同じTaskをまとめたもので、[ELB](./networking_and_content_delivery.md#elb)によって負荷分散をする際には、[EC2](#ec2)の代わりにServiceを指定する。\n\nまた、セキュリティ面では、Taskごとに[IAMロール](./security_and_identity.md#iamロール)を割り当てられるという特徴がある。[EC2](#ec2)では[インスタンス](#ec2)単位でしか設定できない。\n\n\n"},{"term":"Task Definition","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"ecs","content":"\n**ECS**(**Amazon Elastic Container Service**)は、[Docker](../../../../development/docker/_/chapters/docker.md#docker)[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)環境を提供するサービス。[EC2](#ec2)に[Docker](../../../../development/docker/_/chapters/docker.md#docker)[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の導入作業や継続したメンテナンス作業などを加えたもので、その管理を[AWS](./aws.md#aws)がサポートしてくれる。\n\n[EC2インスタンス](#ec2)上で実行される[コンテナ](../../../../development/docker/_/chapters/container.md#コンテナ)のことを**Task**と呼び、[EC2インスタンス](#ec2)のことを**Cluster**と呼ぶ。1つのCluster上では複数のTaskを実行することができる。Cluster上で動作するTaskの定義は**Task Definition**で行う。**Service**は1つ以上の同じTaskをまとめたもので、[ELB](./networking_and_content_delivery.md#elb)によって負荷分散をする際には、[EC2](#ec2)の代わりにServiceを指定する。\n\nまた、セキュリティ面では、Taskごとに[IAMロール](./security_and_identity.md#iamロール)を割り当てられるという特徴がある。[EC2](#ec2)では[インスタンス](#ec2)単位でしか設定できない。\n\n\n"},{"term":"AWS Lambda","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"lambda","content":"\n**AWS Lambda**は、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をプロビジョニングしなくても[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行できるコンピューティングサービスで、サーバレスアーキテクチャの中核を担う。利用者は[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)だけを用意すればすぐに[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が実行できる。LambdaはNode.jsや[Python](../../../../programming/_/chapters/programming_language.md#python)、[Java](../../../../programming/_/chapters/programming_language.md#java)、Ruby、[C#](../../../../programming/_/chapters/programming_language.md#c-1)、[Go](../../../../programming/_/chapters/programming_language.md#go)、Powershellといった多数の言語に対応している。\n\nLambdaは**Lambda関数**という単位で、実行する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)とその実行トリガーとなるイベントを事前に定義する。Lambda関数を実行することを、**キック**という。\n\n\n"},{"term":"Lambda関数","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"lambda","content":"\n**AWS Lambda**は、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をプロビジョニングしなくても[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行できるコンピューティングサービスで、サーバレスアーキテクチャの中核を担う。利用者は[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)だけを用意すればすぐに[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が実行できる。LambdaはNode.jsや[Python](../../../../programming/_/chapters/programming_language.md#python)、[Java](../../../../programming/_/chapters/programming_language.md#java)、Ruby、[C#](../../../../programming/_/chapters/programming_language.md#c-1)、[Go](../../../../programming/_/chapters/programming_language.md#go)、Powershellといった多数の言語に対応している。\n\nLambdaは**Lambda関数**という単位で、実行する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)とその実行トリガーとなるイベントを事前に定義する。Lambda関数を実行することを、**キック**という。\n\n\n"},{"term":"キック","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"lambda","content":"\n**AWS Lambda**は、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をプロビジョニングしなくても[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行できるコンピューティングサービスで、サーバレスアーキテクチャの中核を担う。利用者は[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)だけを用意すればすぐに[プログラム](../../../../programming/_/chapters/programming.md#プログラム)が実行できる。LambdaはNode.jsや[Python](../../../../programming/_/chapters/programming_language.md#python)、[Java](../../../../programming/_/chapters/programming_language.md#java)、Ruby、[C#](../../../../programming/_/chapters/programming_language.md#c-1)、[Go](../../../../programming/_/chapters/programming_language.md#go)、Powershellといった多数の言語に対応している。\n\nLambdaは**Lambda関数**という単位で、実行する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)とその実行トリガーとなるイベントを事前に定義する。Lambda関数を実行することを、**キック**という。\n\n\n"},{"term":"Elastic Beanstalk","link":"./note/ja/./network/aws/_/chapters/computing.md","flagment":"elastic-beanstalk","content":""},{"term":"Amazon Aurora","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"aurora","content":"\n**Amazon Aurora**は、[AWS](./aws.md#aws)が開発したデータベースエンジンで、[RDS](#rds)の利用時に選択することができる。DBインスタンスを作成すると同時にDBクラスタが作成される。DBクラスタは、1つ以上のDBインスタンスと、各DBインスタンスから参照するデータ[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)（クラスタボリューム）で構成される。クラスタボリュームは単一の[リージョン](./aws.md#リージョン)内の3つの[AZ](./aws.md#az)にそれぞれ2つのデータコピーで構成され、各[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)間のデータは自動的に同期される。\n\n**Auroraレプリカ**は通常の[リードレプリカ](#リードレプリカ)と違い、Auroraのプライマリインスタンスに障害が発生した場合にレプリカインスタンスがプライマリインスタンスに昇格することで[フェールオーバ](../../../../system/_/chapters/reliability_design.md#フェールオーバ)を実現する。\n\n"},{"term":"Auroraレプリカ","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"aurora","content":"\n**Amazon Aurora**は、[AWS](./aws.md#aws)が開発したデータベースエンジンで、[RDS](#rds)の利用時に選択することができる。DBインスタンスを作成すると同時にDBクラスタが作成される。DBクラスタは、1つ以上のDBインスタンスと、各DBインスタンスから参照するデータ[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)（クラスタボリューム）で構成される。クラスタボリュームは単一の[リージョン](./aws.md#リージョン)内の3つの[AZ](./aws.md#az)にそれぞれ2つのデータコピーで構成され、各[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)間のデータは自動的に同期される。\n\n**Auroraレプリカ**は通常の[リードレプリカ](#リードレプリカ)と違い、Auroraのプライマリインスタンスに障害が発生した場合にレプリカインスタンスがプライマリインスタンスに昇格することで[フェールオーバ](../../../../system/_/chapters/reliability_design.md#フェールオーバ)を実現する。\n\n"},{"term":"リードレプリカ","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"リードレプリカ","content":"\n**リードレプリカ**は、通常の[RDS](#rds)とは別に参照専用のDBインスタンスを作成するサービス。マスタDBの負荷を抑えたり、読み込みが多い[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)におけるDBリソースの[スケールアウト](../../../../system/_/chapters/system_performance_evaluation.md#スケールアウト)を容易に実現することが可能となる。\n\nマスタとリードレプリカのデータ同期は**非同期レプリケーション方式**であるため、参照されるタイミングによってはマスタ側で更新された情報が反映されていない可能性があることに注意が必要。\n\n"},{"term":"非同期レプリケーション方式","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"リードレプリカ","content":"\n**リードレプリカ**は、通常の[RDS](#rds)とは別に参照専用のDBインスタンスを作成するサービス。マスタDBの負荷を抑えたり、読み込みが多い[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)におけるDBリソースの[スケールアウト](../../../../system/_/chapters/system_performance_evaluation.md#スケールアウト)を容易に実現することが可能となる。\n\nマスタとリードレプリカのデータ同期は**非同期レプリケーション方式**であるため、参照されるタイミングによってはマスタ側で更新された情報が反映されていない可能性があることに注意が必要。\n\n"},{"term":"自動バックアップ","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"バックアップとリストア","content":"\n**自動バックアップ**は、バックアップウィンドウと保持期間を指定することで、1日1回自動的にバックアップ（DBスナップショット）を取得してくれるサービス。\n\n**手動スナップショット**は、任意のタイミングで[RDB](../../../../development/database/_/chapters/database.md#リレーショナルデータベース)のバックアップを取得できるサービス。\n\nデータの**リストア**は、スナップショットから新規の[RDS](#rds)を作成することで簡単に実現できる。\n\n**ポイントインタイムリカバリ**は、自動バックアップのスナップショットを利用して、任意のタイミングの状態の[RDS](#rds)を新規に作成することができるサービス。\n\n"},{"term":"手動スナップショット","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"バックアップとリストア","content":"\n**自動バックアップ**は、バックアップウィンドウと保持期間を指定することで、1日1回自動的にバックアップ（DBスナップショット）を取得してくれるサービス。\n\n**手動スナップショット**は、任意のタイミングで[RDB](../../../../development/database/_/chapters/database.md#リレーショナルデータベース)のバックアップを取得できるサービス。\n\nデータの**リストア**は、スナップショットから新規の[RDS](#rds)を作成することで簡単に実現できる。\n\n**ポイントインタイムリカバリ**は、自動バックアップのスナップショットを利用して、任意のタイミングの状態の[RDS](#rds)を新規に作成することができるサービス。\n\n"},{"term":"リストア","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"バックアップとリストア","content":"\n**自動バックアップ**は、バックアップウィンドウと保持期間を指定することで、1日1回自動的にバックアップ（DBスナップショット）を取得してくれるサービス。\n\n**手動スナップショット**は、任意のタイミングで[RDB](../../../../development/database/_/chapters/database.md#リレーショナルデータベース)のバックアップを取得できるサービス。\n\nデータの**リストア**は、スナップショットから新規の[RDS](#rds)を作成することで簡単に実現できる。\n\n**ポイントインタイムリカバリ**は、自動バックアップのスナップショットを利用して、任意のタイミングの状態の[RDS](#rds)を新規に作成することができるサービス。\n\n"},{"term":"ポイントインタイムリカバリ","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"バックアップとリストア","content":"\n**自動バックアップ**は、バックアップウィンドウと保持期間を指定することで、1日1回自動的にバックアップ（DBスナップショット）を取得してくれるサービス。\n\n**手動スナップショット**は、任意のタイミングで[RDB](../../../../development/database/_/chapters/database.md#リレーショナルデータベース)のバックアップを取得できるサービス。\n\nデータの**リストア**は、スナップショットから新規の[RDS](#rds)を作成することで簡単に実現できる。\n\n**ポイントインタイムリカバリ**は、自動バックアップのスナップショットを利用して、任意のタイミングの状態の[RDS](#rds)を新規に作成することができるサービス。\n\n"},{"term":"暗号化オプション","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"バックアップとリストア","content":"\n**自動バックアップ**は、バックアップウィンドウと保持期間を指定することで、1日1回自動的にバックアップ（DBスナップショット）を取得してくれるサービス。\n\n**手動スナップショット**は、任意のタイミングで[RDB](../../../../development/database/_/chapters/database.md#リレーショナルデータベース)のバックアップを取得できるサービス。\n\nデータの**リストア**は、スナップショットから新規の[RDS](#rds)を作成することで簡単に実現できる。\n\n**ポイントインタイムリカバリ**は、自動バックアップのスナップショットを利用して、任意のタイミングの状態の[RDS](#rds)を新規に作成することができるサービス。\n\n"},{"term":"Amazon DynamoDB","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"dynamodb","content":"\n**Amazon DynamoDB**は、[AWS](./aws.md#aws)が提供するKey-Value型のマネージド[NoSQLデータベース](../../../../development/database/_/chapters/database.md#nosqlデータベース)サービス。[テーブル](../../../../development/database/_/chapters/rdb.md#テーブル)や[インデックス](../../../../development/database/_/chapters/index.md#インデックス)を作成する際に、読み取り・書き込みに必要な[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)を指定してリソースを確保することで、安定した性能を担保する仕組み。[トランザクション](../../../../development/database/_/chapters/transaction.md#トランザクション)機能にも対応している。\n\n以下のようなシステムに適している。\n\n- 高い信頼性と拡張性を必要とする[システム](../../../../system/_/chapters/system.md#システム)\n- [スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)が増減するようなピーク帯のある[システム](../../../../system/_/chapters/system.md#システム)\n- 大量のデータを蓄積して高速な検索が可能な[システム](../../../../system/_/chapters/system.md#システム)\n- 広告やゲームなどのユーザの行動履歴を管理する[システム](../../../../system/_/chapters/system.md#システム)\n- [Web](../../../_/chapters/web.md#web)[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の永続的セッションデータベース\n\n"},{"term":"パーティション","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"データパーティショニング","content":"\nDynamoDBはデータを**パーティション**という単位で分散保存する。1つのパーティションに保存できる容量や[スループットキャパシティ](#スループットキャパシティ)が決まっているため、データの増加や指定した[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)のサイズによって最適化された状態を保つように自動的にパーティションを拡張する。\n\n"},{"term":"DynamoDB Streams","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"dynamodb-streams","content":""},{"term":"Consistent Read","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"consistent-read","content":""},{"term":"Amazon ElastiCache","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"elasticache","content":"\n**Amazon ElastiCache**は、[AWS](./aws.md#aws)が提供するインメモリ型データベースサービス。高頻度で参照するデータや検索に時間がかかるデータセットを[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)上に保持することでパフォーマンスを向上させる。\n\n"},{"term":"Memcached","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"memcached","content":"\n**Memcached**は、KVS（Key-Valueストア）型インメモリデータベースのデファクトスタンダードとして広く利用されているエンジン。データの永続性機能はないため、メンテナンスや障害による再起動時にすべてのデータが消去される。\n\n"},{"term":"Redis","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redis","content":"\n**Redis**は、KVS型インメモリデータベースで、[Memcached](#memcached)よりも多くのデータが扱え、キャッシュ用としてだけではなくメッセージブローカーやキューを構成する要素としても利用される。ノード間のレプリケーション機能やデータ永続性機能といった可用性も考慮された機能が実装されている。\n\n\n"},{"term":"Amazon Redshift","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redshift","content":"\n**Amazon Redshift**は、[AWS](./aws.md#aws)が提供するデータウェアハウス（データの分析に最適化された[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)）向けの[データベース](../../../../development/database/_/chapters/database.md#データベース)サービス。大量のデータから意思決定に役立つ情報を見つけ出すために必要な環境を安価で準備できる。\n\nRedshiftは、複数ノードによる分散並列実行が大きな特徴として挙げられる。1つのRedshiftを構成する複数のノードのまとまりをRedshiftクラスタと呼び、クラスタは1つのリーダノードと複数のコンピュートノードから構成される。いかにコンピュートノードをまたがずに処理を完結させることができるのかがRedshift利用のポイントとなる。\n\n**リーダノード**では、[SQL](../../../../development/database/_/chapters/sql.md#sql)クライアントやBI(Business Intelligence)ツールからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を受け付けて、[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)の解析や実行プランの作成を行う。\n\n**コンピュートノード**では、リーダノードからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を処理する。各コンピュートノードは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)とセットになっている。\n\n**ノードスライス**は、Redshiftが分散並列処理をする最小の単位で、コンピュートノードの中でさらにリソースを分割してスライスという単位を構成する。\n\n"},{"term":"リーダノード","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redshift","content":"\n**Amazon Redshift**は、[AWS](./aws.md#aws)が提供するデータウェアハウス（データの分析に最適化された[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)）向けの[データベース](../../../../development/database/_/chapters/database.md#データベース)サービス。大量のデータから意思決定に役立つ情報を見つけ出すために必要な環境を安価で準備できる。\n\nRedshiftは、複数ノードによる分散並列実行が大きな特徴として挙げられる。1つのRedshiftを構成する複数のノードのまとまりをRedshiftクラスタと呼び、クラスタは1つのリーダノードと複数のコンピュートノードから構成される。いかにコンピュートノードをまたがずに処理を完結させることができるのかがRedshift利用のポイントとなる。\n\n**リーダノード**では、[SQL](../../../../development/database/_/chapters/sql.md#sql)クライアントやBI(Business Intelligence)ツールからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を受け付けて、[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)の解析や実行プランの作成を行う。\n\n**コンピュートノード**では、リーダノードからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を処理する。各コンピュートノードは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)とセットになっている。\n\n**ノードスライス**は、Redshiftが分散並列処理をする最小の単位で、コンピュートノードの中でさらにリソースを分割してスライスという単位を構成する。\n\n"},{"term":"コンピュートノード","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redshift","content":"\n**Amazon Redshift**は、[AWS](./aws.md#aws)が提供するデータウェアハウス（データの分析に最適化された[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)）向けの[データベース](../../../../development/database/_/chapters/database.md#データベース)サービス。大量のデータから意思決定に役立つ情報を見つけ出すために必要な環境を安価で準備できる。\n\nRedshiftは、複数ノードによる分散並列実行が大きな特徴として挙げられる。1つのRedshiftを構成する複数のノードのまとまりをRedshiftクラスタと呼び、クラスタは1つのリーダノードと複数のコンピュートノードから構成される。いかにコンピュートノードをまたがずに処理を完結させることができるのかがRedshift利用のポイントとなる。\n\n**リーダノード**では、[SQL](../../../../development/database/_/chapters/sql.md#sql)クライアントやBI(Business Intelligence)ツールからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を受け付けて、[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)の解析や実行プランの作成を行う。\n\n**コンピュートノード**では、リーダノードからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を処理する。各コンピュートノードは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)とセットになっている。\n\n**ノードスライス**は、Redshiftが分散並列処理をする最小の単位で、コンピュートノードの中でさらにリソースを分割してスライスという単位を構成する。\n\n"},{"term":"ノードスライス","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redshift","content":"\n**Amazon Redshift**は、[AWS](./aws.md#aws)が提供するデータウェアハウス（データの分析に最適化された[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)）向けの[データベース](../../../../development/database/_/chapters/database.md#データベース)サービス。大量のデータから意思決定に役立つ情報を見つけ出すために必要な環境を安価で準備できる。\n\nRedshiftは、複数ノードによる分散並列実行が大きな特徴として挙げられる。1つのRedshiftを構成する複数のノードのまとまりをRedshiftクラスタと呼び、クラスタは1つのリーダノードと複数のコンピュートノードから構成される。いかにコンピュートノードをまたがずに処理を完結させることができるのかがRedshift利用のポイントとなる。\n\n**リーダノード**では、[SQL](../../../../development/database/_/chapters/sql.md#sql)クライアントやBI(Business Intelligence)ツールからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を受け付けて、[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)の解析や実行プランの作成を行う。\n\n**コンピュートノード**では、リーダノードからの実行[クエリ](../../../../development/database/_/chapters/sql.md#クエリ)を処理する。各コンピュートノードは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)とセットになっている。\n\n**ノードスライス**は、Redshiftが分散並列処理をする最小の単位で、コンピュートノードの中でさらにリソースを分割してスライスという単位を構成する。\n\n"},{"term":"Redshift Spectrum","link":"./note/ja/./network/aws/_/chapters/database.md","flagment":"redshift-spectrum","content":""},{"term":"CodeCommit","link":"./note/ja/./network/aws/_/chapters/developer_tool.md","flagment":"codecommit","content":"\n**CodeCommit**は、[Git](../../../../development/git/_/chapters/git.md#git)[リポジトリ](../../../../development/git/_/chapters/create_repository.md#リポジトリ)を提供するマネージドサービス。[IAM](./security_and_identity.md#iam)ユーザを利用して権限管理を行うことができたり、他の[AWS](./aws.md#aws)サービスとシームレスに連携できたり、[プルリクエスト](../../../../development/git/_/chapters/branch.md#プルリクエスト)機能があるといった特徴がある。\n\n\n"},{"term":"CodeBuild","link":"./note/ja/./network/aws/_/chapters/developer_tool.md","flagment":"codebuild","content":"\n**CodeBuild**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)の[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)/ビルド環境を提供するマネージドサービス。ビルドの定義はbuildspec.ymlに記載する。\n\nビルド環境のランタイムとして、[Java](../../../../programming/_/chapters/programming_language.md#java)や[PHP](../../../../programming/_/chapters/programming_language.md#php)、[Python](../../../../programming/_/chapters/programming_language.md#python)、Ruby、Node.jsなどを標準でサポートしており、個人で用意した[Docker](../../../../development/docker/_/chapters/docker.md#docker)[イメージ](../../../../development/docker/_/chapters/image.md#イメージ)を利用することもできる。\n\nまた、料金が従量課金型である点もひとつの特徴である。\n\n\n"},{"term":"CodeDeploy","link":"./note/ja/./network/aws/_/chapters/developer_tool.md","flagment":"codedeploy","content":"\n**CodeDeploy**は、ビルド済みの[モジュール](../../../../computer/software/_/chapters/package.md#モジュール)（アーティファクト）を[サーバ](../../../../computer/_/chapters/computer.md#サーバ)へデプロイする工程を自動化するサービス。また、新しい[モジュール](../../../../computer/software/_/chapters/package.md#モジュール)に不具合が見つかったという場合に備えて、ロールバックの機能もある。\n\nデプロイの定義はappspec.ymlに定義する。また、デプロイ方式についても任意に決定することができる。\n\n\n"},{"term":"CodePipeline","link":"./note/ja/./network/aws/_/chapters/developer_tool.md","flagment":"codepipeline","content":"\n**CodePipeline**は、[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)が変更されてから検証環境にデプロイするまでの流れを自動化するサービス。また、リリースの承認プロセスをパイプラインの途中に挟むことも可能で、チーム開発の権限管理にも対応している。\n"},{"term":"Amazon CloudWatch","link":"./note/ja/./network/aws/_/chapters/management_and_governance.md","flagment":"cloudwatch","content":"\n**Amazon CloudWatch**は、運用監視を支援するマネージドサービスであり、[システム](../../../../system/_/chapters/system.md#システム)の安定運用をサポートする。各[AWS](./aws.md#aws)リソースの状態（メトリクス）を定期的に取得し、既定値を超えた場合にアラートを送信することができる。[AWS](./aws.md#aws)があらかじめ定義している標準メトリクスと、利用者が独自に定義することができるカスタムメトリクスを使用できる。\n\n"},{"term":"CloudWatch Logs","link":"./note/ja/./network/aws/_/chapters/management_and_governance.md","flagment":"cloudwatch-logs","content":""},{"term":"AWS CloudTrail","link":"./note/ja/./network/aws/_/chapters/management_and_governance.md","flagment":"cloudtrail","content":"\n**AWS CloudTrail**は、[AWS](./aws.md#aws)に関する操作ログを自動的に取得するサービス。誰が、いつ、どのような操作をしたか、といった監査ログを残すことができる。\n\n[CloudWatch Logs](#cloudwatch-logs)と連携することで、事前に不正な操作を登録しておき、そのような操作が行われたときに通知するように設定することもできる。\n\n"},{"term":"管理イベント","link":"./note/ja/./network/aws/_/chapters/management_and_governance.md","flagment":"管理イベント","content":"\n**管理イベント**は、マネジメントコンソールへのログインや[EC2インスタンス](./computing.md#ec2)の作成、[S3](./storage.md#s3)[バケット](./storage.md#バケット)の作成などといったイベント。\n\n"},{"term":"データイベント","link":"./note/ja/./network/aws/_/chapters/management_and_governance.md","flagment":"データイベント","content":"\n**データイベント**は、[S3](./storage.md#s3)[バケット](./storage.md#バケット)上のデータの操作、[Lambda関数](./computing.md#lambda)の実行などといったイベント。[CloudTrail](#cloudtrail)において、[管理イベント](#管理イベント)の取得はデフォルトで有効であるが、データイベントの取得はデフォルトで無効となっているので注意。\n"},{"term":"セキュリティグループ","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"セキュリティグループ","content":"\n**セキュリティグループ**は、[VPC](#vpc)内のリソースに対するトラフィックを制御するファイアウォール機能。[EC2](./computing.md#ec2)や[ELB](#elb)、[RDS](./database.md#rds)などのインスタンス単位で[インバウンドルール](#インバウンドルール)と[アウトバウンドルール](#アウトバウンドルール)の許可設定をすることができる。[プロトコル](../../../_/chapters/network_architecture.md#プロトコル)や[ポート](../../../_/chapters/address_on_network.md#ポート番号)範囲、[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)、他のセキュリティグループなどを指定して通信を制御する。ステーフルで、通信の復路は動的に許可される。\n\n"},{"term":"インバウンドルール","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"インバウンドルール","content":"\n**インバウンドルール**は、[ネットワーク](../../../_/chapters/network.md#ネットワーク)や[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に対して外部からアクセスする際の規約。\n\n"},{"term":"アウトバウンドルール","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"アウトバウンドルール","content":"\n**アウトバウンドルール**は、[ネットワーク](../../../_/chapters/network.md#ネットワーク)や機器から外部に向かって通信する際の規約。\n\n"},{"term":"インタフェースエンドポイント","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"インタフェースエンドポイント","content":"\n**インタフェースエンドポイント**は、[PrivateLink](#privatelink)を用いて、[VPC](#vpc)と他のサービスをプライベートに接続するためのサービス。同じ[リージョン](./aws.md#リージョン)内のサービスにしか接続できない。\n\n"},{"term":"Gateway Load Balancerエンドポイント","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"gateway-load-balancerエンドポイント","content":""},{"term":"ゲートウェイエンドポイント","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ゲートウェイエンドポイント","content":"\n**ゲートウェイエンドポイント**は、[VPC](#vpc)の[ルーティングテーブル](../../../_/chapters/internet_layer.md#ルーティングテーブル)にターゲットの[グローバルIPアドレス](../../../_/chapters/address_on_network.md#グローバルipアドレス)を追加することでプライベートに接続するサービス。[S3](./storage.md#s3)と[DynamoDB](./database.md#dynamodb)にのみ対応しており、同じ[リージョン](./aws.md#リージョン)内のサービスにしか接続できない。\n\n\n"},{"term":"AWS Direct Connect","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"direct-connect","content":""},{"term":"AWS PrivateLink","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"privatelink","content":"\n**AWS PrivateLink**は、トラフィックをパブリック[インターネット](../../../_/chapters/network.md#インターネット)に公開することなく、[VPC](#vpc)、[AWS](./aws.md#aws)のサービス、および[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)[ネットワーク](../../../_/chapters/network.md#ネットワーク)間のプライベート接続を実現するサービス。異なる[VPC](#vpc)同士の接続や、[VPC](#vpc)とPrivateLinkに対応したサービスとの接続などに用いられる（[インタフェースエンドポイント](#インタフェースエンドポイント)）。それぞれのサービスに[ENI](#eni)を追加するため、[グローバルIPアドレス](../../../_/chapters/address_on_network.md#グローバルipアドレス)ではなく[プライベートIPアドレス](../../../_/chapters/address_on_network.md#プライベートipアドレス)を用いて接続が可能。\n\n\n"},{"term":"AWS CloudFront","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"cloudfront","content":"\n**AWS CloudFront**は、静的なコンテンツをキャッシュしておき、低[レイテンシ](../../../../system/_/chapters/system_performance_evaluation.md#レイテンシ)でユーザにコンテンツを配信する[CDN](../../../../system/_/chapters/system_architecture.md#cdn)サービス。世界中にエッジサーバが存在しており、あらゆる場所からのアクセスに対しても対応できる。また、オリジンサービスの負荷を軽減にもつながる。\n\n\n"},{"term":"Route53","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"route-53","content":""},{"term":"ホストゾーン","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ホストゾーン","content":"\n**ホストゾーン**は、[Route 53](#route-53)における[レコード](../../../_/chapters/internet_layer.md#aレコード)情報（[ドメイン名](../../../_/chapters/internet_layer.md#ドメイン名)と[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)の対応）を管理するコンテナ。\n\n"},{"term":"Aliasレコード","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"aliasレコード","content":"\n**Aliasレコード**は、[Route 53](#route-53)特有のレコードで、[CloudFront](#cloudfront)や[ELB](#elb)、[S3](./storage.md#s3)などの[AWS](./aws.md#aws)リソース[FQDN](../../../_/chapters/internet_layer.md#fqdn)、Zone Apex（最上位ドメイン）を指定できる。\n\n"},{"term":"ルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"シンプルルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"フェイルオーバルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"位置情報ルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"地理的近接性ルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"レイテンシルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"複数値回答ルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"加重ルーティングポリシー","link":"./note/ja/./network/aws/_/chapters/networking_and_content_delivery.md","flagment":"ルーティングポリシー","content":"\n**ルーティングポリシー**は、[ゾーン](#ホストゾーン)情報の名前解決の問い合わせに対する応答の方針。[Route 53](#route-53)では次のようなポリシーを指定することができる。\n\n- **シンプルルーティングポリシー**: 特別なルーティングポリシーを使わない1対1の[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)。\n- **フェイルオーバルーティングポリシー**: アクティブ/スタンバイ方式で、アクティブ側への[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)が失敗したときにスタンバイ側の[システム](../../../../system/_/chapters/system.md#システム)へ[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。本番[システム](../../../../system/_/chapters/system.md#システム)障害時にSorryサーバ（Webサイトやサービスが停止していることを知らせる[サーバ](../../../../computer/_/chapters/computer.md#サーバ)）の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)をセカンダリレコードとして登録しておくなどの使い方。\n- **位置情報ルーティングポリシー**: ユーザの位置情報に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **地理的近接性ルーティングポリシー**: リソースの場所に基づいてトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **レイテンシルーティングポリシー**: 遅延が最も少ない[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リクエスト](../../../../system/_/chapters/system_processing_model.md#リクエスト)を[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n- **複数値回答ルーティングポリシー**: 1つのレコードに異なる[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)を複数登録して、ランダムに返却された[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)に接続する。[ヘルスチェック](../../../../system/_/chapters/reliability_design.md#ヘルスチェック)がNGになった[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[IPアドレス](../../../_/chapters/address_on_network.md#ipアドレス)は返却されない。\n- **加重ルーティングポリシー**: 指定した比率で複数のリソースにトラフィックを[ルーティング](../../../_/chapters/internet_layer.md#ルーティング)する。\n\n\n"},{"term":"IAMユーザ","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"iamユーザ","content":"\n**IAMユーザ**は、[AWS](./aws.md#aws)リソースの操作をするユーザで、[AWS](./aws.md#aws)のマネジメントコンソールにログインしたり、[AWS](./aws.md#aws)の様々なサービスにアクセスするために用いる。\n\n"},{"term":"IAMポリシー","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"iamポリシー","content":"\n**IAMポリシー**は、[AWS](./aws.md#aws)サービスにアクセスするための権限で、実行できるアクションやリソース、条件を制御することができる。[IAMユーザ](#iamユーザ)を作成しただけでは、[AWS](./aws.md)サービスに対するアクセス権限が何もないため、[AWS](./aws.md#aws)サービスを利用することができない。IAMポリシーを作成し、[IAMユーザ](#iamユーザ)に付与することで、与えられた権限の範囲内で[AWS](./aws.md#aws)サービスを利用することができる。また、[IAMユーザ](#iamユーザ)だけでなく、[IAMユーザグループ](#iamユーザグループ)や[IAMロール](#iamロール)に対してもIAMポリシーを付与することができる。\n\n"},{"term":"IAMユーザグループ","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"iamユーザグループ","content":"\n**IAMユーザグループ**は、[IAMユーザ](#iamユーザ)をグループ化して権限管理を行う機能。共通の権限を与えたい[IAMユーザ](#iamユーザ)に対してまとめて[IAMポリシー](#iamポリシー)を適用することができる。\n\n"},{"term":"IAMロール","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"iamロール","content":"\n**IAMロール**は、[AWS](./aws.md#aws)リソース自体に付与する権限。あるリソースに対して、サービス、リソース、アクションを指定して操作権限を付与することができる。\n\n\n"},{"term":"エンベロープ暗号化","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"エンベロープ暗号化","content":"\n**エンベロープ暗号化**は、データを暗号化するためのキーと、そのキーをさらに暗号化するような2層構造の暗号化方式。\n\n\n"},{"term":"Amazon Cognito","link":"./note/ja/./network/aws/_/chapters/security_and_identity.md","flagment":"cognito","content":"\n**Amazon Cognito**は、Webアプリケーションおよびモバイルアプリに素早く簡単にユーザーのサインアップ/サインイン、アクセスコントロールの機能を追加できるサービス。ユーザプールを保持し、ユーザのサインアップとサインインのためのインタフェースを提供する。\n"},{"term":"ボリュームタイプ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボリュームタイプ","content":"\n[EBS](#ebs)には、[SSD](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ssd)と[HDD](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)それぞれにボリュームタイプの種類があり、それに加えて旧世代のHDDストレージタイプとしてマグネティックタイプがある。各タイプの性能を最大限発揮するためには、[EBS最適化インスタンスオプション](./computing.md#ebs最適化オプション)のついた[EC2](./computing.md#ec2)を利用することが推奨される。\n\n- **汎用SSD**(gp2,gp3): [EBS](#ebs)の中で最も一般的なボリュームタイプ。性能の指標としてIOPS（1秒あたりに処理できるI/Oアクセス数）を用い、容量に応じたベースライン性能がある。容量が少ないボリュームには、一時的なIOPSの上昇に対応できるようにバースト機能が用意されている。\n- **プロビジョンドIOPS SSD**(io1): [EBS](#ebs)の中で最も高性能なボリュームタイプ。[RDS](./database.md#rds)や[EC2インスタンス](./computing.md#ec2)で[データベース](../../../../development/database/_/chapters/database.md#データベース)サーバを構成する場合など、高いIOPS性能が求められる場合や、高い[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)が必要なユースケースに適している。\n- **スループット最適化HDD**(st1): [HDD](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)をベースとした[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)重視のボリュームタイプ。ログデータに対する処理やバッチ処理のインプット用[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)など、大容量[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を高速に読み取るようなユースケースに適している。性能指標として[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)を用いている。\n- **Cold HDD**(sc1): 性能は高くはないが最も低コストなボリュームタイプ。利用頻度が少なく、アクセス時の性能も求められないデータにシーケンシャルアクセス（端から順番にアクセスする、⇔ ランダムアクセス）するようなユースケース、あるいはアーカイブ領域の用途に適している。\n\n"},{"term":"バースト性能","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"バースト性能","content":"\n**バースト性能**は、一時的な処理量の増加へどれほど対応できるかを表す、[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)サービスの性能指標のひとつ。あくまでベースライン性能を中心に設計しておき、バースト性能に頼った[システム](../../../../system/_/chapters/system.md#システム)とならないようにする。\n\n"},{"term":"EBSマルチアタッチ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ebsマルチアタッチ","content":"\n**EBSマルチアタッチ**は、複数の[EC2インスタンス](./computing.md#ec2)に同一の[EBS](#ebs)をアタッチできるという機能。同一の[AZ](./aws.md#az)のインスタンスからのみアタッチ可能で、書き込みの排他制御を利用者自身で検討する必要がある。\n\n\n"},{"term":"amazon-efs-utils","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"efs","content":"\n**EFS**(**Amazon Elastic File System**)は、容量無制限で複数の[EC2インスタンス](./computing.md#ec2)から同時にアクセスできるファイルストレージサービス。クライアントからEFSへの接続は、一般的な**NFS**(Network File System)[プロトコル](../../../_/chapters/network_architecture.md#プロトコル)をサポートしている。**amazon-efs-utils**ツールを使うと、EFSへの[マウント](../../../../computer/software/_/chapters/file_system.md#マウント)に関する推奨オプションが含まれていたり、[ファイルシステム](../../../../computer/software/_/chapters/file_system.md#ファイルシステム)にトラブルが発生した場合のトラブルシューティングに役立つログが記録できる。EFSはファイルが作成されると3か所以上の[AZ](./aws.md#az)に保存される分散[ファイルシステム](../../../../computer/software/_/chapters/file_system.md#ファイルシステム)を構成する。\n\n"},{"term":"パフォーマンスモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"パフォーマンスモード","content":"\n[EFS](#efs)には、**汎用パフォーマンスモード**と**最大I/Oパフォーマンスモード**がある。通常は汎用パフォーマンスモード、数百～数千台といったクライアントから同時に[EFS](#efs)にアクセスするようなユースケースでは最大I/Oパフォーマンスモードを用いる。\n\nどちらのモードを用いるかの指標として、[CloudWatch](./management_and_governance.md#cloudwatch)の**PercentIOLimit**というメトリクスが参考になる。汎用パフォーマンスモードでPercentIOLimitが長時間高い状態であれば、最大I/Oパフォーマンスモードに変更することを検討するとよい。\n\nパフォーマンスモードは後から変更できないので注意する。\n\n"},{"term":"汎用パフォーマンスモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"パフォーマンスモード","content":"\n[EFS](#efs)には、**汎用パフォーマンスモード**と**最大I/Oパフォーマンスモード**がある。通常は汎用パフォーマンスモード、数百～数千台といったクライアントから同時に[EFS](#efs)にアクセスするようなユースケースでは最大I/Oパフォーマンスモードを用いる。\n\nどちらのモードを用いるかの指標として、[CloudWatch](./management_and_governance.md#cloudwatch)の**PercentIOLimit**というメトリクスが参考になる。汎用パフォーマンスモードでPercentIOLimitが長時間高い状態であれば、最大I/Oパフォーマンスモードに変更することを検討するとよい。\n\nパフォーマンスモードは後から変更できないので注意する。\n\n"},{"term":"最大I/Oパフォーマンスモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"パフォーマンスモード","content":"\n[EFS](#efs)には、**汎用パフォーマンスモード**と**最大I/Oパフォーマンスモード**がある。通常は汎用パフォーマンスモード、数百～数千台といったクライアントから同時に[EFS](#efs)にアクセスするようなユースケースでは最大I/Oパフォーマンスモードを用いる。\n\nどちらのモードを用いるかの指標として、[CloudWatch](./management_and_governance.md#cloudwatch)の**PercentIOLimit**というメトリクスが参考になる。汎用パフォーマンスモードでPercentIOLimitが長時間高い状態であれば、最大I/Oパフォーマンスモードに変更することを検討するとよい。\n\nパフォーマンスモードは後から変更できないので注意する。\n\n"},{"term":"PercentIOLimit","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"パフォーマンスモード","content":"\n[EFS](#efs)には、**汎用パフォーマンスモード**と**最大I/Oパフォーマンスモード**がある。通常は汎用パフォーマンスモード、数百～数千台といったクライアントから同時に[EFS](#efs)にアクセスするようなユースケースでは最大I/Oパフォーマンスモードを用いる。\n\nどちらのモードを用いるかの指標として、[CloudWatch](./management_and_governance.md#cloudwatch)の**PercentIOLimit**というメトリクスが参考になる。汎用パフォーマンスモードでPercentIOLimitが長時間高い状態であれば、最大I/Oパフォーマンスモードに変更することを検討するとよい。\n\nパフォーマンスモードは後から変更できないので注意する。\n\n"},{"term":"スループットモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"スループットモード","content":"\n[EFS](#efs)には、**バーストスループットモード**と**プロビジョニングスループットモード**がある。\n\nバーストスループットモードは、[EFS](#efs)に保存されているデータ容量に応じてベースラインとなる[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)が設定されている。一時的な[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)の上昇にも耐えられるようなバースト機能を持ったモードとなっている。\n\nプロビジョニングスループットモードは、バーストスループットモードで設定されているベースライン[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)やバースト時の最大[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)では性能が足りない場合に、任意の[スループット](../../../../system/_/chapters/system_performance_evaluation.md#スループット)値を指定することができるモード。[Web](../../../_/chapters/web.md#web)配信コンテンツやアプリケーションデータなどの頻繁なアクセスが見込まれる場合に有用。\n\nどちらのモードを用いるかの指標として、[CloudWatch](./management_and_governance.md#cloudwatch)の**BurstCreditBalance**というメトリクスが参考になる。クレジットバランスをすべて使い切ってしまったり、常に減少傾向である場合にはプロビジョニングスループットモードを選択する。\n\nスループットモードはあとから変更できる。\n\n\n"},{"term":"バーストスループットモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"バーストスループットモード","content":""},{"term":"プロビジョニングスループットモード","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"プロビジョニングスループットモード","content":""},{"term":"BurstCreditBalance","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"プロビジョニングスループットモード","content":""},{"term":"バケット","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"バケット","content":"\n**バケット**は、[S3](#s3)において[オブジェクト](#オブジェクト)を保存するための領域。バケット名は[AWS](./aws.md#aws)内で一意である必要がある。\n\n"},{"term":"オブジェクト","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"オブジェクト","content":"\n**オブジェクト**は、[S3](#s3)において保存されるデータそのもの。各オブジェクトにはキーが付与され、「バケット名+キー名+バージョンID」で必ず一意になる[URL](../../../_/chapters/web.md#url)が作成される。\n\n"},{"term":"メタデータ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"メタデータ","content":"\n**メタデータ**は、[S3](#s3)において[オブジェクト](#オブジェクト)を管理するための情報。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)で必要な情報をユーザ定義メタデータとして保持することもできる。\n\n"},{"term":"ストレージクラス","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"S3標準","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"S3標準 - 低頻度アクセス","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"S3標準 1ゾーン - IA","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"S3 intelligent - Tiering","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"S3 Glacier Deep Archive","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ストレージクラス","content":"\n[S3](#s3)には用途に応じてランク分けされたストレージクラスがある。[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)の性能にはSLA(Service Level Agreement)が用いられている。\n\n- **S3標準** : デフォルトのストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3標準 - 低頻度アクセス** : 格納コストが安価なストレージクラス。データの読み出し容量に対する従量課金が行われる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- **S3 1ゾーン - IA** : 単一の[AZ](./aws.md#az)内のみでデータを複製するストレージクラス。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.5%\n- **S3 Intelligent - Tiering** : 参照頻度の高低を明確に決めることができないデータを扱う場合に有効なストレージクラス。S3標準とS3標準 - 低頻度アクセスの2層構成となっている。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.9%\n- [S3 Glacier](#s3-glacier) : ほとんど参照されないアーカイブ目的のデータを保存するストレージクラス。新規作成時に選択することはできず、ライフサイクル管理機能によって利用可能となる。データへのアクセスには事前にリクエストが必要で、アクセスできるようになるまで時間がかかる。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n- **S3 Glacier Deep Archive** : [S3 Glacier](#s3-glacier)同様アーカイブ用のストレージクラス。さらにアクセス頻度が低いデータを想定している。\n\t- 耐久性： 99.999999999%（イレブンナイン）\n\t- 可用性： 99.99%\n\n"},{"term":"静的コンテンツホスティング機能","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"静的コンテンツホスティング機能","content":"\n**静的コンテンツホスティング機能**は、[S3](#s3)を[CDN](../../../../system/_/chapters/system_architecture.md#cdn)として静的なコンテンツの配信を行う機能。\n\n"},{"term":"署名付きURL","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"署名付きurl","content":"\n**署名付きURL**は、アクセスを許可したい[オブジェクト](#オブジェクト)に対して期限を指定して[URL](../../../_/chapters/web.md#url)を発行する機能。[バケット](#バケット)や[オブジェクト](#オブジェクト)のアクセス制御を変更することなく特定の[オブジェクト](#オブジェクト)に一時的にアクセスを許可したい場合に有効。署名付きURLを知っている人はだれでも[オブジェクト](#オブジェクト)にアクセスできる。\n\n\n"},{"term":"Amazon S3 Glacier","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"s3-glacier","content":""},{"term":"ボールト","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボールト","content":"\n**ボールト**は、[S3 Glacier](#s3-glacier)においてアーカイブを保存するための領域で、[S3](#s3)の[バケット](#バケット)に相当する。\n\n"},{"term":"アーカイブ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"アーカイブ","content":"\n**アーカイブ**は、[S3 Glacier](#s3-glacier)に格納されるデータのことで、[S3](#s3)の[オブジェクト](#オブジェクト)に相当する。\n\n"},{"term":"インベントリ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"インベントリ","content":"\n**インベントリ**は、各[ボールト](#ボールト)に保存されているアーカイブの情報を収集し、1日1回の頻度で更新される。リアルタイムで状況を確認したい場合は、マネジメントコンソールで確認するか、ListVaults APIを実行する。\n\n"},{"term":"ジョブ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ジョブ","content":"\n**ジョブ**は、アーカイブやインベントリに対して検索をかけたり、データをダウンロードするといった要求に対して処理を実行し、処理の状況を管理する機能。\n\n"},{"term":"S3 Glacier Select","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"s3-glacier-select","content":""},{"term":"ボールトロック","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボールトロック","content":"\n**ボールトロック**は、[S3 Glacier](#s3-glacier)のアーカイブが削除されないように制御する機能。ボールトロックポリシーを設定することで、ユーザのアーカイブ削除を拒否する。\n\n\n"},{"term":"AWS Storage Gateway","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"storage-gateway","content":""},{"term":"ファイルゲートウェイ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ファイルゲートウェイ","content":"\n**ファイルゲートウェイ**は、[S3](#s3)をクライアントサーバからNFS[マウント](../../../../computer/software/_/chapters/file_system.md#マウント)して、[ファイルシステム](../../../../computer/software/_/chapters/file_system.md#ファイルシステム)のように扱うことができる[ゲートウェイ](../../../_/chapters/network_architecture.md#ゲートウェイ)。作成した[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)は、非同期（ほぼリアルタイム）で[S3](#s3)にアップロードされる。\n\n"},{"term":"ボリュームゲートウェイ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボリュームゲートウェイ","content":"\n**ボリュームゲートウェイ**は、各[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を[オブジェクト](#オブジェクト)として管理するのではなく、[S3](#s3)のデータ保存領域全体を1つのボリュームとして管理する。クライアントサーバからの[ゲートウェイ](../../../_/chapters/network_architecture.md#ゲートウェイ)への接続方式は、[iSCSI](../../../../computer/hardware/_/chapters/bus.md#scsi)接続になる。\n\n- **キャッシュ型ボリューム** : 頻繁に利用するデータは[Storage Gateway](#storage-gateway)内のキャッシュディスク（[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)）に保存して、すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)（プライマリストレージ）として[S3](#s3)を利用する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のキャッシュボリュームに頻繁に使用するデータを、アップロードバッファボリュームに[S3](#s3)にアップロードするデータを保管しておく。\n- **保管型ボリューム** : すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)としてローカルストレージを利用し、データを定期的にスナップショット形式で[S3](#s3)へ転送する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のデータを定期的にバックアップする用途に適している。\n\n"},{"term":"キャッシュ型ボリューム","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボリュームゲートウェイ","content":"\n**ボリュームゲートウェイ**は、各[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を[オブジェクト](#オブジェクト)として管理するのではなく、[S3](#s3)のデータ保存領域全体を1つのボリュームとして管理する。クライアントサーバからの[ゲートウェイ](../../../_/chapters/network_architecture.md#ゲートウェイ)への接続方式は、[iSCSI](../../../../computer/hardware/_/chapters/bus.md#scsi)接続になる。\n\n- **キャッシュ型ボリューム** : 頻繁に利用するデータは[Storage Gateway](#storage-gateway)内のキャッシュディスク（[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)）に保存して、すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)（プライマリストレージ）として[S3](#s3)を利用する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のキャッシュボリュームに頻繁に使用するデータを、アップロードバッファボリュームに[S3](#s3)にアップロードするデータを保管しておく。\n- **保管型ボリューム** : すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)としてローカルストレージを利用し、データを定期的にスナップショット形式で[S3](#s3)へ転送する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のデータを定期的にバックアップする用途に適している。\n\n"},{"term":"保管型ボリューム","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"ボリュームゲートウェイ","content":"\n**ボリュームゲートウェイ**は、各[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を[オブジェクト](#オブジェクト)として管理するのではなく、[S3](#s3)のデータ保存領域全体を1つのボリュームとして管理する。クライアントサーバからの[ゲートウェイ](../../../_/chapters/network_architecture.md#ゲートウェイ)への接続方式は、[iSCSI](../../../../computer/hardware/_/chapters/bus.md#scsi)接続になる。\n\n- **キャッシュ型ボリューム** : 頻繁に利用するデータは[Storage Gateway](#storage-gateway)内のキャッシュディスク（[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)）に保存して、すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)（プライマリストレージ）として[S3](#s3)を利用する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のキャッシュボリュームに頻繁に使用するデータを、アップロードバッファボリュームに[S3](#s3)にアップロードするデータを保管しておく。\n- **保管型ボリューム** : すべてのデータを保存する[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)としてローカルストレージを利用し、データを定期的にスナップショット形式で[S3](#s3)へ転送する。[オンプレミス](../../../../system/_/chapters/system_architecture.md#オンプレミス)のデータを定期的にバックアップする用途に適している。\n\n"},{"term":"テープゲートウェイ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"テープゲートウェイ","content":"\n**テープゲートウェイ**は、テープデバイスの代替として[S3](#s3)や[S3 Glacier](#s3-glacier)にデータをバックアップするタイプの[ゲートウェイ](../../../_/chapters/network_architecture.md#ゲートウェイ)。すでにバックアップにテープデバイスを利用している場合は、[Storage Gateway](#storage-gateway)への移行が可能。\n\n\n"},{"term":"Amazon FSx","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"fsx","content":"\n**Amazon FSx**は、フルマネージドなファイルストレージで、[Windows](../../../../computer/software/_/chapters/operating_system.md#windows)向けの[Amazon FSx for Windowsファイルサーバ](#fsx-for-windows)と、ハイパフォーマンスコンピューティング向けの[Amazon FSx for Lustre](./fsx-for-lustre)がある。\n\n"},{"term":"Amazon FSx for Windowsファイルサーバ","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"fsx-for-windowsファイルサーバ","content":""},{"term":"Amazon FSx for Lustre","link":"./note/ja/./network/aws/_/chapters/storage.md","flagment":"fsx-for-lustre","content":""},{"term":"強い人工知能","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"強い人工知能","content":"\n**強い人工知能**は、人間と同じような認知的状態を持った機械のことで、知能そのものを模倣することができる。\n\n"},{"term":"弱い人工知能","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"弱い人工知能","content":"\n**弱い人工知能**は、人間の行動を模倣することで、人間の能力の一部を代替できる機械。このような[人工知能](#人工知能)は知的に振る舞っているように見えるが、あくまで[人工知能](#人工知能)自体が自己の存在意義についての何かしらの認知を持っているわけではない。\n\n"},{"term":"汎用人工知能","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"汎用人工知能","content":"\n**汎用人工知能**は、様々な用途に対して利用することができ、設計時に想定していないようなタスクにも対応できるような[人工知能](#人工知能)。\n\n"},{"term":"特化型人工知能","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"特化型人工知能","content":"\n**特化型人工知能**は、限定的な状況や目的においてのみ知的な振る舞いを見せる[人工知能](#人工知能)。現在実現している[人工知能](#人工知能)のほとんどは特化型人工知能で、特定のタスクのみに特化している。\n\n\n"},{"term":"記号主義","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"記号主義","content":"\n**記号主義**は、人間の思考の対象はすべて記号化することができ、その記号を論理的に操作することで知能を再現できるという考え方。\n\n"},{"term":"エキスパートシステム","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"エキスパートシステム","content":"\n**エキスパートシステム**は、[記号主義](#記号主義)に基づいて、すべてを記号化して論理で操作するような[人工知能](#人工知能)。あらかじめ専門家の膨大な知識を[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)にインプットしておき、現状の状況を表すデータを元に推論結果を導く。[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)は自力で知識を獲得することができないため、人間が大量の知識を教え込む必要があり、知識が増えれば増えるほど[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)が爆発的に増大するという問題がある。\n\n"},{"term":"シンボルグラウンディング問題（記号接地問題）","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"シンボルグラウンディング問題","content":"\n**シンボルグラウンディング問題**（**記号接地問題**）は、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に対して知識をインプットしても、その知識が指し示す実体験を理解させることができないという問題。\n\n\n"},{"term":"コネクショニズム","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"コネクショニズム","content":"\n**コネクショニズム**は、人間の脳の仕組みを模倣することで知能を再現できるという考え方。[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)を用いて[人工知能](#人工知能)を実現する。\n\n\n"},{"term":"ビックデータ","link":"./note/ja/./artificial_intelligence/_/chapters/artificial_intelligence.md","flagment":"ビックデータ","content":""},{"term":"学習モデル（モデル）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"学習モデル","content":"\n**学習モデル**（**モデル**）は、[機械学習](#機械学習)を行う際の学習機の構成や、学習を行い[パラメータ](#パラメータ)を調整した後の学習機の状態を指す用語。データの[特徴量](#特徴量)を入力することで、何かしらの出力を行う。\n\n"},{"term":"パラメータ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"パラメータ","content":"\n**パラメータ**は、[機械学習](#機械学習)において[モデル](#学習モデル)の振る舞いを決める基準となる値。\n\n"},{"term":"チューニング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"チューニング","content":"\n**チューニング**は、[パラメータ](#パラメータ)をより良い値へと更新することによって、[モデル](#学習モデル)の性能を向上させる処理。\n\n"},{"term":"特徴量","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"特徴量","content":"\n**特徴量**は、[モデル](#学習モデル)に入力されるデータの性質を表現する値:。分析する対象の見た目や匂い、触感などの様々な性質を表す情報を数値化したもので、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)として用いられる。\n\n"},{"term":"学習率","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"学習率","content":"\n**学習率**は、[モデル](#学習モデル)に対して学習の結果をどれほど反映させるか（[パラメータ](#パラメータ)をどれほど更新するか）という割合。学習率が高いと、新しいデータを学習しようとしたときに適応しやすくなる一方、古いデータの情報が失われやすくなる。\n\n"},{"term":"汎化性能","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"汎化性能","content":"\n**汎化性能**は、[モデル](#学習モデル)の未知データに対する予測・分析性能。[モデル](#学習モデル)が学習データに対してどれだけ高い性能を持っていても、実際に[モデル](#学習モデル)を使用したい実場面において入力されるのは未知データであるため、汎化性能の高さが重要となる。\n\n"},{"term":"重み","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"重み","content":"\n**重み**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が[目的変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)にどれほど影響しているかを表す係数。\n\n"},{"term":"バイアス","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"バイアス","content":"\n**バイアス**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に関係なく[目的変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に影響を与える項。\n\n"},{"term":"分類","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"分類","content":"\n**分類**は、データが複数のグループのうちどれに属するかを判断する[モデル](#学習モデル)、あるいはそのような問題。入力されるデータがいくつかのグループに分類できることを前提として、グループ内でのデータの細かな違いは無視する。分類問題では、[モデル](#学習モデル)の出力は分類されるグループを表す離散値となる。\n\n"},{"term":"回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"回帰","content":"\n**回帰**は、データの傾向を見るための[モデル](#学習モデル)、あるいはそのような問題。入力されるデータを1つのグループとして見て、そのグループ内での違いを分析する。回帰では、[モデル](#学習モデル)の出力は連続値となる。\n\n"},{"term":"クラス","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"クラス","content":"\n**クラス**は、[分類](#分類)問題において、データが分類されるカテゴリやグループ。\n\n\n"},{"term":"教師あり学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"教師あり学習","content":"\n**教師あり学習**は、解決したいタスクの答えが含まれたデータを用いて、[モデル](#学習モデル)を学習させる[機械学習](#機械学習)の手法。この方法では、[モデル](#学習モデル)が出力する予測値と、[ラベル付きデータ](#ラベル付きデータ)の[ラベル](#ラベル)との誤差を小さくするように[パラメータ](#パラメータ)を調整していくことで学習を進める。\n\n"},{"term":"ラベル","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ラベル","content":"\n**ラベル**は、[教師あり学習](#教師あり学習)における学習データの答え。\n\n"},{"term":"ラベル付きデータ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ラベル付きデータ","content":"\n**ラベル付きデータ**は、[教師あり学習](#教師あり学習)に用いられる、[ラベル](#ラベル)が付与された学習データ。\n\n"},{"term":"ラベリング（アノテーション）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ラベリング","content":"\n**ラベリング**（**アノテーション**）は、学習に用いたいデータに[ラベル](#ラベル)付けを行うことで、[ラベル付きデータ](#ラベル付きデータ)を作成する処理や作業。\n\n\n"},{"term":"教師なし学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"教師なし学習","content":"\n**教師なし学習**は、与えられたデータの本質的な構造や法則を抽出する方法。データの特徴を捉えることを目的としている。\n\n"},{"term":"クラスタリング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"クラスタリング","content":"\n**クラスタリング**は、データ群の中から特徴の似ているデータをグループ（クラスタ）ごとに分類するタスク。\n\n"},{"term":"階層的クラスタリング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"階層的クラスタリング","content":"\n**階層的クラスタリング**は、特徴の似ているクラスタ同士を1つずつ結合させていき、最終的に1つの大きなクラスタになるまで繰り返す方法。\n\n"},{"term":"非階層的クラスタリング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"非階層的クラスタリング","content":"\n**非階層的クラスタリング**は、あらかじめ最終的なクラスタ数を決めておき、そのクラスタ数で最もよくデータを分類できるように[クラスタリング](#クラスタリング)する方法。\n\n"},{"term":"次元削減","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"次元削減","content":"\n**次元削減**は、データから重要な情報だけを抜き出して、重要度の低い情報を削減するタスク。ここで次元とは、[特徴量](#特徴量)の数を指す。4次元以上のデータを2次元や3次元に次元削減することによって、データの特徴を可視化することができるようになる。\n\n"},{"term":"次元の呪い","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"次元の呪い","content":"\n**次元の呪い**は、データの[特徴量](#特徴量)が多すぎることで、どの[特徴量](#特徴量)が重要であるかが判断できなくなり、[モデル](#学習モデル)の性能が悪くなる現象。\n\n\n"},{"term":"強化学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"強化学習","content":"\n**強化学習**は、[学習モデル](#学習モデル)に試行を繰り返させて、最適な行動を学習させる方法。[教師あり学習](#教師あり学習)のように明示的な正解があるわけではなく、[モデル](#学習モデル)がとった行動に対して報酬を与えることで、その報酬が高くなるような行動をするように仕向ける。\n\n"},{"term":"エージェント","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"エージェント","content":"\n**エージェント**は、[強化学習](#強化学習)においてタスクに取り組む行動主体（プレイヤー）。\n\n\n"},{"term":"能動学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"能動学習","content":"\n**能動学習**は、教師データを闇雲に作って学習を行うのではなく、教師データの数を絞って学習を行う方法。あきらかに区別がつくデータではなく、紛らわしいデータに絞って[ラベリング](#ラベリング)を行うことで、ラベル付けのコストを抑えることができる。\n\n\n"},{"term":"前処理","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"前処理","content":"\n**前処理**は、データを[機械学習](#機械学習)[モデル](#学習モデル)に入力する前に、データを加工したり整形したりする処理。\n\n"},{"term":"カテゴリデータ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"カテゴリデータ","content":"\n**カテゴリデータ**は、そのデータのカテゴリを表すもの。[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)が扱いやすいように数値として表されるが、割り振られた番号は意味を持たず、大小を比較するといった数学的処理はできない。\n\n"},{"term":"ラベルエンコーディング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ラベルエンコーディング","content":"\n**ラベルエンコーディング**は、各カテゴリにひとつの数字を割り当てる方法。\n\n| ID | 都市   |\n|----|--------|\n| 1  | 東京   |\n| 2  | 大阪   |\n| 3  | 名古屋 |\n| 4  | 大阪   |\n\n| ID | 都市 |\n|----|------|\n| 1  | 1    |\n| 2  | 2    |\n| 3  | 3    |\n| 4  | 2    |\n\n"},{"term":"カウントエンコーディング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"カウントエンコーディング","content":"\n**カウントエンコーディング**は、その[カテゴリデータ](#カテゴリデータ)が出現した回数を割り当てる方法。\n\n| ID | 都市   |\n|----|--------|\n| 1  | 東京   |\n| 2  | 大阪   |\n| 3  | 名古屋 |\n| 4  | 大阪   |\n\n| ID | 都市 |\n|----|------|\n| 1  | 1    |\n| 2  | 2    |\n| 3  | 1    |\n| 4  | 2    |\n\n"},{"term":"One-Hotエンコーディング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"one-hotエンコーディング","content":"\n**One-Hotエンコーディング**は、列の名前をカテゴリ名にして、一致した列には1、それ以外の列には0を割り当てる方法。カテゴリの数だけ列の数が増える。\n\n| ID | 都市   |\n|----|--------|\n| 1  | 東京   |\n| 2  | 大阪   |\n| 3  | 名古屋 |\n| 4  | 大阪   |\n\n| ID | 東京 | 大阪 | 名古屋 |\n|----|------|------|--------|\n| 1  | 1    | 0    | 0      |\n| 2  | 0    | 1    | 0      |\n| 3  | 0    | 0    | 1      |\n| 4  | 0    | 1    | 0      |\n\n"},{"term":"離散化","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"離散化","content":"\n**離散化**は、連続した値をある区分に分類する操作。データの持つ細かな性質の違いを吸収し、データを扱いやすくしたり、より意味のあるデータに変換したりする。\n\n"},{"term":"対数変換","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"対数変換","content":"\n**対数変換**は、データの[対数](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#対数)を取ることで、大きい値を持つデータを圧縮し、小さい値を持つデータを拡大することができる。\n\n"},{"term":"スケーリング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"スケーリング","content":"\n**スケーリング**は、データのとり得る範囲を変換する操作。**Min-Maxスケーリング**では、データの最小値が0、最大値が1となるように、データのとり得る範囲を変換する。**標準化**では、値の[平均](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#平均値)が $0$ 、[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)が $1$ となるように、データのとり得る範囲を変換する。\n\n\n"},{"term":"Min-Maxスケーリング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"スケーリング","content":"\n**スケーリング**は、データのとり得る範囲を変換する操作。**Min-Maxスケーリング**では、データの最小値が0、最大値が1となるように、データのとり得る範囲を変換する。**標準化**では、値の[平均](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#平均値)が $0$ 、[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)が $1$ となるように、データのとり得る範囲を変換する。\n\n\n"},{"term":"標準化","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"スケーリング","content":"\n**スケーリング**は、データのとり得る範囲を変換する操作。**Min-Maxスケーリング**では、データの最小値が0、最大値が1となるように、データのとり得る範囲を変換する。**標準化**では、値の[平均](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#平均値)が $0$ 、[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)が $1$ となるように、データのとり得る範囲を変換する。\n\n\n"},{"term":"イテレーション","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"イテレーション","content":"\n**イテレーション**は、[モデル](#学習モデル)に学習データを繰り返し学習させることで、徐々に正しい出力ができるように調整していく処理。\n\n"},{"term":"バッチ処理（オフライン処理）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"バッチ処理","content":""},{"term":"ミニバッチ処理（オンライン処理）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ミニバッチ処理","content":""},{"term":"アウトオブコア学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"アウトオブコア学習","content":"\n**アウトオブコア学習**は、データが大きすぎて[バッチ学習](#バッチ学習)が行えない場合に、データを小さな単位に分割した上で、[オンライン学習](#ミニバッチ学習)の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)を用いて学習を行う方法。\n\n\n"},{"term":"訓練データ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"訓練データ","content":"\n**訓練データ**は、[モデル](#学習モデル)の[パラメータ](#パラメータ)を調整するための学習用データ。\n\n"},{"term":"検証データ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"検証データ","content":"\n**検証データ**は、[ハイパーパラメータ](#ハイパーパラメータ)の[チューニング](#チューニング)のためのデータで、学習には用いない。学習の途中で検証データによる性能の評価と[ハイパーパラメータ](#ハイパーパラメータ)の調整を繰り返していく。\n\n"},{"term":"テストデータ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"テストデータ","content":"\n**テストデータ**は、[モデル](#学習モデル)の[汎化性能](#汎化性能)を測るために、学習が終了した後に用いる評価用データ。\n\n"},{"term":"ホールドアウト検証","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ホールドアウト検証","content":"\n**ホールドアウト検証**は、データを[訓練データ](#訓練データ)と[テストデータ](#テストデータ)にある割合で分割する方法。学習データが膨大な場合に用いられることが多い。\n\n"},{"term":"クロスバリデーション（K分割交差検証）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"クロスバリデーション","content":"\n**クロスバリデーション**（**K分割交差検証**）は、[訓練データ](#訓練データ)と[テストデータ](#テストデータ)を入れ替えた複数の組み合わせを用意し、それらすべてで学習を行う方法。[テストデータ](#テストデータ)の偏りをなくしたり、不足している学習データ量を補ったりする目的で利用される。\n\n"},{"term":"Leave-one-out交差","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"leave-one-out交差","content":"\n**Leave-one-out交差**は、全データから1つを[テストデータ](#テストデータ)として抜き出し、残りのすべてを[訓練データ](#訓練データ)とするような複数の組み合わせを用意して学習を行う方法。データ数に比例して[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)が増大するため、データ数が少ない場合にのみ利用される。\n\n\n"},{"term":"損失関数（コスト関数、誤差関数）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"損失関数","content":"\n**損失関数**（**コスト関数**、**誤差関数**）は、[モデル](#学習モデル)を最適化するための指標となる関数。[モデル](#学習モデル)が出力する予測値と、[ラベル付きデータ](#ラベル付きデータ)の[ラベル](#ラベル)との[誤差](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#誤差)を損失関数とする場合が多い。\n\n"},{"term":"決定係数","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"決定係数","content":"\n**決定係数**( $R^2$ )は、予測誤差を正規化することで得られる指標で、全く予測できていない場合を $0$ 、すべて予測できている場合を $1$ として、大きいほどよい性能であることを表す。[回帰](#回帰)問題の[損失関数](#損失関数)として用いられる。\n\n"},{"term":"クロスエントロピー誤差（交差エントロピー誤差）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"クロスエントロピー誤差","content":"\n**クロスエントロピー誤差**（**交差エントロピー誤差**）は、[モデル](#学習モデル)の出力したカテゴリの[確率分布](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率分布)を元に、正解[ラベル](#ラベル)との[誤差](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#誤差)を評価するための指標。[分類](#分類)問題の[損失関数](#損失関数)として用いられる。\n\n\n"},{"term":"混合行列","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"混合行列","content":"\n**混合行列**は、2値の[分類](#分類)問題において、[モデル](#学習モデル)の出力と正解[ラベル](#ラベル)との関係をまとめたマトリクス。データがとり得る値は真か偽の2値である。\n\n"},{"term":"ハイパーパラメータ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ハイパーパラメータ","content":"\n**ハイパーパラメータ**は、[モデル](#学習モデル)の持つ[パラメータ](#パラメータ)の中で、学習によって調整されるものではなく、手動で決める必要があるもの。ただし、通常は人間が判断して決定することは非常に難しい。\n\n"},{"term":"未学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"未学習","content":"\n**未学習**は、十分に学習が行われていないことで、[モデル](#学習モデル)の性能が低い状態。学習データに対する予測や分類の精度が十分に高くない場合は未学習であると言える。\n\n"},{"term":"過学習（オーバフィッティング）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"過学習","content":"\n**過学習**（**オーバフィッティング**）は、学習を過度に行いすぎることで、学習データに対しての精度は高いものの[汎化性能](#汎化性能)が低くなってしまう状態。\n\n"},{"term":"オートチューニング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"オートチューニング","content":"\n**オートチューニング**は、[ハイパーパラメータ](#ハイパーパラメータ)の[チューニング](#チューニング)を自動化するメカニズム。\n\n"},{"term":"グリッドサーチ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"グリッドサーチ","content":"\n**グリッドサーチ**は、すべての[ハイパーパラメータ](#ハイパーパラメータ)の組み合わせの中で最も良いものを選択する[オートチューニング](#オートチューニング)の手法。ただし、候補の数が多くなると[計算量](../../../basics/information_theory/_/chapters/computational_complexity.md#計算量)が増大するため、[モデル](#学習モデル)が複雑である場合には現実的ではない。\n\n"},{"term":"ランダムサーチ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ランダムサーチ","content":"\n**ランダムサーチ**は、[ハイパーパラメータ](#ハイパーパラメータ)の組み合わせをランダムに試行する[オートチューニング](#オートチューニング)の手法。\n\n"},{"term":"焼きなまし法（疑似アニーリング、SA）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"焼きなまし法","content":"\n**焼きなまし法**（**疑似アニーリング**、**SA**）は、最初は様々な[ハイパーパラメータ](#ハイパーパラメータ)の組み合わせを広く試行し、徐々に探す範囲を狭くしながらよい組み合わせを探索する方法。\n\n"},{"term":"ベイズ最適化","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"ベイズ最適化","content":"\n**ベイズ最適化**は、ガウス過程という回帰モデルを利用した[オートチューニング](#オートチューニング)の手法。試しにいくつかの組み合わせで精度を計算し、その結果を元に、更に精度が高くなりそうな[パラメータ](#パラメータ)の候補を推定することで効率的に探索を行う。\n\n"},{"term":"遺伝的アルゴリズム","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"遺伝的アルゴリズム","content":"\n**遺伝的アルゴリズム**は、[ハイパーパラメータ](#ハイパーパラメータ)の組み合わせを遺伝子とみなし、淘汰・交叉・突然変異などの処理を繰り返し行う（世代交代）ことで良い組み合わせを探索する手法。\n\n\n"},{"term":"最適化問題（最適化）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"最適化問題","content":"\n**最適化問題**（**最適化**）は、目的関数が最小化あるいは最大化するような[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の組み合わせを求める問題。通常は目的関数の形がわかっていないため、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に適当な値を入れてみてより良い値を探したり、これらの情報から目的関数の形を予測する。\n\n[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の数が増えると、試行する組み合わせの数が爆発的に増加する（**組み合わせ爆発**）ため、最適化問題を解くための工夫を加えた**最適化アルゴリズム**が研究されている。\n\n[機械学習](#機械学習)において最適な[パラメータ](#パラメータ)を求めることは、[損失関数](#損失関数)に関する最適化問題を解くことで、[誤差](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#誤差)を最小化するということである。[損失関数](#損失関数)は目的関数を予想して定義したものが用いられる。\n"},{"term":"組み合わせ爆発","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"最適化問題","content":"\n**最適化問題**（**最適化**）は、目的関数が最小化あるいは最大化するような[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の組み合わせを求める問題。通常は目的関数の形がわかっていないため、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に適当な値を入れてみてより良い値を探したり、これらの情報から目的関数の形を予測する。\n\n[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の数が増えると、試行する組み合わせの数が爆発的に増加する（**組み合わせ爆発**）ため、最適化問題を解くための工夫を加えた**最適化アルゴリズム**が研究されている。\n\n[機械学習](#機械学習)において最適な[パラメータ](#パラメータ)を求めることは、[損失関数](#損失関数)に関する最適化問題を解くことで、[誤差](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#誤差)を最小化するということである。[損失関数](#損失関数)は目的関数を予想して定義したものが用いられる。\n"},{"term":"最適化アルゴリズム","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning.md","flagment":"最適化問題","content":"\n**最適化問題**（**最適化**）は、目的関数が最小化あるいは最大化するような[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の組み合わせを求める問題。通常は目的関数の形がわかっていないため、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に適当な値を入れてみてより良い値を探したり、これらの情報から目的関数の形を予測する。\n\n[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の数が増えると、試行する組み合わせの数が爆発的に増加する（**組み合わせ爆発**）ため、最適化問題を解くための工夫を加えた**最適化アルゴリズム**が研究されている。\n\n[機械学習](#機械学習)において最適な[パラメータ](#パラメータ)を求めることは、[損失関数](#損失関数)に関する最適化問題を解くことで、[誤差](../../../basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md#誤差)を最小化するということである。[損失関数](#損失関数)は目的関数を予想して定義したものが用いられる。\n"},{"term":"最尤推定","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"最尤推定","content":"\n**最尤推定**は、[推定](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#推定)結果として最も尤もらしい（ふさわしい）値を求めるような方法。最もふさわしい値を求めることができる一方で、その値がどれほどふさわしいかということには注目していない。\n\n\n"},{"term":"ベイズ推定","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ベイズ推定","content":"\n**ベイズ推定**は、推測結果を値とその値の尤度によって表す方法。これにより、最もふさわしい値がどれほどふさわしいかという情報まで考慮することができる。ベイズ推定には、[ベイズの定理](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#ベイズの定理)という[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)理論が用いられる。\n\n"},{"term":"事前分布","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"事前分布","content":"\n**事前分布**は、[ベイズ推定](#ベイズ推定)において値がどれくらいになりそうかという予想の分布。\n\n"},{"term":"事後分布","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"事後分布","content":"\n**事後分布**は、[ベイズ推定](#ベイズ推定)を行った結果として得られる値の尤度分布。\n\n"},{"term":"ベイズ更新","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ベイズ更新","content":"\n**ベイズ更新**は、[事前分布](#事前分布)に対して修正を加える操作。これにより最終的に[事後分布](#事後分布)が生成される。\n\n\n"},{"term":"回帰分析","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"回帰分析","content":"\n**回帰分析**は、結果となる数値と要因となる数値の関係を調べて、それぞれの関係を明らかにする統計的手法。\n\n"},{"term":"単回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"単回帰","content":"\n**単回帰**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が1つである[回帰](./machine_learning.md#回帰)モデル。直線的にデータを予測する最もシンプルな方法で、[損失関数](./machine_learning.md#損失関数)として[平方二乗誤差](./machine_learning.md#平方二乗誤差)を使用する**最小二乗法**が用いられる。\n\n"},{"term":"最小二乗法","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"単回帰","content":"\n**単回帰**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が1つである[回帰](./machine_learning.md#回帰)モデル。直線的にデータを予測する最もシンプルな方法で、[損失関数](./machine_learning.md#損失関数)として[平方二乗誤差](./machine_learning.md#平方二乗誤差)を使用する**最小二乗法**が用いられる。\n\n"},{"term":"重回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"重回帰","content":"\n**重回帰**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が複数ある[回帰](./machine_learning.md#回帰)モデル。複数の[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)を用いることで、より複雑なモデルに対しても予測が行える。\n\n"},{"term":"多項式回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"多項式回帰","content":"\n**多項式回帰**は、1つの[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)のべき乗を組み合わせた多項式を用いる[回帰](#回帰分析)モデル。次数が大きくなるほど曲線が複雑になり、不安定になってしまう。\n\n"},{"term":"ロバスト回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ロバスト回帰","content":"\n**ロバスト回帰**は、外れ値の影響を小さくするような[回帰](./machine_learning.md#回帰)モデル。最小二乗法の外れ値に弱いという欠点を克服することを目的としている。\n\n**RANSAC**(Random Sample Consensus)はロバスト回帰の代表的な方法で、データをランダムに抽出して[回帰](./machine_learning.md#回帰)を行い、正常値に当たるデータの割合を求める。これを繰り返して最も正常値の割合が高い直線を回帰直線とする。\n\n"},{"term":"罰則項（正規化項）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"罰則項","content":"\n**罰則項**（**正規化項**）は、[回帰](./machine_learning.md#回帰)の[過学習](./machine_learning.md#過学習)を抑えるための項で、回帰係数が大きいことによるペナルティを与える。[過学習](./machine_learning.md#過学習)を起こした回帰曲線では、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が少し変化しただけで[目的変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)に大きな影響を与えてしまうため、これを抑える。\n\n"},{"term":"L1正則化","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"l1正則化","content":"\n**L1正則化**は、回帰係数の絶対値の和を基準とする[罰則項](#罰則項)の設定方法。あまり重要ではない[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の回帰係数がゼロになる性質がある。そのため、本当に必要な変数だけが[回帰](./machine_learning.md#回帰)に利用されることになる。\n\n"},{"term":"L2正則化","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"l2正則化","content":"\n**L2正則化**は、回帰係数の二乗和を基準とする[罰則項](#罰則項)の設定方法。[損失関数](./machine_learning.md#損失関数)を最小化する計算が[L1正則化](#l1正則化)に比べて簡単であるが、回帰係数を正確にゼロにすることはあまりない。一般的には[L1正則化](#l1正則化)よりもL2正則化の方が予測の性能は高い。\n\n"},{"term":"ラッソ回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ラッソ回帰","content":"\n**ラッソ回帰**は、[L1正則化](#l1正則化)による[罰則項](#罰則項)を加えた[回帰](./machine_learning.md#回帰)モデル。\n\n"},{"term":"リッジ回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"リッジ回帰","content":"\n**リッジ回帰**は、[L2正則化](#l2正則化)による[罰則項](#罰則項)を加えた[回帰](./machine_learning.md#回帰)モデル。\n\n"},{"term":"Elastic Net回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"elastic-net回帰","content":""},{"term":"SVM（サポートベクターマシン）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"svm","content":"\n**SVM**（**サポートベクターマシン**）は、データを分類する境界線（境界面）を決定するための手法。[クラス](./machine_learning.md#クラス)ごとの境界に近いデータをできるだけ境界から引き離す（[マージン](#マージン)を最大化する）ように学習を進める。\n\n境界は、[特徴量](./machine_learning.md#特徴量)の数が2つならば2次元平面上の直線として、[特徴量](./machine_learning.md#特徴量)の数が3つならば3次元空間上の平面として表される。[特徴量](./machine_learning.md#特徴量)が4つ以上の場合は、この境界のことを[超平面](#超平面)という。\n\nSVMは、直線・平面・超平面によってデータ群を分離するため、境界が曲線状になる場合には、[カーネル法](#カーネル法)などを用いる必要がある。\n\n"},{"term":"マージン","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"マージン","content":"\n**マージン**は、[SVM](#svm)において、境界線（境界面）から最も近いデータとの距離。\n\n"},{"term":"超平面（分離超平面）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"超平面","content":"\n**超平面**（**分離超平面**）は、[特徴量](./machine_learning.md#特徴量)が4つ以上のデータに対する[SVM](#svm)において、各[クラス](./machine_learning.md#クラス)のデータを分離するための境界。\n\n"},{"term":"ハードマージンSVM","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ハードマージンsvm","content":"\n**ハードマージンSVM**は、直線・平面・[超平面](#超平面)によって完全にデータを分離する[SVM](#svm)。\n\n"},{"term":"ソフトマージンSVM","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ソフトマージンsvm","content":"\n**ソフトマージンSVM**は、直線・平面・[超平面](#超平面)に対して誤差を認める[SVM](#svm)で、[マージン](#マージン)上にデータが存在することを許容する。[マージン](#マージン)に入ったデータにはペナルティを与え、[マージン](#マージン)の最大化とペナルティの最小化を目的として最適化を進める。\n\n"},{"term":"カーネル法","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"カーネル法","content":"\n**カーネル法**は、線形分離不可能なデータ群を線形分離可能な高次元特徴空間に写像することで、[SVM](#svm)を適用する方法。元の低次元空間では線形分離ができない場合に、それを線形分離可能な高次元特徴空間に写像して[SVM](#svm)を適用し、それを元の低次元空間に逆写像することで境界を求める。\n\n"},{"term":"カーネル関数","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"カーネル関数","content":"\n**カーネル関数**は、[カーネル法](#カーネル法)において、低次元空間のデータ群を高次元特徴空間に写像するための変換関数。\n\n"},{"term":"カーネルトリック","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"カーネルトリック","content":"\n**カーネルトリック**は、[カーネル法](#カーネル法)においてデータを高次元特徴空間に写像する際に、計算が複雑にならないように式変形を行うテクニック。\n\n"},{"term":"SVR（サポートベクトル回帰）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"svr","content":"\n**SVR**（**サポートベクトル回帰**）は、[SVM](#svm)を[回帰](./machine_learning.md#回帰)問題に応用したもの。[ソフトマージンSVM](#ソフトマージンsvm)における[マージン](#マージン)の最大化とペナルティの最小化を用いて、正規化最小二乗法を使った[回帰](./machine_learning.md#回帰)に置き替えることで、回帰直線を求める。\n\n\n"},{"term":"決定木","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"決定木","content":"\n**決定木**は、[木](../../../basics/applied_mathematics/_/chapters/graph_theory.md#木)構造を用いて条件分岐を繰り返していき[分類](./machine_learning.md#分類)を行う手法。各[ノード](../../../basics/applied_mathematics/_/chapters/graph_theory.md#グラフ)には条件が設けれており、末端の[ノード](../../../basics/applied_mathematics/_/chapters/graph_theory.md#グラフ)は分類される[クラス](./machine_learning.md#クラス)にあたる。[モデル](./machine_learning.md#学習モデル)がブラックボックス化しないため解析がしやすく、データの[前処理](./machine_learning.md#前処理)がほとんど必要ないという特徴がある。\n\n"},{"term":"剪定","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"剪定","content":"\n**剪定**は、[決定木](#決定木)の[過学習](./machine_learning.md#過学習)を防止するための方法。分割の深さを制限したり、分割に必要なデータの数の下限を定めたりする。[訓練データ](./machine_learning.md#訓練データ)によって[決定木](#決定木)を意図的に[過学習](./machine_learning.md#過学習)させたのちに、[検証データ](./machine_learning.md#検証データ)を使って性能の悪い[決定木](#決定木)の分岐を切り取ることで、[過学習](./machine_learning.md#過学習)を防いで予測能力を向上させる、といった方法がある。\n\n"},{"term":"アンサンブル学習","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"アンサンブル学習","content":"\n**アンサンブル学習**は、精度の低い[モデル](./machine_learning.md#学習モデル)を複数組み合わせることで精度の高い[モデル](./machine_learning.md#学習モデル)を作る方法。弱学習器は精度は低いものの学習にかかる時間が短い。このような弱学習器の出力を全て参考にし、多数決や[平均](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#平均値)、加重平均などによって最終的な出力を決定する。\n\n"},{"term":"ブートストラップ法","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ブートストラップ","content":"\n**ブートストラップ法**は、[母集団](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#推定)から重複込みでランダムにデータを抽出する方法。\n\n"},{"term":"バギング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"バギング","content":"\n**バギング**は、[ブートストラップ法](#ブートストラップ法)によって全データから[訓練データ](./machine_learning.md#訓練データ)を複数組生成し、それぞれのデータ群に対して[モデル](./machine_learning.md#学習モデル)を用意する[アンサンブル学習](#アンサンブル学習)の手法。ランダムに[訓練データ](./machine_learning.md#訓練データ)を生成することで、それぞれの[モデル](./machine_learning.md#学習モデル)が影響を受けるノイズが打ち消しあう。\n\n"},{"term":"ベースティング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ベースティング","content":""},{"term":"ブースティング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ブースティング","content":"\n**ブースティング**は、[モデル](./machine_learning.md#学習モデル)を順番に学習させていき、前の[モデル](./machine_learning.md#学習モデル)の出力結果と実際の値との差を補正するように次の[モデル](./machine_learning.md#学習モデル)を学習させる[アンサンブル学習](#アンサンブル学習)の手法。並行して[モデル](./machine_learning.md#学習モデル)の学習ができないため、[バギング](#バギング)よりも時間がかかる。\n\n"},{"term":"ランダムフォレスト","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ランダムフォレスト","content":"\n**ランダムフォレスト**は、[決定木](#決定木)を用いた[バギング](#バギング)の一種で、[決定木](#決定木)を分岐させるときに使う[特徴量](./machine_learning.md#特徴量)もランダムに抽出する手法。各[モデル](./machine_learning.md#学習モデル)の[決定木](#決定木)がどれも同じ[特徴量](./machine_learning.md#特徴量)についての分岐ばかりでは予測精度の向上が見込めないため、異なる[特徴量](./machine_learning.md#特徴量)が利用されるようにする。\n\n"},{"term":"スタッキング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"スタッキング","content":"\n**スタッキング**は、最初に[バギング](#バギング)と同様[ブートストラップ法](#ブートストラップ法)で得たデータを各[モデル](./machine_learning.md#学習モデル)に学習させ、その[モデル](./machine_learning.md#学習モデル)の予測結果を入力として次の[モデル](./machine_learning.md#学習モデル)を学習させる手法。[アンサンブル学習](#アンサンブル学習)の各[モデル](./machine_learning.md#学習モデル)のうち、どの出力がより有効であるかを2段階目以降の[モデル](./machine_learning.md#学習モデル)に学習させる構造となる。\n\n"},{"term":"勾配ブースティング","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"勾配ブースティング","content":"\n**勾配ブースティング**は、[ブースティング](#ブースティング)を行う際に、前の[モデル](./machine_learning.md#学習モデル)の予測値と正解データの誤差を最小化するために[勾配降下法](./neural_network.md#勾配降下法)を用いる手法。新しい[モデル](./machine_learning.md#学習モデル)は古い[モデル](./machine_learning.md#学習モデル)の欠点を穴埋めするように学習されていく。\n\n\n"},{"term":"ロジスティック回帰","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ロジスティック回帰","content":"\n**ロジスティック回帰**は、[回帰分析](#回帰分析)と同様、関数の最適な係数を発見する手法で、主に[分類](./machine_learning.md#分類)に用いられる。ここで、関数としては[ロジスティック関数](#シグモイド関数)が用いられ、この関数の値はどちらの[クラス](./machine_learning.md#クラス)に分類されるかを表す[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)となる。\n\n"},{"term":"シグモイド関数（ロジスティック関数）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"シグモイド関数","content":"\n**シグモイド関数**（**ロジスティック関数**）は、最小値が $0$ で最大値が $1$ となるようなS字曲線の関数。\n\n\n"},{"term":"ベイジアンモデル","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ベイジアンモデル","content":"\n**ベイジアンモデル**は、[ベイズ推定](#ベイズ推定)によってデータがどのように発生しているのかという発生構造をモデル化する手法。\n\n\n"},{"term":"時系列分析","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"時系列分析","content":"\n**時系列分析**は、[時系列データ](#時系列データ)に対するモデリングを行い分析をするような手法。基本的には、現在の値は少し前の値に近いという前提でモデリングを行う。\n\n"},{"term":"時系列データ","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"時系列データ","content":"\n**時系列データ**は、あるデータの状態が、そのデータの過去の状態に影響を受けて決定されるようなデータ群。時系列データのように、データがそのデータ自身に影響を受けるような性質のことを**自己相関**があるという。\n\n"},{"term":"自己相関","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"時系列データ","content":"\n**時系列データ**は、あるデータの状態が、そのデータの過去の状態に影響を受けて決定されるようなデータ群。時系列データのように、データがそのデータ自身に影響を受けるような性質のことを**自己相関**があるという。\n\n"},{"term":"状態空間モデル","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"状態空間モデル","content":"\n**状態空間モデル**は、実際に観測される値と、その裏に隠れた本当の状態との間の観測誤差を考慮した時系列分析の[モデル](./machine_learning.md#学習モデル)。観測モデルと状態モデルを組み合わせてモデル化を行う。\n\n\n"},{"term":"k近傍法","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"k近傍法","content":"\n**k近傍法**は、主に[教師あり学習](./machine_learning.md#教師あり学習)の分類に利用される手法で、分類したいデータと各[クラス](./machine_learning.md#クラス)の[ベクトル](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#ベクトル)の類似度を計算する方法。類似度には、2つの[ベクトル](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#ベクトル)間の距離が用いられることが多い。\n\n"},{"term":"マンハッタン距離（L1ノルム）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"マンハッタン距離","content":"\n**マンハッタン距離**（**L1ノルム**）は、2点間の座標平面（空間）上の軸に沿った最短の道なり。\n\n"},{"term":"ユークリッド距離（L2ノルム）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ユークリッド距離","content":"\n**ユークリッド距離**（**L2ノルム**）は、2点間の直線距離。k近傍法において用いられる、最も一般的な類似度である。\n\n"},{"term":"チェビシェフ距離","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"チェビシェフ距離","content":"\n**チェビシェフ距離**は、2点間の座標平面（空間）上の軸に沿った差のうち最大のもの。\n\n"},{"term":"ミンコフスキー距離","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"ミンコフスキー距離","content":"\n**ミンコフスキー距離**は、2点間の距離の指標を一般化したもの。2点 $x, y$ 間の距離 $D(x, y)$ は、 $D(x, y) = (\\sum^{n}_{i=0}{| x_i - y_i |^p})^{\\frac{1}{p}}$ で表され、 $p=1$ のときは[マンハッタン距離](#マンハッタン距離)、 $p=2$ の時は[ユークリッド距離](#ユークリッド距離)、 $p=\\infty$ の時は[チェビシェフ距離](#チェビシェフ距離)となる。\n\n\n"},{"term":"k-means法（k平均法）","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"k-means法","content":"\n**k-means法**（**k平均法**）は、[教師なし学習](./machine_learning.md#教師なし学習)における[クラスタリング](./machine_learning.md#クラスタリング)の手法で、データを[ベクトル](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#ベクトル)化したときの距離に応じてそのデータが所属するクラスタを決定する。\n\n"},{"term":"k-means++","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"k-means","content":"\n**k-means法**（**k平均法**）は、[教師なし学習](./machine_learning.md#教師なし学習)における[クラスタリング](./machine_learning.md#クラスタリング)の手法で、データを[ベクトル](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#ベクトル)化したときの距離に応じてそのデータが所属するクラスタを決定する。\n\n"},{"term":"主成分","link":"./note/ja/./artificial_intelligence/_/chapters/machine_learning_algorithm.md","flagment":"主成分分析","content":"\n**主成分分析**(**PCA**)は、[次元削減](./machine_learning.md#次元削減)に用いられる手法で、データの情報（[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)）をなるべく損なわないようにして、複数の[特徴量](./machine_learning.md#特徴量)から新しい[特徴量](./machine_learning.md#特徴量)を合成する。この手法で合成された新しい[特徴量](./machine_learning.md#特徴量)のことを**主成分**といい、[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)が最大化されるような主成分を第一主成分、次に[分散](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#分散)が大きくなる主成分を第二主成分という。\n"},{"term":"パーセプトロン","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"パーセプトロン","content":"\n**パーセプトロン**は、単一の[ニューロン](#ニューロン)を[モデル](./machine_learning.md#学習モデル)化したもの。パーセプトロンでは、複数の入力に対してそれぞれ[重み](#重み)をかけたものの和をとる。また、この時[バイアス](#バイアス)を足し合わせる場合もある。こうして求められた和に対して、[活性化関数](#活性化関数)と呼ばれる非線形関数を適用し、最終的な出力を求める。\n\n"},{"term":"ニューロン","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ニューロン","content":"\n**ニューロン**は、人間の神経回路。\n\n\n"},{"term":"ノード","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ノード","content":"\n**ノード**は、[ニューラルネットワーク](#ニューラルネットワーク)における、単体の[パーセプトロン](#パーセプトロン)。\n\n"},{"term":"エッジ","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"エッジ","content":"\n**エッジ**は、[ニューラルネットワーク](#ニューラルネットワーク)における、[ノード](#ノード)と[ノード](#ノード)を接続している部分。各エッジはそれぞれ[重み](#重み)を持っている。\n\n"},{"term":"重み","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"重み","content":"\n**重み**は、[ニューラルネットワーク](#ニューラルネットワーク)における[パラメータ](./machine_learning.md#パラメータ)で、[ノード](#ノード)と[ノード](#ノード)の結びつきの強さ。重みが大きいほど後段の[ノード](#ノード)への影響が大きくなる。\n\n"},{"term":"バイアス","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"バイアス","content":"\n**バイアス**は、[ニューラルネットワーク](#ニューラルネットワーク)における[パラメータ](./machine_learning.md#パラメータ)で、各[ノード](#ノード)で入力に関係なく加えられる項。\n\n"},{"term":"入力層","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"入力層","content":"\n**入力層**は、[ニューラルネットワーク](#ニューラルネットワーク)に入力される[特徴量](./machine_learning.md#特徴量)を受け付けるレイヤ。\n\n"},{"term":"中間層（隠れ層）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"中間層","content":"\n**中間層**（**隠れ層**）は、[ニューラルネットワーク](#ニューラルネットワーク)において、[入力層](#入力層)と[出力層](#出力層)の間にあるレイヤで、データを分類したり分析したりといった様々な操作を行う。ネットワークごとに様々な種類の中間層のレイヤが用意される。\n\n"},{"term":"出力層","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"出力層","content":"\n**出力層**は、[ニューラルネットワーク](#ニューラルネットワーク)において、最終的なデータの分類・分析結果を出力するレイヤ。\n\n"},{"term":"3層ニューラルネットワーク","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"3層ニューラルネットワーク","content":"\n**3層ニューラルネットワーク**は、[中間層](#中間層)を1層持つ、最も基本的な[ニューラルネットワーク](#ニューラルネットワーク)。\n\n"},{"term":"順伝搬","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"順伝搬","content":"\n**順伝搬**は、[ニューラルネットワーク](#ニューラルネットワーク)に入力されたデータが、[重み](#重み)を掛けられたり、[活性化関数](#活性化関数)を適用されたりすることで、最終的な結果が出力されるという流れ。[ニューラルネットワーク](#ニューラルネットワーク)により予測や分類を行うには順伝搬を用いる。\n\n\n"},{"term":"誤差逆伝搬法（バックプロバゲーション）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"誤差逆伝搬法","content":"\n**誤差逆伝搬法**（**バックプロバゲーション**）は、[ニューラルネットワーク](#ニューラルネットワーク)の出力と正解データとの誤差を、[出力層](#出力層)から[入力層](#入力層)に向かって伝搬（**逆伝搬**）しながら[パラメータ](./machine_learning.md#パラメータ)を調整する方法。[出力層](#出力層)の[損失関数](./machine_learning.md#損失関数)の値が小さくなるように、各[ノード](#ノード)での局所誤差を小さくしながら[モデル](./machine_learning.md#学習モデル)を最適化していく。\n\n\n"},{"term":"逆伝搬","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"誤差逆伝搬法","content":"\n**誤差逆伝搬法**（**バックプロバゲーション**）は、[ニューラルネットワーク](#ニューラルネットワーク)の出力と正解データとの誤差を、[出力層](#出力層)から[入力層](#入力層)に向かって伝搬（**逆伝搬**）しながら[パラメータ](./machine_learning.md#パラメータ)を調整する方法。[出力層](#出力層)の[損失関数](./machine_learning.md#損失関数)の値が小さくなるように、各[ノード](#ノード)での局所誤差を小さくしながら[モデル](./machine_learning.md#学習モデル)を最適化していく。\n\n\n"},{"term":"勾配降下法","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"勾配降下法","content":"\n**勾配降下法**は、[最適化アルゴリズム](./machine_learning.md#最適化問題)のひとつで、ある[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が入力された時の[目的関数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の値とその傾きを用いて、[目的関数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の値が最小化されるように傾きの下降方向に[パラメータ](./machine_learning.md#パラメータ)を調整する方法。**勾配**（傾き）は、ある[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が入力されたときの目的関数の[微分係数](../../../basics/applied_mathematics/_/chapters/formal_processing.md#微分係数)で求められる。\n\n勾配降下法は、初期値によって、必ずしも[大域最適解](#大域最適解)に向かって[パラメータ](./machine_learning.md#パラメータ)を調整するとは限らず、[局所最適解](#局所最適解)に陥ってしまうこともある。\n\n勾配降下法においては、[学習率](./machine_learning.md#学習率)の設定が非常に重要となる。[学習率](./machine_learning.md#学習率)が小さすぎると[パラメータ](./machine_learning.md#パラメータ)が収束するまでに時間がかかってしまい、[学習率](./machine_learning.md#学習率)が大きすぎると[パラメータ](./machine_learning.md#パラメータ)が発散して正しい値に収束しない。\n\n"},{"term":"勾配（傾き）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"勾配降下法","content":"\n**勾配降下法**は、[最適化アルゴリズム](./machine_learning.md#最適化問題)のひとつで、ある[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が入力された時の[目的関数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の値とその傾きを用いて、[目的関数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の値が最小化されるように傾きの下降方向に[パラメータ](./machine_learning.md#パラメータ)を調整する方法。**勾配**（傾き）は、ある[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)が入力されたときの目的関数の[微分係数](../../../basics/applied_mathematics/_/chapters/formal_processing.md#微分係数)で求められる。\n\n勾配降下法は、初期値によって、必ずしも[大域最適解](#大域最適解)に向かって[パラメータ](./machine_learning.md#パラメータ)を調整するとは限らず、[局所最適解](#局所最適解)に陥ってしまうこともある。\n\n勾配降下法においては、[学習率](./machine_learning.md#学習率)の設定が非常に重要となる。[学習率](./machine_learning.md#学習率)が小さすぎると[パラメータ](./machine_learning.md#パラメータ)が収束するまでに時間がかかってしまい、[学習率](./machine_learning.md#学習率)が大きすぎると[パラメータ](./machine_learning.md#パラメータ)が発散して正しい値に収束しない。\n\n"},{"term":"大域最適解","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"大域最適解","content":"\n**大域最適解**は、[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)がとり得る範囲全体で、目的関数が最小化（または最大化）されるような[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の組み合わせ。\n\n"},{"term":"局所最適解","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"局所最適解","content":"\n**局所最適解**は、ある限られた範囲において、目的関数が最小化（または最大化）されるような[説明変数](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#回帰分析)の組み合わせ。\n\n"},{"term":"モーメンタム","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"モーメンタム","content":"\n**モーメンタム**は、[SGD](#sgd)に慣性の概念を加えた[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、直前の勾配を考慮した項を加えることで収束までの時間を短縮することができる。\n\n"},{"term":"Adagrad","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"adagrad","content":"\n**Adagrad**は、[SGD](#sgd)において学習が進むにつれて[学習率](./machine_learning.md#学習率)を自動的に小さくしていく[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、[パラメータ](./machine_learning.md#パラメータ)が発散することを防ぐ。\n\n"},{"term":"RMSprop","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"rmsprop","content":"\n**RMSprop**は、[Adagrad](#adagrad)を改良した[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、勾配の合計を指数移動平均することで、より最近の勾配を重視することができる。\n\n"},{"term":"Adam","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"adam","content":"\n**Adam**は、[RMSprop](#rmsprop)と[モーメンタム](#モーメンタム)を組み合わせた[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、それぞれの恩恵を受けることができる。\n\n\n"},{"term":"勾配消失問題","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"勾配消失問題","content":"\n**勾配消失問題**は、[誤差逆伝搬法](#誤差逆伝搬法)によって[パラメータ](./machine_learning.md#パラメータ)を更新する際に、レイヤを通過するたびに勾配が小さくなっていき、前段の層の[パラメータ](./machine_learning.md#パラメータ)の収束に時間がかかる問題。勾配は各[ノード](#ノード)における[活性化関数](#活性化関数)の[微分](../../../basics/applied_mathematics/_/chapters/formal_processing.md#微分)により算出できるが、この値が $1$ よりも小さい場合は徐々に勾配が小さくなっていく。\n\n[シグモイド関数](#シグモイド関数)を[微分](../../../basics/applied_mathematics/_/chapters/formal_processing.md#微分)した関数は最大値が $0.25$ と小さく、勾配消失問題が発生しやすいため、[隠れ層](#中間層)の[活性化関数](#活性化関数)としては[ReLU関数](#relu関数)がよく用いられている。\n\n\n"},{"term":"勾配爆発問題","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"勾配爆発問題","content":"\n**勾配爆発問題**は、[誤差逆伝搬法](#誤差逆伝搬法)によって[パラメータ](./machine_learning.md#パラメータ)を更新する際に、レイヤを通過するたびに勾配が大きくなっていき、前段の層の[パラメータ](./machine_learning.md#パラメータ)の更新時に発散してしまう問題。\n\n\n"},{"term":"活性化関数","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"活性化関数","content":"\n**活性化関数**は、入力を重み付けした和を別の値に変形させる関数のことで、非線形関数が用いられる。活性化関数を用いない[パーセプトロン](#パーセプトロン)や[ニューラルネットワーク](#ニューラルネットワーク)は、出力が各層の重みづけを行った入力の線形関数で表現されるため、線形分離可能な問題にしか対応できない。\n\n"},{"term":"ステップ関数","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ステップ関数","content":"\n**ステップ関数**は、入力が $0$ より大きければ $1$ 、 $0$ 以下であれば $0$ を出力するような関数。初期の[パーセプトロン](#パーセプトロン)の[活性化関数](#活性化関数)として用いられていた。\n\n"},{"term":"シグモイド関数","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"シグモイド関数","content":"\n**シグモイド関数**は、最小値が $0$ で最大値が $1$ となるようなS字曲線の関数で、最終的な[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)を出力するような場合に有用。ただし、勾配が $0$ に近い値となることが多く、学習がうまく進まないという問題（[勾配消失問題](#勾配消失問題)）がある。\n\n"},{"term":"tanh関数（ハイパボリックタンジェント関数）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"tanh関数","content":"\n**tanh関数**（ハイパボリックタンジェント関数）は、最小値が $-1$ で最大値が $1$ となるようなS字曲線の関数。[シグモイド関数](#シグモイド関数)に比べて[勾配消失問題](#勾配消失問題)が軽減される。\n\n"},{"term":"ドロップアウト","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ドロップアウト","content":"\n**ドロップアウト**は、一定の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で[中間層](#中間層)の一部を無視して学習を行うことで、[過学習](./machine_learning.md#過学習)を防止する手法。\n\n\n"},{"term":"転移学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"転移学習","content":"\n**転移学習**は、あるタスクに最適化されている[ニューラルネットワーク](#ニューラルネットワーク)[モデル](./machine_learning.md#学習モデル)を、類似した別のタスクに応用するために調整する学習方法。転移学習がうまくいけば、学習に必要な時間が大幅に削減できる。\n\n"},{"term":"ファインチューニング","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ファインチューニング","content":"\n**ファインチューニング**は、既に学習済みの[ニューラルネットワーク](#ニューラルネットワーク)[モデル](./machine_learning.md#学習モデル)の後段の層の[パラメータ](./machine_learning.md#パラメータ)のみを学習し直し、タスクに最適化させる手法。\n\n"},{"term":"負の転移","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"負の転移","content":"\n**負の転移**は、[転移学習](#転移学習)において、元の[モデル](./machine_learning.md#学習モデル)が解決しようとしていたタスクと転移先のタスクがそれほど似ていなかった場合に、通常より性能の悪い[モデル](./machine_learning.md#学習モデル)が完成してしまう現象。\n\n"},{"term":"ドメイン混合","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"ドメイン混合","content":"\n**ドメイン混合**は、[ニューラルネットワーク](#ニューラルネットワーク)において本来特化させたいタスクとは別の出力を設けることで、[モデル](./machine_learning.md#学習モデル)があるタスクにフィッティングしすぎることを防ぐ手法。これにより、[モデル](./machine_learning.md#学習モデル)を[転移学習](#転移学習)に利用しやすくする。\n\n"},{"term":"マルチタスク学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"マルチタスク学習","content":"\n**マルチタスク学習**は、複数のタスクに関する学習を同時に行う手法。\n\n"},{"term":"One-shot学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"one-shot学習","content":"\n**One-shot学習**は、[分類](./machine_learning.md#分類)問題において、ある[ラベル](./machine_learning.md#ラベル)の[訓練データ](./machine_learning.md#訓練データ)がひとつ（あるいは小数）しかなくても正しく[分類](./machine_learning.md#分類)ができるような学習方法。\n\n"},{"term":"Zero-shot学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"zero-shot学習","content":"\n**Zero-shot学習**は、[分類](./machine_learning.md#分類)問題において、ある[ラベル](./machine_learning.md#ラベル)の[訓練データ](./machine_learning.md#訓練データ)がひとつもなくても正しく[分類](./machine_learning.md#分類)ができるような学習方法。\n\n\n"},{"term":"特徴抽出","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"特徴抽出","content":"\n**特徴抽出**は、あるデータの[特徴量](./machine_learning.md#特徴量)から、情報量の少ない[特徴量](./machine_learning.md#特徴量)を削除したり、いくつかの[特徴量](./machine_learning.md#特徴量)からそれらを複合した新しい[特徴量](./machine_learning.md#特徴量)を合成したりする方法。[ニューラルネットワーク](#ニューラルネットワーク)の[出力層](#出力層)をそのほかの[モデル](./machine_learning.md#学習モデル)（[SVM](./machine_learning_algorithm.md#svm)など）につなげることで、特徴抽出器としても用いることができる。\n\n\n"},{"term":"パターン認識","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"パターン認識","content":"\n**パターン認識**は、画像認識や音声認識といった、学習データから一定のパターンを見つけ出すことによって未知データを解析する方法。\n\n\n"},{"term":"自然言語処理","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"自然言語処理","content":"\n**自然言語処理**は、人が用いる言語をテキストとして[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)に処理させるタスク。\n\n"},{"term":"分散表現","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network.md","flagment":"分散表現","content":"\n**分散表現**は、ひとつの単語を低次元の[ベクトル](../../../basics/applied_mathematics/_/chapters/numerical_calculation.md#ベクトル)として表現することで、[コンピュータ](../../../computer/_/chapters/computer.md#コンピュータ)で処理できるようにする手法。\n"},{"term":"全結合層","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"全結合層","content":"\n**全結合層**は、[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)に用いられるレイヤのひとつで、前の層の出力全てと結合するような[ノード](./neural_network.md#ノード)からなる。\n\n\n"},{"term":"CNN（畳み込みニューラルネットワーク）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"cnn","content":"\n**CNN**（**畳み込みニューラルネットワーク**）は、平面・空間上で隣り合う[特徴量](./machine_learning.md#特徴量)を考慮して学習を行う機構を持った[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)。\n\n"},{"term":"畳み込み層","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"畳み込み層","content":"\n**畳み込み層**は、畳み込みフィルタによって平面・空間上のある範囲に反応するフィルタを用いて新しい**特徴マップ**を作るレイヤ。データの[特徴量](./machine_learning.md#特徴量)の端の部分からフィルタを適用し、フィルタをずらしていくことで特徴マップを作成する。\n\n"},{"term":"特徴マップ","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"畳み込み層","content":"\n**畳み込み層**は、畳み込みフィルタによって平面・空間上のある範囲に反応するフィルタを用いて新しい**特徴マップ**を作るレイヤ。データの[特徴量](./machine_learning.md#特徴量)の端の部分からフィルタを適用し、フィルタをずらしていくことで特徴マップを作成する。\n\n"},{"term":"プーリング層","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"プーリング層","content":"\n**プーリング層**は、平面・空間上のある範囲（ウィンドウ）のうち値を1つだけ抽出することで[特徴量](./machine_learning.md#特徴量)を削減するレイヤ。**マックスプーリング**では、ウィンドウ上で最大の値だけを抽出する。\n\n\n"},{"term":"マックスプーリング","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"プーリング層","content":"\n**プーリング層**は、平面・空間上のある範囲（ウィンドウ）のうち値を1つだけ抽出することで[特徴量](./machine_learning.md#特徴量)を削減するレイヤ。**マックスプーリング**では、ウィンドウ上で最大の値だけを抽出する。\n\n\n"},{"term":"RNN（再帰型ニューラルネットワーク）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"rnn","content":"\n**RNN**（**再帰型ニューラルネットワーク**）は、[時系列データ](./machine_learning_algorithm.md#時系列データ)を再帰的に処理する機構を持った[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)。[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)がループ状に接続されるような構造となっており、古いデータを処理したときの情報を次のデータを処理する際に引き継ぐ。\n\n"},{"term":"再帰セル","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"再帰セル","content":"\n**再帰セル**は、[RNN](#rnn)の[モデル](./machine_learning.md#学習モデル)中でループで繋がれているレイヤ。\n\n"},{"term":"内部状態（隠れ状態）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"内部状態","content":"\n**内部状態**（隠れ状態）は、[再帰セル](#再帰セル)が保持する情報。\n\n"},{"term":"ゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"lstm","content":"\n**LSTM**(Long Short Term Memory)は、[再帰セル](#再帰セル)の構造のひとつで、古い情報の記憶が薄れていく（内部情報には直近のデータの状態が反映されやすく、最初のデータの情報は徐々に消えていく）という[再帰セル](#再帰セル)の弱点を軽減している。また、時間方向の[勾配消失問題](./neural_network.md#勾配消失問題)を軽減し、学習が効率よく進む。LSTMには情報の伝わり方を調整するための3つの**ゲート**が設けられている。\n\n**忘却ゲート**では前の情報をどれだけ切り捨てるかを調整し、**入力ゲート**では新しい情報をどれだけ取り込むかを調整し、**出力ゲート**では情報をどれだけ出力するかを調整する。\n\n"},{"term":"忘却ゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"lstm","content":"\n**LSTM**(Long Short Term Memory)は、[再帰セル](#再帰セル)の構造のひとつで、古い情報の記憶が薄れていく（内部情報には直近のデータの状態が反映されやすく、最初のデータの情報は徐々に消えていく）という[再帰セル](#再帰セル)の弱点を軽減している。また、時間方向の[勾配消失問題](./neural_network.md#勾配消失問題)を軽減し、学習が効率よく進む。LSTMには情報の伝わり方を調整するための3つの**ゲート**が設けられている。\n\n**忘却ゲート**では前の情報をどれだけ切り捨てるかを調整し、**入力ゲート**では新しい情報をどれだけ取り込むかを調整し、**出力ゲート**では情報をどれだけ出力するかを調整する。\n\n"},{"term":"入力ゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"lstm","content":"\n**LSTM**(Long Short Term Memory)は、[再帰セル](#再帰セル)の構造のひとつで、古い情報の記憶が薄れていく（内部情報には直近のデータの状態が反映されやすく、最初のデータの情報は徐々に消えていく）という[再帰セル](#再帰セル)の弱点を軽減している。また、時間方向の[勾配消失問題](./neural_network.md#勾配消失問題)を軽減し、学習が効率よく進む。LSTMには情報の伝わり方を調整するための3つの**ゲート**が設けられている。\n\n**忘却ゲート**では前の情報をどれだけ切り捨てるかを調整し、**入力ゲート**では新しい情報をどれだけ取り込むかを調整し、**出力ゲート**では情報をどれだけ出力するかを調整する。\n\n"},{"term":"出力ゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"lstm","content":"\n**LSTM**(Long Short Term Memory)は、[再帰セル](#再帰セル)の構造のひとつで、古い情報の記憶が薄れていく（内部情報には直近のデータの状態が反映されやすく、最初のデータの情報は徐々に消えていく）という[再帰セル](#再帰セル)の弱点を軽減している。また、時間方向の[勾配消失問題](./neural_network.md#勾配消失問題)を軽減し、学習が効率よく進む。LSTMには情報の伝わり方を調整するための3つの**ゲート**が設けられている。\n\n**忘却ゲート**では前の情報をどれだけ切り捨てるかを調整し、**入力ゲート**では新しい情報をどれだけ取り込むかを調整し、**出力ゲート**では情報をどれだけ出力するかを調整する。\n\n"},{"term":"リセットゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"gru","content":"\n**GRU**(Gated Recurrent Unit)は、[再帰セル](#再帰セル)の構造のひとつで、[LSTM](#lstm)の構造を単純化している。GRUには情報の伝わり方を調整するための2つの**ゲート**が設けられている。\n\n**リセットゲート**では情報をどれだけ切り捨てるかを調整し、**更新ゲート**では情報をどれだけ取り込むかを調整する。\n\n"},{"term":"更新ゲート","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"gru","content":"\n**GRU**(Gated Recurrent Unit)は、[再帰セル](#再帰セル)の構造のひとつで、[LSTM](#lstm)の構造を単純化している。GRUには情報の伝わり方を調整するための2つの**ゲート**が設けられている。\n\n**リセットゲート**では情報をどれだけ切り捨てるかを調整し、**更新ゲート**では情報をどれだけ取り込むかを調整する。\n\n"},{"term":"双方向RNN","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"双方向rnn","content":"\n**双方向RNN**は、前のデータの情報だけでなく、後ろのデータの情報も用いることで予測精度を向上させた[RNN](#rnn)。\n\n"},{"term":"Encoder","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"seq2seq","content":"\n**Seq2Seq**(sequence-to-sequence)は、[自然言語処理](./neural_network.md#自然言語処理)に特化した双方向[RNN](#rnn)[モデル](./machine_learning.md#学習モデル)。\n\nある単語系列をRNN(**Encoder**)に入力し、Encoderの最終的な内部状態を別のRNN(**Decoder**)に入力として渡すことで、新しい単語系列を出力させる。これにより機械翻訳などを実現している。\n\n"},{"term":"Decoder","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"seq2seq","content":"\n**Seq2Seq**(sequence-to-sequence)は、[自然言語処理](./neural_network.md#自然言語処理)に特化した双方向[RNN](#rnn)[モデル](./machine_learning.md#学習モデル)。\n\nある単語系列をRNN(**Encoder**)に入力し、Encoderの最終的な内部状態を別のRNN(**Decoder**)に入力として渡すことで、新しい単語系列を出力させる。これにより機械翻訳などを実現している。\n\n"},{"term":"Attention（注意機構）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"attention","content":"\n**Attention**（**注意機構**）は、入力された[時系列データ](./machine_learning_algorithm.md#時系列データ)のすべての[内部状態](#内部状態)を参照し、それらに[重み](./neural_network.md#重み)をつけて着目すべき部分を変化させる機構。[Seq2Seq](#seq2seq)では、最終的な[内部状態](#内部状態)だけを[Encoder](#encoder)から[Decoder](#decoder)に渡していたため、情報のボトルネックが生じてしまっていた。Attentionはこのような弱点を克服し、翻訳精度を上げることに成功している。\n\nまた、[RNN](#rnn)のような前の出力を[モデル](./machine_learning.md#学習モデル)に再帰的に入力するような方法では、学習を並列化させることができないため最適化に時間がかかるという欠点があったが、Attentionを用いることでこれも解決できる。\n\n\n"},{"term":"Transformer","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"transformer","content":"\n**Transformer**は、[Attention](#attention)を応用した**Self-Attention**機構を持つ[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)の[モデル](./machine_learning.md#学習モデル)。Self-Attentionは[自然言語処理](./neural_network.md#自然言語処理)のタスクにおいて、ある単語がその文章中のどの単語と結びつきが強いのか、という情報を明らかにするレイヤ。基本形は[Seq2Seq](#seq2seq)と同様Encoder-Decoderの[モデル](./machine_learning.md#学習モデル)であるが、Encoderのみを取り出したものもある。\n\n\n"},{"term":"Self-Attention","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"transformer","content":"\n**Transformer**は、[Attention](#attention)を応用した**Self-Attention**機構を持つ[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)の[モデル](./machine_learning.md#学習モデル)。Self-Attentionは[自然言語処理](./neural_network.md#自然言語処理)のタスクにおいて、ある単語がその文章中のどの単語と結びつきが強いのか、という情報を明らかにするレイヤ。基本形は[Seq2Seq](#seq2seq)と同様Encoder-Decoderの[モデル](./machine_learning.md#学習モデル)であるが、Encoderのみを取り出したものもある。\n\n\n"},{"term":"オートエンコーダ（自己符号化器）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"オートエンコーダ","content":"\n**オートエンコーダ**（**自己符号化器**）は、[教師なし学習](./machine_learning.md#教師なし学習)の手法のひとつで、[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)の入力と同じ出力を行うように[モデル](./machine_learning.md#学習モデル)を学習する方法。[中間層](./neural_network.md#中間層)のサイズを[入力層](./neural_network.md#入力層)よりも小さくしておくことで、学習後の[モデル](./machine_learning.md#学習モデル)の[中間層](./neural_network.md#中間層)には入力された[特徴量](./machine_learning.md#特徴量)を圧縮した情報が存在する状態となる。最終的に[出力層](./neural_network.md#出力層)（あるいは後段の層）を取り除くことで、[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)を[特徴抽出](./neural_network.md#特徴抽出)器として利用することができる。\n\n"},{"term":"VAE（変分自己符号化器: Variational Autoencoder）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"vae","content":"\n**VAE**（**変分自己符号化器**: Variational Autoencoder）は、[オートエンコーダ](#オートエンコーダ)において[中間層](./neural_network.md#中間層)の潜在変数に[確率分布](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率分布)を用いることで、未知のデータに対しても[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)的に応用できる。[オートエンコーダ](#オートエンコーダ)は入力データと同じデータを出力することしかできないが、VAEは[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)的に様々なデータを生成することができる。\n\n\n"},{"term":"GAN（敵対的生成ネットワーク: Generative Adversarial Network）","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"gan","content":"\n**GAN**（**敵対的生成ネットワーク**: Generative Adversarial Network）は、データから特徴を学ぶことで実在しない偽造データを生成するGeneratorと、データが本物であるか偽造データであるかを識別するDiscriminatorからなるネットワーク。\n\n学習の方向性によっては、生成されるデータに偏りができる**モード崩壊**を起こす可能性がある。そういった場合は、[ハイパーパラメータ](./machine_learning.md#ハイパーパラメータ)の[チューニング](./machine_learning.md#チューニング)などを見直す必要がある。\n\n\n"},{"term":"モード崩壊","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"gan","content":"\n**GAN**（**敵対的生成ネットワーク**: Generative Adversarial Network）は、データから特徴を学ぶことで実在しない偽造データを生成するGeneratorと、データが本物であるか偽造データであるかを識別するDiscriminatorからなるネットワーク。\n\n学習の方向性によっては、生成されるデータに偏りができる**モード崩壊**を起こす可能性がある。そういった場合は、[ハイパーパラメータ](./machine_learning.md#ハイパーパラメータ)の[チューニング](./machine_learning.md#チューニング)などを見直す必要がある。\n\n\n"},{"term":"強化学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"強化学習","content":"\n強化学習の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)は大きく**モデルベース**と**モデルフリー**に大別できる。さらにモデルベースの学習は、**方策ベース**と**価値ベース**の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)に分類できる。\n\n"},{"term":"モデルベース","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"強化学習","content":"\n強化学習の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)は大きく**モデルベース**と**モデルフリー**に大別できる。さらにモデルベースの学習は、**方策ベース**と**価値ベース**の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)に分類できる。\n\n"},{"term":"方策ベース","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"強化学習","content":"\n強化学習の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)は大きく**モデルベース**と**モデルフリー**に大別できる。さらにモデルベースの学習は、**方策ベース**と**価値ベース**の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)に分類できる。\n\n"},{"term":"価値ベース","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"強化学習","content":"\n強化学習の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)は大きく**モデルベース**と**モデルフリー**に大別できる。さらにモデルベースの学習は、**方策ベース**と**価値ベース**の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)に分類できる。\n\n"},{"term":"モデルフリー","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"強化学習","content":"\n強化学習の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)は大きく**モデルベース**と**モデルフリー**に大別できる。さらにモデルベースの学習は、**方策ベース**と**価値ベース**の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)に分類できる。\n\n"},{"term":"Q学習","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"q学習","content":"\n**Q学習**は、[価値ベース](#強化学習)の[強化学習](./machine_learning.md#強化学習)手法で、対応表（Qテーブル）を用いてある状態においてある行動をとることがどれほど価値があるかを学習する。状態と行動の選択肢が増えると、Qテーブルが膨大になってしまうという欠点がある。\n\n"},{"term":"Experience Reply","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"experience-reply","content":""},{"term":"greedy方策","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"greedy方策","content":"\n**greedy方策**は、[価値ベース](#強化学習)の[強化学習](./machine_learning.md#強化学習)における[エージェント](./machine_learning.md#エージェント)の行動選択の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)のひとつで、最適行動価値関数がわかっていると仮定したときに、現在の状態に対して最適行動価値関数が最大となるような行動を選択する方法。\n\n学習中は最適行動価値関数が確定していないため、 $\\epsilon$ の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)でランダムな行動を選択し、 $1 - \\epsilon$ の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で最適な行動を選択する**ε-greedy方策**が用いられる。\n\n"},{"term":"ε-greedy方策","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"greedy方策","content":"\n**greedy方策**は、[価値ベース](#強化学習)の[強化学習](./machine_learning.md#強化学習)における[エージェント](./machine_learning.md#エージェント)の行動選択の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)のひとつで、最適行動価値関数がわかっていると仮定したときに、現在の状態に対して最適行動価値関数が最大となるような行動を選択する方法。\n\n学習中は最適行動価値関数が確定していないため、 $\\epsilon$ の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)でランダムな行動を選択し、 $1 - \\epsilon$ の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)で最適な行動を選択する**ε-greedy方策**が用いられる。\n\n"},{"term":"方策勾配法","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"方策勾配法","content":"\n**方策勾配法**は、[方策ベース](#強化学習)の[強化学習](./machine_learning.md#強化学習)における[エージェント](./machine_learning.md#エージェント)の行動選択の[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)のひとつで、方策をパラメータで表された関数として、パラメータを最適化することで方策を学習する方法。\n\n"},{"term":"REINFORCE","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"reinforce","content":"\n**REINFORCE**は、[方策勾配法](#方策勾配法)の代表的な[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、最初に行動を繰り返して状態・行動・報酬のデータを収集し、高い報酬を得ることのつながった行動の確率を高くする手法。\n\n"},{"term":"Actor-Critic","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"actor-critic","content":"\n**Actor-Critic**は、[方策ベース](#強化学習)の[モデル](./machine_learning.md#学習モデル)であるActor（状態を入力として各行動の[確率](../../../basics/applied_mathematics/_/chapters/probability_and_statistics.md#確率)を出力する）と、[価値ベース](#強化学習)の[モデル](./machine_learning.md#学習モデル)であるCritic（状態を入力として状態価値を出力する）を組み合わせて学習を進める。\n\n\n"},{"term":"物体検出","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"物体検出","content":"\n**物体検出**は、画像の中に何が写っている物体を認識する技術。**バウンディングボックス**という矩形の範囲を生成し、その中に含まれる物体の[ラベル](./machine_learning.md#ラベル)を出力する、というタスクを行う。\n\n物体検出は、注目領域の決定と物体の[ラベル](./machine_learning.md#ラベル)推測という2つのタスクを解決する必要がある。[sliding window method](#sliding-window-method)や[region proposal method](#region-proposal-method)は注目領域決定のための[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、[end-to-end](#end-to-end)は注目領域決定と物体の[ラベル](./machine_learning.md#ラベル)推測をまとめて行う[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)。\n\n"},{"term":"バウンディングボックス","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"物体検出","content":"\n**物体検出**は、画像の中に何が写っている物体を認識する技術。**バウンディングボックス**という矩形の範囲を生成し、その中に含まれる物体の[ラベル](./machine_learning.md#ラベル)を出力する、というタスクを行う。\n\n物体検出は、注目領域の決定と物体の[ラベル](./machine_learning.md#ラベル)推測という2つのタスクを解決する必要がある。[sliding window method](#sliding-window-method)や[region proposal method](#region-proposal-method)は注目領域決定のための[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)で、[end-to-end](#end-to-end)は注目領域決定と物体の[ラベル](./machine_learning.md#ラベル)推測をまとめて行う[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)。\n\n"},{"term":"sliding-window-method","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"sliding-window-method","content":""},{"term":"region-proposal-method","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"region-proposal-method","content":""},{"term":"end-to-end","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"end-to-end","content":"\n**end-to-end**は、注目領域決定と[ラベル](./machine_learning.md#ラベル)推測のタスクをひとつの[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)で行う手法。代表的な[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)として、**Faster R-CNN**、**SSD**、**Yolo**といったものがある。\n\n| アルゴリズム | 識別精度 | 処理速度 |\n|--------------|----------|----------|\n| Faster R-CNN | 高       | 低       |\n| SSD          | 中       | 中       |\n| Yolo         | 低       | 高       |\n"},{"term":"Faster R-CNN","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"end-to-end","content":"\n**end-to-end**は、注目領域決定と[ラベル](./machine_learning.md#ラベル)推測のタスクをひとつの[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)で行う手法。代表的な[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)として、**Faster R-CNN**、**SSD**、**Yolo**といったものがある。\n\n| アルゴリズム | 識別精度 | 処理速度 |\n|--------------|----------|----------|\n| Faster R-CNN | 高       | 低       |\n| SSD          | 中       | 中       |\n| Yolo         | 低       | 高       |\n"},{"term":"SSD","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"end-to-end","content":"\n**end-to-end**は、注目領域決定と[ラベル](./machine_learning.md#ラベル)推測のタスクをひとつの[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)で行う手法。代表的な[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)として、**Faster R-CNN**、**SSD**、**Yolo**といったものがある。\n\n| アルゴリズム | 識別精度 | 処理速度 |\n|--------------|----------|----------|\n| Faster R-CNN | 高       | 低       |\n| SSD          | 中       | 中       |\n| Yolo         | 低       | 高       |\n"},{"term":"Yolo","link":"./note/ja/./artificial_intelligence/_/chapters/neural_network_algorithm.md","flagment":"end-to-end","content":"\n**end-to-end**は、注目領域決定と[ラベル](./machine_learning.md#ラベル)推測のタスクをひとつの[ニューラルネットワーク](./neural_network.md#ニューラルネットワーク)で行う手法。代表的な[アルゴリズム](../../../programming/_/chapters/algorithm.md#アルゴリズム)として、**Faster R-CNN**、**SSD**、**Yolo**といったものがある。\n\n| アルゴリズム | 識別精度 | 処理速度 |\n|--------------|----------|----------|\n| Faster R-CNN | 高       | 低       |\n| SSD          | 中       | 中       |\n| Yolo         | 低       | 高       |\n"},{"term":"タグ","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"タグ","content":"\n**タグ**は、[HTML](#html)文書内で[要素](#要素)を定義するために使用されるマークアップ言語の記法。タグは `<>` で囲まれ、開始タグと終了タグのペアで構成される。開始タグは `<` の後に[要素](#要素)名が続き、終了タグは `</` の後に[要素](#要素)名が続く。\n\n\n"},{"term":"要素","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"要素","content":"\n**要素**は、[HTML](#html)文書内で意味のあるコンテンツや構造を定義するための、[タグ](#タグ)とコンテンツの組み合わせ。これにより[HTML](#html)文書内の様々な要素を表現し、[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)によって解釈される。要素は、テキスト、画像、リンク、ボタン、テーブル、フォームなど、様々な種類のコンテンツを表現するために使用される。\n\n"},{"term":"ブロック要素","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"ブロック要素","content":"\n**ブロック要素**は、ページ上で目に見えるブロックを形成する[HTML](#html)[要素](#要素)で、その前のコンテンツから改行して描画され、ブロック要素に続くコンテンツも新しい行に描画される。ブロック要素は[インライン](#インライン要素)の中に含めることはできないが、別のブロック要素の中に入れ子になることはできる。 `div` 、 `p` 、 `h1` 、 `ul` 、 `li` 、 `table` 、 `form` などはブロック要素に含まれる。\n\n"},{"term":"インライン要素","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"インライン要素","content":"\n**インライン要素**は、[ブロック要素](#ブロック要素)の中に包含され、文書のコンテンツの小さな部分だけを囲む[HTML](#html)[要素](#要素)。この[要素](#要素)は基本的にコンテンツ内で改行を行わず、テキストとともに使用される。 `span` 、 `a` 、 `img` 、 `strong` 、 `em` 、 `b` 、 `i` などはインライン要素に含まれる。\n\n"},{"term":"空要素","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"空要素","content":"\n**空要素**は、単一の[タグ](#タグ)によって構成される（内容や[終了タグ](#タグ)を持たない）[HTML](#html)[要素](#要素)。 `img` 、 `br` 、 `hr` 、 `input` などは空要素に含まれる。\n\n\n"},{"term":"属性","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"属性","content":"\n**属性**は、[HTML](#html)[要素](#要素)に対する追加情報や設定を提供するために使用される。[開始タグ](#タグ)内に記述され、属性名と属性値のペアで表現される。 `class` 、 `href` 、 `src` 、 `alt` 、 `type` 、 `name` などの属性があり、全ての[要素](#要素)に共通する属性もあれば、特定の[要素](#要素)の挙動や外観を制御するために使用される属性もある。\n\n"},{"term":"論理属性","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"論理属性","content":"\n**論理属性**は、[HTML](#html)[要素](#要素)に対して付与される[属性](#属性)のうち、属性値を持たないもの。論理属性は[要素](#要素)の意味や役割を示し、[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)によって動作や表示が制御される。 `disabled` 、 `readonly` 、 `required` 、 `hidden` 、 `checked` などの論理属性がある。\n\n\n"},{"term":"実体参照","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"実体参照","content":"\n**実体参照**は、[HTML](#html)文書内で、特別な意味として扱われる文字や特定の記号を表示するための記法。 `<` 、 `>` 、 `\"` 、 `'` 、 `&` といった文字はHTMLの構文の一部であり、テキストにこれらの文字を含めようとしても[HTML](#html)のコードとして解釈されてしまう。\n\n| 実際の文字 | 等価な文字参照 |\n| ---------- | -------------- |\n| <          | `&lt;`         |\n| >          | `&gt;`         |\n| \"          | `&quot;`       |\n| '          | `&apos;`       |\n| &          | `&amp;`        |\n\nこれらの記号以外に対して実体参照を使用する必要はない（現代の[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)は、文字エンコーディングが[UTF-8](../../../../basics/information_theory/_/chapters/character_representation.md#unicode)であれば、実際の記号を正しく扱うことができるため）。\n\n\n"},{"term":"コメント","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"コメント","content":"\n**コメント**は、[HTML](#html)文書内に記述されるコードのうち、[ブラウザ](../../../../network/_/chapters/web.md#webブラウザ)によって無視され、画面上に描画されることのない部分。コメントを記述するには、特別なマーカである `<!--` と `-->` で内容を囲む。\n\n```html\n<!-- コメント -->\n<p>Hello, World</p>\n```\n\n\n"},{"term":"ヘッド部","link":"./note/ja/./web_development/html/_/chapters/html.md","flagment":"ヘッド部","content":"\n**ヘッド部***は、[HTML](#html)文書のうち、ページが読み込まれても[Webブラウザ](../../../../network/_/chapters/web.md#webブラウザ)に表示されない部分。 `html` [タグ](#タグ)内で `head` [タグ](#タグ)で囲まれた領域がヘッド部となる。 `title` やCSSおよび[JavaScript](../../../../programming/_/chapters/programming_language.md#javascript)へのリンク、独自のファビコンへのリンク、その他のメタデータの情報を含む。\n"},{"term":"集中管理方式（集中型）","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"集中管理方式","content":"\n**集中管理方式**（**集中型**）の[バージョン管理システム](#バージョン管理システム)は、バージョン管理のための専用[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リポジトリ](./create_repository.md#リポジトリ)を用意しておき、その[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上で履歴を一元管理する。ユーザは[サーバ](../../../../computer/_/chapters/computer.md#サーバ)から自身の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)のコピーをダウンロードし、変更を加えたらその変更を[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)に記録する。\n\nユーザは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に繋がっていない状態だと、変更を記録することができない。また、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が[単一障害点](../../../../system/_/chapters/system_architecture.md#単一障害点)となっており、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)が破損するとデータが復旧できない可能性がある。\n\n集中管理方式の[バージョン管理システム](#バージョン管理システム)としては、**CVS**や**SVN**が代表的。\n\n"},{"term":"CVS","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"集中管理方式","content":"\n**集中管理方式**（**集中型**）の[バージョン管理システム](#バージョン管理システム)は、バージョン管理のための専用[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リポジトリ](./create_repository.md#リポジトリ)を用意しておき、その[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上で履歴を一元管理する。ユーザは[サーバ](../../../../computer/_/chapters/computer.md#サーバ)から自身の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)のコピーをダウンロードし、変更を加えたらその変更を[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)に記録する。\n\nユーザは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に繋がっていない状態だと、変更を記録することができない。また、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が[単一障害点](../../../../system/_/chapters/system_architecture.md#単一障害点)となっており、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)が破損するとデータが復旧できない可能性がある。\n\n集中管理方式の[バージョン管理システム](#バージョン管理システム)としては、**CVS**や**SVN**が代表的。\n\n"},{"term":"SVN","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"集中管理方式","content":"\n**集中管理方式**（**集中型**）の[バージョン管理システム](#バージョン管理システム)は、バージョン管理のための専用[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リポジトリ](./create_repository.md#リポジトリ)を用意しておき、その[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上で履歴を一元管理する。ユーザは[サーバ](../../../../computer/_/chapters/computer.md#サーバ)から自身の[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)に[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)のコピーをダウンロードし、変更を加えたらその変更を[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)に記録する。\n\nユーザは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に繋がっていない状態だと、変更を記録することができない。また、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が[単一障害点](../../../../system/_/chapters/system_architecture.md#単一障害点)となっており、[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上の[リポジトリ](./create_repository.md#リポジトリ)が破損するとデータが復旧できない可能性がある。\n\n集中管理方式の[バージョン管理システム](#バージョン管理システム)としては、**CVS**や**SVN**が代表的。\n\n"},{"term":"分散管理方式（分散型）","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"分散管理方式","content":"\n**分散管理方式**（**分散型**）の[バージョン管理システム](#バージョン管理システム)は、全ユーザの変更を集約する中央[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リポジトリ](./create_repository.md#リポジトリ)を設置し、個々の作業用[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にはその[リポジトリ](./create_repository.md#リポジトリ)の複製（[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)）を作成する。変更履歴の管理は各々の[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)上で行われ、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と同期することで変更内容を共有する。\n\nユーザは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に接続されていなくても[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)上でほとんどの操作を行うことができる。また、各[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上に[リポジトリ](./create_repository.md#リポジトリ)の複製が存在するため、中央[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[リポジトリ](./create_repository.md#リポジトリ)が破損した場合の復旧が容易である。\n\n分散管理方式の[バージョン管理システム](#バージョン管理システム)としては、[Git](#git)や**Mercurial**が代表的。\n\n\n"},{"term":"Mercurial","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"分散管理方式","content":"\n**分散管理方式**（**分散型**）の[バージョン管理システム](#バージョン管理システム)は、全ユーザの変更を集約する中央[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に[リポジトリ](./create_repository.md#リポジトリ)を設置し、個々の作業用[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にはその[リポジトリ](./create_repository.md#リポジトリ)の複製（[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)）を作成する。変更履歴の管理は各々の[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)上で行われ、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と同期することで変更内容を共有する。\n\nユーザは[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に接続されていなくても[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)上でほとんどの操作を行うことができる。また、各[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)上に[リポジトリ](./create_repository.md#リポジトリ)の複製が存在するため、中央[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の[リポジトリ](./create_repository.md#リポジトリ)が破損した場合の復旧が容易である。\n\n分散管理方式の[バージョン管理システム](#バージョン管理システム)としては、[Git](#git)や**Mercurial**が代表的。\n\n\n"},{"term":"Git","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"git","content":"\n**Git**は、開発におけるデファクトスタンダードとなっている[分散型](#分散管理方式)[バージョン管理システム](#バージョン管理システム)。もともとは[Linux](../../../../computer/software/_/chapters/operating_system.md#linux)の開発のためにLinus Torvaldsによって実装され、巨大な[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)であっても変更点の抽出や[リポジトリ](./create_repository.md#リポジトリ)操作が高速にできるように工夫されている。\n\n"},{"term":"GUIソフトウェア","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"guiソフトウェア","content":"\n[Git](#git)[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)は、[ターミナル](../../../../computer/linux/_/chapters/shell_and_terminal.md#ターミナル)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)上で[CLI](../../../../computer/software/_/chapters/software.md#cui)として利用できる。[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)による操作が苦手な場合は、[Git](#git)用の[GUI](../../../../computer/software/_/chapters/software.md#gui)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)をインストールすることで直感的な操作が可能となる。\n\n代表的な[Git](#git)の[GUI](../../../../computer/software/_/chapters/software.md#gui)クライアント[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)は以下の通り。\n\n- [SourceTree](https://www.sourcetreeapp.com/)\n- [Git Fork](https://git-fork.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n\n"},{"term":"SourceTree","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"guiソフトウェア","content":"\n[Git](#git)[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)は、[ターミナル](../../../../computer/linux/_/chapters/shell_and_terminal.md#ターミナル)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)上で[CLI](../../../../computer/software/_/chapters/software.md#cui)として利用できる。[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)による操作が苦手な場合は、[Git](#git)用の[GUI](../../../../computer/software/_/chapters/software.md#gui)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)をインストールすることで直感的な操作が可能となる。\n\n代表的な[Git](#git)の[GUI](../../../../computer/software/_/chapters/software.md#gui)クライアント[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)は以下の通り。\n\n- [SourceTree](https://www.sourcetreeapp.com/)\n- [Git Fork](https://git-fork.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n\n"},{"term":"Git Fork","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"guiソフトウェア","content":"\n[Git](#git)[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)は、[ターミナル](../../../../computer/linux/_/chapters/shell_and_terminal.md#ターミナル)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)上で[CLI](../../../../computer/software/_/chapters/software.md#cui)として利用できる。[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)による操作が苦手な場合は、[Git](#git)用の[GUI](../../../../computer/software/_/chapters/software.md#gui)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)をインストールすることで直感的な操作が可能となる。\n\n代表的な[Git](#git)の[GUI](../../../../computer/software/_/chapters/software.md#gui)クライアント[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)は以下の通り。\n\n- [SourceTree](https://www.sourcetreeapp.com/)\n- [Git Fork](https://git-fork.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n\n"},{"term":"GitKraken","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"guiソフトウェア","content":"\n[Git](#git)[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)は、[ターミナル](../../../../computer/linux/_/chapters/shell_and_terminal.md#ターミナル)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)上で[CLI](../../../../computer/software/_/chapters/software.md#cui)として利用できる。[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)による操作が苦手な場合は、[Git](#git)用の[GUI](../../../../computer/software/_/chapters/software.md#gui)[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)をインストールすることで直感的な操作が可能となる。\n\n代表的な[Git](#git)の[GUI](../../../../computer/software/_/chapters/software.md#gui)クライアント[ソフトウェア](../../../../computer/software/_/chapters/software.md応用ソフトウェア)は以下の通り。\n\n- [SourceTree](https://www.sourcetreeapp.com/)\n- [Git Fork](https://git-fork.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n\n"},{"term":"Gitホスティングサービス","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"gitホスティングサービス","content":"\n**Gitホスティングサービス**は、クラウド上で[Git](#git)の環境が整えられた[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をサービスとして提供した[SaaS](../../../../system/_/chapters/system_architecture.md#saas)。Gitホスティングサービスを利用することで、自身で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を用意することなく手軽に[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を共有するための[リモートリポジトリ](./record_history.md#リモートリポジトリ)を用意することができる。\n\n代表的なGitホスティングサービスとしては**GitHub**や**GitLab**、**BitBucket**などがある。\n\n- [GitHub](https://github.co.jp/)\n- [GitLab](https://about.gitlab.com/)\n- [BitBucket](https://bitbucket.org/)\n"},{"term":"GitHub","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"gitホスティングサービス","content":"\n**Gitホスティングサービス**は、クラウド上で[Git](#git)の環境が整えられた[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をサービスとして提供した[SaaS](../../../../system/_/chapters/system_architecture.md#saas)。Gitホスティングサービスを利用することで、自身で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を用意することなく手軽に[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を共有するための[リモートリポジトリ](./record_history.md#リモートリポジトリ)を用意することができる。\n\n代表的なGitホスティングサービスとしては**GitHub**や**GitLab**、**BitBucket**などがある。\n\n- [GitHub](https://github.co.jp/)\n- [GitLab](https://about.gitlab.com/)\n- [BitBucket](https://bitbucket.org/)\n"},{"term":"GitLab","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"gitホスティングサービス","content":"\n**Gitホスティングサービス**は、クラウド上で[Git](#git)の環境が整えられた[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をサービスとして提供した[SaaS](../../../../system/_/chapters/system_architecture.md#saas)。Gitホスティングサービスを利用することで、自身で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を用意することなく手軽に[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を共有するための[リモートリポジトリ](./record_history.md#リモートリポジトリ)を用意することができる。\n\n代表的なGitホスティングサービスとしては**GitHub**や**GitLab**、**BitBucket**などがある。\n\n- [GitHub](https://github.co.jp/)\n- [GitLab](https://about.gitlab.com/)\n- [BitBucket](https://bitbucket.org/)\n"},{"term":"BitBucket","link":"./note/ja/./development/git/_/chapters/git.md","flagment":"gitホスティングサービス","content":"\n**Gitホスティングサービス**は、クラウド上で[Git](#git)の環境が整えられた[サーバ](../../../../computer/_/chapters/computer.md#サーバ)をサービスとして提供した[SaaS](../../../../system/_/chapters/system_architecture.md#saas)。Gitホスティングサービスを利用することで、自身で[サーバ](../../../../computer/_/chapters/computer.md#サーバ)を用意することなく手軽に[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)を共有するための[リモートリポジトリ](./record_history.md#リモートリポジトリ)を用意することができる。\n\n代表的なGitホスティングサービスとしては**GitHub**や**GitLab**、**BitBucket**などがある。\n\n- [GitHub](https://github.co.jp/)\n- [GitLab](https://about.gitlab.com/)\n- [BitBucket](https://bitbucket.org/)\n"},{"term":"system","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"設定のレベル","content":"\n[Git](./git.md#git)の設定にはレベルがあり、異なるレベルに同じ設定が登録されている場合には `local > global > system` の順に優先して適用される。\n\n| レベル | 適用範囲                           | 設定ファイルの場所(Linux)               | オプション |\n|--------|------------------------------------|-----------------------------------------|------------|\n| system | システム上の全ユーザの全リポジトリ | `/etc/gitconfig`                        | `--system` |\n| global | ログイン中のユーザの全リポジトリ   | `~/.gitconfig` , `~/.config/git/config` | `--global` |\n| local  | 各リポジトリ内                     | `<path>/.git/config`                    | `--local`  |\n\n"},{"term":"global","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"設定のレベル","content":"\n[Git](./git.md#git)の設定にはレベルがあり、異なるレベルに同じ設定が登録されている場合には `local > global > system` の順に優先して適用される。\n\n| レベル | 適用範囲                           | 設定ファイルの場所(Linux)               | オプション |\n|--------|------------------------------------|-----------------------------------------|------------|\n| system | システム上の全ユーザの全リポジトリ | `/etc/gitconfig`                        | `--system` |\n| global | ログイン中のユーザの全リポジトリ   | `~/.gitconfig` , `~/.config/git/config` | `--global` |\n| local  | 各リポジトリ内                     | `<path>/.git/config`                    | `--local`  |\n\n"},{"term":"local","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"設定のレベル","content":"\n[Git](./git.md#git)の設定にはレベルがあり、異なるレベルに同じ設定が登録されている場合には `local > global > system` の順に優先して適用される。\n\n| レベル | 適用範囲                           | 設定ファイルの場所(Linux)               | オプション |\n|--------|------------------------------------|-----------------------------------------|------------|\n| system | システム上の全ユーザの全リポジトリ | `/etc/gitconfig`                        | `--system` |\n| global | ログイン中のユーザの全リポジトリ   | `~/.gitconfig` , `~/.config/git/config` | `--global` |\n| local  | 各リポジトリ内                     | `<path>/.git/config`                    | `--local`  |\n\n"},{"term":"セクション","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"セクション","content":"\n**セクション**は、いくつかの設定値をまとめたグループ。\n\n"},{"term":"キー","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"キー","content":"\n**キー**は、[セクション](#セクション)内の個別の設定値。\n\n\n"},{"term":"git config","link":"./note/ja/./development/git/_/chapters/git_config.md","flagment":"設定の変更","content":"\n`git config` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に変更したい項目の[セクション](#セクション)と[キー](#キー)、登録したい値を与えることで、設定を変更できる。\n\n```sh\n"},{"term":"リポジトリ","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"リポジトリ","content":"\n**リポジトリ**は、[Git](./git.md#git)の変更履歴を管理する[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)、あるいはデータ構造。リポジトリの配下の[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)は、履歴管理の対象となる。\n\n開発チームや一般に公開されている[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上のリポジトリを[リモートリポジトリ](./record_history.md#リモートリポジトリ)、ユーザの作業用[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)にコピーしたリポジトリを[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)という。\n\n"},{"term":"ベアリポジトリ","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"ベアリポジトリ","content":"\n**ベアリポジトリ**は、[ワークツリー](./record_history.md#ワークツリー)を持たない[リポジトリ](#リポジトリ)で、変更履歴の管理のみを行う。\n\n"},{"term":"ノンベアリポジトリ","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"ノンベアリポジトリ","content":"\n**ノンベアリポジトリ**は、[ワークツリー](./record_history.md#ワークツリー)を持つ、ユーザが作業を行う[リポジトリ](#リポジトリ)。\n\n\n"},{"term":"git init","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"リポジトリの初期化","content":"\n`git init` は、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)内で[Git](./git.md#git)の管理対象としたい任意の[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)を、[リポジトリ](#リポジトリ)として初期化するには[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"クローン","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"クローン","content":"\n**クローン**は、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の複製をローカルに作成する操作。基本的にはプロジェクトに加わった際に、最初に1度だけ実行する操作であり、それ以降の[リモートリポジトリ](./record_history.md#リモートリポジトリ)からの差分の取得には[フェッチ](./repository_sync.md#フェッチ)や[プル](./repository_sync.md#プル)を用いる。\n\nクローン元となった[リモートリポジトリ](./record_history.md#リモートリポジトリ)は、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に `origin` という[エイリアス](./remote_repository.md#エイリアス)で登録される。\n\n[リポジトリ](#リポジトリ)のクローンには、 `git clone` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"git clone","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"クローン","content":"\n**クローン**は、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の複製をローカルに作成する操作。基本的にはプロジェクトに加わった際に、最初に1度だけ実行する操作であり、それ以降の[リモートリポジトリ](./record_history.md#リモートリポジトリ)からの差分の取得には[フェッチ](./repository_sync.md#フェッチ)や[プル](./repository_sync.md#プル)を用いる。\n\nクローン元となった[リモートリポジトリ](./record_history.md#リモートリポジトリ)は、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に `origin` という[エイリアス](./remote_repository.md#エイリアス)で登録される。\n\n[リポジトリ](#リポジトリ)のクローンには、 `git clone` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"フォーク","link":"./note/ja/./development/git/_/chapters/create_repository.md","flagment":"フォーク","content":"\n**フォーク**は、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の複製を別の[リモートリポジトリ](./record_history.md#リモートリポジトリ)として作成する操作。[クローン](#クローン)はあるプロジェクトに参加する場合などに用いるのに対し、フォークはあるプロジェクトを元に別のプロジェクトを作成したい場合に用いる。\n\n実際にはワークフローの違いだけであり、新規に作成した[リモートリポジトリ](./record_history.md#リモートリポジトリ)に対して `git clone` した[リポジトリ](#リポジトリ)を[プッシュ](./repository_sync.md#プッシュ)することで、[リポジトリ](#リポジトリ)をフォークできる。\n"},{"term":"エイリアス（ショートカット）","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"エイリアス","content":"\n**エイリアス**（**ショートカット**）は、紐づく[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[URL](../../../../network/_/chapters/web.md#url)に対してつけることができる任意の名前。\n\n"},{"term":"origin","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"origin","content":"\n`origin` は、[クローン](./create_repository.md#クローン)元の[リモートリポジトリ](./record_history.md#リモートリポジトリ)を指す[エイリアス](#エイリアス)で、[クローン](./create_repository.md#クローン)を行った際に[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に自動的にエントリが追加される。\n\n\n"},{"term":"git remote","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"リモートリポジトリとの接続を一覧表示","content":"\n`git remote` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いると、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に紐づく[リモートリポジトリ](./record_history.md#リモートリポジトリ)を確認できる。また、 `-v` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を追加することで詳細を確認することができる。\n\n```sh\n"},{"term":"git remote add","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"リモートリポジトリとの接続を追加","content":"\n`git remote add` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いることで、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に新たな[リモートリポジトリ](./record_history.md#リモートリポジトリ)のエントリを追加できる。エントリの追加の際には、任意の[エイリアス](#エイリアス)と[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[URL](../../../../network/_/chapters/web.md#url)を指定する必要がある。\n\n```sh\n"},{"term":"git remote rm","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"リモートリポジトリとの接続を削除","content":"\n`git remote rm` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いることで、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)に紐づく[リモートリポジトリ](./record_history.md#リモートリポジトリ)のエントリを削除できる。削除対象の[エイリアス](#エイリアス)を指定して接続を削除する。\n\n```git\n"},{"term":"git remote rename","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"リモートリポジトリとの接続を編集","content":"\n`git remote rename` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いることで、[リモートリポジトリ](./record_history.md#リモートリポジトリ)のエントリの[エイリアス](#エイリアス)を変更できる。また、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[URL](../../../../network/_/chapters/web.md#url)を変更するには、 `git remote set-url` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```git\n"},{"term":"git remote set-url","link":"./note/ja/./development/git/_/chapters/remote_repository.md","flagment":"リモートリポジトリとの接続を編集","content":"\n`git remote rename` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いることで、[リモートリポジトリ](./record_history.md#リモートリポジトリ)のエントリの[エイリアス](#エイリアス)を変更できる。また、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[URL](../../../../network/_/chapters/web.md#url)を変更するには、 `git remote set-url` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```git\n"},{"term":"ワークツリー（ワーキングディレクトリ）","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ワークツリー","content":"\n**ワークツリー**（**ワーキングディレクトリ**）は、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の編集作業を行う[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)。この領域での変更内容はまだ[リポジトリ](./create_repository.md#リポジトリ)に記録されていない状態となる。\n\n"},{"term":"ステージ（インデックス）","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ステージ","content":"\n**ステージ**（**インデックス**）は、変更履歴を作成するための中間領域。[コミット](#コミット)に含めたい[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)は一時的にステージに移動する必要がある。\n\n"},{"term":"ローカルリポジトリ","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ローカルリポジトリ","content":"\n**ローカルリポジトリ**は、実際に[コミット](#コミット)履歴が記録される領域。[コミット](#コミット)しただけでは[リモートリポジトリ](#リモートリポジトリ)には反映されず、あくまで自身のローカル環境でのみ履歴として追加される。また、複数の[リモートリポジトリ](#リモートリポジトリ)と紐づけることも可能。基本的には[ノンベアリポジトリ](./create_repository.md#ノンベアリポジトリ)で運用される。\n\n"},{"term":"リモートリポジトリ","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"リモートリポジトリ","content":"\n**リモートリポジトリ**は、各ユーザの[ローカルリポジトリ](#ローカルリポジトリ)の変更を集約し、全体の[コミット](#コミット)履歴を管理する領域。[インターネット](../../../../network/_/chapters/network.md#インターネット)や[サーバ](../../../../computer/_/chapters/computer.md#サーバ)上に用意する[リポジトリ](./create_repository.md#リポジトリ)で、開発者間で変更内容を共有したり、開発した[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を[OSS](../../../../computer/software/_/chapters/open_source_software.md#オープンソースソフトウェア)として公開するために用いられる。基本的には[ベアリポジトリ](./create_repository.md#ベアリポジトリ)で運用される。\n\n\n"},{"term":"git status","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"状態の確認","content":"\n`git status` は、[ワークツリー](#ワークツリー)、[ステージ](#ステージ)にある[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ git status\n```\n\n特に変更がない場合は次のような出力となる。\n\n```sh\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n```\n\n新しく[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を追加した場合には次のような出力となる。\n\n```sh\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        example.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)に変更を加えた場合は次のような出力となる。\n\n```sh\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   example.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n[ステージエリア](#ステージ)に[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)が存在する場合は次のような出力となる。\n\n```sh\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   example1.txt\n        new file:   example2.txt\n```\n\n"},{"term":"ステージング","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ステージング","content":"\n**ステージング**は、履歴として記録したい[ワークツリー](#ワークツリー)の変更内容を一時的に[ステージエリア](#ステージ)に登録する操作。ステージングしただけでは変更は履歴に記録されないので注意が必要。\n\nステージングには、 `git add` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"git add","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ステージング","content":"\n**ステージング**は、履歴として記録したい[ワークツリー](#ワークツリー)の変更内容を一時的に[ステージエリア](#ステージ)に登録する操作。ステージングしただけでは変更は履歴に記録されないので注意が必要。\n\nステージングには、 `git add` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"インタラクティブセッション","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"インタラクティブセッション","content":"\n`git add` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に `-p` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、インタラクティブな[ステージング](#ステージング)セッションが開始される。このモードでは、順番に変更内容の[ハンク](#ハンク)が表示され、 `y` を選択するとその[ハンク](#ハンク)を[ステージ](#ステージ)に移動し、 `n` を選択するとその[ハンク](#ハンク)を無視する。また、 `s` を選択すると[ハンク](#ハンク)がさらに細かく分解され、 `e` を選択するとその[ハンク](#ハンク)を手作業で編集でき、 `q` を選択するとインタラクティブセッションを終了する。\n\n```sh\n$ git add -p\ndiff --git a/example.txt b/example.txt\nindex xxxxxxx..xxxxxxx 000000\n--- a/example.txt\n+++ b/example.txt\n@@ -1,0 +1,1 @@\n+Hello, Git!\n\n(1/1) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?\n```\n\n\n"},{"term":"git restore","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"ファイルの復元","content":"\n`git restore` は、指定した[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の変更内容を取り消し、元の状態を復元する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"コミット","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミット","content":"\n**コミット**は、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)の変更を履歴に記録する操作、あるいはその変更履歴。[リポジトリ](./create_repository.md#リポジトリ)の変更履歴は**リビジョン**と呼ぶ場合もある。\n\n[Git](./git.md#git)では、コミットごとに差分のみ記録するのではなく、毎回すべての[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の**スナップショット**（ある時点での[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)や[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)などの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンの[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。\n\nコミットには、 `git commit` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"リビジョン","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミット","content":"\n**コミット**は、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)の変更を履歴に記録する操作、あるいはその変更履歴。[リポジトリ](./create_repository.md#リポジトリ)の変更履歴は**リビジョン**と呼ぶ場合もある。\n\n[Git](./git.md#git)では、コミットごとに差分のみ記録するのではなく、毎回すべての[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の**スナップショット**（ある時点での[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)や[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)などの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンの[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。\n\nコミットには、 `git commit` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"git commit","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミット","content":"\n**コミット**は、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)の変更を履歴に記録する操作、あるいはその変更履歴。[リポジトリ](./create_repository.md#リポジトリ)の変更履歴は**リビジョン**と呼ぶ場合もある。\n\n[Git](./git.md#git)では、コミットごとに差分のみ記録するのではなく、毎回すべての[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の**スナップショット**（ある時点での[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)や[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)、[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)などの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンの[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。\n\nコミットには、 `git commit` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。\n\n```sh\n"},{"term":"コミットハッシュ","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミットハッシュ","content":"\n**コミットハッシュ**は、[コミット](#コミット)ごとに生成される、40桁の文字列。コミットハッシュを指定することで、[コミット](#コミット)の履歴から特定の[コミット](#コミット)を絞り込むことができる。\n\n"},{"term":"HEAD","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミットハッシュのエイリアス","content":"\n[コミット](#コミット)履歴のうち特別な意味を持つ[コミット](#コミット)に対しては、[コミットハッシュ](#コミットハッシュ)のエイリアスが指定されている。\n\n| エイリアス                          | 概要                                   |\n|-------------------------------------|----------------------------------------|\n| `HEAD`, `@`                         | 現在のHEADコミット                     |\n| `HEAD^` , `HEAD~` , `@^` , `@~`     | 1つ前のコミット                        |\n| `HEAD^^` , `HEAD~~` , `@^^` , `@~~` | 2つ前のコミット                        |\n| `HEAD~{n}` , `@~{n}`                | n個前のコミット                        |\n| `HEAD^{n}` , `@^{n}`                | 親コミットが複数ある場合のコミット指定 |\n\n"},{"term":"コミットメッセージ","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミットメッセージ","content":"$ git commit -m \"<message>\"\n```\n\n"},{"term":"--amend","link":"./note/ja/./development/git/_/chapters/record_history.md","flagment":"コミットの修正","content":"\n`git commit` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に `--amend` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、直前の[コミット](#コミット)の[コミットメッセージ](#コミットメッセージ)を修正できる。\n\n```sh\n"},{"term":"git push","link":"./note/ja/./development/git/_/chapters/repository_sync.md","flagment":"プッシュ","content":"\n**プッシュ**(Push)は、自身の[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)の[コミット](./record_history.md#コミット)履歴を、[リモートリポジトリ](./record_history.md#リモートリポジトリ)にアップロードする操作。\n\nプッシュは、 `git push` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いて、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と[ブランチ](./branch.md#ブランチ)を指定して行う。\n\n```sh\n"},{"term":"git fetch","link":"./note/ja/./development/git/_/chapters/repository_sync.md","flagment":"フェッチ","content":"\n**フェッチ**(Fetch)は、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[コミット](./record_history.md#コミット)履歴を、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)の[トピックブランチ](./branch.md#ブランチ)にダウンロードする操作。\n\nフェッチは、 `git fetch` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いて、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と[ブランチ](./branch.md#ブランチ)を指定して行う。フェッチを行うと、変更は即座に同名の[ブランチ](./branch.md#ブランチ)に反映されるわけではなく、 `<remote>/<branch>` という名前の[トピックブランチ](./branch.md#ブランチ)に取り込まれる。任意の[ブランチ](./branch.md#ブランチ)に変更を取り込みたい場合、[マージ](./branch.md#マージ)を行う必要がある。\n\n```sh\n"},{"term":"git pull","link":"./note/ja/./development/git/_/chapters/repository_sync.md","flagment":"プル","content":"\n**プル**(Pull)は、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[コミット](./record_history.md#コミット)履歴を、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)の同名[ブランチ](./branch.md#ブランチ)に即座にダウンロードする操作。\n\nプルは、 `git pull` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いて、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と[ブランチ](./branch.md#ブランチ)を指定して行う。プルは[フェッチ](#フェッチ)と[マージ](./branch.md#マージ)を組み合わせた操作で、[リモートリポジトリ](./record_history.md#リモートリポジトリ)の変更を `<remote>/<branch>` という名前の[トピックブランチ](./branch.md#ブランチ)に一時的に取り込み、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)の同名の[ブランチ](./branch.md#ブランチ)に[マージ](./branch.md#マージ)する。\n\n```sh\n"},{"term":"git log","link":"./note/ja/./development/git/_/chapters/commit_history.md","flagment":"履歴の確認","content":"\n`git log` は、[コミット](./record_history.md#コミット)履歴を確認するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ git log\ncommit xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (HEAD -> main, origin/main, origin/HEAD)\nAuthor: name <example@example.com>\nDate:   Thu Feb 2 00:00:00 2023\n\n    feat: Add new utility functions\n\ncommit xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nAuthor: name <example@example.com>\nDate:   Wed Feb 1 00:00:00 2023\n\n    Initial commit\n```\n\n"},{"term":"git revert","link":"./note/ja/./development/git/_/chapters/commit_history.md","flagment":"コミットの打ち消し","content":"\n`git revert` は、任意の[コミット](./record_history.md#コミット)を打ち消すための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[コミット](./record_history.md#コミット)履歴を削除するのではなく、特定の[コミット](./record_history.md#コミット)を打ち消すような新しい[コミット](./record_history.md#コミット)を作成する。[コミット](./record_history.md#コミット)履歴を破壊しないため、[リモートリポジトリ](./record_history.md#リモートリポジトリ)と同期済みの[コミット](./record_history.md#コミット)を取り消しても安全。また、この[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)では特定の[コミット](./record_history.md#コミット)のみを打ち消すため、指定した[コミット](./record_history.md#コミット)以降のすべての変更内容を元に戻すわけではない。\n\n```sh\n"},{"term":"git reset","link":"./note/ja/./development/git/_/chapters/commit_history.md","flagment":"コミットの取り消し","content":"\n`git reset` は、[コミット](./record_history.md#コミット)を取り消すための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[ブランチ](./branch.md#ブランチ)上の `HEAD` の位置を移動し、[オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)に応じて[ステージ](./record_history.md#ステージ)と[ワークツリー](./record_history.md#ワークツリー)の状態も変更する。\n\n| オプション | 概要                                                                                      |\n|------------|-------------------------------------------------------------------------------------------|\n| `--hard`   | `HEAD` を指定の位置に移動し、ステージとワークツリーをその時の状態に戻す                   |\n| `--mixed`  | `HEAD` を指定の位置に移動し、ステージをその時の状態に戻す（ワークツリーの変更内容は維持） |\n| `--soft`   | `HEAD` を指定の位置に移動する（ステージとワークツリーの変更内容は維持）                   |\n\n```sh\n"},{"term":"git reflog","link":"./note/ja/./development/git/_/chapters/commit_history.md","flagment":"gitの操作履歴","content":"\n`git reflog` は、[Git](./git.md#git)の操作履歴を確認するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[Git](./git.md#git)では操作履歴に対してもハッシュがついており、 `git reset` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)にハッシュあるいは `HEAD@{0}` のようなエイリアスを指定することで、その操作を取り消すとこができる。誤って必要な[ブランチ](./branch.md#ブランチ)を消してしまったり、[ワークツリー](./record_history.md#ワークツリー)の変更内容を破棄してしまった場合などに、その操作を取り消すことで復旧できる。\n\n```sh\n$ git reflog\nxxxxxxx (HEAD -> main, origin/main, origin/HEAD) HEAD@{0}: commit: example commit\nxxxxxxx HEAD@{1}: pull origin main: Fast-forward\nxxxxxxx HEAD@{2}: checkout: moving from exampole to main\n```\n"},{"term":"git diff","link":"./note/ja/./development/git/_/chapters/difference_comparison.md","flagment":"差分の比較","content":"\n`git diff` は、2つの入力データセットを比較して、その差分を出力する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定しなかった場合は、 `HEAD` と[ワークツリー](./record_history.md#ワークツリー)の差分を出力する。\n\n```sh\n$ git diff\n```\n\n"},{"term":"git show","link":"./note/ja/./development/git/_/chapters/difference_comparison.md","flagment":"特定のコミットの確認","content":"\n`git show` は、[コミットハッシュ](./record_history.md#コミットハッシュ)を指定することで、指定した[コミット](./record_history.md#コミット)と直前の[コミット](./record_history.md#コミット)を `git diff` した結果を出力できる。\n\n```sh\n"},{"term":"ブランチ","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"ブランチ","content":"\n**ブランチ**は、[リポジトリ](./create_repository.md#リポジトリ)の[コミット](./record_history.md#コミット)履歴を分岐させる機能、あるいは枝分かれした流れ。一般的には管理の本流となるブランチを `master` ( `main` )とし、分岐させるブランチのことを**トピックブランチ**という。複数人が各自[バグ](../../../../programming/_/chapters/programming.md#バグ)修正や新機能の開発を並行して行うような場合に、各々がトピックブランチ上で作業を進めることで、他のユーザの作業に影響を受けることなく独立した状態を保つことができる。\n\n"},{"term":"トピックブランチ","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"ブランチ","content":"\n**ブランチ**は、[リポジトリ](./create_repository.md#リポジトリ)の[コミット](./record_history.md#コミット)履歴を分岐させる機能、あるいは枝分かれした流れ。一般的には管理の本流となるブランチを `master` ( `main` )とし、分岐させるブランチのことを**トピックブランチ**という。複数人が各自[バグ](../../../../programming/_/chapters/programming.md#バグ)修正や新機能の開発を並行して行うような場合に、各々がトピックブランチ上で作業を進めることで、他のユーザの作業に影響を受けることなく独立した状態を保つことができる。\n\n"},{"term":"git branch","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"ブランチの確認","content":"\n`git branch` は、[リポジトリ](./create_repository.md#リポジトリ)上の[ブランチ](#ブランチ)の一覧を表示する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定しない場合は[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)の[ブランチ](#ブランチ)を、 `-r` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定すると[リモートリポジトリ](./record_history.md#リモートリポジトリ)の[ブランチ](#ブランチ)を確認できる。また、 `-a` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、[ローカルリポジトリ](./record_history.md#ローカルリポジトリ)と[リモートリポジトリ](./record_history.md#リモートリポジトリ)の両方を一覧表示できる。\n\n```sh\n"},{"term":"git switch","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"ブランチの切り替え","content":"\n`git swtich` は、指定した[ブランチ](#ブランチ)への切り替えを行う[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。切り換え先の `HEAD` の内容が[ワークツリー](./record_history.md#ワークツリー)に展開される。 `git swtich` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に `-c` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、新規[ブランチ](#ブランチ)の作成も同時に行える。\n\n```sh\n"},{"term":"マージ","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"マージ","content":"\n**マージ**は、ある[ブランチ](#ブランチ)の `HEAD` を別の[ブランチ](#ブランチ)に取り込む操作。[トピックブランチ](#ブランチ)の変更を本流となる[ブランチ](#ブランチ)に統合したり、本流となる[ブランチ](#ブランチ)の変更点を[トピックブランチ](#ブランチ)に取り込むといった使い方をする。\n\nマージには `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。まずは `HEAD` をマージ先の[ブランチ](#ブランチ)に切り替え、 `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)の[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にマージしたい[ブランチ](#ブランチ)名を指定する。\n\n```sh\n"},{"term":"git merge","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"マージ","content":"\n**マージ**は、ある[ブランチ](#ブランチ)の `HEAD` を別の[ブランチ](#ブランチ)に取り込む操作。[トピックブランチ](#ブランチ)の変更を本流となる[ブランチ](#ブランチ)に統合したり、本流となる[ブランチ](#ブランチ)の変更点を[トピックブランチ](#ブランチ)に取り込むといった使い方をする。\n\nマージには `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。まずは `HEAD` をマージ先の[ブランチ](#ブランチ)に切り替え、 `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)の[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にマージしたい[ブランチ](#ブランチ)名を指定する。\n\n```sh\n"},{"term":"Fast-forwardマージ（早送りマージ）","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"fast-forwardマージ","content":"\n**Fast-forwardマージ**（**早送りマージ**）は、[マージ](#マージ)先の[ブランチ](#ブランチ)の `HEAD` から[マージ](#マージ)したい[ブランチ](#ブランチ)の `HEAD` に向かって1本の直線的なパスのみが通っている場合に適用される戦略（[マージ](#マージ)したい[ブランチ](#ブランチ)以外の[ブランチ](#ブランチ)で[コミット](./record_history.md#コミット)が行われていない状態での[マージ](#マージ)）。この場合は、実際には差分の統合が行われているわけではなく、[マージ](#マージ)先の `HEAD` を[マージ](#マージ)したい[ブランチ](#ブランチ)の `HEAD` に移動する。これにより、実質的に全ての履歴が統合され、[マージ](#マージ)したい[ブランチ](#ブランチ)からアクセス可能であった全ての[コミット](./record_history.md#コミット)が[マージ](#マージ)先からも利用できるようになる。\n\n"},{"term":"3wayマージ（三方向マージ）","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"3wayマージ","content":"\n**3wayマージ**（**三方向マージ**）は、[マージ](#マージ)先の[ブランチ](#ブランチ)と[マージ](#マージ)したい[ブランチ](#ブランチ)の両方で[コミット](./record_history.md#コミット)が行われており、単純な[Fast-forwardマージ](#fast-forwardマージ)が実行できない場合に適用される戦略。この[マージ](#マージ)方法では、2つの[ブランチ](#ブランチ)の `HEAD` を統合するような新たな[マージ](#マージ)[コミット](./record_history.md#コミット)が作成される。\n\n"},{"term":"コンフリクト","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"コンフリクト","content":"\n**コンフリクト**は、[3wayマージ](#3wayマージ)の際に同じ[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の同じ行に対する変更があった場合や、片方の[ブランチ](#ブランチ)で削除された[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)に対してもう片方の[ブランチ](#ブランチ)で編集を加えた場合などに、どちらの変更を優先すれば良いかを自動的に判断できなくなり[マージ](../../../../computer/software/_/chapters/file_system.md#ファイル)に失敗する現象。コンフリクトが発生した場合、コンフリクトが発生した[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)の該当箇所に以下のようなマークが追加される。\n\n```sh\n<<<<<<< HEAD\n// マージ先のブランチの変更\naaa\n=======\n// マージしたいブランチの変更\nbbb\n>>>>>>> <branch>\n```\n\nこの部分を統合したい形に編集して保存し、[コミット](./record_history.md#コミット)を作成すると、コンフリクトしていた[マージ](#マージ)も完了した状態となる。また、 `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に `--abort` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、[マージ](#マージ)を中止することもできる。\n\n```sh\n$ git merge --abort\n```\n\n"},{"term":"リベース","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"リベース","content":"\n**リベース**は、[Fast-forwardマージ](#fast-forwardマージ)ができないような2つの[ブランチ](#ブランチ)を、[マージ](#マージ)[コミット](./record_history.md#コミット)を作成せずに統合する方法。統合元の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)履歴の先頭に、統合先の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)履歴の差分を全て直線的に追加する。これにより不要な[マージ](#マージ)[コミット](./record_history.md#コミット)が除去され、履歴を汚さずに済む。ただし、リベースを行うと統合元の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)を打ち消してしまう可能性があるので、本流となる[ブランチ](#ブランチ)を自身が作業する[トピックブランチ](#ブランチ)に統合する場合などに限って利用すると良い。\n\nリベースには `git rebase` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。まずは `HEAD` を統合先の[ブランチ](#ブランチ)に切り替え、 `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)の[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)に統合したい[ブランチ](#ブランチ)名を指定する。\n\n```sh\n"},{"term":"git rebase","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"リベース","content":"\n**リベース**は、[Fast-forwardマージ](#fast-forwardマージ)ができないような2つの[ブランチ](#ブランチ)を、[マージ](#マージ)[コミット](./record_history.md#コミット)を作成せずに統合する方法。統合元の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)履歴の先頭に、統合先の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)履歴の差分を全て直線的に追加する。これにより不要な[マージ](#マージ)[コミット](./record_history.md#コミット)が除去され、履歴を汚さずに済む。ただし、リベースを行うと統合元の[ブランチ](#ブランチ)の[コミット](./record_history.md#コミット)を打ち消してしまう可能性があるので、本流となる[ブランチ](#ブランチ)を自身が作業する[トピックブランチ](#ブランチ)に統合する場合などに限って利用すると良い。\n\nリベースには `git rebase` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いる。まずは `HEAD` を統合先の[ブランチ](#ブランチ)に切り替え、 `git merge` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)の[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)に統合したい[ブランチ](#ブランチ)名を指定する。\n\n```sh\n"},{"term":"プルリクエスト","link":"./note/ja/./development/git/_/chapters/branch.md","flagment":"プルリクエスト","content":"\n**プルリクエスト**は、[ブランチ](#ブランチ)の[マージ](#マージ)を他のユーザに通知し、[マージ](#マージ)を実行してよいか確認する機能。プルリクエストは[Git](./git.md#git)自身の機能ではなく、[GitHub](./git.md#gitホスティングサービス)などの[Gitホスティングサービス](./git.md#gitホスティングサービス)により提供されているため、環境によっては利用できない場合もある。\n\n実装者は[Gitホスティングサービス](./git.md#gitホスティングサービス)上で[マージ](#マージ)したい[ブランチ](#ブランチ)を指定してプルリクエストを発行し、確認者が[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)のレビューを行う。確認者がプルリクエストを承認すると実際に[マージ](#マージ)が実行される。プルリクエストを活用することで、このようなコードレビューのフローが実施しやすくなる。\n"},{"term":"git stash","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"ワークツリーの退避","content":"\n`git stash` は、[ワークツリー](./record_history.md#ワークツリー)に加えた変更を一時的に退避するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[ワークツリー](./record_history.md#ワークツリー)の変更内容を**スタッシュ**領域に退避しておき、緊急の作業等を行った後にスタッシュの内容を復元する、といった使い方ができる。また、[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にコメントをつけることで、複数のスタッシュが管理しやすくなる。\n\n```sh\n"},{"term":"スタッシュ","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"ワークツリーの退避","content":"\n`git stash` は、[ワークツリー](./record_history.md#ワークツリー)に加えた変更を一時的に退避するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[ワークツリー](./record_history.md#ワークツリー)の変更内容を**スタッシュ**領域に退避しておき、緊急の作業等を行った後にスタッシュの内容を復元する、といった使い方ができる。また、[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にコメントをつけることで、複数のスタッシュが管理しやすくなる。\n\n```sh\n"},{"term":"git stash list","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"ワークツリーの退避","content":"\n`git stash` は、[ワークツリー](./record_history.md#ワークツリー)に加えた変更を一時的に退避するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[ワークツリー](./record_history.md#ワークツリー)の変更内容を**スタッシュ**領域に退避しておき、緊急の作業等を行った後にスタッシュの内容を復元する、といった使い方ができる。また、[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にコメントをつけることで、複数のスタッシュが管理しやすくなる。\n\n```sh\n"},{"term":"git stash apply","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"ワークツリーの退避","content":"\n`git stash` は、[ワークツリー](./record_history.md#ワークツリー)に加えた変更を一時的に退避するための[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[ワークツリー](./record_history.md#ワークツリー)の変更内容を**スタッシュ**領域に退避しておき、緊急の作業等を行った後にスタッシュの内容を復元する、といった使い方ができる。また、[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)にコメントをつけることで、複数のスタッシュが管理しやすくなる。\n\n```sh\n"},{"term":"git stash pop","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"ワークツリーの復元","content":""},{"term":"git stash show","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"スタッシュの確認","content":"\n`git stash show` は、[スタッシュ](#ワークツリーの退避)の変更[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定しなければ直前の[スタッシュ](#ワークツリーの退避)の変更[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を表示し、[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)に[スタッシュ](#ワークツリーの退避)の識別子を指定すると任意の[スタッシュ](#ワークツリーの退避)の変更[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を表示できる。また、 `git stash show` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)に `-p` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定することで、[スタッシュ](#ワークツリーの退避)の変更内容を確認できる。\n\n```sh\n"},{"term":"git stash drop","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"スタッシュの削除","content":"\n`git stash drop` は、[スタッシュ](#ワークツリーの退避)を削除する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)として[スタッシュ](#ワークツリーの退避)の識別子を指定することで、任意の[スタッシュ](#ワークツリーの退避)を削除できる。また、 `git stash clear` を用いることで全ての[スタッシュ](#ワークツリーの退避)を一括で削除できる。\n\n\n```sh\n"},{"term":"git stash clear","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"スタッシュの削除","content":"\n`git stash drop` は、[スタッシュ](#ワークツリーの退避)を削除する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[引数](../../../../computer/linux/_/chapters/basic_command.md#オプション)として[スタッシュ](#ワークツリーの退避)の識別子を指定することで、任意の[スタッシュ](#ワークツリーの退避)を削除できる。また、 `git stash clear` を用いることで全ての[スタッシュ](#ワークツリーの退避)を一括で削除できる。\n\n\n```sh\n"},{"term":"タグ","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"タグ","content":"\n**タグ**は、特定の[コミット](./record_history.md#コミット)をマークすることで参照しやすくするための機能。**軽量タグ**では、ある特定の[コミット](./record_history.md#コミット)に対して名前を付けることができる。**注釈付きタグ**では、タグ名に加えて作成者や作成日、コメントといった情報を付与することができる。タグは[コミットハッシュ](./record_history.md#コミットハッシュ)のエイリアスとしても利用できる。\n\n"},{"term":"軽量タグ","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"タグ","content":"\n**タグ**は、特定の[コミット](./record_history.md#コミット)をマークすることで参照しやすくするための機能。**軽量タグ**では、ある特定の[コミット](./record_history.md#コミット)に対して名前を付けることができる。**注釈付きタグ**では、タグ名に加えて作成者や作成日、コメントといった情報を付与することができる。タグは[コミットハッシュ](./record_history.md#コミットハッシュ)のエイリアスとしても利用できる。\n\n"},{"term":"注釈付きタグ","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"タグ","content":"\n**タグ**は、特定の[コミット](./record_history.md#コミット)をマークすることで参照しやすくするための機能。**軽量タグ**では、ある特定の[コミット](./record_history.md#コミット)に対して名前を付けることができる。**注釈付きタグ**では、タグ名に加えて作成者や作成日、コメントといった情報を付与することができる。タグは[コミットハッシュ](./record_history.md#コミットハッシュ)のエイリアスとしても利用できる。\n\n"},{"term":"git tag","link":"./note/ja/./development/git/_/chapters/others.md","flagment":"タグの一覧表示","content":"\n`git tag` は、登録されている[タグ](#タグ)の一覧を表示する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ git tag\n```\n\n"},{"term":"データベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"データベース","content":"\n**データベース**は、構造化したデータや情報を蓄積して、再利用できるようにした[システム](../../../../system/_/chapters/system.md#システム)。データの構造化の形式によって、[リレーショナルデータベース](#リレーショナルデータベース)や[ネットワーク型データベース](#ネットワーク型データベース)、[NoSQLデータベース](#nosqlデータベース)などに分類される。\n\n"},{"term":"リレーショナルデータベース（関係データベース）","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"リレーショナルデータベース","content":"\n**リレーショナルデータベース**（関係データベース）は、2次元の表形式でデータを管理する[データベース](#データベース)で、データを扱う[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)では最も一般的に用いられている。リレーショナルデータベースのことを単に[データベース](#データベース)と言う場合も多い。\n\n"},{"term":"階層型データベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"階層型データベース","content":"\n**階層型データベース**は、データをヒエラルキー構造で管理する[データベース](#データベース)。レコード間に階層構造をもたせた[木](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#木)構造で表現され、親レコードと子レコードは[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)によって結合される。各要素が最大1つの親を持つ**シングルペアレント階層**となっている。\n\n"},{"term":"シングルペアレント階層","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"階層型データベース","content":"\n**階層型データベース**は、データをヒエラルキー構造で管理する[データベース](#データベース)。レコード間に階層構造をもたせた[木](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#木)構造で表現され、親レコードと子レコードは[ポインタ](../../../../programming/_/chapters/data_type.md#ポインタ型)によって結合される。各要素が最大1つの親を持つ**シングルペアレント階層**となっている。\n\n"},{"term":"ネットワーク型データベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"ネットワーク型データベース","content":"\n**ネットワーク型データベース**は、一連のレコードに階層構造があり、かつレコード間に複数のつながりがある、[グラフ](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#グラフ)構造で表現される[データベース](#データベース)。各要素が2つ以上の親を持つことも許される**マルチペアレント階層**となっている。\n\n"},{"term":"マルチペアレント階層","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"ネットワーク型データベース","content":"\n**ネットワーク型データベース**は、一連のレコードに階層構造があり、かつレコード間に複数のつながりがある、[グラフ](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#グラフ)構造で表現される[データベース](#データベース)。各要素が2つ以上の親を持つことも許される**マルチペアレント階層**となっている。\n\n"},{"term":"オブジェクト指向データベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"オブジェクト指向データベース","content":"\n**オブジェクト指向データベース**は、データと手続きを一体化させた[オブジェクト](../../../../programming/_/chapters/object_oriented.md#オブジェクト)によりレコードを表現する[データベース](#データベース)。\n\n"},{"term":"ハイパーテキストデータベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"ハイパーテキストデータベース","content":"\n**ハイパーテキストデータベース**は、複数の文書をそれぞれ[リンク](../../../../network/_/chapters/web.md#ハイパーリンク)させた形でもたせた[データベース](#データベース)。\n\n"},{"term":"マルチメディアデータベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"マルチメディアデータベース","content":"\n**マルチメディアデータベース**は、テキストだけではなく、静止画や動画、音声などを管理することに最適化された[データベース](#データベース)。\n\n"},{"term":"XMLデータベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"xmlデータベース","content":"\n**XMLデータベース**は、タグを用いてデータの構造と意味を表す[データベース](#データベース)。\n\n"},{"term":"NoSQLデータベース","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"nosqlデータベース","content":"\n**NoSQLデータベース**は、[リレーショナルデータベース](#リレーショナルデータベース)を操作するための言語である[SQL](./sql.md#sql)を使わない[データベース](#データベース)の総称。[リレーショナルデータベース](#リレーショナルデータベース)の機能の一部を捨てるなどの工夫によって、パフォーマンスを追求したものが多い。大量データを扱う[システム](../../../../system/_/chapters/system.md#システム)などと相性が良い。\n\n\n"},{"term":"DBMS（データベース管理システム: Database Management System）","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"dbms","content":"\n**DBMS**（**データベース管理システム**: Database Management System）は、[データベース](#データベース)の管理や制御、データの検索などを行うための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)（[ミドルウェア](../../../../computer/software/_/chapters/middleware.md#ミドルウェア)）。代表的なものとして、OracleやMySQL(MariaDB)、PostgreSQL、SQL Server、DB2などがある。\n\n"},{"term":"Oracle","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"dbms","content":"\n**DBMS**（**データベース管理システム**: Database Management System）は、[データベース](#データベース)の管理や制御、データの検索などを行うための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)（[ミドルウェア](../../../../computer/software/_/chapters/middleware.md#ミドルウェア)）。代表的なものとして、OracleやMySQL(MariaDB)、PostgreSQL、SQL Server、DB2などがある。\n\n"},{"term":"PostgreSQL","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"dbms","content":"\n**DBMS**（**データベース管理システム**: Database Management System）は、[データベース](#データベース)の管理や制御、データの検索などを行うための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)（[ミドルウェア](../../../../computer/software/_/chapters/middleware.md#ミドルウェア)）。代表的なものとして、OracleやMySQL(MariaDB)、PostgreSQL、SQL Server、DB2などがある。\n\n"},{"term":"SQL Server","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"dbms","content":"\n**DBMS**（**データベース管理システム**: Database Management System）は、[データベース](#データベース)の管理や制御、データの検索などを行うための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)（[ミドルウェア](../../../../computer/software/_/chapters/middleware.md#ミドルウェア)）。代表的なものとして、OracleやMySQL(MariaDB)、PostgreSQL、SQL Server、DB2などがある。\n\n"},{"term":"DB2","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"dbms","content":"\n**DBMS**（**データベース管理システム**: Database Management System）は、[データベース](#データベース)の管理や制御、データの検索などを行うための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)（[ミドルウェア](../../../../computer/software/_/chapters/middleware.md#ミドルウェア)）。代表的なものとして、OracleやMySQL(MariaDB)、PostgreSQL、SQL Server、DB2などがある。\n\n"},{"term":"スキーマ","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"スキーマ","content":"\n**スキーマ**は、[データベース](#データベース)の構造を定義したもの。[データベース](#データベース)のデータをどのように管理するかを定めた、一連の取り決め。\n\n"},{"term":"3層スキーマ","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"3層スキーマ","content":"\n**3層スキーマ**は、[データベース](#データベース)を構造や形式（[スキーマ](#スキーマ)）を3つの階層に分けてそれぞれ定義する方式。[外部スキーマ](#外部スキーマ)、[概念スキーマ](#概念スキーマ)、[内部スキーマ](#内部スキーマ)の3階層に分ける考え方と、概念スキーマ、論理スキーマ、物理スキーマの3階層に分ける考え方が代表的。\n\n"},{"term":"外部スキーマ","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"外部スキーマ","content":"\n**外部スキーマ**は、利用者（[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)）から見たデータの形式。実際に保存されているデータを[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)側でユーザが求めている形に加工した[ビュー](./sql.md#ビュー操作)を生成するレイヤ。\n\n"},{"term":"概念スキーマ","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"概念スキーマ","content":"\n**概念スキーマ**は、開発者がわから見たデータの形式。[外部スキーマ](#外部スキーマ)を[データベース](#データベース)上で扱いやすくするために、重複した項目の排除や関連性に応じた分割などの正規化を行ったレイヤ。\n\n"},{"term":"内部スキーマ","link":"./note/ja/./development/database/_/chapters/database.md","flagment":"内部スキーマ","content":"\n**内部スキーマ**は、物理的なデータの格納形式。記憶装置上にどのようにデータを格納し、アクセスするのかといった、[データベース](#データベース)の物理的な構造を定義する。[インデックス](./index.md#インデックス)の定義による検索の高速化などが行われるレイヤ。\n"},{"term":"リレーショナルモデル","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"リレーショナルモデル","content":"\n**リレーショナルモデル**は、[リレーショナルデータベース](./database.md#リレーショナルデータベース)のデータモデル。\n\n"},{"term":"エンティティ","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"エンティティ","content":"\n**エンティティ**は、顧客、部品、地域などの、[データベース](./database.md#データベース)に格納される対象となるデータ。\n\n"},{"term":"アトリビュート","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"アトリビュート","content":"\n**アトリビュート**は、[エンティティ](#エンティティ)が持つ属性。例えば、顧客という[エンティティ](#エンティティ)には、顧客番号、顧客名、顧客所属名などのアトリビュートを格納するといった具合。\n\n"},{"term":"テーブル","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"テーブル","content":"\n**テーブル**は、関連する情報の集合を格納した表形式のデータ構造。[リレーショナルモデル](#リレーショナルモデル)における[エンティティ](#エンティティ)を、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が扱いやすいようにした形式で、データは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)に格納されて永続的に保持される。\n\n"},{"term":"レコード（行）","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"レコード","content":"\n**レコード**（**行**）は、[テーブル](#テーブル)に格納された実際のデータ。[エンティティ](#エンティティ)の各データの[アトリビュート](#アトリビュート)を説明するための[カラム](#カラム)の集合。\n\n"},{"term":"カラム（列）","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"レコード","content":"\n**レコード**（**行**）は、[テーブル](#テーブル)に格納された実際のデータ。[エンティティ](#エンティティ)の各データの[アトリビュート](#アトリビュート)を説明するための[カラム](#カラム)の集合。\n\n"},{"term":"結果セット","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"結果セット","content":"\n**結果セット**は、[クエリ](./sql.md#クエリ)の結果として得られる、非永続的な[テーブル](#テーブル)。\n\n"},{"term":"プライマリキー","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"プライマリキー","content":"\n**プライマリキー**（**主キー**）は、[テーブル](#テーブル)内の各[レコード](#レコード)に与えられる一意のIDとして用いることができる、1つ以上の[カラム](#カラム)。各[テーブル](#テーブル)はプライマリキーとして利用できる[カラム](#カラム)を持つことがほとんどで、各[レコード](#レコード)は必ずこの[カラム](#カラム)に一意の値を持つ必要がある。\n\n"},{"term":"外部キー","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"外部キー","content":"\n**外部キー**は、ある[テーブル](#テーブル)が別の[テーブル](#テーブル)の[レコード](#レコード)を一意に特定するための情報を持つ[カラム](#カラム)。この[制約](#制約)のある[カラム](#カラム)には、参照先の[テーブル](#テーブル)の[プライマリキー](#プライマリキー)として存在する値しか格納することができない。\n\n\n"},{"term":"インスタンス","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"インスタンス","content":"\n**インスタンス**は、[DBMS](./database.md#dbms)の動作単位で、[データベース](./database.md#データベース)よりも上の階層にある概念。[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)からは[プロセス](../../../../computer/software/_/chapters/operating_system.md#プロセス)として見える。\n\n"},{"term":"スキーマ","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"スキーマ","content":"\n**スキーマ**は、[データベース](./database.md#データベース)の下の階層で、[テーブル](#テーブル)を格納してまとめる[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)のような概念。スキーマごとにアクセス制限をかけてセキュリティを向上させたり、用途によって[テーブル](#テーブル)を分けて管理したりすることができる。[MySQL](./database.md#dbms)では、[データベース](./database.md#データベース)とスキーマを同一とみなしており、標準SQLの定める4階層構造ではなく3階層構造を採用している。\n\n\n"},{"term":"正規化","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"正規化","content":"\n**正規化**は、[エンティティ](#エンティティ)や[アトリビュート](#アトリビュート)を[データベース](./database.md#データベース)で管理しやすいように、正しく[テーブル](#テーブル)を分割したり、重複した項目を削除する処理。1つのデータを1箇所で管理することで、データの整合性が保ちやすくなる。\n\n"},{"term":"非正規化形","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"非正規化形","content":"\n**非正規化形**は、[エンティティ](#エンティティ)の情報をそのまま表現した形。1つの[レコード](#レコード)が同じ[カラム](#カラム)に格納するべき[アトリビュート](#アトリビュート)を複数持つ可能性があるため、通常はそのままでは[データベース](./database.md#データベース)に格納することはできない。\n\n"},{"term":"第1正規化形","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"第1正規化形","content":"\n**第1正規化形**は、同じ[カラム](#カラム)に格納するべき[アトリビュート](#アトリビュート)を複数持つ[レコード](#レコード)については、[アトリビュート](#アトリビュート)の数だけ独立した[レコード](#レコード)を用意した形。同じ候補キー（[レコード](#レコード)を一意に特定するための属性）を持つ[レコード](#レコード)が複数存在する状態のため、候補キーを[プライマリキー](#プライマリキー)として扱うことはできない。また、候補キーとなる[カラム](#カラム)が複数存在する可能性がある。\n\n"},{"term":"第2正規化形","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"第2正規化形","content":"\n**第2正規化形**は、同じ[テーブル](#テーブル)の中で異なる候補キーに依存している部分を、別[テーブル](#テーブル)に分離した形。\n\n"},{"term":"第3正規化形","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"第3正規化形","content":"\n**第3正規化形**は、同じ[テーブル](#テーブル)の中で候補キーではない[アトリビュート](#アトリビュート)に依存している部分を、別[テーブル](#テーブル)に分離した形。\n\n\n"},{"term":"null","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"null","content":"\n**null**は、値がないことを表す値。値が不明であったり、未定義の場合に[データベース](./database.md#データベース)に代入される。\n\n\n"},{"term":"制約","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"制約","content":"\n**制約**は、[テーブル](#テーブル)の各[カラム](#カラム)に格納されるデータに関する決まりごと。\n\n"},{"term":"NOT NULL","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"not-null","content":""},{"term":"PRIMARY KEY","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"primary-key","content":""},{"term":"UNIQUE KEY","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"unique-key","content":""},{"term":"FOREIGN KEY","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"foreign-key","content":""},{"term":"CHECK","link":"./note/ja/./development/database/_/chapters/rdb.md","flagment":"check","content":"\n**CHECK**は、指定した条件に合致しないデータが格納できなくなるという[制約](#制約)。\n"},{"term":"SQL","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"sql","content":"\n**SQL**は、[リレーショナルデータベース](./database.md#リレーショナルデータベース)を操作するための言語。各[RDBMS](./database.md#rdbms)ごとに多少違いはあるものの、基本的には標準SQLの仕様に準拠している場合が多い。\n\n"},{"term":"クエリ（問合せ）","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"クエリ","content":"\n**クエリ**（問合せ）は、[データベース](./database.md#データベース)に対するデータの抽出や更新といった処理要求の文字列。\n\n"},{"term":"サブクエリ（副問合せ）","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"サブクエリ","content":"\n**サブクエリ**（副問合せ）は、[SQL](#sql)の命令文中で呼び出す別の命令文。\n\n\n"},{"term":"SHOW DATABASES","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データベースの一覧表示","content":"\n[インスタンス](./rdb.md#インスタンス)に存在する[データベース](./database.md#データベース)の一覧を表示するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSHOW DATABASES;\n```\n\n"},{"term":"CREATE DATABASES","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データベースの作成","content":"\n[インスタンス](./rdb.md#インスタンス)に新しい[データベース](./database.md#データベース)を作成するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCREATE DATABASE [name];\n```\n\n"},{"term":"DROP DATABASES","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データベースの削除","content":"\n[インスタンス](./rdb.md#インスタンス)に存在する[データベース](./database.md#データベース)を削除するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nDROP DATABASE [name];\n```\n\n"},{"term":"USE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データベースの選択","content":"\n操作したい[データベース](./database.md#データベース)を選択するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nUSE [name];\n```\n\n\n"},{"term":"SHOW TABLES","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"テーブルの一覧表示","content":"\n[データベース](./database.md#データベース)中の[テーブル](./rdb.md#テーブル)の一覧を表示するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSHOW TABLES;\n```\n\n"},{"term":"CREATE TABLE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"テーブルの作成","content":"\n[データベース](./database.md#データベース)中に新しい[テーブル](./rdb.md#テーブル)を作成するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCREATE TABLE [name]\n(\n    [column1] [type] [restriction],\n    [column2] [type] [restriction],\n    ...\n    PRIMARY KEY ([column])\n);\n```\n\n```sql\n-- テーブル作成の例\nCREATE TABLE `user`\n(\n    `user_id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n    `name` VARCHAR(64) NOT NULL,\n    `address` VARCHAR(128) NOT NULL,\n    PRIMARY KEY (`user_id`)\n);\n```\n\n"},{"term":"ALTER TABLE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"テーブルの変更","content":"\n[データベース](./database.md#データベース)中の[テーブル](./rdb.md#テーブル)の定義を変更するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- カラムの追加\nALTER TABLE [name] ADD COLUMN [column] [type] [restriction];\nALTER TABLE [name] ADD\n(\n    [column1] [type] [restriction],\n    [column2] [type] [restriction],\n    ...\n);\n\n-- カラムの変更\nALTER TABLE [name] MODIFY COLUMN [column] [type] [restriction];\nALTER TABLE [name] MODIFY\n(\n    [column1] [type] [restriction],\n    [column2] [type] [restriction],\n    ...\n);\n\n-- カラムの削除\nALTER TABLE [name] DROP COLUMN [column];\nALTER TABLE [name] DROP ([column1], [column2], ...);\n```\n\n"},{"term":"DROP TABLE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"テーブルの削除","content":"\n[データベース](./database.md#データベース)中の[テーブル](./rdb.md#テーブル)を削除するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nDROP TABLE [name];\n```\n\n\n"},{"term":"SELECT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの取得","content":"\n[テーブル](./rdb.md#テーブル)からデータを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table];\n\n-- 重複を削除した検索\nSELECT DISTINCT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table];\n```\n\n"},{"term":"INSERT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの挿入","content":"\n[テーブル](./rdb.md#テーブル)に新しいデータを挿入するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nINSERT INTO [table]\n(\n    [column1],\n    [column2],\n    ...\n)\nVALUES\n(\n    [value1],\n    [value2],\n    ...\n);\n```\n\n"},{"term":"UPDATE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの更新","content":"\n[テーブル](./rdb.md#テーブル)のデータを更新するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nUPDATE\n    [table]\nSET\n    [column1] = [value1],\n    [column2] = [value2],\n    ...;\n```\n\n"},{"term":"DELETE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの削除","content":"\n[テーブル](./rdb.md#テーブル)のデータを削除するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nDELETE FROM [table];\n```\n\n"},{"term":"WHERE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの抽出","content":"\n[テーブル](./rdb.md#テーブル)のデータを抽出して取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [condition];\n\n-- OR条件\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [condition1] OR\n    [condition2] OR\n    ...;\n\n-- AND条件\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [condition1] AND\n    [condition2] AND\n    ...;\n\n-- NOT条件\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    NOT [condition];\n\n-- 範囲条件\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [column] BETWEEN [value1] AND [value2];\n\n-- 含有条件\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [column] IN ([value1], [value2], ...);\n\n-- ワイルドカード\n-- '%': 0文字以上の任意の文字列\n-- '_': 任意の1文字\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nWHERE\n    [column] LIKE '%[value]%';\n```\n\n"},{"term":"AS","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"エイリアスの設定","content":"\n操作するデータに別名をつけるには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。複数のテーブルを組み合わせたクエリを記述する場合などに、長いテーブル名を繰り返し記述して冗長になることを避けるために用いられる。\n\n```sql\nSELECT\n    [column] AS [alias]\nFROM\n    [table]\n```\n\n"},{"term":"ORDER BY","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データのソート","content":"\n[テーブル](./rdb.md#テーブル)のデータをソートして取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 昇順\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nORDER BY\n    [column];\n\n-- 降順\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nORDER BY\n    [column] DESC;\n```\n\n"},{"term":"LIMIT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの制限","content":"\n[テーブル](./rdb.md#テーブル)のデータの取得数を制限するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nLIMIT\n    [offset], [num];\n```\n\n"},{"term":"SUM","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの集約","content":"\n[テーブル](./rdb.md#テーブル)のデータを集約して様々な統計データを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 合計値\nSELECT\n    SUM([column])\nFROM\n    [table];\n\n-- 平均値\nSELECT\n    AVG([column])\nFROM\n    [table];\n\n-- 最大値\nSELECT\n    MAX([column])\nFROM\n    [table];\n\n-- 最小値\nSELECT\n    MIN([column])\nFROM\n    [table];\n\n-- データ数\nSELECT\n    COUNT([column])\nFROM\n    [table];\n```\n\n"},{"term":"AVG","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの集約","content":"\n[テーブル](./rdb.md#テーブル)のデータを集約して様々な統計データを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 合計値\nSELECT\n    SUM([column])\nFROM\n    [table];\n\n-- 平均値\nSELECT\n    AVG([column])\nFROM\n    [table];\n\n-- 最大値\nSELECT\n    MAX([column])\nFROM\n    [table];\n\n-- 最小値\nSELECT\n    MIN([column])\nFROM\n    [table];\n\n-- データ数\nSELECT\n    COUNT([column])\nFROM\n    [table];\n```\n\n"},{"term":"MAX","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの集約","content":"\n[テーブル](./rdb.md#テーブル)のデータを集約して様々な統計データを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 合計値\nSELECT\n    SUM([column])\nFROM\n    [table];\n\n-- 平均値\nSELECT\n    AVG([column])\nFROM\n    [table];\n\n-- 最大値\nSELECT\n    MAX([column])\nFROM\n    [table];\n\n-- 最小値\nSELECT\n    MIN([column])\nFROM\n    [table];\n\n-- データ数\nSELECT\n    COUNT([column])\nFROM\n    [table];\n```\n\n"},{"term":"MIN","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの集約","content":"\n[テーブル](./rdb.md#テーブル)のデータを集約して様々な統計データを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 合計値\nSELECT\n    SUM([column])\nFROM\n    [table];\n\n-- 平均値\nSELECT\n    AVG([column])\nFROM\n    [table];\n\n-- 最大値\nSELECT\n    MAX([column])\nFROM\n    [table];\n\n-- 最小値\nSELECT\n    MIN([column])\nFROM\n    [table];\n\n-- データ数\nSELECT\n    COUNT([column])\nFROM\n    [table];\n```\n\n"},{"term":"COUNT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの集約","content":"\n[テーブル](./rdb.md#テーブル)のデータを集約して様々な統計データを取得するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 合計値\nSELECT\n    SUM([column])\nFROM\n    [table];\n\n-- 平均値\nSELECT\n    AVG([column])\nFROM\n    [table];\n\n-- 最大値\nSELECT\n    MAX([column])\nFROM\n    [table];\n\n-- 最小値\nSELECT\n    MIN([column])\nFROM\n    [table];\n\n-- データ数\nSELECT\n    COUNT([column])\nFROM\n    [table];\n```\n\n"},{"term":"ROUND","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの加工","content":"\n[テーブル](./rdb.md#テーブル)のデータを加工するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 四捨五入\nSELECT\n    ROUND([column], [valid digit])\nFROM\n    [table];\n\n-- 切り捨て\nSELECT\n    FLOOR([column])\nFROM\n    [table];\n\n-- 切り上げ\nSELECT\n    CEILING([column])\nFROM\n    [table];\n```\n\n"},{"term":"FLOOR","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの加工","content":"\n[テーブル](./rdb.md#テーブル)のデータを加工するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 四捨五入\nSELECT\n    ROUND([column], [valid digit])\nFROM\n    [table];\n\n-- 切り捨て\nSELECT\n    FLOOR([column])\nFROM\n    [table];\n\n-- 切り上げ\nSELECT\n    CEILING([column])\nFROM\n    [table];\n```\n\n"},{"term":"CEILING","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データの加工","content":"\n[テーブル](./rdb.md#テーブル)のデータを加工するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- 四捨五入\nSELECT\n    ROUND([column], [valid digit])\nFROM\n    [table];\n\n-- 切り捨て\nSELECT\n    FLOOR([column])\nFROM\n    [table];\n\n-- 切り上げ\nSELECT\n    CEILING([column])\nFROM\n    [table];\n```\n\n"},{"term":"GROUP BY","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"データのグループ化","content":"\n[テーブル](./rdb.md#テーブル)のデータをグループ化するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table]\nGROUP BY\n    [column]\n\n-- グループ化したカラムを元に集計\nSELECT\n    [column1],\n    SUM([column2]),\n    AVG([column3]),\n    ...\nFROM\n    [table]\nGROUP BY\n    [column1]\n```\n\n\n"},{"term":"内部結合","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"内部結合","content":"\n**内部結合**は、結合する[テーブル](./rdb.md#テーブル)のデータのうち、条件に指定した[カラム](./rdb.md#カラム)の値が一致するデータのみを結合する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nINNER JOIN\n    [table2]\nON\n    [condition];\n\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1],\n    [table2],\n    ...\nWHERE\n    [condition]\n```\n\n"},{"term":"INNER JOIN","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"内部結合","content":"\n**内部結合**は、結合する[テーブル](./rdb.md#テーブル)のデータのうち、条件に指定した[カラム](./rdb.md#カラム)の値が一致するデータのみを結合する。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nINNER JOIN\n    [table2]\nON\n    [condition];\n\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1],\n    [table2],\n    ...\nWHERE\n    [condition]\n```\n\n"},{"term":"外部結合","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"外部結合","content":"\n**外部結合**は、結合する[テーブル](./rdb.md#テーブル)のデータのうち、片方の[テーブル](./rdb.md#テーブル)のデータをすべて取り出し、条件に指定した[カラム](./rdb.md#カラム)の値が一致するデータに関してのみ結合される。\n\n```sql\n-- 左外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nLEFT OUTER JOIN\n    [table2]\nON\n    [condition];\n\n-- 右外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nRIGHT OUTER JOIN\n    [table2]\nON\n    [condition];\n\n-- 完全外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nFULL OUTER JOIN\n    [table2]\nON\n    [condition];\n```\n\n"},{"term":"OUTER JOIN","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"外部結合","content":"\n**外部結合**は、結合する[テーブル](./rdb.md#テーブル)のデータのうち、片方の[テーブル](./rdb.md#テーブル)のデータをすべて取り出し、条件に指定した[カラム](./rdb.md#カラム)の値が一致するデータに関してのみ結合される。\n\n```sql\n-- 左外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nLEFT OUTER JOIN\n    [table2]\nON\n    [condition];\n\n-- 右外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nRIGHT OUTER JOIN\n    [table2]\nON\n    [condition];\n\n-- 完全外部結合\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nFULL OUTER JOIN\n    [table2]\nON\n    [condition];\n```\n\n"},{"term":"交差結合（直積結合）","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"交差結合","content":"\n**交差結合**（**直積結合**）は、結合する[テーブル](./rdb.md#テーブル)のデータのすべての組み合わせを取り出す。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nCROSS JOIN\n    [table2]\n```\n\n\n"},{"term":"CROSS JOIN","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"交差結合","content":"\n**交差結合**（**直積結合**）は、結合する[テーブル](./rdb.md#テーブル)のデータのすべての組み合わせを取り出す。\n\n```sql\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table1]\nCROSS JOIN\n    [table2]\n```\n\n\n"},{"term":"CASE","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"条件分岐","content":"\n[クエリ](#クエリ)中で条件分岐を行いたい場合は、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCASE\n    WHEN [condition1] THEN [value1]\n    WHEN [condition2] THEN [value2]\n    ...\n    ELSE [value]\nEND\n```\n\n\n"},{"term":"CREATE VIEW","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"ビューの作成","content":"\n[データベース](./database.md#データベース)中に新しいビューを作成するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCREATE VIEW [name]\n(\n    [column1],\n    [column2],\n    ...\n) AS\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table];\n```\n\n"},{"term":"ALTER VIEW","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"ビューの変更","content":"\n[データベース](./database.md#データベース)中のビューを変更するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\n-- ビュー名の変更\nALTER VIEW [old name] RENAME TO [new name];\n\n-- ビュー定義の変更\nALTER VIEW [name]\n(\n    [column1],\n    [column2],\n    ...\n) AS\nSELECT\n    [column1],\n    [column2],\n    ...\nFROM\n    [table];\n```\n\n"},{"term":"DROP VIEW","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"ビューの削除","content":"\n[データベース](./database.md#データベース)中のビューを削除するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nDROP VIEW [name];\n```\n\n\n"},{"term":"START TRANSACTION","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"トランザクションの開始","content":"\n[トランザクション](./transaction.md#トランザクション)を開始するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSTART TRANSACTION;\n```\n\n"},{"term":"COMMIT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"コミット","content":"\n[トランザクション](./transaction.md#トランザクション)中の実行結果を[コミット](./transaction.md#コミット)するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCOMMIT;\n```\n\n"},{"term":"ROLLBACK","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"ロールバック","content":"\n[トランザクション](./transaction.md#トランザクション)中の実行結果を[ロールバック](./transaction.md#ロールバック)するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nROLLBACK;\n```\n\n"},{"term":"SAVEPOINT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"セーブポイント","content":"\n[トランザクション](./transaction.md#トランザクション)中に[セーブポイント](./transaction.md#セーブポイント)を設けるには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nSAVEPOINT [name];\n\n-- ロールバック時にセーブポイントを復元\nROLLBACK TO SAVEPOINT [name];\n```\n\n\n"},{"term":"CREATE USER","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"ユーザの作成","content":"\n[インスタンス](./rdb.md#インスタンス)中に新しいユーザを作成するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nCREATE USER [name]@[host] IDENTIFIED BY [password];\n```\n\n"},{"term":"GRANT","link":"./note/ja/./development/database/_/chapters/sql.md","flagment":"権限の付与","content":"\nユーザに権限を付与するには、以下の[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を実行する。\n\n```sql\nGRANT [type] ON [database].[table] TO [user]@[host];\n\n-- exampleデータベースに全権限を与える例\nGRANT ALL ON example.* TO my_user@localhost;\n```\n"},{"term":"トランザクション","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"トランザクション","content":"\n**トランザクション**は、複数の[SQL](./sql.md#sql)を1つの作業単位としてまとめて実行する処理。トランザクションは[SQL](./sql.md#sql)文をグループ化するためのメカニズムであり、すべての文が成功したか、すべての文が失敗したかの2つの結果しか起こり得ない。\n\nトランザクション中は[ロック](#ロック)機構により他のトランザクションが実行できなくなるが、トランザクションを並行して複数実行できるように意識することで処理は高速になる。\n\n"},{"term":"コミット","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"コミット","content":"\n**コミット**は、[トランザクション](#トランザクション)が開始されてからの操作を確定し、[トランザクション](#トランザクション)を終了する命令。\n\n"},{"term":"ロールバック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ロールバック","content":"\n**ロールバック**は、[トランザクション](#トランザクション)が開始されてからの操作を取り消し、[トランザクション](#トランザクション)を終了する命令。\n\n"},{"term":"セーブポイント","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"セーブポイント","content":"\n**セーブポイント**は、[トランザクション](#トランザクション)が異常終了して[ロールバック](#ロールバック)するときに、最初の状態まで戻すのではなく途中の状態に戻したいといった場合に用いる機能。\n\n\n"},{"term":"ロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ロック","content":"\n**ロック**は、データリソースが同時に使用されることで整合性が失われることを防ぐため、[トランザクション](#トランザクション)がデータリソースを占有する機構。ロックされているデータに対して、別の[トランザクション](#トランザクション)がロックをかけようとした場合、前のロックが解除されるまで待機する必要がある。\n\n"},{"term":"共有ロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"共有ロック","content":"\n**共有ロック**は、複数の[トランザクション](#トランザクション)で共有することができる[ロック](#ロック)で、同じリソースの読み込みはできるが、書き込みはできない。\n\n"},{"term":"排他ロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"排他ロック","content":"\n**排他ロック**は、ひとつの[トランザクション](#トランザクション)によって占有される[ロック](#ロック)で、他の[トランザクション](#トランザクション)はリソースに対して読み込みも書き込みもできない。\n\n"},{"term":"テーブルロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"テーブルロック","content":"\n**テーブルロック**は、[テーブル](./rdb.md#テーブル)内のすべてのデータを変更できないようにする[ロック](#ロック)。\n\n"},{"term":"ページロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ページロック","content":"\n**ページロック**は、[テーブル](./rdb.md#テーブル)内の同じページ（一般に2〜16KBのメモリセグメント）のデータを変更できないようにする[ロック](#ロック)。\n\n"},{"term":"レコードロック（行ロック）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"レコードロック","content":"\n**レコードロック**（**行ロック**）は、[テーブル](./rdb.md#テーブル)内の同じ[レコード](./rdb.md#レコード)を変更できないようにする[ロック](#ロック)。\n\n"},{"term":"ロックタイムアウト","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ロックタイムアウト","content":"\n**ロックタイムアウト**は、[ロック](#ロック)中のデータに別の[トランザクション](#トランザクション)が[ロック](#ロック)をかけようとして[ロック](#ロック)待ちの状態となった場合に、待ち時間の上限となる時間。ロックタイムアウトがないと、[デッドロック](#デッドロック)が発生したときに[トランザクション](#トランザクション)が解除できなくなってしまう。\n\n"},{"term":"デッドロック","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"デッドロック","content":"\n**デッドロック**は、複数の[トランザクション](#トランザクション)が互いに[ロック](#ロック)を掛け合うような状態となり、どちらの[トランザクション](#トランザクション)もそれより先に処理を進めることができなくなる状態。デッドロックの状態となると、[トランザクション](#トランザクション)は[ロックタイムアウト](#ロックタイムアウト)に達し、[トランザクション](#トランザクション)が解除される（[ロックタイムアウト](#ロックタイムアウト)時は、設定に応じた挙動となる。自動的に[ロールバック](#ロールバック)するなど。）。\n\n\n"},{"term":"アイソレーションレベル","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"アイソレーションレベル","content":"\n**アイソレーションレベル**は、[トランザクション](#トランザクション)の分離性のレベル。制限が厳しいものは並行に実行できる[トランザクション](#トランザクション)が少なくなるため、安全性は高い。制限が緩いものは並行性が高く、高速な処理ができる一方で、データの不整合性が発生しないように注意する必要がある。\n\n"},{"term":"シリアライザブル（直列化可能）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"シリアライザブル","content":"\n**シリアライザブル**（**直列化可能**）は、最も厳しい[アイソレーションレベル](#アイソレーションレベル)で、[トランザクション](#トランザクション)は常に1つしか実行されない。データの整合性が失われたり、[デッドロック](#デッドロック)となるケースはない一方で、実行速度は遅い。\n\n"},{"term":"リピータブルリード（再読み込み可能読み取り）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"リピータブルリード","content":"\n**リピータブルリード**（**再読み込み可能読み取り**）は、[シリアライザブル](#シリアライザブル)の次に厳しい[アイソレーションレベル](#アイソレーションレベル)で、データの読み取り時と変更時に[ロック](#ロック)がかかり、[トランザクション](#トランザクション)が終わるまで[ロック](#ロック)は解除されない。\n\n[シリアライザブル](#シリアライザブル)では発生しない[ファントム](#ファントム)が発生する可能性がある。ただし、[RDBMS](./database.md#rdbms)によっては[ファントム](#ファントム)が発生しない。\n\n"},{"term":"リードアンコミッテッド（コミット済み読み取り）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"リードアンコミッテッド","content":"\n**リードアンコミッテッド**（**コミット済み読み取り**）は、[リードコミッテッド](#リードコミッテッド)の次に緩い[アイソレーションレベル](#アイソレーションレベル)で、データの読み取り時と変更時に[ロック](#ロック)がかかり、読み込み時は[SQL](./sql.md#sql)実行後に[ロック](#ロック)が解除されるが、変更時は[トランザクション](#トランザクション)が終わるまで[ロック](#ロック)が解除されない。\n\n[シリアライザブル](#シリアライザブル)では発生しない[ファントム](#ファントム)と[ファジーリード](#ファジーリード)が発生する可能性がある。\n\n"},{"term":"リードコミッテッド（非コミット読み取り）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"リードコミッテッド","content":"\n**リードコミッテッド**（**非コミット読み取り**）は、最も緩い[アイソレーションレベル](#アイソレーションレベル)で、データの変更時に[ロック](#ロック)がかかり、[トランザクション](#トランザクション)が終わるまで[ロック](#ロック)が解除されない。読み込み時には[ロック](#ロック)がかからない。\n\n[シリアライザブル](#シリアライザブル)では発生しない[ファントム](#ファントム)と[ファジーリード](#ファジーリード)と[ダーティリード](#ダーティリード)が発生する可能性がある。\n\n"},{"term":"ファントム","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ファントム","content":"\n**ファントム**は、[トランザクション](#トランザクション)中である範囲のデータを読み込む[クエリ](./sql.md#クエリ)を複数回実行したときに、2回目以降の実行で最初の実行時よりもデータが増減する現象。[リピータブルリード](#リピータブルリード)（あるいは[リードアンコミッテッド](#リードアンコミッテッド)）よりも緩い[アイソレーションレベル](#アイソレーションレベル)では、データの読み込み時に読み込むデータの[レコードロック](#レコードロック)を取るが、その[レコードロック](#レコードロック)の範囲外で別の[トランザクション](#トランザクション)によりデータが挿入・削除される可能性があるため、ファントムが発生し得る。\n\n"},{"term":"ファジーリード（ノーリピータブルリード）","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ファジーリード","content":"\n**ファジーリード**（**ノーリピータブルリード**）は、[トランザクション](#トランザクション)中で同じ読み込みの[クエリ](./sql.md#クエリ)を複数実行したときに、その結果が変わる現象。[リードアンコミッテッド](#リードアンコミッテッド)よりも緩い[アイソレーションレベル](#アイソレーションレベル)では、データの読み取り後に[ロック](#ロック)が解除されるため、別の[トランザクション](#トランザクション)によってそのデータが変更されるとファジーリードが発生する。\n\n"},{"term":"ダーティリード","link":"./note/ja/./development/database/_/chapters/transaction.md","flagment":"ダーティリード","content":"\n**ダーティリード**は、ある[トランザクション](#トランザクション)の変更が[コミット](#コミット)される前に、別の[トランザクション](#トランザクション)から変更後の値を読み出せてしまう現象。[リードコミッテッド](#リードコミッテッド)では、データの読み出し時に[ロック](#ロック)を獲得しようとしないため、ダーティリードが発生し得る。\n"},{"term":"Docker","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"docker","content":"\n**Docker**は、2013年にリリースされた[OSS](../../../../computer/software/_/chapters/open_source_software.md#オープンソースソフトウェア)で、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)や[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)の開発・配信を行うための[コンテナエンジン](./container.mdコンテナエンジン)。Dockerを利用することで、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発者は[ハードウェア](../../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資源を意識せずに、容易に[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の開発・実行環境を構築することができる。[ハイパーバイザ型](../../../../system/_/chapters/system_architecture.md#ハイパーバイザ型)の[仮想化](../../../../system/_/chapters/system_architecture.md#仮想化技術)[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)に比べて、[ハードウェア](../../../../computer/hardware/_/chapters/hardware.md#ハードウェア)資源の消費が少なく、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)に必要な環境のみを集約して再現することができる。\n\n[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発においては、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)単位での環境の分離や、開発環境の作成と廃棄を容易に行えるというメリットがある。また、運用管理の面で見ても、ITインフラでDockerを運用することにより、開発した[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)を素早く展開することができるDevOps環境やイミュータブルインフラストラクチャが実現しやすくなる。\n\n"},{"term":"Dockerエンジン","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"dockerエンジン","content":"\n**Dockerエンジン**は、[Docker](#docker)の[コンテナエンジン](./container.md#コンテナエンジン)。[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)としてホストOSに常駐し、[コンテナ](./container.md#コンテナ)の管理や実行を担う。\n\n"},{"term":"Dockerクライアント","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"dockerクライアント","content":"\n**Dockerクライアント**は、[Dockerエンジン](#dockerエンジン)を操作するためのインタフェース。ホストOS上で[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)として起動している[Dockerエンジン](#dockerエンジン)に対して命令を与える。遠隔で[Docker](#docker)[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)と通信することも可能。\n\n"},{"term":"Docker Hub","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"docker-hub","content":""},{"term":"Rootfulモード","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"rootfulモード","content":"\n**Rootfulモード**は、[Docker](#docker)のデフォルトのエンジンモード。\n\n"},{"term":"Rootlessモード","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"rootlessモード","content":"\n**Rootlessモード**は、[Docker](#docker)を[root](../../../../computer/linux/_/chapters/user_and_permission.md#rootユーザ)権限を必要とせずに一般[ユーザ](../../../../computer/linux/_/chapters/user_and_permission.md#ユーザ)として利用できるモード。\n\n\n"},{"term":"名前空間（ネームスペース）","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"名前空間","content":"\n**名前空間**（**ネームスペース**）は、[Linux](../../../../computer/linux/_/chapters/linux.md#linux)が持つ機能で、[コンテナ](./container.md#コンテナ)をホストOS上で分離（隔離）するために利用されている。[プロセス](../../../../computer/linux/_/chapters/process_and_job.md#プロセス)や[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)、[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)、[ユーザ](../../../../computer/linux/_/chapters/user_and_permission.md#ユーザ)などを分離する機能となっている。\n\n| 名前空間 | 概要                                                                                     |\n| -------- | ---------------------------------------------------------------------------------------- |\n| UTS      | ホスト名、ドメイン名などを分離                                                           |\n| PID      | 実行するプロセスIDを分離し、異なる名前空間のプロセス同士は互いにアクセスできない         |\n| マウント | ファイルシステムのマウント                                                               |\n| ユーザ   | ユーザやグループの管理を分離                                                             |\n| IPC      | 共有メモリやセマフォ、メッセージキューなどを分離                                         |\n| Network  | ネットワークデバイスやIPアドレス、ルーティングテーブル、フィルタリング、ポート番号を分離 |\n\n\n"},{"term":"コンテナ専用OS","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"コンテナ専用os","content":"\n**コンテナ専用OS**は、[Docker](#docker)などの[コンテナ](./container.md#コンテナ)利用に特化して開発された専用[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)。[コンテナ](./container.md#コンテナ)を稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的な[Linux](../../../../computer/linux/_/chapters/linux.md#linux)とは異なる。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)や稼働する[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)、[パッケージマネージャ](../../../../computer/software/_/chapters/package.md#パッケージマネージャ)などが削られており、[コンテナ](./container.md#コンテナ)の稼働に必要最低限のコンポーネントで構成されている。一般の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)に比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。\n\nコンテナ専用OSとしては、**Red Hat Enterprise Linux CoreOS**(**RHCOS**)、**Fedora CoreOS**、**FlatcarContainer Linux**、**k3OS**といったものが有名。\n\n\n"},{"term":"Fedora CoreOS","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"コンテナ専用os","content":"\n**コンテナ専用OS**は、[Docker](#docker)などの[コンテナ](./container.md#コンテナ)利用に特化して開発された専用[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)。[コンテナ](./container.md#コンテナ)を稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的な[Linux](../../../../computer/linux/_/chapters/linux.md#linux)とは異なる。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)や稼働する[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)、[パッケージマネージャ](../../../../computer/software/_/chapters/package.md#パッケージマネージャ)などが削られており、[コンテナ](./container.md#コンテナ)の稼働に必要最低限のコンポーネントで構成されている。一般の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)に比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。\n\nコンテナ専用OSとしては、**Red Hat Enterprise Linux CoreOS**(**RHCOS**)、**Fedora CoreOS**、**FlatcarContainer Linux**、**k3OS**といったものが有名。\n\n\n"},{"term":"FlatcarContainer Linux","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"コンテナ専用os","content":"\n**コンテナ専用OS**は、[Docker](#docker)などの[コンテナ](./container.md#コンテナ)利用に特化して開発された専用[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)。[コンテナ](./container.md#コンテナ)を稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的な[Linux](../../../../computer/linux/_/chapters/linux.md#linux)とは異なる。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)や稼働する[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)、[パッケージマネージャ](../../../../computer/software/_/chapters/package.md#パッケージマネージャ)などが削られており、[コンテナ](./container.md#コンテナ)の稼働に必要最低限のコンポーネントで構成されている。一般の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)に比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。\n\nコンテナ専用OSとしては、**Red Hat Enterprise Linux CoreOS**(**RHCOS**)、**Fedora CoreOS**、**FlatcarContainer Linux**、**k3OS**といったものが有名。\n\n\n"},{"term":"k3OS","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"コンテナ専用os","content":"\n**コンテナ専用OS**は、[Docker](#docker)などの[コンテナ](./container.md#コンテナ)利用に特化して開発された専用[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)。[コンテナ](./container.md#コンテナ)を稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的な[Linux](../../../../computer/linux/_/chapters/linux.md#linux)とは異なる。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)や稼働する[デーモン](../../../../computer/linux/_/chapters/process_and_job.md#デーモン)、[パッケージマネージャ](../../../../computer/software/_/chapters/package.md#パッケージマネージャ)などが削られており、[コンテナ](./container.md#コンテナ)の稼働に必要最低限のコンポーネントで構成されている。一般の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)に比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。\n\nコンテナ専用OSとしては、**Red Hat Enterprise Linux CoreOS**(**RHCOS**)、**Fedora CoreOS**、**FlatcarContainer Linux**、**k3OS**といったものが有名。\n\n\n"},{"term":"Docker Desktop","link":"./note/ja/./development/docker/_/chapters/docker.md","flagment":"docker-desktop","content":""},{"term":"イメージ","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージ","content":"\n**イメージ**は、[コンテナ](./container.md#コンテナ)の生成時のテンプレートとなるもので、[コンテナ](./container.md#コンテナ)内で使用する[実行ファイル](../../../../computer/software/_/chapters/file_system.md#実行ファイル)や[ライブラリ](../../../../computer/software/_/chapters/package.md#ライブラリ)、[コンテナ](./container.md#コンテナ)起動時に実行させたい[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)などが含まれる。Dockerイメージにより、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の実行環境を容易に入手したり、開発環境と本番環境のランタイムシステムの違いを吸収したりすることができる。また、1つのDockerイメージから複数の[コンテナ](./container.md#コンテナ)を素早く起動することができるため、[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)のスケールを容易に行うことができるというメリットもある。\n\n\n"},{"term":"docker pull","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージの入手","content":"\n`docker pull` は、[Docker Hub](./docker.md#docker-hub)から[Dockerイメージ](#イメージ)を入手する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[インターネット](../../../../network/_/chapters/network.md#インターネット)環境に繋がった状態で実行すると、[イメージ](#イメージ)のダウンロードが始まる。\n\n```sh\n"},{"term":"docker images","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージの一覧","content":"\n`docker images` は、入手した[イメージ](#イメージ)一覧を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker rmi","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージの削除","content":"\n`docker rmi` は、[イメージ](#イメージ)を削除する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[イメージ](#イメージ)を削除するためには、その[イメージ](#イメージ)を元にした[コンテナ](./container.md#コンテナ)を全て停止するか削除する必要がある。ただし、その[イメージ](#イメージ)を元にした停止中の[コンテナ](./container.md#コンテナ)がある場合には、 `-f` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与する必要がある。\n\n```sh\n"},{"term":"docker save","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージのセーブ","content":"\n`docker save` は、[イメージ](#イメージ)を `tar` 形式の[アーカイブ](../../../../computer/software/_/chapters/multimedia.md#アーカイブ)に変換する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker load","link":"./note/ja/./development/docker/_/chapters/image.md","flagment":"イメージのロード","content":"\n`docker load` は、[セーブ](#イメージのセーブ)した[イメージ](#イメージ)の[アーカイブ](../../../../computer/software/_/chapters/multimedia.md#アーカイブ)から[イメージ](#イメージ)を取り込む[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"コンテナ","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナ","content":"\n**コンテナ**は、ホストOS上で独立した[プロセス](../../../../computer/linux/_/chapters/process_and_job.md#プロセス)として実行される[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)環境。[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)の基本[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)や[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の実行[バイナリ](../../../../computer/software/_/chapters/file_system.md#バイナリファイル)、[ライブラリ](../../../../computer/software/_/chapters/package.md#ライブラリ)などの実行環境全体を[パッケージ](../../../../computer/software/_/chapters/package.md#パッケージ)化し、それらをホストOS上の分離された空間で実行できる技術。\n\n"},{"term":"コンテナエンジン","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナエンジン","content":"\n**コンテナエンジン**は、[コンテナ](#コンテナ)を稼働させ、管理するための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)。中でも、実際に[コンテナ](#コンテナ)を実行する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)のことを**コンテナランタイム**という。\n\n\n"},{"term":"コンテナランタイム","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナエンジン","content":"\n**コンテナエンジン**は、[コンテナ](#コンテナ)を稼働させ、管理するための[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)。中でも、実際に[コンテナ](#コンテナ)を実行する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)のことを**コンテナランタイム**という。\n\n\n"},{"term":"docker run","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの起動","content":"\n`docker run` は、[イメージ](./image.md#イメージ)を元にして[コンテナ](#コンテナ)を起動する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker ps","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの一覧","content":"\n`docker ps` は、起動中の[コンテナ](#コンテナ)の一覧を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。また、 `-a` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)をつけることで、停止中の[コンテナ](#コンテナ)も表示することができる。\n\n起動中の[コンテナ](#コンテナ)は `STATUS` に `Up` と表示され、停止中の[コンテナ](#コンテナ)は `Exit` と表示される。\n\n```sh\n$ docker ps -a\nCONTAINER ID   IMAGE          COMMAND       CREATED        STATUS                       PORTS     NAMES\nc2d63875bf6a   ubuntu:22.10   \"/bin/bash\"   2 hours ago    Exited (137) 6 seconds ago             ubuntu_linux_01\n```\n\n"},{"term":"docker inspect","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの情報","content":"\n`docker inspect` は、[コンテナ](#コンテナ)の情報を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker stats","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナのリソース使用状況","content":"\n`docker stats` は、[コンテナ](#コンテナ)のリソース使用状況を追跡する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。 `-a` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定すると、停止している[コンテナ](#コンテナ)を含めてすべてのリソース使用状況を表示する。 `--no-stream` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定すると、リソースの使用状況を追跡するのではなく、一度だけ表示する。 `--no-trunc` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定すると完全なコンテナIDを表示。\n\n```sh\n$ docker stats\nCONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT   MEM %     NET I/O   BLOCK I/O   PIDS\n```\n\n"},{"term":"docker logs","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナのログ","content":"\n`docker logs` は、[コンテナ](#コンテナ)内で作業した命令をログとして確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。 `-t` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を指定すると、時刻付きでログを出力できる。\n\n```sh\n"},{"term":"docker rm","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの削除","content":"\n`docker rm` は、停止中の[コンテナ](#コンテナ)を削除する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[コンテナ](#コンテナ)のIDあるいは[コンテナ](#コンテナ)名を指定することで削除することができる。起動中の[コンテナ](#コンテナ)を停止したい場合は、 `-f` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与する。\n\n```sh\n"},{"term":"docker start","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの起動","content":"\n`docker run` は、[イメージ](./image.md#イメージ)を元にして[コンテナ](#コンテナ)を起動する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker stop","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナの停止","content":"\n`docker stop` は、[コンテナ](#コンテナ)を停止する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker attach","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナのアタッチ","content":"\n`docker attach` は、バックグラウンドで起動中の[コンテナ](#コンテナ)の[シェル](../../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)に接続する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[コンテナ](#コンテナ)内で[シェル](../../../../computer/linux/_/chapters/shell_and_terminal.md#シェル)が動作していない場合は接続することはできず、 `exit` [コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)を用いると[コンテナ](#コンテナ)は停止する。\n\n```sh\n"},{"term":"docker export","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナのエクスポート","content":"\n`docker export` は、[コンテナ](#コンテナ)を `tar` 形式の[アーカイブ](../../../../computer/software/_/chapters/multimedia.md#アーカイブ)に変換する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker import","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"コンテナのインポート","content":"\n`docker import` は、エクスポートした[コンテナ](#コンテナ)の[アーカイブ](../../../../computer/software/_/chapters/multimedia.md#アーカイブ)を元に[イメージ](./image.md#イメージ)を取り込む[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"データコンテナ","link":"./note/ja/./development/docker/_/chapters/container.md","flagment":"データコンテナ","content":"\n**データコンテナ**は、データ専用の[コンテナ](#コンテナ)。[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)の[コンテナ](#コンテナ)とデータの[コンテナ](#コンテナ)を分離して、データの再利用性を高めたり、バックアップやリストアに利用したりする。データコンテナには、 `busybox` [イメージ](./image.md#イメージ)がよく用いられる。\n"},{"term":"Volume","link":"./note/ja/./development/docker/_/chapters/volume_and_mount.md","flagment":"volume","content":"\n**Volume**は、ホストOSが管理するデータを[コンテナ](./container.md#コンテナ)で利用できるようにする機能。Volumeを利用するには、[コンテナ](./container.md#コンテナ)起動時に `--mount` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与し、 `type=volume` を指定する。また、 `readonly` を指定することで、読み取り専用で[マウント](../../../../computer/software/_/chapters/file_system.md#マウント)することができる。 `--mount` の代わりに `-v` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を利用することもできる。\n\nVolumeは基本的に、ホストOS上の `/var/lib/docker/volumes` 以下に作成される。\n\n```sh\n"},{"term":"docker volume create","link":"./note/ja/./development/docker/_/chapters/volume_and_mount.md","flagment":"volumeの作成","content":"\n`docker volume create` は、[ボリューム](#volume)を作成する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker volume ls","link":"./note/ja/./development/docker/_/chapters/volume_and_mount.md","flagment":"volumeの一覧","content":"\n`docker volume ls` は、[ボリューム](#volume)の一覧を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ dokcer volume ls\nDRIVER    VOLUME NAME\nlocal     vol_hoge\nlocal     vol_fuga\n```\n\n"},{"term":"bind mount","link":"./note/ja/./development/docker/_/chapters/volume_and_mount.md","flagment":"bind-mount","content":""},{"term":"tmpfs mount","link":"./note/ja/./development/docker/_/chapters/volume_and_mount.md","flagment":"tmpfs-mount","content":""},{"term":"Dockerfile","link":"./note/ja/./development/docker/_/chapters/dockerfile.md","flagment":"dockerfile","content":"\n**Dockerfile**は、[イメージ](./image.md#イメージ)を作成するための手順を示した定義書。[イメージ](./image.md#イメージ)がどのような[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)で構成されているのか、どのような手順で構築されるのかといった情報を含んでおり、[イメージ](./image.md#イメージ)のメンテナンス性を向上させる。\n\n```dockerfile\nFROM python:3.6\n\nWORKDIR /app\nADD . /app\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\nEXPOSE 80\nENV DISTRIBUTION dev\nCMD [\"python\", \"app.py\"]\n```\n\n"},{"term":"ビルドコンテキスト","link":"./note/ja/./development/docker/_/chapters/dockerfile.md","flagment":"ビルドコンテキスト","content":"\n**ビルドコンテキスト**は、[イメージ](./image.md#イメージ)の[ビルド](#dockerfileのビルド)時に与える付加情報。[Dockerfile](#dockerfile)内でホストOSを参照する命令において、参照先となる[パス](../../../../computer/software/_/chapters/file_system.md#パス)を指定する。\n\n"},{"term":"docker build","link":"./note/ja/./development/docker/_/chapters/dockerfile.md","flagment":"dockerfileのビルド","content":"\n`docker build` は、[Dockerfile](#dockerfile)から[イメージ](./image.md#イメージ)を生成する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。[コンテキスト](#ビルドコンテキスト)には、[Dockerfile](#dockerfile)が参照するホストOSの[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)[パス](../../../../computer/software/_/chapters/file_system.md#パス)を指定する。デフォルトでは[カレントディレクトリ](../../../../computer/software/_/chapters/file_system.md#カレントディレクトリ)にある `Dockerfile` という名前の[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)を元にビルドを行うが、 `-f` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)で任意の[Dockerfile](#dockerfile)を使用できる。また、 `-t` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与して、[イメージ](./image.md#イメージ)名やタグを指定できる。\n\n```sh\n"},{"term":"マルチステージビルド","link":"./note/ja/./development/docker/_/chapters/dockerfile.md","flagment":"マルチステージビルド","content":"\n**マルチステージビルド**は、[Dockerfile](#dockerfile)内に、処理対象とする[イメージ](./image.md#イメージ)を複数記述して、それらから生成された[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)や[バイナリ](../../../../computer/software/_/chapters/file_system.md#バイナリファイル)を最終的な[Dockerイメージ](./image.md#イメージ)に埋め込む方法。マルチステージビルドを利用することにより、開発用の[Dockerイメージ](./image.md#イメージ)と本番環境用の[Dockerイメージ](./image.md#イメージ)を1つの[Dockerfile](#dockerfile)で記述できたり、[イメージ](./image.md#イメージ)のファイルサイズを減らすことができる。\n\n以下は、[Rust](../../../../programming/rust/_/chapters/rust.md)によって開発環境で[ビルド](#dockerfileのビルド)したリリースバイナリを、リリース用の[イメージ](./image.md#イメージ)にコピーするマルチステージビルド[Dockerfile](#dockerfile)の例。\n\n```dockerfile\n"},{"term":"bridge","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"bridge","content":"\n**bridge**は、デフォルトのネットワークドライバで、[コンテナ](./container.md#コンテナ)はブリッジを介してホストOSの[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)空間に接続される。vethペアの一方が[コンテナ](./container.md#コンテナ)の仮想ネットワークインタフェースとして割り当てられ、もう一方がブリッジネットワークを介してホストOSのネットワークインタフェースに接続される。\n\n"},{"term":"host","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"host","content":"\n**host**は、[Docker](./docker.md#docker)のネットワークドライバのひとつで、[コンテナ](./container.md#コンテナ)が[ホスト](../../../../network/_/chapters/network.md#ホスト)側の[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)名前空間を共有する方法。[Docker](./docker.md#docker)の仮想ネットワークを介することがないため、本番環境における性能の最適化などに利用される。ただし、[ホスト](../../../../network/_/chapters/network.md#ホスト)側との[ポート](../../../../network/_/chapters/address_on_network.md#ポート番号)競合が発生する可能性があるので注意が必要。\n\n"},{"term":"overlay","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"overlay","content":"\n**overlay**は、[Docker](./docker.md#docker)のネットワークドライバのひとつで、マルチ[ホスト](../../../../network/_/chapters/network.md#ホスト)環境において複数の[Dockerデーモン](./docker.md#dockerデーモン)上の[コンテナ](./container.md#コンテナ)を接続する方法。ネットワークトンネルを使用して[ホスト](../../../../network/_/chapters/network.md#ホスト)間通信を行うことで、[コンテナ](./container.md#コンテナ)が同じ[ホスト](../../../../network/_/chapters/network.md#ホスト)上に存在するかのように動作させることができる。\n\n"},{"term":"ipvlan","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ipvlan","content":"\n**ipvlan**は、[Docker](./docker.md#docker)のネットワークドライバのひとつで、[IPv4](../../../../network/_/chapters/internet_layer.md#ipv4)と[IPv6](../../../../network/_/chapters/internet_layer.md#ipv6)の両方の[IPアドレス](../../../../network/_/chapters/address_on_network.md#ipアドレス)の割り当てをユーザがコントロールできる方法。\n\n"},{"term":"macvlan","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"macvlan","content":"\n**macvlan**は、[Docker](./docker.md#docker)のネットワークドライバのひとつで、[コンテナ](./container.md#コンテナ)に対して[MACアドレス](../../../../network/_/chapters/address_on_network.md#macアドレス)を割り当て、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)上の物理デバイスをシミュレートする方法。[コンテナ](./contaner.md#コンテナ)を、ホストOSと同じ[LAN](../../../../network/_/chapters/network.md#lan)[セグメント](../../../../network/_/chapters/datalink_layer.md#セグメント)に所属した、ひとつの物理機器として扱うことができる。\n\n"},{"term":"none","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"none","content":"\n**none**は、[Docker](./docker.md#docker)のネットワークドライバのひとつで、[コンテナ](./container.md#コンテナ)の[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)機能を無効化する方法。noneネットワークを割り当てた[コンテナ](./container.md#コンテナ)は、別の[コンテナ](./container.md#コンテナ)やホストOS、外部[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)には接続できなくなる。\n\n"},{"term":"デフォルトネットワーク","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"デフォルトネットワーク","content":"\n**デフォルトネットワーク**は、[Docker](./docker.md#docker)をインストールした際に自動的に作成される[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)。[bridge](#bridge)と[host](#host)、[none](#none)が作成される。デフォルトの[bridge](#bridge)は、**docker0**という名前になっており、[コンテナ](./container.md#コンテナ)に対して[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を指定しなかった場合はこれが利用される。\n\n\n"},{"term":"docker0","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"デフォルトネットワーク","content":"\n**デフォルトネットワーク**は、[Docker](./docker.md#docker)をインストールした際に自動的に作成される[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)。[bridge](#bridge)と[host](#host)、[none](#none)が作成される。デフォルトの[bridge](#bridge)は、**docker0**という名前になっており、[コンテナ](./container.md#コンテナ)に対して[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を指定しなかった場合はこれが利用される。\n\n\n"},{"term":"docker network create","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの作成","content":"\n`docker network create` は、新しい[Docker](./docker.md#docker)[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を作成する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。 `--attachable` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与すると、手動による[コンテナ](./container.md#コンテナ)のアタッチが可能となる。また、 `--subnet` [オプション](../../../../computer/linux/_/chapters/basic_command.md#オプション)を付与することで、[コンテナ](./container.md#コンテナ)が所属する[サブネット](../../../../network/_/chapters/address_on_network.md#サブネットワーク)を指定することができる。\n\n```sh\n"},{"term":"docker network ls","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの一覧","content":"\n`docker network ls` は、[Docker](./docker.md#docker)上に存在する[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を一覧で表示する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ docker network ls\nNETWORK ID     NAME                DRIVER    SCOPE\ne7d006713a1a   bridge              bridge    local\n4d634efa7d98   host                host      local\n58494b028369   none                null      local\n```\n\n\n"},{"term":"docker network rm","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの削除","content":"\n`docker network rm` は、[Docker](./docker.md#docker)上に存在する[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)を削除する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker network inspect","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの詳細","content":"\n`docker network inspect` は、[Docker](./docker.md#docker)上に存在する[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)の詳細を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker network connect","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの接続","content":"\n`docker network connect` は、[コンテナ](./container.md#コンテナ)を[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)に接続する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"docker network disconnect","link":"./note/ja/./development/docker/_/chapters/network.md","flagment":"ネットワークの切断","content":"\n`docker network disconnect` は、[コンテナ](./container.md#コンテナ)を[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)から切断する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n"},{"term":"Docker Compose","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-compose","content":""},{"term":"docker compose build","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによるビルド","content":""},{"term":"docker compose up","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによる起動","content":""},{"term":"docker compose start","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによる起動","content":""},{"term":"docker compose stop","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによる停止","content":""},{"term":"docker compose rm","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによる削除","content":""},{"term":"docker compose down","link":"./note/ja/./development/docker/_/chapters/docker_compose.md","flagment":"docker-composeによる削除","content":""},{"term":"Docker Swarm","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarm","content":""},{"term":"Swarm Manager","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarm","content":""},{"term":"docker swarm init","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmの起動","content":""},{"term":"docker swarm join","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmノードの追加","content":""},{"term":"docker swarm join-token","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmのトークンの確認","content":""},{"term":"docker swarm node ls","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmノードの確認","content":""},{"term":"Docker Swarmサービス","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービス","content":""},{"term":"docker service create","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの作成","content":""},{"term":"docker service ls","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの一覧","content":""},{"term":"docker service ps","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの確保","content":""},{"term":"docker service update","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの更新","content":""},{"term":"docker service rm","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの削除","content":""},{"term":"docker service scale","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmサービスの削除","content":""},{"term":"Docker Swarmスタック","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmスタック","content":""},{"term":"docker stack deploy","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmスタックのデプロイ","content":""},{"term":"docker stack ls","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmスタックの一覧","content":""},{"term":"docker stack ps","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmスタックの確認","content":""},{"term":"docker stack remove","link":"./note/ja/./development/docker/_/chapters/docker_swarm.md","flagment":"docker-swarmスタックの削除","content":""},{"term":"コンテナオーケストレーション","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"コンテナオーケストレーション","content":"\n**コンテナオーケストレーション**は、複数の[コンテナ](./container.md#コンテナ)やマルチサーバに導入されている[Docker](./docker.md#docker)の管理、[コンテナ](./container.md#コンテナ)のデプロイなど、[コンテナ](./container.md#コンテナ)をより便利に扱うための機能。\n\n\n"},{"term":"Kubernetes管理ノード","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"kubernetes","content":"\n**Kubernetes**(**K8s**)は、Googleが開発した[コンテナオーケストレーション](#コンテナオーケストレーション)ツール。複数の物理[サーバ](../../../../computer/_/chapters/computer.md#サーバ)からなるマルチ[ホスト](../../../../network/_/chapters/network.md#ホスト)の[コンテナ](./container.md#コンテナ)環境を統合的に管理するためのフレームワーク。Kubernetesは、マルチ[ホスト](../../../../network/_/chapters/network.md#ホスト)の[コンテナ](./container.md#コンテナ)環境全体を管理する**Kubernetes管理ノード**（マスタノード）と、コンテナが稼働する**管理対象ノード**（ワーカノード）からなる。\n\nKubernetesは、[Docker](./docker.md#docker)だけではなくcontainerdやcri-oといった[コンテナエンジン](./container.md#コンテナエンジン)もサポートしている。\n\n"},{"term":"管理対象ノード","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"kubernetes","content":"\n**Kubernetes**(**K8s**)は、Googleが開発した[コンテナオーケストレーション](#コンテナオーケストレーション)ツール。複数の物理[サーバ](../../../../computer/_/chapters/computer.md#サーバ)からなるマルチ[ホスト](../../../../network/_/chapters/network.md#ホスト)の[コンテナ](./container.md#コンテナ)環境を統合的に管理するためのフレームワーク。Kubernetesは、マルチ[ホスト](../../../../network/_/chapters/network.md#ホスト)の[コンテナ](./container.md#コンテナ)環境全体を管理する**Kubernetes管理ノード**（マスタノード）と、コンテナが稼働する**管理対象ノード**（ワーカノード）からなる。\n\nKubernetesは、[Docker](./docker.md#docker)だけではなくcontainerdやcri-oといった[コンテナエンジン](./container.md#コンテナエンジン)もサポートしている。\n\n"},{"term":"Pod","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"pod","content":"\n**Pod**は、[管理対象ノード](#kubernetes)上で稼働する複数の[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)[コンテナ](./container.md#コンテナ)をひとまとめにしたものの単位。[Kubernetes](#kubernetes)ではPodを単位として[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)を管理する。\n\n"},{"term":"ReplicaSet","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"replicaset","content":"\n**ReplicaSet**は、[Kubernetes](#kubernetes)において複数の[Pod](#pod)のレプリカをセットで作成する機能。\n\n"},{"term":"kubectl run","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"podの起動","content":"\n`kubectl run` は、[Pod](#pod)単位で[コンテナ](./container.md#コンテナ)を起動する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl run <pod> --image=<image>:<tag>\n```\n\n"},{"term":"kubectl get pods","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"podの状態確認","content":"\n`kubectl get pods` は、[Pod](#pod)の状態を一覧で確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl get pods\n```\n\n`kubectl describe pods` は、[Pod](#pod)の詳細を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl describe pods <pod>\n```\n\n\n"},{"term":"kubectl describe pods","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"podの状態確認","content":"\n`kubectl get pods` は、[Pod](#pod)の状態を一覧で確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl get pods\n```\n\n`kubectl describe pods` は、[Pod](#pod)の詳細を確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl describe pods <pod>\n```\n\n\n"},{"term":"kubectl get rs","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"replicasetの状態確認","content":"\n`kubectl get rs` は、[ReplicaSet](#replicaset)の状態を一覧で確認する[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl get rs\n```\n\n"},{"term":"kubectl scale","link":"./note/ja/./development/docker/_/chapters/kubernetes.md","flagment":"replicasetのスケール","content":"\n`kubectl scale` は、[ReplicaSet](#replicaset)のスケールを行う[コマンド](../../../../computer/linux/_/chapters/basic_command.md#コマンド)。\n\n```sh\n$ kubectl scale --replicas <replica num> -f <filename>\n```\n"},{"term":"プロセスグループ","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"立上げプロセス群","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"計画プロセス群","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"実行プロセス群","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"監視コントロール・プロセス群","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"終結プロセス群","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセスグループ","content":""},{"term":"知識エリア","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"知識エリア","content":""},{"term":"プロジェクトライフサイクル","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロジェクトライフサイクル","content":""},{"term":"PDCAサイクル（Plan-Do-Check-Actサイクル）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"pdcaサイクル","content":""},{"term":"共通フレーム","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"共通フレーム","content":"\n**共通フレーム**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)、[システム](../../../../system/_/chapters/system.md#システム)、サービスの構想から開発、運用、保守、破棄に至るまでのライフサイクルを通じて必要な作業項目、役割などを包括的にまとめたガイドライン。共通フレームでは、各プロセスをアクティビティ、タスク、注記と徐々に詳細化していく。\n\n"},{"term":"V字モデル","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"v字モデル","content":"\n**V字モデル**は、開発からテスト、リリースまでの一連の流れをV字型に並べ、対応関係を表現したモデル。図の左側が開発工程、右側がテスト工程で、それぞれの段階に対応したテストケースを用意することによって、要件を明確化し、品質や信頼性の向上を図ることができる。\n\n![V字モデル](../assets/images/v_model.png)\n\n\n"},{"term":"要件定義","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"要件定義","content":"\n**要件定義**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発プロセスの初期段階で行われる重要な工程で、[システム](../../../../system/_/chapters/system.md#システム)や[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の目的や機能、制約条件などを明確に定義する。\n\n"},{"term":"機能要件","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"機能要件","content":"\n**機能要件**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)や[システム](../../../../system/_/chapters/system.md#システム)に求められる具体的な機能や振る舞いの要件。その[システム](../../../../system/_/chapters/system.md#システム)がどのような機能を提供しなければならないかを明確に定義し、開発やテストの基準となる。\n\nアカウント登録、ログイン、プロフィール編集、メッセージ送信、ファイルアップロード、検索機能、レポート生成、通知機能、といったものは機能要件の例である。\n\n"},{"term":"非機能要件","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"非機能要件","content":"\n**非機能要件**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)や[システム](../../../../system/_/chapters/system.md#システム)に対して機能以外の要求や制約を表す要件。その[システム](../../../../system/_/chapters/system.md#システム)の品質や性能、[セキュリティ](../../../../system/security/_/chapters/security.md#セキュリティ)、信頼性、使いやすさなどの側面に関わる要求を定義する。\n\nパフォーマンス、[可用性](../../../../system/_/chapters/system_performance_evaluation.md#可用性)、[セキュリティ](../../../../system/security/_/chapters/security.md#セキュリティ)、拡張性、ユーザビリティ、メンテナンス性、といったものは非機能要件の例である。\n\n\n"},{"term":"レビュー","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"レビュー","content":"\n**レビュー**は、[システム](../../../../system/_/chapters/system.md#システム)の設計ドキュメントやアーティファクトを評価し、問題や改善点を特定するプロセス。設計が要件を満たしており、[システム](../../../../system/_/chapters/system.md#システム)が適切に構築されることを確認するために行われる。\n\n"},{"term":"ウォークスルー","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"ウォークスルー","content":"\n**ウォークスルー**は、[システム](../../../../system/_/chapters/system.md#システム)開発における[レビュー](#レビュー)手法のひとつで、開発チームや関係者が実際の[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)やドキュメントを順に見ていき、問題や改善点を特定するための対話的なセッションが行われる。ウォークスルーは、問題の早期発見や、理解と共有の促進、チームのコラボレーションを目的として行われる。\n\n"},{"term":"インスペクション","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"インスペクション","content":"\n**インスペクション**は、[システム](../../../../system/_/chapters/system.md#システム)開発における[レビュー](#レビュー)手法のひとつで、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)やドキュメントの品質を向上させるために、経験豊富なチームメンバーや専門家が詳細な検査を行う。インスペクションは、問題の早期発見や、品質の向上、[レビュー](#レビュー)の効率化を目的として行われる。\n\n\n"},{"term":"フローチャート（流れ図）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"フローチャート","content":"\n**フローチャート**（流れ図）は、プロセスや手順をグラフィカルに表現する図。図やシンボルを使って、タスクの流れや意思決定のフロー、プロセスの手順を表現する。フローチャートでは、順次、選択、繰り返しといった[プログラム](../../../../programming/_/chapters/programming.md#プログラム)における基本的な[制御構文](../../../../programming/_/chapters/control_flow.md#制御フロー)を表現することができる。\n\n\n"},{"term":"POA（プロセス中心アプローチ: Process Oriented Approach）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"poa","content":"\n**POA**（プロセス中心アプローチ: Process Oriented Approach）は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の機能（プロセス）を中心としたアプローチで、[システム](../../../../system/_/chapters/system.md#システム)を[サブシステム](../../../../system/_/chapters/system.md#サブシステム)に、さらに段階的に詳細化指定木、最終的には最小機能の単位である[モジュール](../../../../computer/software/_/chapters/package.md#モジュール)に分割する。データの流れを表現する[DFD](#dfd)やプロセスの状態遷移を表現する[状態遷移図](../../../../basics/information_theory/_/chapters/automaton.md#状態遷移図)が用いられたり、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)として[C言語](../../../../programming/_/chapters/programming_language.md#c言語)などの構造化言語がよく採用される。\n\n"},{"term":"プロセス","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"プロセス","content":"\n**プロセス**は、[DFD](#dfd)において、入力データに対して何かしらの処理を施し、データを出力する要素。必ず入力と出力の[データフロー](#データフロー)が存在する。\n\n"},{"term":"ターミネータ","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"ターミネータ","content":"\n**ターミネータ**（外部実体）は、[DFD](#dfd)において、データの入力先、または出力先となる外部要素。\n\n"},{"term":"データストア","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"データストア","content":"\n**データストア**は、[DFD](#dfd)において、データの保存先となる要素。[データベース](../../../database/_/chapters/database.md#データベース)に限らず、[ファイル](../../../../computer/software/_/chapters/file_system.md#ファイル)などのデータを保管する媒体全体を指す。\n\n"},{"term":"データフロー","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"データフロー","content":"\n**データフロー**は、[DFD](#dfd)において、データの移動経路や方向を矢印で表したもの。\n\n\n"},{"term":"DOA（データ中心アプローチ: Data Oriented Approach）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"doa","content":"\n**DOA**（データ中心アプローチ: Data Oriented Approach）は、業務で扱うデータに着目したアプローチで、業務で扱うデータ全体を[ER図](../../../database/_/chapters/rdb.md#er図)を用いてモデル化する。個々の[システム](../../../../system/_/chapters/system.md#システム)はこの[データベース](../../../database/_/chapters/database.md#データベース)を中心に設計することによって、データの整合性や一貫性が保たれ、[システム](../../../../system/_/chapters/system.md#システム)間でのやり取りが容易になる。[プログラミング](../../../../programming/_/chapters/programming.md#プログラミング)と[データベース](../../../database/_/chapters/database.md#データベース)を分離するデータ独立の考え方となっている。\n\n\n"},{"term":"OOA（オブジェクト指向アプローチ: Object Oriented Approach）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"ooa","content":"\n**OOA**（オブジェクト指向アプローチ: Object Oriented Approach）は、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)やデータをオブジェクトとして捉え、それを組み合わせて[システム](../../../../system/_/chapters/system.md#システム)を構築するアプローチ。オブジェクトを表現するために、[クラス図](#クラス図)や[シーケンス図](#シーケンス図)といった[UML](#uml)が用いられたり、[プログラミング言語](../../../../programming/_/chapters/programming.md#プログラミング言語)として[Java](../../../../programming/_/chapters/programming_language.md#java)などの[オブジェクト指向言語](../../../../programming/_/chapters/programming.md#オブジェクト指向プログラミング)がよく採用される。\n\n"},{"term":"UML（統一モデリング言語: Unified Modeling Language）","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"uml","content":"\n**UML**（統一モデリング言語: Unified Modeling Language）は、[オブジェクト指向](../../../../programming/_/chapters/object_oriented.md#オブジェクト指向)で用いられる表記法で、[クラス図](#クラス図)や[シーケンス図](#シーケンス図)などの様々な図が定義されている。\n\n"},{"term":"クラス図","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"クラス図","content":"\n**クラス図**は、[クラス](../../../../programming/_/chapters/object_oriented.md#クラス)の仕様と[クラス](../../../../programming/_/chapters/object_oriented.md#クラス)間の関係を表現する図。[ER図](../../../database/_/chapters/rdb.md#er図)の発展形のようになっており、データのエンティティだけでなく、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の持つプロセス（[メソッド](../../../../programming/_/chapters/object_oriented.md#メソッド)）も表現する。\n\n"},{"term":"シーケンス図","link":"./note/ja/./development/management/_/chapters/development_process.md","flagment":"シーケンス図","content":"\n**シーケンス図**は、[インスタンス](../../../../programming/_/chapters/object_oriented.md#インスタンス)間の相互作用を時系列で表現する図。\n"},{"term":"ウォーターフォールモデル","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ウォーターフォールモデル","content":"\n**ウォーターフォールモデル**は、伝統的な[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法で、開発プロジェクトを時系列にいくつかの作業工程に分割し、それを順番に進めていく。[要件定義](./development_process.md#要件定義)、設計、開発、テストという具合に階層的に工程が分けられ、1つの工程が完了すると次の工程に進む。一度進んだ工程は基本的に戻ることはないため、各工程の最後に[レビュー](./development_process.md#レビュー)を行うなどして信頼性を上げる。この開発手法は、事前に要件が明確に定義されていることを前提として行われ、計画の正確さとスケジュールの厳守が鍵となる。そのため、要件の変更や修正が頻繁に起きるプロジェクトには向いていない。\n\n\n"},{"term":"プロトタイピングモデル","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"プロトタイピングモデル","content":"\n**プロトタイピングモデル**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、開発の早い段階で試作品（プロトタイプ）を作成し、それをユーザが確認して評価することで、[システム](../../../../system/_/chapters/system.md#システム)の仕様を確定していく手法。ユーザのフィードバックをもとに設計の詳細化を進めていくことで、開発を行う。ユーザとのコミュニケーションが重視されており、柔軟な開発プロセスが求められる場合に有効。\n\n\n"},{"term":"スパイラルモデル","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スパイラルモデル","content":"\n**スパイラルモデル**は、[システム](../../../../system/_/chapters/system.md#システム)全体をいくつかの部分（[サブシステム](../../../../system/_/chapters/system.md#サブシステム)など）に分け、分割した単位で開発のサイクルを繰り返す手法。部分ごとに開発を行い、ユーザがそれを確認して評価することで、大規模な[システム](../../../../system/_/chapters/system.md#システム)であっても早い段階でフィードバックを反映することができる。仕様変更に対して柔軟に対応できる一方で、初期の想定よりも仕様が肥大化してコストが増大する可能性もある。\n\n\n"},{"term":"アジャイル開発","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"アジャイル開発","content":"\n**アジャイル開発**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、柔軟性と迅速な反応性を重視するスタイル。継続的な改善とユーザのフィードバックに基づいて、進化的に[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の開発を進める。プロジェクトを複数の短い開発サイクル（イテレーション）に分割し、各イテレーションごとに機能を追加、改善していく。[テスト駆動開発](#テスト駆動開発)や自動化テストなどの手法を活用したり、[CI](#ci)、[CD](#cd)を実践することで、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の品質を維持する。この開発手法には、ユーザのニーズに合わせた柔軟な開発や早期の価値提供、進化的な要求変更への対応が可能であるといった利点があるが、開発チームには十分なコミュニケーションや協力が求められる。\n\n"},{"term":"スクラム","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"スクラムチーム","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"プロダクトオーナ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"スクラムマスタ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"スプリント","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"バックログ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"スクラム","content":"\n**スクラム**は、[アジャイル開発](#アジャイル開発)の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から**スクラムチーム**を形成する。\n\n- **プロダクトオーナ**: 作成するプロダクトに最終的に責任を持つメンバー\n- **スクラムマスタ**: プロジェクトの推進に責任を持つメンバー\n\nスクラムの工程の単位は**スプリント**で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログという**バックログ**を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。\n\n"},{"term":"リーンソフトウェア開発","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"リーンソフトウェア開発","content":"\n**リーンソフトウェア開発**は、製造業の現場から生まれた考え方を[アジャイル開発](#アジャイル開発)のプラクティスに適用したもので、次の7つの原則を重視しながら開発を進める。\n\n1. ムダをなくす\n1. 品質を作り込む\n1. 知識を作り出す\n1. 決定を遅らせる\n1. 早く提供する\n1. 人を尊重する\n1. 全体を最適化する\n\n\n"},{"term":"インクリメンタルモデル","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"インクリメンタルモデル","content":"\n**インクリメンタルモデル**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、プロジェクトを複数の段階（インクリメント）に分割し、各段階ごとに機能を追加、拡張していく開発プロセス。最初の段階では基本的な機能やコアの機能を実装し、その後の段階で追加の機能や機能の改善を行う。段階的な開発とリリースを繰り返すことで、早期に動作する[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)を提供することができる。また、各段階での機能の追加や変更は以前の段階に影響を与えないように実装を進めるため、可逆性のある柔軟な開発が可能となる。\n\n\n"},{"term":"エボリューショナルモデル","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"エボリューショナルモデル","content":"\n**エボリューショナルモデル**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の要件や設計を進化させながら開発を進める方法。[ウォーターフォールモデル](#ウォーターフォールモデル)と比較して、より柔軟で迅速な開発を可能とする。このモデルでは、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発を複数の短いイテレーションに分割し、各イテレーションごとに[要件定義](./development_process.md#要件定義)、設計、実装、テストを行う。各イテレーションの結果やフィードバックをもとに、次のイテレーションで改善や変更を行いながら[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)を進化させていく。また、開発の早期にプロトタイプを使用することで、ユーザとのコミュニケーションや要件の検証を行う。\n\n\n"},{"term":"DevOps","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"devops","content":"\n**DevOps**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、開発(Development)と運用(Operations)を組み合わせた言葉。開発担当者と運用担当者が連携して協力し、両者の境目を曖昧にした開発手法。[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)を迅速にビルドおよびテストする文化と環境により、確実なリリースを、以前よりも迅速に高い頻度で可能とする組織体制の構築を目指している。\n\n\n"},{"term":"ユキビタス言語","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ドメイン駆動開発","content":"\n**ドメイン駆動開発**(**DDD**: Domain-Drive Development)は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、ドメイン（業務領域）乗り会とモデリングに基づいて[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の設計や開発を行う。このモデルでは、開発者がドメインを深く理解し、ドメインエキスパートとコミュニケーションを取ることでドメインの要件やビジネスルールを明確にする。**ユキビタス言語**（ドメインエキスパートや開発者が共有する共通の言語）などによるコミュニケーションを通してドメインモデルを作成し、特にコア領域のモデリングや実装に注力する。\n\n\n"},{"term":"CI（継続的インテグレーション: Continuous Integration）","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ci","content":"\n**CI**（継続的インテグレーション: Continuous Integration）は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発のプラクティスのひとつで、開発者が[コード](../../../../programming/_/chapters/programming.md#ソースコード)を中央の[リポジトリ](../../../git/_/chapters/create_repository.md#リポジトリ)に統合し、その変更を自動的にビルドしたりテストしたりする手法。これによりビルドやテストを自動化することができ、早期のバグ検出が期待できるなど[コード](../../../../programming/_/chapters/programming.md#ソースコード)品質を向上させることができる。[CD](#cd)と組み合わせる場合も多い。\n\n\n"},{"term":"CD（継続的デプロイメント: Continuous Deployment、継続的デリバリー: Continuous Delivery）","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"cd","content":"\n**CD**（継続的デプロイメント: Continuous Deployment、継続的デリバリー: Continuous Delivery）は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発のプラクティスのひとつで、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)のビルドやテストが成功した場合に自動的に本番環境へのデプロイを行う手法。ビルドやテストが完了した段階で自動的にデプロイを実施する、あるいは、デプロイを自動化するプロセス（承認フローなど）を提供することにより、ヒューマンエラーの発生を減らすことができる。リリースを迅速に行い、高い品質と安定性が期待できる。[CI](#ciと組み合わせる場合も多い)\n\n\n"},{"term":"ペアプログラミング","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ペアプログラミング","content":"\n**ペアプログラミング**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、2人の開発者が1つの[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)で協力して[コード](../../../../programming/_/chapters/programming.md#ソースコード)を書く方法。1人が**ドライバ**としてキーボードを操作し、もう1人が**ナビゲータ**としてドライバをサポートする。\n\nペアプログラミングの実施により、[コード](../../../../programming/_/chapters/programming.md#ソースコード)を早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。\n\n\n"},{"term":"ドライバ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ペアプログラミング","content":"\n**ペアプログラミング**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、2人の開発者が1つの[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)で協力して[コード](../../../../programming/_/chapters/programming.md#ソースコード)を書く方法。1人が**ドライバ**としてキーボードを操作し、もう1人が**ナビゲータ**としてドライバをサポートする。\n\nペアプログラミングの実施により、[コード](../../../../programming/_/chapters/programming.md#ソースコード)を早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。\n\n\n"},{"term":"ナビゲータ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"ペアプログラミング","content":"\n**ペアプログラミング**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発手法のひとつで、2人の開発者が1つの[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)で協力して[コード](../../../../programming/_/chapters/programming.md#ソースコード)を書く方法。1人が**ドライバ**としてキーボードを操作し、もう1人が**ナビゲータ**としてドライバをサポートする。\n\nペアプログラミングの実施により、[コード](../../../../programming/_/chapters/programming.md#ソースコード)を早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。\n\n\n"},{"term":"リバースエンジニアリング","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"リバースエンジニアリング","content":"\n**リバースエンジニアリング**は、既存の製品や[システム](../../../../system/_/chapters/system.md#システム)を解析して、内部の仕組みや設計を理解するための手法。通常は、逆[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)や逆[アセンブル](../../../../basics/information_theory/_/chapters/compiler_theory.md#アセンブラ)といった手法や、関数の呼び出し関係をグラフで表現した**コールグラフ**を利用して解析を行う。\n\nリバースエンジニアリングの目的には、[システム](../../../../system/_/chapters/system.md#システム)の理解やドキュメント化、[セキュリティ](../../../../system/security/_/chapters/security.md#セキュリティ)評価、脆弱性解析などがある。\n\n\n"},{"term":"コールグラフ","link":"./note/ja/./development/management/_/chapters/development_method.md","flagment":"リバースエンジニアリング","content":"\n**リバースエンジニアリング**は、既存の製品や[システム](../../../../system/_/chapters/system.md#システム)を解析して、内部の仕組みや設計を理解するための手法。通常は、逆[コンパイル](../../../../basics/information_theory/_/chapters/compiler_theory.md#コンパイラ)や逆[アセンブル](../../../../basics/information_theory/_/chapters/compiler_theory.md#アセンブラ)といった手法や、関数の呼び出し関係をグラフで表現した**コールグラフ**を利用して解析を行う。\n\nリバースエンジニアリングの目的には、[システム](../../../../system/_/chapters/system.md#システム)の理解やドキュメント化、[セキュリティ](../../../../system/security/_/chapters/security.md#セキュリティ)評価、脆弱性解析などがある。\n\n\n"},{"term":"インプレースデプロイ","link":"./note/ja/./development/management/_/chapters/deployment_strategy.md","flagment":"インプレースデプロイ","content":"\n**インプレースデプロイ**は、稼働中の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)に対して直接[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)を配置、再起動する方法。最も直感的ではあるが、異常時のロールバックやダウンタイムといったユーザへの影響が発生する可能性がある。\n\n\n"},{"term":"ブルーグリーンデプロイ","link":"./note/ja/./development/management/_/chapters/deployment_strategy.md","flagment":"ブルーグリーンデプロイ","content":"\n**ブルーグリーンデプロイ**は、既存の環境に影響を与えず、新しい環境に新しい[バージョン](../../../../computer/software/_/chapters/package.md#バージョン)を[デプロイ](#デプロイ)する方法。既存の環境とは分離された新しい環境に[デプロイ](#デプロイ)するため、安全性が高く十分なテストを実施することができる。また、ダウンタイムが発生せず、即時ロールバックが可能というメリットもある。一方で、同時に2つの環境を動作させる必要があるため、高コストである。\n\n\n"},{"term":"イミュータブルデプロイ","link":"./note/ja/./development/management/_/chapters/deployment_strategy.md","flagment":"イミュータブルデプロイ","content":"\n**イミュータブルデプロイ**は、[ブルーグリーンデプロイ](#ブルーグリーンデプロイ)と同様、既存の環境とは分離された新しい環境に[デプロイ](#デプロイ)する方法。ただし、新環境への切り替え後に旧環境を削除することでコスをと抑える、という違いがある。ロールバックの際には、再度新しい環境を作り、古い[バージョン](../../../../computer/software/_/chapters/package.md#バージョン)を[デプロイ](#デプロイ)して切り替える。\n\n\n"},{"term":"ローリングデプロイ","link":"./note/ja/./development/management/_/chapters/deployment_strategy.md","flagment":"ローリングデプロイ","content":"\n**ローリングデプロイ**は、一度にすべてのインスタンスに対して更新を行うのではなく、可用性を維持しながら順次更新を行う[デプロイ](#デプロイ)手法。稼働中の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)が複数台で負荷分散されていることが前提。一部を切り離して[デプロイ](#デプロイ)を行い、再びオンラインに戻す（[インプレースデプロイ](#インプレースデプロイ)）、もしくは新しい環境に[デプロイ](#デプロイ)してから旧環境を削除する（[イミュータブルデプロイ](#イミュータブルデプロイ)）、という操作を繰り返す。\n\n\n"},{"term":"カナリアデプロイ","link":"./note/ja/./development/management/_/chapters/deployment_strategy.md","flagment":"カナリアデプロイ","content":"\n**カナリアデプロイ**は、稼働中の[サーバ](../../../../computer/_/chapters/computer.md#サーバ)の一部だけに[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)を[デプロイ](#デプロイ)する方法。特定のユーザだけに新しい[アプリケーション](../../../../computer/software/_/chapters/software.md#応用ソフトウェア)を利用してもらい、新サービスの検証を行う、という目的で行われる。\n"},{"term":"単体テスト（ユニットテスト）","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"単体テスト","content":"\n**単体テスト**（**ユニットテスト**）は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発において最小単位の[コード](../../../../programming/_/chapters/programming.md#ソースコード)（[関数](../../../../programming/_/chapters/function.md#関数)や[クラス](../../../../programming/_/chapters/object_oriented.md#クラス)など）を個別にテストする手法。個々の[コンポーネント](../../../../computer/software/_/chapters/package.md#コンポーネント)が正確に動作し、期待通りの結果を返すかどうかを検証する。このテストは自動化されている場合が多く、[依存関係](../../../../computer/software/_/chapters/package.md#依存関係)を最小限に抑えて細かい粒度で実施される。\n\n\n"},{"term":"結合テスト","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"結合テスト","content":"\n**結合テスト**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発において複数の[コンポーネント](../../../../computer/software/_/chapters/package.md#コンポーネント)や[モジュール](../../../../computer/software/_/chapters/package.md#モジュール)を組み合わせてテストする手法。個々の[コンポーネント](../../../../computer/software/_/chapters/package.md#コンポーネント)が単独で正常に動作することを確認した後に、それらを組み合わせて連携や相互作用をテストする。複数の[コンポーネント](../../../../computer/software/_/chapters/package.md#コンポーネント)を実際の環境に近い状態で組み合わせてテストを行い、データや制御の流れが正しく動作することを確認する。\n\n\n"},{"term":"総合テスト（システムテスト）","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"総合テスト","content":"\n**総合テスト**（**システムテスト**）は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発において[システム](../../../../system/_/chapters/system.md#システム)全体をテストするための手法。[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)が要求仕様を満たし、全体的な機能や性能が期待通りに動作するかを確認スルために行われる。[システム](../../../../system/_/chapters/system.md#システム)が他の[システム](../../../../system/_/chapters/system.md#システム)や外部環境と連携して動作する場合のテストも含まれ、ユーザの視点から実際のシナリオを想定したテストが実施される。\n\n\n"},{"term":"リグレッションテスト","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"リグレッションテスト","content":"\n**リグレッションテスト**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)開発において変更や修正が既存の機能や動作に与える影響を確認するためのテスト手法。新しい[バージョン](../../../../computer/software/_/chapters/package.md#バージョン)の[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)が以前の[バージョン](../../../../computer/software/_/chapters/package.md#バージョン)と同様に正常に動作することを保証するために行われる。既存のテストケースやシナリオを使用して、変更や修正が既存の機能に与える影響をテストする。[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の変更が他の機能や[コンポーネント](../../../../computer/software/_/chapters/package.md#コンポーネント)との相互作用に影響を与える可能性がある場合に特に重要。\n\n\n"},{"term":"ホワイトボックステスト","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"ホワイトボックステスト","content":"\n**ホワイトボックステスト**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の内部構造や実装の詳細を知った上でテストを行う手法。[ソースコード](../../../../programming/_/chapters/programming.md#ソースコード)や内部のロジック、データフローなどを理解し、テストケースを設計する。[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の品質向上や[バグ](../../../../programming/_/chapters/programming.md#バグ)の発見、[プログラム](../../../../programming/_/chapters/programming.md#プログラム)の正確性の検証などを目的として実施される。\n\n\n"},{"term":"チューニング","link":"./note/ja/./development/management/_/chapters/test.md","flagment":"チューニング","content":"\n**チューニング**は、[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)の性能や効率を向上させるためのプロセス。[システム](../../../../system/_/chapters/system.md#システム)のパフォーマンスを最適化し、リソースの効率的な利用を促進することを目的に実施される。これは、[ハードウェア](../../../../computer/hardware/_/chapters/hardware.md#ハードウェア)や[ソフトウェア](../../../../computer/software/_/chapters/software.md#ソフトウェア)、[ネットワーク](../../../../network/_/chapters/network.md#ネットワーク)、[データベース](../../../database/_/chapters/database.md#データベース)など、様々な要素に対して行われる。リソースの使用状況をモニタリングツールなどで監視して、ボトルネックが発生している場所を特定し、[アルゴリズム](../../../../programming/_/chapters/algorithm.md#アルゴリズム)の最適化やリソース（[CPU](../../../../computer/hardware/_/chapters/processor.md#cpu)、[メモリ](../../../../computer/hardware/_/chapters/memory.md#メモリ)など）の最適化などを行う。\n"},{"term":"GraphQL","link":"./note/ja/./development/_/topics/graphql.md","flagment":"graphql","content":"\n**GraphQL**は、[API](../../../network/_/chapters/web.md#web-api)向けのデータ取得・操作のための[クエリ](../../database/_/chapters/sql.md#クエリ)言語および実行環境。Facebookによって開発され、2015年に[オープンソース](../../../computer/software/_/chapters/open_source_software.md#オープンソースソフトウェア)として公開された。[クライアント](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が明示的に必要なデータを要求し、それに対して[サーバ](../../../system/_/chapters/system_processing_model.md#クライアントサーバシステム)が適切なデータを返すことができるようにするための柔軟な構成となっている。\n\nモバイル[アプリケーション](../../../computer/software/_/chapters/software.md#応用ソフトウェア)や[SPA](../../../programming/_/chapters/programming_language.md#javascript)との相性がよく、活躍の場を広げている。\n"}]