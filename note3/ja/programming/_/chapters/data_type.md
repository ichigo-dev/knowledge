# 『データ型』

（最終更新： 2023-01-24）


## 目次

1. [型](#型)
1. [プリミティブ型](#プリミティブ型)
	1. [文字型](#文字型)
	1. [整数型](#整数型)
	1. [固定長小数点数型](#固定長小数点数型)
	1. [浮動小数点数型](#浮動小数点数型)
	1. [ブーリアン型](#ブーリアン型)
	1. [ポインタ型](#ポインタ型)
	1. [参照型](#参照型)
1. [複合型](#複合型)
1. [コンテナ型](#コンテナ型)
	1. [イテレータ](#イテレータ)
	1. [配列](#配列)
	1. [リスト](#リスト)
	1. [スタック](#スタック)
	1. [キュー](#キュー)
	1. [ハッシュテーブル](#ハッシュテーブル)
	1. [連想配列](#連想配列)
	1. [セット](#セット)
	1. [木](#木)
	1. [グラフ](#グラフ)
	1. [文字列型](#文字列型)
1. [オブジェクト型](#オブジェクト型)
1. [データの複製](#データの複製)
	1. [ディープコピー](#ディープコピ―)
	1. [シャローコピー](#シャローコピー)


## 型

**型**は、プログラムで扱うデータを性質や属性によって分類してもの。静的型付け言語においては、プログラマがソースコード中に型を明示することによってコンパイル時にデータの型が決まる。静的型付け言語においては、実行時に自動的に型が判断される。


## プリミティブ型

**プリミティブ型**（**基本データ型**、**原始型**）は、プログラミング言語で標準的に用意されている最も基本的な型。プリミティブ型に属する型は、プログラミング言語においてそれ以上分解することができないシンプルな型として定義されており、プロセッサが高速に演算できるという特徴がある。

### 文字型

**文字型**( `char` )は、自然言語の1文字を格納するための型。1バイトで表現できるASCII文字や、マルチバイト文字で様々な文字種に対応しているJISコードやUnicodeなどのサポートが一般的。

ソースコード中で `'` で囲まれた部分は文字型のデータとして扱われる（ `'` と `"` を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを**文字リテラル**という。

```c
// C言語

int main()
{
    // 文字リテラル
    char charcter = 'a';
    printf("character: %c\n", character);

    return 0;
}
```

### 整数型

**整数型**( `int, short, long' )は、整数値を格納するための型。1バイトが表現できる範囲は0~255(2の8乗)であるため、より大きい数値を扱えるように2バイトや4バイト、8バイトの整数型などを用意しているプログラミング言語もある。**符号付き整数**と**符号なし整数**をサポートしているプログラミング言語もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。

### 固定長小数点数型

**固定長小数点数型**( `fixed` )は、小数を扱うための型で、どのビットを小数点とするかをあらかじめ決めておく。固定小数点数を扱うため、データの解析が容易である一方で、表せる数の範囲は浮動小数点数に比べて狭い。

### 浮動小数点数型

**浮動小数点数型**( `float, double` )は、小数を扱うための型で、浮動小数点方式の小数を扱う。単精度と倍精度で別の型として用意しているプログラミング言語もある。

### ブーリアン型

**ブーリアン型**( `bool, boolean` )は、真偽痴を扱うための型で、 `true` か `false` のどちらかの値が格納される。この型に対しては、論理積( `AND` )、論理和( `OR` )、排他的論理和( `XOR` )、同値、非同値、否定といった論理演算が可能。条件分岐において評価結果としても用いられる。

### ポインタ型

**ポインタ型**は、変数や関数の実体が格納された、メモリ上のアドレスを保持しておくための特殊な型。配列やオブジェクトといった複合型はメモリ上のヒープ領域に格納されており、実体にアクセスするためにはスタック領域のポインタを経由する必要がある。また、スタック領域に格納されたデータに対してもポインタをつくることができる。

プログラム中で利用される変数や関数などのリソースはメモリ上で固有のアドレスに割り当てられており、アドレスを知っていればそのデータにアクセスすることができる。また、メモリアドレスの足し引きによって隣のデータにアクセスすることもできる。一方で、予期しないアドレスのデータを変更してしまうと深刻なバグに繋がるため、注意が必要である。

ポインタのポインタや、さらにそのポインタを作るといったこともできる。

### 参照型

**参照型**はポインタ型と同様、変数や関数が置かれたメモリ上のアドレスを指す型。ポインタ型とは異なり、参照先に書き込むことはできない、読み込み専用のアドレス。また、参照先にデータが存在しないことを禁止しており、ポインタに比べて安全に利用できるという利点がある。


## Null

**Null**は、何もないことを表すデータで、言語によって実装や扱いが異なる。型として定義されている言語もあれば、特別な値として扱う言語もある。空文字や0とは区別され、変数に値が代入されていない状態などを表す。


## 複合型

**複合型**は、プリミティブ型を組み合わせた構造を持つ型。あらかじめ定義された汎用的な型もあるが、多くのプログラミング言語では開発者が独自に定義することもできる。

各プログラミング言語ごとに用意されている複合型や、内部的なデータ構造が異なる場合があるので注意。


## コンテナ型

**コンテナ型**（**コレクション型**）は、同じ型のデータを複数まとめるための抽象データ型。それぞれに特性や得意とする操作が異なるため、用途に応じて適切に使い分けることでプログラムの質が向上する。

### イテレータ

**イテレータ**は、コンテナ型が持つ各要素に対する繰り返し処理の抽象化構造。繰り返し処理のfor分などにおいて利用される。

### 配列

**配列**は、同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べられる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を0とした整数値となっている。

```c
// C言語

char str[] = "Hello, world";

str[5] = "!";
printf("%s\n", str);     // "Hello! world"が出力される
```

配列には、コンパイル時に要素数が決まる固定長配列と、実行時に要素数を動的に追加したり削除したりできる可変長配列がある。通常、固定長配列はメモリ上のスタック領域に、可変長配列はヒープ領域に格納される。可変長配列において、ヒープ領域に確保したサイズが不足した場合、メモリ領域の再確保（アロケート）が発生するため、あらかじめ十分な領域を用意しておくとよい。

可変長配列の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる計算量は常に $O(1)$ で高速である。データの探索にかかる計算量は基本的に $O(N)$ であるが、配列がソート済みである場合は二分探索を用いて $O(\log{N})$ に抑えることもできる。

基本的には使い勝手の良いコンテナ型の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対してはリストを用いた方が良い場合もある。

### リスト

**リスト**（**連結リスト**、**リンクリスト**）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

- **単方向リスト** : 各ノードが次のノードへのポインタを持つリスト
- **双方向リスト** : 各ノードが次のノードと前のノードへのポインタを持つリスト
- **循環リスト** : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

### スタック

**スタック**は、データを**FILO**（First In Last Out: 先入れ後出し）の構造で保持するコンテナ。スタックに対してデータを追加する操作を**プッシュ**、スタックからデータを取り出す操作をポップといい、これを基本操作とするデータ型となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。

### キュー

**キュー**は、データを**FIFO**（First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作を**エンキュー**、キューからデータを取り出す操作を**デキュー**といい、これを基本操作とするデータ型となる。最初にエンキューしたデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを**優先度つきキュー**という。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを**両端キュー**（デック）という。

### ハッシュテーブル

**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ型。キーを基に生成された**ハッシュ値**をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数を**ハッシュ関数**という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータをリンクリストで管理する。**開番地法**では、衝突が発生したときに別のハッシュ関数を用いて次の候補地を算出する。

### 連想配列

**連想配列**（**連想リスト**、**連想コンテナ**、**辞書**）は、インデックスとして文字列などの整数値以外のデータ型を用いることができるようなデータ型。連想配列の実装には、ハッシュテーブルや平衡二分探索木などが用いられる。

### セット

**セット**（**集合**）は、順序のないデータの集まりを表現するデータ型で、重複するデータが存在しないことを保証する。

### 木

**木**は、**ノード**とノード間を結ぶ**エッジ**からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを**ルートノード**（**根ノード**）、子ノードを持つノードを**ブランチノード**（**枝ノード**）、子ノードを持たないノードを**リーフノード**（**葉ノード**）という。

各ノードが持つ子ノードの数が2つに制限された木を**二分木**、リーフの深さがなるべくそろうように構築された木を**平衡木**という。

### グラフ

**グラフ**は、木と同様にノードとエッジからなるデータ構造であるが、木とは異なりノード同士が親子関係を持たない。

### 文字列型

**文字列型**( `string` )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている文字列型を用いる。文字列型のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で `"` で囲まれた部分は文字列型のデータとして扱われる（ `'` と `"` を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを**文字列リテラル**という。

文字列の終端を判別するための特別な文字として、**NULL文字**が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語の一部では、文字列の長さにNULL文字の分の1を加えたサイズのメモリ領域が必要となる。

```c
// C言語

int main()
{
    // 文字列リテラル
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}
```


## オブジェクト型

**オブジェクト型**は、オブジェクト指向のプログラミング言語において、クラスから生成されたオブジェクトを指すデータ型。


## データの複製

プログラム中で用いるデータを複製する方法には、ディープコピーとシャローコピーがある。

### ディープコピー

**ディープコピー**は、メモリ上のデータの実体を別のメモリアドレスにそのまま複製する方法。多くのプログラミング言語では、プリミティブ型のデータの複製はディープコピーによって行われる。

コンテナ型やオブジェクト型のデータは多くのメモリ領域を使用するため、ディープコピーのコストが大きくなる。そのため、明示しない限りはシャローコピーとなるプログラミング言語が多い。このような特徴から、ディープコピーは**高価なコピー**であるとされ、無駄なディープコピーは避けるべきである。

可変長配列のデータを追加するときに、メモリ不足が発生した場合、より広いメモリ領域がアロケートされ、確保した領域に元のデータがディープコピーされる。

### シャローコピー

**シャローコピー**は、メモリ上のデータアドレスを指すポインタを取得する方式。コピー元と同じデータを指し示すポインタを取得する見かけ上のコピーであるため、データの実体が書き換えられると、コピー元もコピー先もデータが置き換わったように見える。そのため、コピー元かコピー先のどちらかのデータだけを変更したいような場合にはディープコピーを用いる必要がある。

コンテナ型やオブジェクト型のデータはディープコピーにかかるコストが大きいため、シャローコピーを用いることで複製のコストが抑えられる。
