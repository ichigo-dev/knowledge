====================

 ******* は、プログラミングにおけるアンチパターンの一種で、例外が発生した場合に、何の処理も行わないことを指す。 ******* により、エラーが発生した際に、その原因を分析することが難しくなる。

Answer: 例外の握り潰し

Source: ../../note/programming/_/chapters/anti_patterns.md

====================

 ********* は、変数名のつけ方やコメントの書き方、制御構文の書き方といった、ソースコードをつくる際にプログラマが守るように定められたルール。プログラミング言語の仕様として定められていたり、構文上のエラーとなることはないが、チーム内でソースコードの一貫性を持たせるために設けることが多い。どの ********* が正しいといった正解はなく、プログラミング言語ごとのコミュニティや開発チームの文化によって、 ********* も異なる。

Answer: コーディングルール

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 **** は、識別子の命名に関するコーディングルール。1つのプログラムの中で複数の **** を組み合わせることも多い（変数はスネークケース、関数はキャメルケースを用いるといった具合）。

特に、複数の単語からなる識別子を使用する場合には、それらの単語の区切りをどのように表現するかによって様々な **** が存在する（識別子にスペースは使用できないため）。

Answer: 命名規則

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ******* は、命名規則の一種で、全ての単語の1文字目を大文字で始め、複数の単語からなる識別子については単語同士をそのままつなげるスタイル。C#などの一部のプログラミング言語で使われることがある。

User
UserName
SetUserName

Answer: パスカルケース

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ******* は、命名規則の一種で、複数の単語からなる識別子において、2つ目以降の単語の1文字目を大文字で始め、単語同士をそのままつなげるスタイル。スネークケースと並んで、様々なプログラミング言語で広く使われている。

user
userName
setUserName

Answer: キャメルケース

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ******* は、命名規則の一種で、複数の単語からなる識別子において、全ての単語を小文字にし、単語同士をアンダースコアでつなげるというスタイル。キャメルケースと並んで、様々なプログラミング言語で広く使われている。

user
user_name
set_user_name

Answer: スネークケース

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ******* は、命名規則の一種で、全ての単語を大文字にし、単語同士をアンダースコアでつなげるというスタイル。定数名として用いられることが多い。

USER
USER_NAME
SET_USER_NAME

Answer: アッパーケース

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ****** は、命名規則の一種で、全ての単語を小文字にし、単語同士をハイフンでつなげるというスタイル。プログラミング言語で採用されることは少なく、HTMLのclass名や属性、CSSのプロパティなどに用いられる。

user
user-name
set-user-name

Answer: ケバブケース

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ******** は、命名規則の一種で、識別子の先頭や末尾に決まった意味のプレフィックス（接頭辞）やサフィックス（接尾辞）を付与するスタイル。流行していた時代もあったが、現代ではアンチパターンとされることもある。ただし、全ての識別子に対してではなく、一部の決まった識別子に対して ******** を適用するのが有効な場合もあるため、適切に利用するとよい。

// メンバ変数にプレフィックスとしてm_をつける
m_name
m_type

// グローバル変数にプレフィックスとしてg_をつける
g_counter
g_error_code

// 変数の型を表すプレフィックスをつける
i_number    // int型
c_alphabet  // char型

Answer: ハンガリアン記法

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ****** は、プログラミング言語の型名である int や、メモリ制御を表す memory 、 flag といった、プログラミング用語やコンピュータ用語に基づいた技術ベースでの命名方法。変数や関数の意図が読み取りづらく、コードの理解が難しくなるため、避けたほうが良い。また、ロジックが不必要に複雑化する危険性もある。

Answer: 技術駆動命名

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 **** は、 001, 002, 003, ... といった具合に番号付きの名前をつける命名方法。変数や関数の意図が読み取りづらく、コードの理解が難しくなるため、避けたほうが良い。また、ロジックが不必要に複雑化する危険性もある。

Answer: 連番命名

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ********** は、ソースコードの記述に関する細かい決まりごと。

Answer: コーディングスタイル

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ***** （字下げ）は、ソースコード中でブロックの構造が分かりやすくなるように、先頭に挿入する空白。 ***** にスペースを用いるか、タブを用いるか、また ***** はスペースいくつ分がよいかといったスタイルの違いがある。よく用いられるのは、スペース2つやスペース4つ、タブなど。基本的には ***** の付け方によってプログラムの動作に影響はないが、Pythonのように ***** が構造を記述する意味を持っている場合もある。

Answer: インデント

Source: ../../note/programming/_/chapters/coding_rule.md

====================

 ***** は、プログラムの処理の流れ。 ***** を記述するためのプログラミング言語の文法を、制御構文という。

プログラムは通常、上から下へと順次実行されていくが、制御構文を用いることで、処理の流れを分岐させたり、繰り返し同じ処理をさせたりすることができる。

Answer: 制御フロー

Source: ../../note/programming/_/chapters/control_flow.md

====================

制御フローは、プログラムの処理の流れ。制御フローを記述するためのプログラミング言語の文法を、 **** という。

プログラムは通常、上から下へと順次実行されていくが、 **** を用いることで、処理の流れを分岐させたり、繰り返し同じ処理をさせたりすることができる。

Answer: 制御構文

Source: ../../note/programming/_/chapters/control_flow.md

====================

 *** （入れ子）は、制御構文中でさらに別の制御構文を記述する構造。

Answer: ネスト

Source: ../../note/programming/_/chapters/control_flow.md

====================

ネスト（ *** ）は、制御構文中でさらに別の制御構文を記述する構造。

Answer: 入れ子

Source: ../../note/programming/_/chapters/control_flow.md

====================

 **** は、ソースコード中で処理をまとめたもの。多くのプログラミング言語では **** は {} で囲まれた範囲となる。Pythonのようにインデントにより処理 **** を表現するものもある。

 **** は入れ子にすることもできる。

Answer: ブロック

Source: ../../note/programming/_/chapters/control_flow.md

====================

 **** は、変数や関数などの識別子を参照できる範囲。変数などが宣言される位置などによって決定される。 **** は、宣言された場所から宣言されたブロックの終わりまでとなる。

// JavaScript

{
    // 変数xを初期化
    let x = 1;

    {
        // 変数yを初期化
        let y = 3;

        // 変数x, yの **** 内なので、問題ない
        console.log(x);
        console.log(y);

        x = x + y;
    }

    // 変数xの **** 内なので問題ない
    console.log(x);

    // 変数yの **** 外なのでエラーとなる
    console.log(y);
}

Answer: スコープ

Source: ../../note/programming/_/chapters/control_flow.md

====================

 ***** とは、ソースコード全体がスコープとなっているデータ（変数）。 ***** なデータには、全ての関数から直接アクセスすることができる。更新されるタイミングがわかりにくかったり、予想外のデータとなってしまうことからバグを生みやすいため、扱いには注意が必要。

Answer: グローバル

Source: ../../note/programming/_/chapters/control_flow.md

====================

 **** とは、そのデータが宣言された関数内でしか参照できないデータ（スコープが関数内に閉じられている変数）。

Answer: ローカル

Source: ../../note/programming/_/chapters/control_flow.md

====================

 **** は、与えられた条件式の結果によって実行する処理ブロックを切り替えるような構文。

Answer: 条件分岐

Source: ../../note/programming/_/chapters/control_flow.md

====================

 ** （ループ）は、条件に応じて特定の処理ブロックを複数回実行するための構文。

Answer: 反復

Source: ../../note/programming/_/chapters/control_flow.md

====================

反復（ *** ）は、条件に応じて特定の処理ブロックを複数回実行するための構文。

Answer: ループ

Source: ../../note/programming/_/chapters/control_flow.md

====================

for 文は、ループの回数を数える ****** を用いて、 ****** に関する条件式を評価しながら反復処理を行う。ループ開始前の ****** の初期化式、 ****** に関する条件式、1回のループ終了時の ****** の更新式を与えることで、ループの回数が決定される。 while 文を用いても同様の処理は実現できるが、 for 文を用いるとより簡潔に記述することができる。一般的な for 文の書式は以下の通り。

for( 初期化式; 条件式; 更新式 )
{
    // 実行する処理ブロック
}

初期化式には、 ****** の初期化を行う処理を記述する。条件式には、 ループを反復する条件を記述し、結果が true となる間処理を繰り返す。更新式には、ループが1回終わったときの更新処理を記述する。

// C言語

int main()
{
    for( int i=0; i<20; i++ )
    {
        printf("%d\n", i);
    }

    return 0;
}

<?php

// PHP

for( $i=0; $i<20; $i++ )
{
    echo($i);
}

?>

Answer: カウンタ変数

Source: ../../note/programming/_/chapters/control_flow.md

====================

for 文は、ループの回数を数えるカウンタ変数を用いて、カウンタ変数に関する条件式を評価しながら反復処理を行う。ループ開始前のカウンタ変数の **** 、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 while 文を用いても同様の処理は実現できるが、 for 文を用いるとより簡潔に記述することができる。一般的な for 文の書式は以下の通り。

for(  **** ; 条件式; 更新式 )
{
    // 実行する処理ブロック
}

 **** には、カウンタ変数の初期化を行う処理を記述する。条件式には、 ループを反復する条件を記述し、結果が true となる間処理を繰り返す。更新式には、ループが1回終わったときの更新処理を記述する。

// C言語

int main()
{
    for( int i=0; i<20; i++ )
    {
        printf("%d\n", i);
    }

    return 0;
}

<?php

// PHP

for( $i=0; $i<20; $i++ )
{
    echo($i);
}

?>

Answer: 初期化式

Source: ../../note/programming/_/chapters/control_flow.md

====================

for 文は、ループの回数を数えるカウンタ変数を用いて、カウンタ変数に関する *** を評価しながら反復処理を行う。ループ開始前のカウンタ変数の初期化式、カウンタ変数に関する *** 、1回のループ終了時のカウンタ変数の更新式を与えることで、ループの回数が決定される。 while 文を用いても同様の処理は実現できるが、 for 文を用いるとより簡潔に記述することができる。一般的な for 文の書式は以下の通り。

for( 初期化式;  *** ; 更新式 )
{
    // 実行する処理ブロック
}

初期化式には、カウンタ変数の初期化を行う処理を記述する。 *** には、 ループを反復する条件を記述し、結果が true となる間処理を繰り返す。更新式には、ループが1回終わったときの更新処理を記述する。

// C言語

int main()
{
    for( int i=0; i<20; i++ )
    {
        printf("%d\n", i);
    }

    return 0;
}

<?php

// PHP

for( $i=0; $i<20; $i++ )
{
    echo($i);
}

?>

Answer: 条件式

Source: ../../note/programming/_/chapters/control_flow.md

====================

for 文は、ループの回数を数えるカウンタ変数を用いて、カウンタ変数に関する条件式を評価しながら反復処理を行う。ループ開始前のカウンタ変数の初期化式、カウンタ変数に関する条件式、1回のループ終了時のカウンタ変数の *** を与えることで、ループの回数が決定される。 while 文を用いても同様の処理は実現できるが、 for 文を用いるとより簡潔に記述することができる。一般的な for 文の書式は以下の通り。

for( 初期化式; 条件式;  ***  )
{
    // 実行する処理ブロック
}

初期化式には、カウンタ変数の初期化を行う処理を記述する。条件式には、 ループを反復する条件を記述し、結果が true となる間処理を繰り返す。 *** には、ループが1回終わったときの更新処理を記述する。

// C言語

int main()
{
    for( int i=0; i<20; i++ )
    {
        printf("%d\n", i);
    }

    return 0;
}

<?php

// PHP

for( $i=0; $i<20; $i++ )
{
    echo($i);
}

?>

Answer: 更新式

Source: ../../note/programming/_/chapters/control_flow.md

====================

loop 文は、処理ブロックを ***** で実行する。一般的には、ループ内である条件において break 文を実行するように制御することで、途中でループを離脱するような実装とする場合が多い。処理を空回ししたい特殊な場合（OSのhaltなど）にも用いられる。通常のアプリケーションにおいて ***** が発生することはバグである場合が多いため、注意して使用する。

Answer: 無限ループ

Source: ../../note/programming/_/chapters/control_flow.md

====================

 * は、プログラムで扱うデータを性質や属性によって分類してもの。静的 * 付け言語においては、プログラマがソースコード中に * を明示することによってコンパイル時にデータの * が決まる。静的 * 付け言語においては、実行時に自動的に * が判断される。

Answer: 型

Source: ../../note/programming/_/chapters/data_type.md

====================

 **** は、プログラムのソースコード中で使用される、数値や文字列などの直接示された値やデータ。一般的なプログラミング言語の多くでサポートされている **** は以下の通り。

|  ****        | データ型     | 例                      | | -------------- | ------------ | ----------------------- | | Null ****    | Null         | null                  | | 真偽値 ****  | ブーリアン型 | true 、 false       | | 数値 ****    | 整数型       | 10 、 100           | | 文字 ****    | 文字型       | 'a' 、 '1'          | | 文字列 ****  | 文字列型     | "a" 、 "こんにちは" |

Answer: リテラル

Source: ../../note/programming/_/chapters/data_type.md

====================

 ********** は、プログラムのソースコード中で使用される、改行やインデントを含めた文字列をそのままの状態で埋め込むための機能。通常の文字列リテラルとは異なり、多くのプログラミング言語では ``` で囲むと利用できる。

Answer: テンプレートリテラル

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******* （基本データ型、原始型）は、プログラミング言語で標準的に用意されている最も基本的な型。 ******* に属する型は、プログラミング言語においてそれ以上分解することができないシンプルな型として定義されており、プロセッサが高速に演算できるという特徴がある。

Answer: プリミティブ型

Source: ../../note/programming/_/chapters/data_type.md

====================

プリミティブ型（ ****** 、原始型）は、プログラミング言語で標準的に用意されている最も基本的な型。プリミティブ型に属する型は、プログラミング言語においてそれ以上分解することができないシンプルな型として定義されており、プロセッサが高速に演算できるという特徴がある。

Answer: 基本データ型

Source: ../../note/programming/_/chapters/data_type.md

====================

プリミティブ型（基本データ型、 *** ）は、プログラミング言語で標準的に用意されている最も基本的な型。プリミティブ型に属する型は、プログラミング言語においてそれ以上分解することができないシンプルな型として定義されており、プロセッサが高速に演算できるという特徴がある。

Answer: 原始型

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** ( char )は、自然言語の1文字を格納するための型。1バイトで表現できるASCII文字や、マルチバイト文字で様々な文字種に対応しているJISコードやUnicodeなどのサポートが一般的。

ソースコード中で ' で囲まれた部分は *** のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを文字リテラルという。

// C言語

int main()
{
    // 文字リテラル
    char charcter = 'a';
    printf("character: %c\n", character);

    return 0;
}

Answer: 文字型

Source: ../../note/programming/_/chapters/data_type.md

====================

文字型( char )は、自然言語の1文字を格納するための型。1バイトで表現できるASCII文字や、マルチバイト文字で様々な文字種に対応しているJISコードやUnicodeなどのサポートが一般的。

ソースコード中で ' で囲まれた部分は文字型のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを ****** という。

// C言語

int main()
{
    //  ****** 
    char charcter = 'a';
    printf("character: %c\n", character);

    return 0;
}

Answer: 文字リテラル

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** ( `int, short, long' )は、整数値を格納するための型。1バイトが表現できる範囲は $0 \sim 255 (2^8)$ であるため、より大きい数値を扱えるように2バイトや4バイト、8バイトの *** などを用意しているプログラミング言語もある。符号付き整数と符号なし整数をサポートしているプログラミング言語もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。

Answer: 整数型

Source: ../../note/programming/_/chapters/data_type.md

====================

整数型( `int, short, long' )は、整数値を格納するための型。1バイトが表現できる範囲は $0 \sim 255 (2^8)$ であるため、より大きい数値を扱えるように2バイトや4バイト、8バイトの整数型などを用意しているプログラミング言語もある。 ****** と符号なし整数をサポートしているプログラミング言語もあり、値が負にならないことがわかっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。

Answer: 符号付き整数

Source: ../../note/programming/_/chapters/data_type.md

====================

整数型( `int, short, long' )は、整数値を格納するための型。1バイトが表現できる範囲は $0 \sim 255 (2^8)$ であるため、より大きい数値を扱えるように2バイトや4バイト、8バイトの整数型などを用意しているプログラミング言語もある。符号付き整数と ****** をサポートしているプログラミング言語もあり、値が負にならないことがわかっている場合には ****** を用いた方が使用できる数の範囲が増える。

Answer: 符号なし整数

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******** ( fixed )は、小数を扱うための型で、どのビットを小数点とするかをあらかじめ決めておく。固定小数点数を扱うため、データの解析が容易である一方で、表せる数の範囲は浮動小数点数に比べて狭い。

Answer: 固定長小数点数型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******* ( float, double )は、小数を扱うための型で、浮動小数点方式の小数を扱う。単精度と倍精度で別の型として用意しているプログラミング言語もある。

Answer: 浮動小数点数型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ****** ( bool, boolean )は、真偽値を扱うための型で、 true か false のどちらかの値が格納される。この型に対しては、論理積( AND )、論理和( OR )、排他的論理和( XOR )、同値、非同値、否定といった論理演算が可能。条件分岐において評価結果としても用いられる。

Answer: ブーリアン型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ***** は、変数や関数の実体が格納された、メモリ上のアドレスを保持しておくための型。配列やオブジェクトといった複合型はメモリ上のヒープ領域に格納されており、実体にアクセスするためにはスタック領域のポインタを経由する必要がある。また、スタック領域に格納されたデータに対してもポインタをつくることができる。

プログラム中で利用される変数や関数などのリソースはメモリ上で固有のアドレスに割り当てられており、アドレスを知っていればそのデータにアクセスすることができる。また、メモリアドレスの足し引きによって隣のデータにアクセスすることもできる。一方で、予期しないアドレスのデータを変更してしまうと深刻なバグに繋がるため、注意が必要である。

ポインタのポインタや、さらにそのポインタを作るといったこともできる。

Answer: ポインタ型

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** はポインタ型と同様、変数や関数が置かれたメモリ上のアドレスを指す型。ポインタ型とは異なり、参照先に書き込むことはできない、読み込み専用のアドレス。また、参照先にデータが存在しないことを禁止しており、ポインタに比べて安全に利用できるという利点がある。

Answer: 参照型

Source: ../../note/programming/_/chapters/data_type.md

====================

 **** は、何もないことを表すデータで、プログラミング言語によって実装や扱いが異なる。型として定義されている言語もあれば、特別な値として扱う言語もある。空文字や 0 とは区別され、変数に値が代入されていない状態などを表す。

Answer: Null

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** は、プリミティブ型を組み合わせた構造を持つ型。あらかじめ定義された汎用的な型もあるが、多くのプログラミング言語では開発者が独自に定義することもできる。

各プログラミング言語ごとに用意されている *** や、内部的なデータ構造が異なる場合があるので注意。

Answer: 複合型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ***** （コレクション型）は、同じ型のデータを複数まとめるための抽象データ型。それぞれに特性や得意とする操作が異なるため、用途に応じて適切に使い分けることでプログラムの質が向上する。

Answer: コンテナ型

Source: ../../note/programming/_/chapters/data_type.md

====================

コンテナ型（ ******* ）は、同じ型のデータを複数まとめるための抽象データ型。それぞれに特性や得意とする操作が異なるため、用途に応じて適切に使い分けることでプログラムの質が向上する。

Answer: コレクション型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ***** は、コンテナ型が持つ各要素に対する繰り返し処理の抽象化構造。繰り返し処理のfor文などにおいて利用される。 ***** はコンテナ内の要素のポインタを指し示しており、ループが進むにつれて次の要素のポインタを返す。

Answer: イテレータ

Source: ../../note/programming/_/chapters/data_type.md

====================

 ** は、同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べられる。要素にはインデックス（添え字）を使ってアクセスすることができる。インデックスは ** の最初の要素を 0 とした整数値となっている。

// C言語

char str[] = "Hello, world";

str[5] = "!";
printf("%s\n", str);     // "Hello! world"が出力される

 ** には、コンパイル時に要素数が決まる固定長 ** と、実行時に要素数を動的に追加したり削除したりできる可変長 ** がある。通常、固定長 ** はメモリ上のスタック領域に、可変長 ** はヒープ領域に格納される。可変長 ** において、ヒープ領域に確保したサイズが不足した場合、メモリ領域の再確保（アロケート）が発生するため、あらかじめ十分な領域を用意しておくとよい。

可変長 ** の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる計算量は常に $O(1)$ で高速である。データの探索にかかる計算量は基本的に $O(N)$ であるが、 ** がソート済みである場合は二分探索を用いて $O(\log{N})$ に抑えることもできる。

基本的には使い勝手の良いコンテナ型の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対してはリストを用いた方が良い場合もある。

Answer: 配列

Source: ../../note/programming/_/chapters/data_type.md

====================

配列は、同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べられる。要素には ****** （添え字）を使ってアクセスすることができる。 ****** は配列の最初の要素を 0 とした整数値となっている。

// C言語

char str[] = "Hello, world";

str[5] = "!";
printf("%s\n", str);     // "Hello! world"が出力される

配列には、コンパイル時に要素数が決まる固定長配列と、実行時に要素数を動的に追加したり削除したりできる可変長配列がある。通常、固定長配列はメモリ上のスタック領域に、可変長配列はヒープ領域に格納される。可変長配列において、ヒープ領域に確保したサイズが不足した場合、メモリ領域の再確保（アロケート）が発生するため、あらかじめ十分な領域を用意しておくとよい。

可変長配列の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ と非常に高速である。一方、任意の ****** に対するデータの追加・削除の際には、その ****** より後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意の ****** の要素にアクセスするのにかかる計算量は常に $O(1)$ で高速である。データの探索にかかる計算量は基本的に $O(N)$ であるが、配列がソート済みである場合は二分探索を用いて $O(\log{N})$ に抑えることもできる。

基本的には使い勝手の良いコンテナ型の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対してはリストを用いた方が良い場合もある。

Answer: インデックス

Source: ../../note/programming/_/chapters/data_type.md

====================

配列は、同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べられる。要素にはインデックス（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を 0 とした整数値となっている。

// C言語

char str[] = "Hello, world";

str[5] = "!";
printf("%s\n", str);     // "Hello! world"が出力される

配列には、コンパイル時に要素数が決まる ***** と、実行時に要素数を動的に追加したり削除したりできる可変長配列がある。通常、 ***** はメモリ上のスタック領域に、可変長配列はヒープ領域に格納される。可変長配列において、ヒープ領域に確保したサイズが不足した場合、メモリ領域の再確保（アロケート）が発生するため、あらかじめ十分な領域を用意しておくとよい。

可変長配列の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる計算量は常に $O(1)$ で高速である。データの探索にかかる計算量は基本的に $O(N)$ であるが、配列がソート済みである場合は二分探索を用いて $O(\log{N})$ に抑えることもできる。

基本的には使い勝手の良いコンテナ型の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対してはリストを用いた方が良い場合もある。

Answer: 固定長配列

Source: ../../note/programming/_/chapters/data_type.md

====================

配列は、同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べられる。要素にはインデックス（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を 0 とした整数値となっている。

// C言語

char str[] = "Hello, world";

str[5] = "!";
printf("%s\n", str);     // "Hello! world"が出力される

配列には、コンパイル時に要素数が決まる固定長配列と、実行時に要素数を動的に追加したり削除したりできる ***** がある。通常、固定長配列はメモリ上のスタック領域に、 ***** はヒープ領域に格納される。 ***** において、ヒープ領域に確保したサイズが不足した場合、メモリ領域の再確保（アロケート）が発生するため、あらかじめ十分な領域を用意しておくとよい。

 ***** の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ と非常に高速である。一方、任意のインデックスに対するデータの追加・削除の際には、そのインデックスより後ろのデータ全てを移動する必要があるため、 $O(N)$ と低速となる。任意のインデックスの要素にアクセスするのにかかる計算量は常に $O(1)$ で高速である。データの探索にかかる計算量は基本的に $O(N)$ であるが、配列がソート済みである場合は二分探索を用いて $O(\log{N})$ に抑えることもできる。

基本的には使い勝手の良いコンテナ型の構造となっているが、中間位置へのデータの挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対してはリストを用いた方が良い場合もある。

Answer: 可変長配列

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** （連結 *** 、リンク *** ）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

• 単方向 ***  : 各ノードが次のノードへのポインタを持つ *** 
• 双方向 ***  : 各ノードが次のノードと前のノードへのポインタを持つ *** 
• 循環 ***  : 末尾のノードが先頭のノードへのポインタを持つ *** （単方向と双方向がある）

 *** は、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

 *** の任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、 *** の要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

リスト（ ***** 、リンクリスト）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

• 単方向リスト : 各ノードが次のノードへのポインタを持つリスト
• 双方向リスト : 各ノードが次のノードと前のノードへのポインタを持つリスト
• 循環リスト : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: 連結リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

リスト（連結リスト、 ****** ）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

• 単方向リスト : 各ノードが次のノードへのポインタを持つリスト
• 双方向リスト : 各ノードが次のノードと前のノードへのポインタを持つリスト
• 循環リスト : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: リンクリスト

Source: ../../note/programming/_/chapters/data_type.md

====================

リスト（連結リスト、リンクリスト）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

•  ******  : 各ノードが次のノードへのポインタを持つリスト
• 双方向リスト : 各ノードが次のノードと前のノードへのポインタを持つリスト
• 循環リスト : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: 単方向リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

リスト（連結リスト、リンクリスト）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

• 単方向リスト : 各ノードが次のノードへのポインタを持つリスト
•  ******  : 各ノードが次のノードと前のノードへのポインタを持つリスト
• 循環リスト : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: 双方向リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

リスト（連結リスト、リンクリスト）は、各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。ノードが別のノードのアドレス情報を持つことによって、データの集まりを表現している。

• 単方向リスト : 各ノードが次のノードへのポインタを持つリスト
• 双方向リスト : 各ノードが次のノードと前のノードへのポインタを持つリスト
•  *****  : 末尾のノードが先頭のノードへのポインタを持つリスト（単方向と双方向がある）

リストは、前後のノードとアドレス上で隣り合っている必要がないため、データ数が増えてもアロケートが発生しないという利点がある。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ と高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり、配列に比べると遅い。これは、リストの要素へアクセスするには、先頭の要素から順番にポインタをたどっていく必要があるためである（メモリ上での配置が隣り合っているとは限らないため）。

Answer: 循環リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

 **** は、データをFILO（First In Last Out: 先入れ後出し）の構造で保持するコンテナ。 **** に対してデータを追加する操作をプッシュ、 **** からデータを取り出す操作をポップといい、これを基本操作とするデータ型となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。

Answer: スタック

Source: ../../note/programming/_/chapters/data_type.md

====================

スタックは、データを **** （First In Last Out: 先入れ後出し）の構造で保持するコンテナ。スタックに対してデータを追加する操作をプッシュ、スタックからデータを取り出す操作をポップといい、これを基本操作とするデータ型となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。

Answer: FILO

Source: ../../note/programming/_/chapters/data_type.md

====================

スタックは、データをFILO（First In Last Out: 先入れ後出し）の構造で保持するコンテナ。スタックに対してデータを追加する操作を **** 、スタックからデータを取り出す操作をポップといい、これを基本操作とするデータ型となる。最後に **** したデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。

Answer: プッシュ

Source: ../../note/programming/_/chapters/data_type.md

====================

スタックは、データをFILO（First In Last Out: 先入れ後出し）の構造で保持するコンテナ。スタックに対してデータを追加する操作をプッシュ、スタックからデータを取り出す操作を *** といい、これを基本操作とするデータ型となる。最後にプッシュしたデータから取り出したいような場合に用いる（画面上のパネルの重なり、積み重ねた本、エレベータの乗り降り）。

Answer: ポップ

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** は、データをFIFO（First In First Out: 先入れ先出し）の構造で保持するコンテナ。 *** に対してデータを追加する操作をエン *** 、 *** からデータを取り出す操作をデ *** といい、これを基本操作とするデータ型となる。最初にエン *** したデータから取り出したいような場合に用いる（待ち行列）。

 *** に追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するような *** のことを優先度つき *** という。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにした *** のことを両端 *** （デック）という。

Answer: キュー

Source: ../../note/programming/_/chapters/data_type.md

====================

キューは、データを **** （First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作をエンキュー、キューからデータを取り出す操作をデキューといい、これを基本操作とするデータ型となる。最初にエンキューしたデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを優先度つきキューという。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを両端キュー（デック）という。

Answer: FIFO

Source: ../../note/programming/_/chapters/data_type.md

====================

キューは、データをFIFO（First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作を ***** 、キューからデータを取り出す操作をデキューといい、これを基本操作とするデータ型となる。最初に ***** したデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを優先度つきキューという。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを両端キュー（デック）という。

Answer: エンキュー

Source: ../../note/programming/_/chapters/data_type.md

====================

キューは、データをFIFO（First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作をエンキュー、キューからデータを取り出す操作を **** といい、これを基本操作とするデータ型となる。最初にエンキューしたデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを優先度つきキューという。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを両端キュー（デック）という。

Answer: デキュー

Source: ../../note/programming/_/chapters/data_type.md

====================

キューは、データをFIFO（First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作をエンキュー、キューからデータを取り出す操作をデキューといい、これを基本操作とするデータ型となる。最初にエンキューしたデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを ******** という。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを両端キュー（デック）という。

Answer: 優先度つきキュー

Source: ../../note/programming/_/chapters/data_type.md

====================

キューは、データをFIFO（First In First Out: 先入れ先出し）の構造で保持するコンテナ。キューに対してデータを追加する操作をエンキュー、キューからデータを取り出す操作をデキューといい、これを基本操作とするデータ型となる。最初にエンキューしたデータから取り出したいような場合に用いる（待ち行列）。

キューに追加する要素に優先度をつけ、優先度に基づいてデータをソートし、取り出し順を制御するようなキューのことを優先度つきキューという。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようにしたキューのことを ***** （デック）という。

Answer: 両端キュー

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******** は、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数をハッシュ関数という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを衝突という。連鎖法では、同じハッシュ値で解決されるデータをリンクリストで管理する。開番地法では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: ハッシュテーブル

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなる **** を複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数をハッシュ関数という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを衝突という。連鎖法では、同じハッシュ値で解決されるデータをリンクリストで管理する。開番地法では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: エントリ

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成された ***** をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。 ***** を産出するための関数をハッシュ関数という。

 ***** をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成される ***** が同じものになってしまう場合があり、これを衝突という。連鎖法では、同じ ***** で解決されるデータをリンクリストで管理する。開番地法では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: ハッシュ値

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数を ****** という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを衝突という。連鎖法では、同じハッシュ値で解決されるデータをリンクリストで管理する。開番地法では、衝突が発生したときに別の ****** を用いて次の候補地となるアドレスを算出する。

Answer: ハッシュ関数

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数をハッシュ関数という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを ** という。連鎖法では、同じハッシュ値で解決されるデータをリンクリストで管理する。開番地法では、 ** が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: 衝突

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数をハッシュ関数という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを衝突という。 *** では、同じハッシュ値で解決されるデータをリンクリストで管理する。開番地法では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: 連鎖法

Source: ../../note/programming/_/chapters/data_type.md

====================

ハッシュテーブルは、キーと値の組からなるエントリを複数格納するデータ型。キーを基に生成されたハッシュ値をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ の計算量で実現することができる。ハッシュ値を産出するための関数をハッシュ関数という。

ハッシュ値をインデックスとした配列であり、インデックスが飛び飛びとなるため、メモリ効率は悪い。

複数の異なるキーから生成されるハッシュ値が同じものになってしまう場合があり、これを衝突という。連鎖法では、同じハッシュ値で解決されるデータをリンクリストで管理する。 **** では、衝突が発生したときに別のハッシュ関数を用いて次の候補地となるアドレスを算出する。

Answer: 開番地法

Source: ../../note/programming/_/chapters/data_type.md

====================

 **** （連想リスト、連想コンテナ、辞書）は、インデックスとして文字列などの整数値以外のデータ型を用いることができるようなコンテナ。 **** の実装には、ハッシュテーブルや平衡二分探索木などが用いられる。

Answer: 連想配列

Source: ../../note/programming/_/chapters/data_type.md

====================

連想配列（ ***** 、連想コンテナ、辞書）は、インデックスとして文字列などの整数値以外のデータ型を用いることができるようなコンテナ。連想配列の実装には、ハッシュテーブルや平衡二分探索木などが用いられる。

Answer: 連想リスト

Source: ../../note/programming/_/chapters/data_type.md

====================

連想配列（連想リスト、 ****** 、辞書）は、インデックスとして文字列などの整数値以外のデータ型を用いることができるようなコンテナ。連想配列の実装には、ハッシュテーブルや平衡二分探索木などが用いられる。

Answer: 連想コンテナ

Source: ../../note/programming/_/chapters/data_type.md

====================

連想配列（連想リスト、連想コンテナ、 ** ）は、インデックスとして文字列などの整数値以外のデータ型を用いることができるようなコンテナ。連想配列の実装には、ハッシュテーブルや平衡二分探索木などが用いられる。

Answer: 辞書

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** （集合）は、順序のないデータの集まりを表現するデータ型で、重複するデータが存在しないことを保証する。

Answer: セット

Source: ../../note/programming/_/chapters/data_type.md

====================

セット（ ** ）は、順序のないデータの集まりを表現するデータ型で、重複するデータが存在しないことを保証する。

Answer: 集合

Source: ../../note/programming/_/chapters/data_type.md

====================

 * は、ノードとノード間を結ぶエッジからなる * 構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された * を二分 * 、リーフの深さがなるべくそろうように構築された * を平衡 * という。

Answer: 木

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、 *** と *** 間を結ぶエッジからなる木構造のデータ。1つの *** が複数の子 *** を持ち、親 *** を持たない *** をルート *** （根 *** ）、子 *** を持つ *** をブランチ *** （枝 *** ）、子 *** を持たない *** をリーフ *** （葉 *** ）という。

各 *** が持つ子 *** の数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: ノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶ *** からなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: エッジ

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードを ****** （根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: ルートノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（ **** ）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: 根ノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードを ******* （枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: ブランチノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（ **** ）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: 枝ノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードを ****** （葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: リーフノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（ **** ）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: 葉ノード

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を *** 、リーフの深さがなるべくそろうように構築された木を平衡木という。

Answer: 二分木

Source: ../../note/programming/_/chapters/data_type.md

====================

木は、ノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないノードをルートノード（根ノード）、子ノードを持つノードをブランチノード（枝ノード）、子ノードを持たないノードをリーフノード（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を二分木、リーフの深さがなるべくそろうように構築された木を *** という。

Answer: 平衡木

Source: ../../note/programming/_/chapters/data_type.md

====================

 *** は、木と同様にノードとエッジからなるデータ構造であるが、木とは異なりノード同士が親子関係を持たない。

Answer: グラフ

Source: ../../note/programming/_/chapters/data_type.md

====================

 **** ( string )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている **** を用いる。 **** のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で " で囲まれた部分は **** のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを文字列リテラルという。

文字列の終端を判別するための特別な文字としては、NULL文字が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語では、文字列の長さにNULL文字の分の1を加えたサイズのメモリ領域が必要となる。

// C言語

int main()
{
    // 文字列リテラル
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}

文字列中で、プログラムとしての特別な意味を持つ文字を含めたい場合は、エスケープシーケンス（プログラムとしての意味を無視する文字）を用いてエスケープする必要がある。多くのプログラミング言語では、特別な文字の前にバックスラッシュをつけることでエスケープシーケンスとなる。

Answer: 文字列型

Source: ../../note/programming/_/chapters/data_type.md

====================

文字列型( string )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている文字列型を用いる。文字列型のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で " で囲まれた部分は文字列型のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを ******* という。

文字列の終端を判別するための特別な文字としては、NULL文字が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語では、文字列の長さにNULL文字の分の1を加えたサイズのメモリ領域が必要となる。

// C言語

int main()
{
    //  ******* 
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}

文字列中で、プログラムとしての特別な意味を持つ文字を含めたい場合は、エスケープシーケンス（プログラムとしての意味を無視する文字）を用いてエスケープする必要がある。多くのプログラミング言語では、特別な文字の前にバックスラッシュをつけることでエスケープシーケンスとなる。

Answer: 文字列リテラル

Source: ../../note/programming/_/chapters/data_type.md

====================

文字列型( string )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている文字列型を用いる。文字列型のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で " で囲まれた部分は文字列型のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを文字列リテラルという。

文字列の終端を判別するための特別な文字としては、 ****** が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語では、文字列の長さに ****** の分の1を加えたサイズのメモリ領域が必要となる。

// C言語

int main()
{
    // 文字列リテラル
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}

文字列中で、プログラムとしての特別な意味を持つ文字を含めたい場合は、エスケープシーケンス（プログラムとしての意味を無視する文字）を用いてエスケープする必要がある。多くのプログラミング言語では、特別な文字の前にバックスラッシュをつけることでエスケープシーケンスとなる。

Answer: NULL文字

Source: ../../note/programming/_/chapters/data_type.md

====================

文字列型( string )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている文字列型を用いる。文字列型のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で " で囲まれた部分は文字列型のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを文字列リテラルという。

文字列の終端を判別するための特別な文字としては、NULL文字が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語では、文字列の長さにNULL文字の分の1を加えたサイズのメモリ領域が必要となる。

// C言語

int main()
{
    // 文字列リテラル
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}

文字列中で、プログラムとしての特別な意味を持つ文字を含めたい場合は、 ********** （プログラムとしての意味を無視する文字）を用いてエスケープする必要がある。多くのプログラミング言語では、特別な文字の前にバックスラッシュをつけることで ********** となる。

Answer: エスケープシーケンス

Source: ../../note/programming/_/chapters/data_type.md

====================

文字列型( string )は、複数の文字からなる文字列を表現するための型。文字型には1つの文字しか格納できないため、2つ以上の文字からなる文字列を取り扱いたい場合はプログラミング言語ごとに用意されている文字列型を用いる。文字列型のオブジェクトを用意している場合もあれば、文字型の配列を文字列として扱う言語もある。

ソースコード中で " で囲まれた部分は文字列型のデータとして扱われる（ ' と " を使い分けないプログラミング言語もある）。このようにクォーテーションで囲まれた、ソースコード中に直接記述された文字のことを文字列リテラルという。

文字列の終端を判別するための特別な文字としては、NULL文字が用いられる（Nullとは異なる）。配列により文字列を表現するプログラミング言語では、文字列の長さにNULL文字の分の1を加えたサイズのメモリ領域が必要となる。

// C言語

int main()
{
    // 文字列リテラル
    char str[] = "All roads lead to Rome.";
    printf("str: %s\n", str);

    return 0;
}

文字列中で、プログラムとしての特別な意味を持つ文字を含めたい場合は、 ***** シーケンス（プログラムとしての意味を無視する文字）を用いて ***** する必要がある。多くのプログラミング言語では、特別な文字の前にバックスラッシュをつけることで ***** シーケンスとなる。

Answer: エスケープ

Source: ../../note/programming/_/chapters/data_type.md

