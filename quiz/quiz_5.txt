====================

 ****** は、試行回数が十分に大きく、発生確率が低いベルヌーイ試行を繰り返し行ったときに、ある事象が何回起こるかを示した離散型の確率分布。

成功する確率が $p$ のベルヌーイ試行を $n$ 回行ったとき、期待発生回数を $\lambda = np$ とおく。このとき、成功する回数 $X$ は以下の式で表され、 $X$ が ****** に従うとき $X \sim Po(\lambda)$ と表す。

$$ \begin{array}{cc} P(X = k) = \frac{\lambda^k e^{-\lambda}}{k!} & (k = 0, 1, 2, \cdots) \end{array} $$

 ****** のグラフ

Answer: ポアソン分布

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 **** （ガウス分布）は、連続的な確率分布の1つであり、平均値と標準偏差によって特徴づけられる。 **** は平均値を中心としたベル型曲線としてグラフ化される。自然現象や社会現象の多くは **** に従っており、実験や推定なども **** を前提として行うことが多い。

平均値を $\mu$ 、分散を $s^2$ とおく。このとき、確率変数 $X$ は以下の式で表され、 $X$ が **** に従うとき $X \sim N(\mu, s^2)$ と表す。

$$ f(x) = \frac{1}{\sqrt{2 \pi s^2}} \exp \left( -\frac{(x - \mu)^2}{2 s^2} \right) $$

 **** のグラフ  **** のグラフ

Answer: 正規分布

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

正規分布（ ***** ）は、連続的な確率分布の1つであり、平均値と標準偏差によって特徴づけられる。正規分布は平均値を中心としたベル型曲線としてグラフ化される。自然現象や社会現象の多くは正規分布に従っており、実験や推定なども正規分布を前提として行うことが多い。

平均値を $\mu$ 、分散を $s^2$ とおく。このとき、確率変数 $X$ は以下の式で表され、 $X$ が正規分布に従うとき $X \sim N(\mu, s^2)$ と表す。

$$ f(x) = \frac{1}{\sqrt{2 \pi s^2}} \exp \left( -\frac{(x - \mu)^2}{2 s^2} \right) $$

正規分布のグラフ 正規分布のグラフ

Answer: ガウス分布

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ****** は、平均が $0$ 、標準偏差が $1$ であるような正規分布のことで、 $N(0, 1)$ と表す。任意の正規分布を ****** に変換することで、確率変数の値を ****** 表から求めることができる。

Answer: 標準正規分布

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

標準正規分布は、平均が $0$ 、標準偏差が $1$ であるような正規分布のことで、 $N(0, 1)$ と表す。任意の正規分布を標準正規分布に変換することで、確率変数の値を ******* から求めることができる。

Answer: 標準正規分布表

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ****** は、ある時点での状態にのみ依存して次の状態が決まるような性質を持つ確率過程。 ****** は過去の状態や未来の状態に依存せず、数学的に扱いやすい。さらに、挙動を決定する変数が1つのみであるものを単純 ****** と呼ぶ。

Answer: マルコフ過程

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

マルコフ過程は、ある時点での状態にのみ依存して次の状態が決まるような性質を持つ確率過程。マルコフ過程は過去の状態や未来の状態に依存せず、数学的に扱いやすい。さらに、挙動を決定する変数が1つのみであるものを ******** と呼ぶ。

Answer: 単純マルコフ過程

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ****** は、マルコフ過程のうち、とりうる状態が離散的なもの。特に時間について離散的なものを指す場合が多く、未来の状態が現在の状態にのみ依存しており、過去とは無関係であるという性質を持つ。

Answer: マルコフ連鎖

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 **** は、2つの変数の関連性の強さを表すための指標。 **** を数値で表したものを相関係数という。

相関係数 $r$ は $-1 \leq r \leq +1$ であり、この値が $1$ に近いほど強い正の相関があるといい、 $-1$ に近いほど強い負の相関があるという。

Answer: 相関関係

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

相関関係は、2つの変数の関連性の強さを表すための指標。相関関係を数値で表したものを **** という。

 ****  $r$ は $-1 \leq r \leq +1$ であり、この値が $1$ に近いほど強い正の相関があるといい、 $-1$ に近いほど強い負の相関があるという。

Answer: 相関係数

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

相関関係は、2つの変数の関連性の強さを表すための指標。相関関係を数値で表したものを相関係数という。

相関係数 $r$ は $-1 \leq r \leq +1$ であり、この値が $1$ に近いほど強い **** があるといい、 $-1$ に近いほど強い負の相関があるという。

Answer: 正の相関

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

相関関係は、2つの変数の関連性の強さを表すための指標。相関関係を数値で表したものを相関係数という。

相関係数 $r$ は $-1 \leq r \leq +1$ であり、この値が $1$ に近いほど強い正の相関があるといい、 $-1$ に近いほど強い **** があるという。

Answer: 負の相関

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 *** （散布図）は、何らかの相関関係があると予想される2つのデータ系列をそれぞれ縦軸と横軸にとって、個々のデータをプロットしたもの。

 *** 

Answer: 相関図

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

相関図（ *** ）は、何らかの相関関係があると予想される2つのデータ系列をそれぞれ縦軸と横軸にとって、個々のデータをプロットしたもの。

相関図

Answer: 散布図

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 **** は、相関関係にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を説明変数、その値をもとに予測したい変数を目的変数という。説明変数が1つの場合を単 **** 、2つ以上の場合を重 **** という。

Answer: 回帰分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

回帰分析は、相関関係にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を **** 、その値をもとに予測したい変数を目的変数という。 **** が1つの場合を単回帰分析、2つ以上の場合を重回帰分析という。

Answer: 説明変数

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

回帰分析は、相関関係にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を説明変数、その値をもとに予測したい変数を **** という。説明変数が1つの場合を単回帰分析、2つ以上の場合を重回帰分析という。

Answer: 目的変数

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

回帰分析は、相関関係にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を説明変数、その値をもとに予測したい変数を目的変数という。説明変数が1つの場合を ***** 、2つ以上の場合を重回帰分析という。

Answer: 単回帰分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

回帰分析は、相関関係にある2つの変数の関係を数式で表現し、データを分析・予測する統計的手法。2つの変数のうち、値が分かっている変数を説明変数、その値をもとに予測したい変数を目的変数という。説明変数が1つの場合を単回帰分析、2つ以上の場合を ***** という。

Answer: 重回帰分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 *********** は、1つのカテゴリ変数（2値の変数）の発生確率を、複数の説明変数によって予測する解析手法。

Answer: ロジスティック回帰分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

ロジスティック回帰分析は、1つの ****** （2値の変数）の発生確率を、複数の説明変数によって予測する解析手法。

Answer: カテゴリ変数

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ***** は、測定値と論理値の差の二乗の合計が最小になるようにパラメータを決定する手法。観測されたデータとモデルの予測値の誤差の平方和を最小化することで、回帰直線を求める。

Answer: 最小二乗法

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ***** (PCA: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。

変換後の低次元のデータについて分散が最大となるものを第一主成分、次に分散が大きくなるものを第二主成分という。

Answer: 主成分分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

主成分分析( *** : Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。

変換後の低次元のデータについて分散が最大となるものを第一主成分、次に分散が大きくなるものを第二主成分という。

Answer: PCA

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 *** 分析(PCA: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向( *** )を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。

変換後の低次元のデータについて分散が最大となるものを第一 *** 、次に分散が大きくなるものを第二 *** という。

Answer: 主成分

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

主成分分析(PCA: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。

変換後の低次元のデータについて分散が最大となるものを ***** 、次に分散が大きくなるものを第二主成分という。

Answer: 第一主成分

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

主成分分析(PCA: Principal Component Analysis)は、高次元のデータをできるだけ情報を失わずに低次元に変換する手法。多数の変数を持つデータセットから、その中で最も分散の大きい方向(主成分)を見つけ出し、次にその方向に沿った成分を削減することで、元のデータの情報をなるべく失わずにデータを圧縮する。

変換後の低次元のデータについて分散が最大となるものを第一主成分、次に分散が大きくなるものを ***** という。

Answer: 第二主成分

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 **** は、高次元のデータの背景にある共通因子を探る手法。主成分分析は高次元のデータを合成することを目的としているが、 **** では高次元データに対して影響を与えている原因を抽出するため、因果関係が逆になっている。

多数の変数から主因子（共通因子）を抽出し、それぞれの変数が主因子によって説明される割合を求める。この割合をもとにして、各変数の特性を説明する。

Answer: 因子分析

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

因子分析は、高次元のデータの背景にある共通因子を探る手法。主成分分析は高次元のデータを合成することを目的としているが、因子分析では高次元データに対して影響を与えている原因を抽出するため、因果関係が逆になっている。

多数の変数から *** （共通因子）を抽出し、それぞれの変数が *** によって説明される割合を求める。この割合をもとにして、各変数の特性を説明する。

Answer: 主因子

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

因子分析は、高次元のデータの背景にある **** を探る手法。主成分分析は高次元のデータを合成することを目的としているが、因子分析では高次元データに対して影響を与えている原因を抽出するため、因果関係が逆になっている。

多数の変数から主因子（ **** ）を抽出し、それぞれの変数が主因子によって説明される割合を求める。この割合をもとにして、各変数の特性を説明する。

Answer: 共通因子

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ** は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出し、それをもとに全体の平均・分散などの傾向を算出する方法。全体のデータのことを母集団、 ** のために取り出したデータのことを標本という。

Answer: 推定

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

推定は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出し、それをもとに全体の平均・分散などの傾向を算出する方法。全体のデータのことを *** 、推定のために取り出したデータのことを標本という。

Answer: 母集団

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

推定は、データ量が多く全てのデータを調査することが困難な場合において、いくつかのデータを取り出し、それをもとに全体の平均・分散などの傾向を算出する方法。全体のデータのことを母集団、推定のために取り出したデータのことを ** という。

Answer: 標本

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ***** は、データの散らばりや分布をわかりやすくするために、データをいくつかの階級に分けてその階級に属するデータの数をまとめた表。

Answer: 度数分布表

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 ****** は、度数分布表をもとにプロットした棒グラフ。

Answer: ヒストグラム

Source: ../../note/basics/applied_mathematics/_/chapters/probability_and_statistics.md

====================

 **** は、ユーザがサービスを受ける際の混雑状況を数理的に表現したもの。待つことなくサービスを受けられる[確率や、サービスの平均待ち時間などを考えるために用いられる。

Answer: 待ち行列

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

 ******* は、待ち行列を考える上で必要となる要素をモデル化して表現したもの。 ******* には以下の情報が含まれている。

• 到着分布 : 待ち行列に並びに来る人の到着間隔
• サービス時間分布 : サービスを行う時間
• 窓口数 : サービスを行う窓口の数

M/M/1モデルやM/M/mモデル、M/D/1モデルなどがある。

Answer: ケンドール記法

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

ケンドール記法は、待ち行列を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。

•  ****  : 待ち行列に並びに来る人の到着間隔
• サービス時間分布 : サービスを行う時間
• 窓口数 : サービスを行う窓口の数

M/M/1モデルやM/M/mモデル、M/D/1モデルなどがある。

Answer: 到着分布

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

ケンドール記法は、待ち行列を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。

• 到着分布 : 待ち行列に並びに来る人の到着間隔
•  ********  : サービスを行う時間
• 窓口数 : サービスを行う窓口の数

M/M/1モデルやM/M/mモデル、M/D/1モデルなどがある。

Answer: サービス時間分布

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

ケンドール記法は、待ち行列を考える上で必要となる要素をモデル化して表現したもの。ケンドール記法には以下の情報が含まれている。

• 到着分布 : 待ち行列に並びに来る人の到着間隔
• サービス時間分布 : サービスを行う時間
•  ***  : サービスを行う窓口の数

M/M/1モデルやM/M/mモデル、M/D/1モデルなどがある。

Answer: 窓口数

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

 ******** は、待ち行列における最もシンプルなモデルで、到着分布とサービス時間分布はランダム（ポアソン分布）で、窓口数は1つのみを仮定している。このモデルにおける平均待ち時間は次の式で求められる。

\begin{array}
\rm{窓口利用率}   & = & \frac{\rm{仕事をしている時間}}{\rm{全体の時間}} = \frac{\rm{平均サービス時間}}{\rm{平均到着間隔}} \
\rm{平均待ち時間} & = & \frac{\rm{窓口利用率}}{1 - \rm{窓口利用率}} \times \rm{平均サービス時間}
\end{array}

Answer: M/M/1モデル

Source: ../../note/basics/applied_mathematics/_/chapters/waiting_queue_theory.md

====================

 *** は、電気信号により情報を伝送するための媒体を指す用語。

Answer: 伝送路

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 *** の伝送路は、決まった方向にしか通信できない。

Answer: 単方向

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 *** の伝送路は、双方向の通信が可能であるが、送信と受信が同時に行えない。

Answer: 半二重

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 *** の伝送路は、双方向の通信が可能であり、送信と受信を同時に行うことができる。

Answer: 全二重

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 **** は、機器同士が通信を行う際に、回線状況などにより伝送データ起こる誤り。

Answer: 送信誤り

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 **** は、ネットワークを通じたデータ伝送などにおいて、送信誤りを検出する方法。

Answer: 誤り検出

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 **** は、送信誤りを検出し、その誤りを受信側で訂正する方法。

Answer: 誤り訂正

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 ****** は、通信回線の混線やケーブルの不具合などにより、一度にまとめて起こる誤り。

Answer: バースト誤り

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 **** は、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に **** ビットを付加する。ビット列の $1$ の数が偶数になるように付加されたものを偶数 **** 、奇数になるように付加されたものを奇数 **** という。

 **** は方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回 **** ビット（垂直 **** ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときの **** ビット列（水平 **** ）を伝送する。垂直 **** と水平 **** の組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: パリティ

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

パリティは、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後に ******* を付加する。ビット列の $1$ の数が偶数になるように付加されたものを偶数パリティ、奇数になるように付加されたものを奇数パリティという。

パリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回 ******* （垂直パリティ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときの ******* 列（水平パリティ）を伝送する。垂直パリティと水平パリティの組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: パリティビット

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

パリティは、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後にパリティビットを付加する。ビット列の $1$ の数が偶数になるように付加されたものを ****** 、奇数になるように付加されたものを奇数パリティという。

パリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（垂直パリティ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（水平パリティ）を伝送する。垂直パリティと水平パリティの組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: 偶数パリティ

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

パリティは、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後にパリティビットを付加する。ビット列の $1$ の数が偶数になるように付加されたものを偶数パリティ、奇数になるように付加されたものを ****** という。

パリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（垂直パリティ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（水平パリティ）を伝送する。垂直パリティと水平パリティの組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: 奇数パリティ

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

パリティは、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後にパリティビットを付加する。ビット列の $1$ の数が偶数になるように付加されたものを偶数パリティ、奇数になるように付加されたものを奇数パリティという。

パリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（ ****** ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（水平パリティ）を伝送する。 ****** と水平パリティの組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: 垂直パリティ

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

パリティは、数字の並びの合計値が偶数であるか奇数であるかによって伝送誤りを検出する方法。この方法では、データの最後にパリティビットを付加する。ビット列の $1$ の数が偶数になるように付加されたものを偶数パリティ、奇数になるように付加されたものを奇数パリティという。

パリティは方法によっては誤り訂正も行うことができる。分割された伝送データの最後に毎回パリティビット（垂直パリティ）を付加し、全てのデータの伝送が終わった後にデータ全体を横断的に見たときのパリティビット列（ ****** ）を伝送する。垂直パリティと ****** の組み合わせにより、どのビットで誤りがあるかを判断することができ、そのビットを反転することで誤りを訂正する。

Answer: 水平パリティ

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 ****** は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

 ****** では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、符号語の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

 ****** では最初に、 $m$ 行 $n$ 列の検査行列 $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

検査行列は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような生成行列 $G$ を求める。前述の検査行列に対する生成行列は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と生成行列の積をとった結果得られる答えが、 ****** 化後の符号語となる。送信したいデータを 1011 とすると、符号語は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、受信語 $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は誤りベクトルとする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、受信語 $Y$ と検査行列の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の列が誤っているということがわかる。例えば、受信語が 1111100 であった場合は次のような誤りベクトルが得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、誤りベクトルの転置行列は検査行列の2列目と一致するので、受信語の2ビット目が誤っている、すなわち正しい受信語は 1011100 であることがわかる。

Answer: ハミング符号

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

ハミング符号は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

ハミング符号では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、 *** の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

ハミング符号では最初に、 $m$ 行 $n$ 列の検査行列 $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

検査行列は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような生成行列 $G$ を求める。前述の検査行列に対する生成行列は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と生成行列の積をとった結果得られる答えが、ハミング符号化後の *** となる。送信したいデータを 1011 とすると、 *** は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、受信語 $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は誤りベクトルとする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、受信語 $Y$ と検査行列の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の列が誤っているということがわかる。例えば、受信語が 1111100 であった場合は次のような誤りベクトルが得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、誤りベクトルの転置行列は検査行列の2列目と一致するので、受信語の2ビット目が誤っている、すなわち正しい受信語は 1011100 であることがわかる。

Answer: 符号語

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

ハミング符号は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

ハミング符号では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、符号語の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

ハミング符号では最初に、 $m$ 行 $n$ 列の ****  $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような **** となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

 **** は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような生成行列 $G$ を求める。前述の **** に対する生成行列は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と生成行列の積をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを 1011 とすると、符号語は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、受信語 $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は誤りベクトルとする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、受信語 $Y$ と **** の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する **** の列が誤っているということがわかる。例えば、受信語が 1111100 であった場合は次のような誤りベクトルが得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、誤りベクトルの転置行列は **** の2列目と一致するので、受信語の2ビット目が誤っている、すなわち正しい受信語は 1011100 であることがわかる。

Answer: 検査行列

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

ハミング符号は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

ハミング符号では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、符号語の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

ハミング符号では最初に、 $m$ 行 $n$ 列の検査行列 $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

検査行列は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような ****  $G$ を求める。前述の検査行列に対する **** は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と **** の積をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを 1011 とすると、符号語は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、受信語 $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は誤りベクトルとする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、受信語 $Y$ と検査行列の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の列が誤っているということがわかる。例えば、受信語が 1111100 であった場合は次のような誤りベクトルが得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、誤りベクトルの転置行列は検査行列の2列目と一致するので、受信語の2ビット目が誤っている、すなわち正しい受信語は 1011100 であることがわかる。

Answer: 生成行列

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

ハミング符号は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

ハミング符号では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、符号語の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

ハミング符号では最初に、 $m$ 行 $n$ 列の検査行列 $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

検査行列は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような生成行列 $G$ を求める。前述の検査行列に対する生成行列は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と生成行列の積をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを 1011 とすると、符号語は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、 ***  $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は誤りベクトルとする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、 ***  $Y$ と検査行列の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の列が誤っているということがわかる。例えば、 *** が 1111100 であった場合は次のような誤りベクトルが得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、誤りベクトルの転置行列は検査行列の2列目と一致するので、 *** の2ビット目が誤っている、すなわち正しい *** は 1011100 であることがわかる。

Answer: 受信語

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

ハミング符号は、データにいくつかの冗長ビットを付加することで、1ビットの誤りを検出し、それを訂正する方法。

ハミング符号では、ある整数 $m$ に対して、符号化するデータのビット数 $k$ と、符号語の長さ $n$ は次のようになる。

\begin{eqnarray}
k & = & n - m \
n & = & 2^m - 1
\end{eqnarray}

ハミング符号では最初に、 $m$ 行 $n$ 列の検査行列 $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。

H =
\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]

検査行列は、全ての列要素がゼロではなく、それぞれが相違となるようなビット列を並べたものとなる。列の並べ方は任意で、上記の例に限らない。

次に、 $HG^{T} = GH^{T} = 0$ を満たすような生成行列 $G$ を求める。前述の検査行列に対する生成行列は次のようになる。

G =
\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

そして、送信したい情報と生成行列の積をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを 1011 とすると、符号語は次のようになる。

\left[
\begin{array}{cccc}
1 & 0 & 1 & 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

受信側では、受信語 $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。

\begin{eqnarray}
Y    & = & xG \
YH^T & = & xGH^T \
YH^T & = & 0
\end{eqnarray}

送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は ****** とする。

\begin{eqnarray}
Y    & = & xG \oplus e_i \
YH^T & = & (xG \oplus e_i)H^T \
YH^T & = & xGH^T \oplus e_i H^T \
YH^T & = & e_i H^T
\end{eqnarray}

これらの関係より、受信語 $Y$ と検査行列の転置行列の積が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の列が誤っているということがわかる。例えば、受信語が 1111100 であった場合は次のような ****** が得られる。

\left[
\begin{array}{ccccccc}
1 & 1 & 1 & 1 & 1 & 0 & 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 & 0 & 1 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 & 1 & 1
\end{array}
\right]

この場合、 ****** の転置行列は検査行列の2列目と一致するので、受信語の2ビット目が誤っている、すなわち正しい受信語は 1011100 であることがわかる。

Answer: 誤りベクトル

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 *** (Cyclic Redundancy Check)は、連続する誤り（バースト誤り）を検出するための誤り制御の仕組み。誤り訂正の機能はない。

送信側では、生成多項式を基にした定数ビット列でデータを除算した剰余をデータの末尾に付与する。受信側では、同様の生成多項式を用いて剰余を求め、データの末尾に付与された値と一致するかを確認する。剰余が一致すれば誤りがないということがわかる。

2進数における除算は、ビット列をずらしながらXOR演算を繰り返し行っていく。このような様子から *** という名前となっている。

Answer: CRC

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

CRC(Cyclic Redundancy Check)は、連続する誤り（バースト誤り）を検出するための誤り制御の仕組み。誤り訂正の機能はない。

送信側では、 ***** を基にした定数ビット列でデータを除算した剰余をデータの末尾に付与する。受信側では、同様の ***** を用いて剰余を求め、データの末尾に付与された値と一致するかを確認する。剰余が一致すれば誤りがないということがわかる。

2進数における除算は、ビット列をずらしながらXOR演算を繰り返し行っていく。このような様子からCRCという名前となっている。

Answer: 生成多項式

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 ****** は、データの整合性を確認するための簡易的なエラーチェック手法のひとつで、主にデータ転送やデータ保存の過程でデータが正しく受信または保存されているかどうかを確認するために使用される。データの各ビットを足し合わせるか、特定の数学的アルゴリズムを用いてビット列全体を変換し、得られた結果を ****** 値としてデータとともに保存する。データを利用する側は、同じアルゴリズムによって受信したデータの ****** 値を計算し、それらを比較することによってデータに誤りがないことを確認する。

Answer: チェックサム

Source: ../../note/basics/communication_theory/_/chapters/transmission_theory.md

====================

 **** とは有限で離散的な値を扱う数学のうち、非計算の分野を対象としたもの。コンピュータでは主に離散値を扱うため、 **** の考え方が基本となる。

Answer: 離散数学

Source: ../../note/basics/discrete_mathematics/README.md

====================

 ***** は、ある数の各桁の数値を左あるいは右にずらすことで、その数のべき乗を計算する方法。n進法において、桁を左へシフトすると数は元の $n$ 倍に、右へシフトすると数は元の $\frac{1}{n}$ 倍になる。

2進数のビット列は、左に $k$ ビットシフトすることで元の数の $2^k$ 倍に、右に $k$ ビットシフトすることで元の数の $2^{-k}$ 倍になる。ただし、あらかじめ決められたビット幅をあふれたビットは捨てられるため、必ず正しい結果になるとは限らない（オーバフローやアンダーフロー）。

Answer: シフト演算

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ***** は、最上位ビットを符号ビットとして扱わずにシフト演算を行う方法。符号ビットが存在しないため、負の数を扱うことはできない。

論理右シフトは、ビット列を右に指定された数だけシフトし、左端には $0$ を埋める演算。

論理左シフトは、ビット列を左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 論理シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

論理シフトは、最上位ビットを符号ビットとして扱わずにシフト演算を行う方法。符号ビットが存在しないため、負の数を扱うことはできない。

 ****** は、ビット列を右に指定された数だけシフトし、左端には $0$ を埋める演算。

論理左シフトは、ビット列を左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 論理右シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

論理シフトは、最上位ビットを符号ビットとして扱わずにシフト演算を行う方法。符号ビットが存在しないため、負の数を扱うことはできない。

論理右シフトは、ビット列を右に指定された数だけシフトし、左端には $0$ を埋める演算。

 ****** は、ビット列を左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 論理左シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ***** は、最上位ビットを符号ビットとして固定してシフト演算を行う方法。

算術右シフトは、符号付きビット列の符号ビット以外のビットを右に指定された数だけシフトし、左端には符号ビットと同じ値を繰り返して埋める演算。

算術左シフトは、符号付きビット列の符号ビット以外のビットを左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 算術シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

算術シフトは、最上位ビットを符号ビットとして固定してシフト演算を行う方法。

 ****** は、符号付きビット列の符号ビット以外のビットを右に指定された数だけシフトし、左端には符号ビットと同じ値を繰り返して埋める演算。

算術左シフトは、符号付きビット列の符号ビット以外のビットを左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 算術右シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

算術シフトは、最上位ビットを符号ビットとして固定してシフト演算を行う方法。

算術右シフトは、符号付きビット列の符号ビット以外のビットを右に指定された数だけシフトし、左端には符号ビットと同じ値を繰り返して埋める演算。

 ****** は、符号付きビット列の符号ビット以外のビットを左に指定された数だけシフトし、右端には $0$ を埋める演算。

Answer: 算術左シフト

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ** は、正確な値と計算結果の差異を指す用語。コンピュータは有限の桁数でしか数値を扱うことができないので、扱える数の範囲が決まっている。そのため、コンピュータが内部で扱う値と真の値の間には、 ** を生じる可能性がある。

浮動小数点数は表現できる数の精度が限られているため、小数点以下の値が正確に表現できない可能性がある。10進数で表したときに有限小数であっても、2進数に変換すると無限小数となる場合もあるので注意が必要（ $0.01_{10}$ など）。

整数の四則演算やシフト演算においても、オーバフローなどの ** が発生する場合がある。

これらの ** を最小限に抑えるためには、適切なビット数で数を表現したり、演算の順序を変えるといった工夫が必要になる。

Answer: 誤差

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 *** は、値がほぼ等しい2つの数値の差を求めたときに、元の数より有効桁数が減ってしまうことで生じる誤差。次の例では、元の数の有効桁数は10桁であるが、計算後の有効桁数は2桁になっている。

$$ \begin{eqnarray} 0.00123456789_{10} - 0.001234567_{10} & = & 0.00000000089_{10} 1.23456789_{10} \times 10^{-3} - 1.234567_{10} \times 10^{-3} & = & 8.9_{10} \times 10^{-10} \end{eqnarray} $$

コンピュータが扱う浮動小数点数は、基数部が正規化されるため、数の右側にある $0$ が正しい値であるか正規化によって付与された値であるかが保証できない。

Answer: 桁落ち

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 **** は、有効桁数が限られた計算において、絶対値が非常に大きい数と小さい数で加算や減算を行った時に、小さい方の数が計算結果に反映されない誤差。次の例では、有効桁数が8桁であるとすると、計算結果に小さい方の数の情報が失われている。

$$ \begin{eqnarray} 1234.5678_{10} + 0.0000001_{10} & = & 1234.5678001_{10} \simeq 1234.5678_{10} 1.2345678_{10} \times 10^3 + 1_{10} \times 10^{-7} & = & 1.2345678001_{10} \times 10^3 \simeq 1.2345678_{10} \times 10^3 \end{eqnarray} $$

Answer: 情報落ち

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 **** は、有効桁数が限られた数値の表現において、切り捨て、切り上げ、四捨五入などを行うことによって、下位の桁が削除されて発生する誤差。例えば、10進数の $\frac{1}{3}$ は、3桁までの有効桁数で表現すると $0.333_{10}$ となり、本来の値から近似された値となっている。また、 $0.1_{10}$ を10回足し合わせると、10進数では $1_{10}$ となるが、2進数では **** により $1_{10}$ よりもわずかに小さくなる。

Answer: 丸め誤差

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ****** は、有効桁数が限られた計算において、計算結果の小数部を切り捨てることで生じる誤差。小数点以下の桁数が多い演算においては、 ****** が顕著になる。

Answer: 打ち切り誤差

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ****** （桁あふれ）は、演算の結果が、決められた桁数の中で表すことができる数値の範囲を超えることで発生する誤差。例えば、1バイトの符号付き整数データであれば、表現できる範囲は $-128 \sim 127$ であるが、上限である $127$ を超える結果、あるいは下限である $-128$ を下回る結果となるような演算を行うと、 ****** が発生する。

Answer: オーバフロー

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

オーバフロー（ **** ）は、演算の結果が、決められた桁数の中で表すことができる数値の範囲を超えることで発生する誤差。例えば、1バイトの符号付き整数データであれば、表現できる範囲は $-128 \sim 127$ であるが、上限である $127$ を超える結果、あるいは下限である $-128$ を下回る結果となるような演算を行うと、オーバフローが発生する。

Answer: 桁あふれ

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 ******* は、浮動小数点数の演算において、演算結果の指数部が小さくなりすぎることで数値を表現できなくなるような誤差。浮動小数点数の指数部で表現可能な範囲の最小値よりも小さくなった場合に発生する。 $0$ に限りなく近い数値を扱う場合などに ******* が発生することがある。

Answer: アンダーフロー

Source: ../../note/basics/discrete_mathematics/_/chapters/arithmetic_operation_and_precision.md

====================

 **** は、命題や真偽値を対象として行う演算。命題の評価や条件文の制御、データのフィルタリング等、様々な分野で使用される。

基本な **** には、OR演算、AND演算、NOT演算があり、これらはコンピュータが行う演算の最小単位となる。真偽値は2進数1桁で表現することができ、これはコンピュータが扱う情報の最小単位であるため、コンピュータが行う演算は全てこれらの **** の組み合わせにより成り立っている。

また、基本 **** を組み合わせた複合的な **** として、NOR演算、NAND演算、XOR演算などがある。

 **** の入出力関係は真理値表やベン図を用いて表されることが多い。

Answer: 論理演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 **** は、論理演算の入力の組み合わせと出力を表で表現したもの。例えば、入力を $x$ 、出力を $z$ とし、 $x$ を反転した値を出力するような論理演算についての **** は以下のように表される。

| $x$ | $z$ | | --- | --- | | $0$ | $1$ | | $1$ | $0$ |

Answer: 真理値表

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 **** （論理和）は、2つの真偽値の入力値のうち、どちらか一方でも真であれば真を出力する演算で、数学的には和集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $1$ |

 **** のベン図

Answer: OR演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

OR演算（ *** ）は、2つの真偽値の入力値のうち、どちらか一方でも真であれば真を出力する演算で、数学的には和集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $1$ |

OR演算のベン図

Answer: 論理和

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ***** （論理積）は、2つの真偽値の入力値のうち、両方が真であるときにだけ真を出力する演算で、数学的には積集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $0$ | | $1$ | $0$ | $0$ | | $1$ | $1$ | $1$ |

 ***** のベン図

Answer: AND演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

AND演算（ *** ）は、2つの真偽値の入力値のうち、両方が真であるときにだけ真を出力する演算で、数学的には積集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $0$ | | $1$ | $0$ | $0$ | | $1$ | $1$ | $1$ |

AND演算のベン図

Answer: 論理積

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ***** （論理否定）は、1つの真偽値の入力値を反転した値を出力する演算で、数学的には補集合に対応する。

入力変数を $x$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $z$ | | --- | --- | | $0$ | $1$ | | $1$ | $0$ |

 ***** のベン図

Answer: NOT演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

NOT演算（ **** ）は、1つの真偽値の入力値を反転した値を出力する演算で、数学的には補集合に対応する。

入力変数を $x$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $z$ | | --- | --- | | $0$ | $1$ | | $1$ | $0$ |

NOT演算のベン図

Answer: 論理否定

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ***** （否定論理和）は、OR演算とNOT演算を組み合わせたもので、2つの真偽値の入力値のうち、どちらか一方でも真であれば偽を出力する演算。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $1$ | | $0$ | $1$ | $0$ | | $1$ | $0$ | $0$ | | $1$ | $1$ | $0$ |

 ***** のベン図

Answer: NOR演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

NOR演算（ ***** ）は、OR演算とNOT演算を組み合わせたもので、2つの真偽値の入力値のうち、どちらか一方でも真であれば偽を出力する演算。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $1$ | | $0$ | $1$ | $0$ | | $1$ | $0$ | $0$ | | $1$ | $1$ | $0$ |

NOR演算のベン図

Answer: 否定論理和

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ****** （否定論理積）は、AND演算とNOT演算を組み合わせたもので、2つの真偽値の入力値のうち、両方が真であるときにだけ偽を出力する演算。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $1$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $0$ |

 ****** のベン図

Answer: NAND演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

NAND演算（ ***** ）は、AND演算とNOT演算を組み合わせたもので、2つの真偽値の入力値のうち、両方が真であるときにだけ偽を出力する演算。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $1$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $0$ |

NAND演算のベン図

Answer: 否定論理積

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ***** （排他的論理和）は、2つの真偽値の入力値の値が異なる場合にのみ真を出力する演算で、数学的には対称差集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $0$ |

 ***** のベン図

Answer: XOR演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

XOR演算（ ****** ）は、2つの真偽値の入力値の値が異なる場合にのみ真を出力する演算で、数学的には対称差集合に対応する。

2つの入力変数をそれぞれ $x, y$ 、出力を $z$ とすると、真理値表とベン図は次のようになる。

| $x$ | $y$ | $z$ | | --- | --- | --- | | $0$ | $0$ | $0$ | | $0$ | $1$ | $1$ | | $1$ | $0$ | $1$ | | $1$ | $1$ | $0$ |

XOR演算のベン図

Answer: 排他的論理和

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ********* は、否定論理和および否定論理積をそれぞれ論理和と論理積に変換する式で、以下のように表される。

$$ \begin{eqnarray} \overline{A \cdot B} & = & \overline{A} + \overline{B} \ \overline{A + B}     & = & \overline{A} \cdot \overline{B} \end{eqnarray} $$

これは複雑な論理演算を簡略化したり、論理的な等価性を証明したりするために用いられる。

Answer: ド・モルガンの法則

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ****** は、あるビット列の特定のビットにだけ操作を行いたい場合などに用いるビット列で、操作対象となるビットに対応するビットを $1$ 、それ以外を $0$ としたものとなる。

Answer: マスクビット

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ******** （ビットマスク）は、ビット列のうち特定の部分だけを取り出すために使用される演算。取り出したいビットに対するマスクビットとのAND演算を行うことで得られる。対象としなかった部分は $0$ で埋められる。

次の例では、対象となるビット列 $10011011$ に対して末尾の4ビットを取り出す操作を行っている。

$$ \begin{array}{rr} & 10011011 \ \lor & 00001111 \ \hline & 00001011 \end{array} $$

Answer: ビットマスク演算

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ****** 演算（ ****** ）は、ビット列のうち特定の部分だけを取り出すために使用される演算。取り出したいビットに対するマスクビットとのAND演算を行うことで得られる。対象としなかった部分は $0$ で埋められる。

次の例では、対象となるビット列 $10011011$ に対して末尾の4ビットを取り出す操作を行っている。

$$ \begin{array}{rr} & 10011011 \ \lor & 00001111 \ \hline & 00001011 \end{array} $$

Answer: ビットマスク

Source: ../../note/basics/discrete_mathematics/_/chapters/logical_operation.md

====================

 ***** は、2進数で表された数において数の正負を意味するビット。一般的には、最上位ビットを ***** とし、 ***** が $0$ ならば正の数、 $1$ ならば負の数として扱う。

Answer: 符号ビット

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ** は、n進数のある数に対して足し合わせることでちょうど $n$ のべき乗（あるいは $n$ のべき乗から1を引いたもの）になる自然数のうち、最小のもの。言い換えると、ある数に足し合わせることで桁が1つ上がる最小の数。例として、 $560_{10}$ に対する ** は $440_{10}$ （ $560_{10} + 440_{10} = 1000_{10}$ となるため）となる。

 ** を使用することで、負の数の表現や演算が容易になるため、コンピュータのプログラムや回路設計において重要な概念となっている。

Answer: 補数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

