
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <style>
   body
   {
       display: flex;
       justify-content: center;
       min-height: 100vh;
       background-color: #444;
       color: #fff;
   }

   .quiz_container
   {
       line-height: 2;
   }

   .mask
   {
       background-color: #fff;
       color: #fff;
       padding: 2px 8px;
       margin: 0 4px;
   }

   .mask.active
   {
       color: #000;
   }

   .btn_answer_container
   {
       text-align: center;
   }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css">
 </head>
 <body>
  <div class="quiz_container">
   <p><p><strong>ハミング符号</strong>は、データにいくつかの冗長<a href="../../../_/chapters/computer_and_number.md#%E3%83%93%E3%83%83%E3%83%88">ビット</a>を付加することで、1<a href="../../../_/chapters/computer_and_number.md#%E3%83%93%E3%83%83%E3%83%88">ビット</a>の誤りを検出し、それを訂正する方法。</p>
<p>ハミング符号では、ある整数 $m$ に対して、符号化するデータの<a href="../../../_/chapters/computer_and_number.md#%E3%83%93%E3%83%83%E3%83%88">ビット</a>数 $k$ と、<strong>符号語</strong>の長さ $n$ は次のようになる。</p>
<pre><code class="language-math">\begin{eqnarray}
k &amp; = &amp; n - m \
n &amp; = &amp; 2^m - 1
\end{eqnarray}
</code></pre>
<p>ハミング符号では最初に、 $m$ <a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">行</a> $n$ <a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">列</a>の<strong>検査行列</strong> $H$ を求める。 $m = 3$ （ $n = 7$ ）の場合、 次のような検査行列となる。</p>
<pre><code class="language-math">H =
\left[
\begin{array}{ccccccc}
1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right]
</code></pre>
<p>検査行列は、全ての<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">列要素</a>がゼロではなく、それぞれが相違となるような<a href="../../../_/chapters/computer_and_number.md#%E3%83%93%E3%83%83%E3%83%88">ビット</a>列を並べたものとなる。<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">列</a>の並べ方は任意で、上記の例に限らない。</p>
<p>次に、 $HG^{T} = GH^{T} = 0$ を満たすような<strong>生成行列</strong> $G$ を求める。前述の検査行列に対する生成行列は次のようになる。</p>
<pre><code class="language-math">G =
\left[
\begin{array}{ccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{array}
\right]
</code></pre>
<p>そして、送信したい情報と生成行列の<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97%E3%81%AE%E7%A9%8D">積</a>をとった結果得られる答えが、ハミング符号化後の符号語となる。送信したいデータを <code>1011</code> とすると、符号語は次のようになる。</p>
<pre><code class="language-math">\left[
\begin{array}{cccc}
1 &amp; 0 &amp; 1 &amp; 1
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{array}
\right]

=

\left[
\begin{array}{ccccccc}
1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0
\end{array}
\right]
</code></pre>
<p>受信側では、<strong>受信語</strong> $Y$ に対して次のような関係が成り立つ。ここで、 $x$ は複合後のデータとし、送信時の誤りは発生していないものとする。</p>
<pre><code class="language-math">\begin{eqnarray}
Y    &amp; = &amp; xG \
YH^T &amp; = &amp; xGH^T \
YH^T &amp; = &amp; 0
\end{eqnarray}
</code></pre>
<p>送信時の誤りが発生していた場合、次のような関係が成り立つ。ここで、 $e_i$ は<strong><span class="mask">誤りベクトル</span></strong>とする。</p>
<pre><code class="language-math">\begin{eqnarray}
Y    &amp; = &amp; xG \oplus e_i \
YH^T &amp; = &amp; (xG \oplus e_i)H^T \
YH^T &amp; = &amp; xGH^T \oplus e_i H^T \
YH^T &amp; = &amp; e_i H^T
\end{eqnarray}
</code></pre>
<p>これらの関係より、受信語 $Y$ と検査行列の<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%BB%A2%E7%BD%AE%E8%A1%8C%E5%88%97">転置行列</a>の<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97%E3%81%AE%E7%A9%8D">積</a>が $0$ であった場合には誤りはなく、非 $0$ であった場合には、 $e_i^T$ に対応する検査行列の<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">列</a>が誤っているということがわかる。例えば、受信語が <code>1111100</code> であった場合は次のような<span class="mask">誤りベクトル</span>が得られる。</p>
<pre><code class="language-math">\left[
\begin{array}{ccccccc}
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0
\end{array}
\right]

\cdot

\left[
\begin{array}{ccccccc}
1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right]^T

=

\left[
\begin{array}{ccc}
0 &amp; 1 &amp; 1
\end{array}
\right]
</code></pre>
<p>この場合、<span class="mask">誤りベクトル</span>の<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%BB%A2%E7%BD%AE%E8%A1%8C%E5%88%97">転置行列</a>は検査行列の2<a href="../../../applied_mathematics/_/chapters/numerical_calculation.md#%E8%A1%8C%E5%88%97">列</a>目と一致するので、受信語の2<a href="../../../_/chapters/computer_and_number.md#%E3%83%93%E3%83%83%E3%83%88">ビット</a>目が誤っている、すなわち正しい受信語は <code>1011100</code> であることがわかる。</p>
</p>
   <div class="btn_answer_container">
    <button id="btn_answer" class="btn_answer">Show answer</button>
   </div>
  </div>

  <script>
   const btn_answer = document.getElementById("btn_answer");
   btn_answer.addEventListener("click", function()
   {
       const mask = document.querySelectorAll(".mask");
       mask.forEach(function(item)
       {
           item.classList.toggle("active");
       });
   });
  </script>
 </body>
</html>
            