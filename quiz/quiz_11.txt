====================

 ** は、Linux及びUNIX系オペレーティングシステムで使用される、ファイルやディレクトリの一覧表示を行うコマンド。  **  は"list"の略語。ファイル名やパーミッション、所有者、更新日時、ファイルサイズなどの情報を表示することができる。

コマンドの書式は以下の通り。

 **  [OPTION]... [FILE]...

 **  コマンドを単体で使用すると、カレントディレクトリのファイルやディレクトリを一覧表示する。また、  **  コマンドの主要なオプションは以下の通り。

| オプション | 概要                                                                                  | | ---------- | :------------------------------------------------------------------------------------ | | -l       | パーミッションや所有者、グループ、ファイルサイズ、更新日時など、詳細な情報を表示する  | | -a       | 隠しファイルも含めたすべてのファイルを表示する                                        | | -h       | ファイルサイズを人間が読みやすい形式で表示する                                        | | -t       | 更新日時の新しい順に並べ替えて表示する                                                | | -r       | 結果を逆順で表示する                                                                  | | -R       | サブディレクトリ以下のファイルやディレクトリを再帰的に表示する                        | | -F       | ファイル名の後ろにファイルの種類を表す記号を追加して表示する                          |

-F オプションを指定した場合、ファイル名の後ろに次のような記号が追加で表示される。

| 種別               | 記号 | | ------------------ | ---- | | 通常ファイル       | なし | | ディレクトリ       | /  | | 実行可能ファイル   | *  | | シンボリックリンク | @  |

Answer: ls

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ***** は、LinuxおよびUNIX系オペレーティグシステムで使用される、空のファイルを作成したり、既存のファイルの更新日時を変更するコマンドです。

コマンドの書式は以下の通り。

 *****  [OPTION]... FILE...

 *****  コマンドを単独で使用すると、カレントディレクトリに空のファイルを作成する。例えば次のコマンドは、カレントディレクトリに test.txt という名前のからファイルを作成する。

$  *****  test.txt

また、既存のファイルの更新日時を変更する場合は、ファイル名を指定して  *****  コマンドを実行する。  *****  コマンドの代表的なオプションは以下の通り。

| オプション | 概要                                                                    | | ---------- | :---------------------------------------------------------------------- | | -c       | ファイルが存在しない場合に、ファイルを新規作成せずにコマンドを終了する  | | -d       | ファイルの更新日時を指定した日時に変更する                              | | -m       | ファイルの更新日時だけを変更する（最終アクセス日時は更新しない）        | | -r       | 指定したファイルと同じ更新日時にする                                    |

Answer: touch

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ** は、LinuxおよびUNIX系オペレーティングシステムで使用される、ファイルやディレクトリを削除するためのコマンド。  **  は"remove"の略語。

コマンドの書式は以下の通り。

ls [OPTION]... [FILE]...

 **  コマンドを単独で使用すると、指定したファイルを削除する。例えば次のコマンドは、カレントディレクトリにある test.txt という名前のファイルを削除する。

$  **  test.txt

 **  コマンドによって削除されたファイルは元に戻すことができないので、注意が必要。  **  コマンドの代表的なオプションは以下の通り。

| オプション | 概要                                                                                                  | | ---------- | :---------------------------------------------------------------------------------------------------- | | -r       | サブディレクトリを削除するためのオプションで、サブディレクトリ内のファイルやディレクトリもすべて削除 | | -i       | 削除時に確認を求める                                                                                  | | -f       | 警告を表示せずに、強制的にファイルを削除する                                                          |

 **  は強力なコマンドであり、誤って重要なファイルやディレクトリを削除しないように十分に注意が必要。

Answer: rm

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ** は、LinuxおよびUNIX系オペレーティングシステムで使用される、ファイルやディレクトリをコピーするためのコマンド。  **  は"copy"の略語。

コマンドの書式は以下の通り。

 **  [OPTION]... [-T] SOURCE DEST
 **  [OPTION]... SOURCE... DIRECTORY
 **  [OPTION]... -t DIRECTORY SOURCE...

 **  コマンドにコピー元ファイルとコピー先ファイルのパスを指定することで、ファイルをコピーすることができる。例えば次のコマンドは、 /home/user/src/test.txt というファイルを /home/user/dest/test.txt というファイルにコピーする。

 **  /home/user/src/test.txt /home/user/dest/test.txt

 **  コマンドの代表的なオプションは以下の通り。

| オプション | 概要                                             | | ---------- | :----------------------------------------------- | | -r       | 指定したディレクトリの中身を再帰的にコピーする   | | -p       | コピー元ファイルの属性やパーミッションを維持する | | -i       | 上書き確認を求める                               |

 **  コマンドはファイルやディレクトリを簡単にコピーすることができるが、コピー先に同名のファイルが存在する場合には、内容が上書きされるため注意が必要。

Answer: cp

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ** は、LinuxおよびUNIX系オペレーティングシステムで使用される、ファイルやディレクトリを移動するためのコマンド。また、ファイルやディレクトリの名前を変更するためにも用いられる。  **  は"move"の略語。

コマンドの書式は以下の通り。

 **  [OPTION]... [-T] SOURCE DEST
 **  [OPTION]... SOURCE... DIRECTORY
 **  [OPTION]... -t DIRECTORY SOURCE...

 **  コマンドに移動元ファイルまたはディレクトリのパスと移動先のパスを指定することで、ファイルやディレクトリを移動することができる。例えば次のコマンドは、 /home/user/src/test.txt というファイルを /home/user/dest/test.txt というファイルに移動する。

$  **  /home/user/src/test.txt /home/user/dest/test.txt

また、  **  コマンドを使用してファイルやディレクトリをリネームすることもできる。例えば次のコマンドは、 /home/user/src/test.txt というファイルを /home/user/src/test2.txt という名前に変更する。

$  **  /home/user/src/test.txt /home/user/src/test2.txt

 **  コマンドに -i オプションを指定すると、移動先に同じ名前のファイルがあった場合に上書き確認を行う。

Answer: mv

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 *** は、LinuxおよびUNIX系オペレーティングシステムで使用される、テキストファイルの内容を表示するためのコマンド。  ***  は"con *** enate"の略語。

コマンドの書式は以下の通り。

 ***  [OPTION]... [FILE]...

基本的に、 ***  コマンドは1つ以上のファイルを引数として受け取り、それらのファイルの内容を順番に連結して標準出力に表示する。例えば次のコマンドを実行すると、ファイル file1.txt と file2.txt の内容が順番に表示される。

$  ***  test1.txt test2.txt

 ***  コマンドにファイル名を指定しなかった場合、標準入力を待ち受ける状態となり、受け取った入力をそのまま標準出力に表示する。

 ***  コマンドの代表的なオプションは以下の通り。

| オプション | 概要                                         | | ---------- | :------------------------------------------- | | -n       | 行番号を表示する                             | | -b       | 行番号を表示する（空行には行番号を付けない） | | -s       | 空行をまとめる                               | | -E       | 各行の末尾に $ を表示する                  |

 ***  はテキストファイルの内容を素早く表示することができるが、大きなファイルを扱う場合には less や more といったページャコマンドの方が向いている。

Answer: cat

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 **** やmoreは、LinuxおよびUNIX系オペレーティングシステムで使用される、テキストファイルを閲覧するためのコマンド。  ****  は more よりも高度な機能を持っている。

コマンドの書式は以下の通り。

 ****  [OPTION]... [FILE]...

 ****  コマンドを使用すると、指定したファイルの内容が先頭から表示される。 Space キーを入力すると1ページ分のテキストをスクロールダウンし、 b キーを入力すると1ページ分のテキストをスクロールアップする。また、 q キーを入力すると  ****  コマンドを終了する。

また、  ****  コマンドは more コマンドにはない以下のような機能を提供する。

• テキスト内の文字列を検索する機能（ / キーを押して、検索したい文字列を入力する）
• ファイル内の行数を表示する（ = キーを入力する）
• ファイル内の任意の行に移動する（ g キーを入力するとファイルの先頭に、 G キーを入力するとファイルの末尾にジャンプする）

例えば次のコマンドを実行すると、  ****  ページャ内に /var/log/syslog ファイルを表示する。

$  ****  /var/log/syslog

Answer: less

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

lessや **** は、LinuxおよびUNIX系オペレーティングシステムで使用される、テキストファイルを閲覧するためのコマンド。 less は  ****  よりも高度な機能を持っている。

コマンドの書式は以下の通り。

less [OPTION]... [FILE]...

less コマンドを使用すると、指定したファイルの内容が先頭から表示される。 Space キーを入力すると1ページ分のテキストをスクロールダウンし、 b キーを入力すると1ページ分のテキストをスクロールアップする。また、 q キーを入力すると less コマンドを終了する。

また、 less コマンドは  ****  コマンドにはない以下のような機能を提供する。

• テキスト内の文字列を検索する機能（ / キーを押して、検索したい文字列を入力する）
• ファイル内の行数を表示する（ = キーを入力する）
• ファイル内の任意の行に移動する（ g キーを入力するとファイルの先頭に、 G キーを入力するとファイルの末尾にジャンプする）

例えば次のコマンドを実行すると、 less ページャ内に /var/log/syslog ファイルを表示する。

$ less /var/log/syslog

Answer: more

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 **** は、LinuxおよびUNIX系オペレーティングシステムで使用される、テキストファイルの先頭から指定された行数分の内容を表示するコマンド。 tail コマンドと同様に、ログファイルや大容量テキストファイルの処理に便利なツール。

コマンドの書式は以下の通り。

 ****  [OPTION]... [FILE]...

デフォルトでは、  ****  コマンドは指定されたファイルの先頭10行を表示する。 -n オプションを使用することで、表示する行数を変更することができる。例えば次のコマンドを実行すると、カレントディレクトリにある test.txt の先頭5行が表示される。

$  ****  -n 5 test.txt

また、複数のファイルを指定して、それぞれのファイルの先頭を表示することもできる。例えば次のコマンドを実行すると、カレントディレクトリにある test1.txt と test2.txt の先頭10行がそれぞれ表示される。

$  ****  test1.txt test2.txt

Answer: head

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 **** は、LinuxおよびUNIX系オペレーティングシステムで使用される、テキストファイルの末尾から指定された行数分の内容を表示するためのコマンド。主にログファイルや大容量のテキストファイルの処理や解析に便利なツール。

コマンドの書式は以下の通り。

 ****  [OPTION]... [FILE]...

デフォルトでは、  ****  コマンドは指定されたファイルの末尾10行を表示する。 -n オプションを使用することで、表示する行数を変更することができる。例えば次のコマンドを実行すると、カレントディレクトリにある test.txt の末尾5行が表示される。

$  ****  -n 5 test.txt

また、複数のファイルを指定して、それぞれのファイルの末尾を表示することもできる。例えば次のコマンドを実行すると、カレントディレクトリにある test1.txt と test2.txt の末尾10行がそれぞれ表示される。

$  ****  test1.txt test2.txt

-f オプションを使用すると、ファイルの変更をリアルタイムに追跡するとこができる。これは、ログファイルの解析などにおいて非常に便利なオプションで、以下の例では access.log の変更をリアルタイムに追跡する。

$  ****  -f access.log

Answer: tail

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 *** は、LinuxおよびUNIX系オペレーティングシステムで使用される、現在の作業ディレクトリを表示するためのコマンド。  ***  は"print working directory"の略語。

コマンドの書式は以下の通り。

 ***  [OPTION]...

基本的に  ***  は現在の作業ディレクトリの絶対パスを表示する。例えば、現在の作業ディレクトリが ~/docs である場合、  ***  コマンドを実行すると、 /home/user/docs という出力が得られる。

 ***  コマンドに -P オプションを指定すると、シンボリックリンクを解決したパスを表示する。

Answer: pwd

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ** は、LinuxおよびUNIX系オペレーティングシステムで使用される、カレントディレクトリを変更するためのコマンド。  **  は"change directory"の略語。

コマンドの書式は以下の通り。

 **  [PATH]

 **  に移動先のパスを指定すると、カレントディレクトリを指定したパスに変更する。例えば以下のコマンドを実行すると、 /home/user/docs ディレクトリに移動する。

$  **  /home/user/docs

.. を使用することで、1つ上のディレクトリを指定することができる。例えば以下のコマンドを実行すると、カレントディレクトリから見て1つ上のディレクトリ移動する。

$  **  ..

Answer: cd

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ***** は、LinuxおよびUNIX系オペレーティングシステムで使用される、新しいディレクトリを作成するためのコマンド。  *****  は"make directory"の略語。

コマンドの書式は以下の通り。

 *****  [OPTION]... DIRECTORY...

 *****  コマンドにディレクトリ名を指定すると、カレントディレクトリに指定した名前のサブディレクトリが作成される。例えば以下のコマンドを実行すると、カレントディレクトリに docs という名前の新しいディレクトリが作成される。

$  *****  docs

 *****  コマンドは一度に複数のディレクトリを作成することもできる。例えば以下のコマンドを実行すると、カレントディレクトリに docs と music と pictures という3つの新しいディレクトリを同時に作成する。

$  *****  docs music pictures

Answer: mkdir

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ***** は、LinuxおよびUNIX系オペレーティングシステムで使用される、空のディレクトリを削除するためのコマンド。  *****  は"remove directory"の略語。

コマンドの書式は以下の通り。

 *****  [OPTION]... DIRECTORY...

 *****  にディレクトリ名を指定すると、カレントディレクトリにある指定した名前のディレクトリを削除する。例えば以下のコマンドを実行すると、 docs という名前の空のディレクトリを削除する。

$  *****  docs

Answer: rmdir

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ** は、LinuxおよびUNIX系オペレーティングシステムで使用される、リンクを作成するために使用されるコマンド。  **  は"link"の略語。

コマンドの書式は以下の通り。

 **  [OPTION]... [-T] TARGET LINK_NAME
 **  [OPTION]... TARGET
 **  [OPTION]... TARGET... DIRECTORY
 **  [OPTION]... -t DIRECTORY TARGET...

例えば、 /home/user/test.txt というファイルに対して /home/user/test_link.txt というハードリンクを作成するには、次のようなコマンドを実行する。

$  **  /home/user/test.txt /home/user/test_link.txt

また、 /home/user/docs というディレクトリに対して /home/user/docs_link というシンボリックリンクを作成するには、次のようなコマンドを実行する。

$  **  -s /home/user/docs /home/user/docs_link

-s オプションを使用することで、シンボリックリンクを作成することができる。

Answer: ln

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 **** は、LinuxおよびUNIX系オペレーティングシステムで使用される、指定されたディレクトリツリー内でファイルやディレクトリを検索するためのコマンド。条件に合致するファイルを見つけ出して、指定されたアクションを実行することができる。

コマンドの書式は以下の通り。

 ****  [OPTION]... [PATH] [EXPRESSION]...

PATH には検索を開始するディレクトリのパスを指定し、 EXPRESSION には検索条件を指定する。検索条件は、 -name や -type などのオプションを指定することができる。例えば次のコマンドを実行すると、現在のディレクトリ以下で名前が test.txt であるファイルを検索する。

$  ****  . -name "test.txt"

 ****  コマンドの主要なオプションは以下の通り。

| オプション | 概要                                                                                                                                              | | ---------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | | -name    | ファイル名が指定したパターンに一致するファイルを検索する                                                                                          | | -type    | 指定したファイルタイプに一致するファイルを検索する（ -type f は通常ファイル、 -type d はディレクトリ、 -type l はシンボリックリンク）      | | -mtime   | ファイルの最終更新日時が指定した日数前（正）または後（負）であるファイルを検索する                                                                | | -size    | ファイルサイズが指定したサイズに一致したファイルを検索する（単位として c （バイト）、 k （キロバイト）、 M （メガバイト）などを指定できる） | | -exec    | 検索されたファイルに対して指定されたコマンドを実行する                                                                                            |

Answer: find

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ****** は、ファイルシステム内で指定した文字列にマッチするファイルを高速に検索するためのコマンド。 find コマンドよりも効率的で、パターンマッチングにも対応している。

コマンドの書式は以下の通り。

 ******  [OPTION]... PATTERN

例えば以下のコマンドを実行すると、 /etc ディレクトリ以下の ssh という名前を含むファイルを検索する。

$  ******  /etc/*ssh*

 ******  は、ディスクをスキャンすることなく、専用のデータベースを利用するため、高速に動作する。ただし、ファイルパスのデータベースが更新されていない可能性があるため、既に存在しないファイルが表示されたり、存在するファイルが表示されない可能性がある。最新の情報を手動で更新するには、 updatedb コマンドを実行する。主要なオプションは以下の通り。

| オプション | 概要                           | | ---------- | :----------------------------- | | -i       | 大文字と小文字を区別しない     | | -l [NUM] | 最大の検索結果数を指定する     | | -c       | 該当するファイルの数を表示する |

パターンに複数のパターンを指定するとOR検索になり、 -A | --alll オプションを指定するとAND検索になる。

Answer: locate

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 **** は、指定したパターンに一致する行をファイルから検索し、マッチする行を出力するためのコマンド。

コマンドの書式は以下の通り。

 ****  [OPTION]... PATTERNS [FILE]...
 ****  [OPTION]... -e PATTERNS ... [FILE]...
 ****  [OPTION]... -f PATTERN_FILE ... [FILE]...

例えば以下のコマンドを実行すると、 test.txt ファイル内から hello という文字列を検索し、それが含まれる行を表示する。

 ****  "hello" test.txt

また以下の例では、現在のディレクトリ内の全てのファイルから、正規表現を用いて該当箇所を検索する。

 ****  "*.png" *

主要なオプションは以下の通り。

| オプション | 概要                                             | | ---------- | :----------------------------------------------- | | -i       | 大文字小文字を区別せずに検索する                 | | -v       | パターンと一致しない行を検索する                 | | -c       | パターンと一致する行の数を表示する               | | -n       | パターンと一致する行の行番号を表示する           | | -r       | ディレクトリを再帰的に検索する                   | | -l       | ファイル名のみを表示する                         | | -w       | パターンと完全一致する行のみを検索する           | | -E       | 拡張正規表現を使用する                           | | -F       | パターンを正規表現ではなく、固定文字列として扱う |

Answer: grep

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 ***** は、LinuxおよびUNIX系オペレーティングシステムで使用される、コマンドがどの場所にインストールされているかを特定するためのコマンド。

コマンドの書式は以下の通り。

 *****  [OPTION] [--] PROGRAMNAME...

例えば以下のコマンドを実行すると、 python コマンドがインストールされているパスが表示される。

$  *****  python

デフォルトでは、 PATH 環境変数に定義された場所でコマンドを検索する。

Answer: which

Source: ../../note/computer/linux/_/chapters/basic_command.md

====================

 *** (Filesystem Hierarchy Standard)は、Linuxのディレクトリ構成の標準化仕様。ディストリビューションによってディレクトリ構成に多少の違いはあるが、基本的には *** に準拠している。

| ディレクトリ    | 説明                                                                                                  | | --------------- | :---------------------------------------------------------------------------------------------------- | | /             | ファイルシステムのルートディレクトリ                                                                  | | ├ bin/        | 一般ユーザ向けの基本コマンドの実行ファイルを格納するディレクトリ                                      | | ├ boot/       | ブートローダ関連のファイルを格納するディレクトリ                                                      | | ├ dev/        | デバイスファイル（コンピュータに接続された周辺機器に関するファイル）を格納するディレクトリ            | | ├ etc/        | 各種プログラムの設定ファイルを格納したディレクトリ                                                    | | ├ home/       | ユーザごとのホームディレクトリ群を格納したディレクトリ                                                | | ├ lib/        | /bin や /sbin にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                | | ├ lost+found/ | 予期しないシャットダウンなどにより破損したファイルなどの断片が格納されるディレクトリ                  | | ├ media/      | 外部メディアが接続された際にOSによって自動的にマウンティングされるディレクトリを格納したディレクトリ  | | ├ mnt/        | 一時的なファイルシステムのマウントなどに用いるディレクトリで、ユーザが手動でマウントを行う            | | ├ opt/        | パッケージマネージャを使わずにインストールしたアプリケーションなどが格納されるディレクトリ            | | ├ proc/       | カーネルやプロセスの状態に関する情報を格納するディレクトリ                                            | | ├ root/       | rootユーザのホームディレクトリ                                                                        | | ├ run/        | 実行中のプログラムのPIDファイルなどを格納するディレクトリ                                             | | ├ sbin/       | システム管理用のコマンドの実行ファイルを格納するディレクトリ                                          | | ├ srv/        | サービスを提供する際のデータを格納するディレクトリ                                                    | | ├ sys/        | デバイスやドライバについての情報を格納するディレクトリ                                                | | ├ tmp/        | 一時ファイルの置き場として利用されるディレクトリ                                                      | | ├ usr/        | システム以外の全ユーザが共通して利用するプログラムやライブラリを格納するディレクトリ                  | | │ ├ bin/      | ユーザが利用するコマンドを格納するディレクトリ                                                        | | │ ├ include/  | ユーザ空間のソースコードをコンパイルするのに必要なヘッダファイルを格納するディレクトリ                | | │ ├ lib/      | /usr/bin にある実行ファイルに紐づけられた共有ライブラリを格納したディレクトリ                       | | │ ├ share/    | アイコンやフォントなど、アーキテクチャに依存しない共有う可能なファイルを格納したディレクトリ          | | │ ├ src/      | ソースコードを格納するためのディレクトリ                                                              | | │ └ local/    | ホスト固有のローカルデータを格納する第三階層（ bin や lib 、 share などを持つ）                 | | └ var/        | ログやメールなどの可変ファイルを格納する為のディレクトリ                                              | |   ├ cache/    | キャッシュファイルを格納するディレクトリ                                                              | |   ├ log/      | 各種ログファイルを格納するディレクトリ                                                                | |   ├ mail/     | ユーザのメールボックスとして利用されるディレクトリ                                                    | |   ├ spool/    | 処理待ち状態のタスクのスプールを格納するディレクトリ                                                  | |   ├ tmp/      | 一時ファイルの置き場として利用されるディレクトリ                                                      | |   └ www/      | 慣習的にWebコンテンツを格納するために利用されるディレクトリ                                           |

Answer: FHS

Source: ../../note/computer/linux/_/chapters/file.md

====================

 *** は、ファイルに別名をつける機能。 *** を利用することで、長いパス名を省略したり、複数バージョンのプログラムを共存させたりすることができる。

Answer: リンク

Source: ../../note/computer/linux/_/chapters/file.md

====================

 ********* （ソフトリンク）は、リンク先のファイルやディレクトリのパスを記憶する方法で、リンク先のファイルが削除されると無効なリンクとなる。ディレクトリに対するリンクや、別のファイルシステムに対するリンクを作成することができる。Windowsにおけるショートカットや、macOSにおけるエイリアスと似た機能。

Answer: シンボリックリンク

Source: ../../note/computer/linux/_/chapters/file.md

====================

シンボリックリンク（ ****** ）は、リンク先のファイルやディレクトリのパスを記憶する方法で、リンク先のファイルが削除されると無効なリンクとなる。ディレクトリに対するリンクや、別のファイルシステムに対するリンクを作成することができる。Windowsにおけるショートカットや、macOSにおけるエイリアスと似た機能。

Answer: ソフトリンク

Source: ../../note/computer/linux/_/chapters/file.md

====================

シンボリックリンク（ソフトリンク）は、リンク先のファイルやディレクトリのパスを記憶する方法で、リンク先のファイルが削除されると無効なリンクとなる。ディレクトリに対するリンクや、別のファイルシステムに対するリンクを作成することができる。Windowsにおける ******* や、macOSにおけるエイリアスと似た機能。

Answer: ショートカット

Source: ../../note/computer/linux/_/chapters/file.md

====================

シンボリックリンク（ソフトリンク）は、リンク先のファイルやディレクトリのパスを記憶する方法で、リンク先のファイルが削除されると無効なリンクとなる。ディレクトリに対するリンクや、別のファイルシステムに対するリンクを作成することができる。Windowsにおけるショートカットや、macOSにおける ***** と似た機能。

Answer: エイリアス

Source: ../../note/computer/linux/_/chapters/file.md

====================

 ****** は、ファイルの実体を直接指し示して共有するリンク。ファイルシステム上ではファイルのメタデータをiノードで管理しており、iノード番号という固有の番号で実体のデータと紐付けられている。 ****** は元のファイルと同じiノード番号を指す参照カウントとなっているため、リンク先のファイルが削除されても実体にアクセスできる。

Answer: ハードリンク

Source: ../../note/computer/linux/_/chapters/file.md

====================

ハードリンクは、ファイルの実体を直接指し示して共有するリンク。ファイルシステム上ではファイルのメタデータを **** で管理しており、 **** 番号という固有の番号で実体のデータと紐付けられている。ハードリンクは元のファイルと同じ **** 番号を指す参照カウントとなっているため、リンク先のファイルが削除されても実体にアクセスできる。

Answer: iノード

Source: ../../note/computer/linux/_/chapters/file.md

====================

ハードリンクは、ファイルの実体を直接指し示して共有するリンク。ファイルシステム上ではファイルのメタデータをiノードで管理しており、 ****** という固有の番号で実体のデータと紐付けられている。ハードリンクは元のファイルと同じ ****** を指す参照カウントとなっているため、リンク先のファイルが削除されても実体にアクセスできる。

Answer: iノード番号

Source: ../../note/computer/linux/_/chapters/file.md

====================

 *********** は、プログラムがアクセスするファイルや標準入出力などをOSが識別するために用いる識別子。 $0$ から順番に整数の値が割り当てられる。

 *********** には、識別子とともにファイル名、ファイルサイズ、プログラムが操作中のファイル内の位置、作成日時、更新日時などの情報が含まれている。

通常は、 $0$ に標準入力、 $1$ に標準出力、 $2$ に標準エラー出力がOSによって最初に用意されるため、プログラムがファイルをオープンすると $3$ から順番にディスクリプタが割り当てられる。

Answer: ファイルディスクリプタ

Source: ../../note/computer/linux/_/chapters/file.md

====================

 ******** （スペシャルファイル）は、LinuxのOSの入出力機能のひとつで、コンピュータに接続した周辺機器などをファイルシステム上のファイルのように扱い、ファイルの読み書きと同じ手順でデータの入出力を制御をできるようにしたもの。コンピュータに装置を接続してデバイスドライバを導入すると、 /dev ディレクトリ配下に ******** が作成される。シェルやプログラムなどからは、通常のファイル入出力と同じ機能を通じてアクセスすることができる。

Answer: デバイスファイル

Source: ../../note/computer/linux/_/chapters/file.md

====================

デバイスファイル（ ********* ）は、LinuxのOSの入出力機能のひとつで、コンピュータに接続した周辺機器などをファイルシステム上のファイルのように扱い、ファイルの読み書きと同じ手順でデータの入出力を制御をできるようにしたもの。コンピュータに装置を接続してデバイスドライバを導入すると、 /dev ディレクトリ配下にデバイスファイルが作成される。シェルやプログラムなどからは、通常のファイル入出力と同じ機能を通じてアクセスすることができる。

Answer: スペシャルファイル

Source: ../../note/computer/linux/_/chapters/file.md

====================

 ***** は、Linus Torvaldsによって実装されたOSであり、サーバ用から組み込み機器用、学習用、デスクトップ用など、幅広い用途で利用されている。設計はUNIXに非常に似ているものの、System Vの流れもBSDの流れも汲まない独自のUNIX互換OSとして開発された。

UNIXは高いライセンス使用料が必要であり、個人用として利用するには敷居が高いが、 ***** はGPLライセンスであり誰でも無償で利用することができる。さらに、ソースコードの改変や再配布も自由に行えたため多くのディストリビュータにより改良され、一般に広まることとなった。

また、 ***** には高品質のソフトウェアが多く揃っているため、大変使いやすいOSとなっている。

Answer: Linux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ******** は、Linuxカーネルを指す言葉。OSの中核となる、ハードウェア制御を行うソフトウェアのみを指し、実際にユーザが用いるツールやアプリケーションは含まれない。

Answer: 狭義のLinux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ******** は、Linuxカーネルに加えて、基本的なコマンド群やアプリケーションなどを含めて、ユーザがそのまま利用できるようにパッケージングして提供されたものを指す言葉。一般的には、単にLinuxというときには、 ******** のことを指す場合が多い。

Answer: 広義のLinux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *********** （Linux *********** ）は、Linuxカーネルと様々なツールやアプリケーション群を組み合わせてパッケージ化したもの。LinuxはOSSである性質上、様々な開発者によってメンテナンスされる、多くの種類の *********** が存在する。

Answer: ディストリビューション

Source: ../../note/computer/linux/_/chapters/linux.md

====================

ディストリビューション（ **************** ）は、Linuxカーネルと様々なツールやアプリケーション群を組み合わせてパッケージ化したもの。LinuxはOSSである性質上、様々な開発者によってメンテナンスされる、多くの種類のディストリビューションが存在する。

Answer: Linuxディストリビューション

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ********* は、Linuxディストリビューションの開発やメンテナンスを行う人、あるいは団体を指す言葉。Linuxに限らず、OSSのメンテナンスを行う人のことを指す場合にも用いられる。

Answer: ディストリビュータ

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ******** のディストリビューションは、Red Hat社によって開発されたRed Hat Linuxをベースに開発されたディストリビューション。バランスに特化したディストリビューションで、サーバなどの用途で利用されることが多い。

有償のRed Hat Enterprise Linux(RHEL)や、RHELとの互換性を目指したフリーのOSであるCentOS、REHLの後継として開発が進められたFedoraなどが有名。

Answer: Red Hat系

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Red Hat系のディストリビューションは、Red Hat社によって開発されたRed Hat Linuxをベースに開発されたディストリビューション。バランスに特化したディストリビューションで、サーバなどの用途で利用されることが多い。

有償の ************************ (RHEL)や、RHELとの互換性を目指したフリーのOSであるCentOS、REHLの後継として開発が進められたFedoraなどが有名。

Answer: Red Hat Enterprise Linux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Red Hat系のディストリビューションは、Red Hat社によって開発されたRed Hat Linuxをベースに開発されたディストリビューション。バランスに特化したディストリビューションで、サーバなどの用途で利用されることが多い。

有償のRed Hat Enterprise Linux( **** )や、 **** との互換性を目指したフリーのOSであるCentOS、REHLの後継として開発が進められたFedoraなどが有名。

Answer: RHEL

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Red Hat系のディストリビューションは、Red Hat社によって開発されたRed Hat Linuxをベースに開発されたディストリビューション。バランスに特化したディストリビューションで、サーバなどの用途で利用されることが多い。

有償のRed Hat Enterprise Linux(RHEL)や、RHELとの互換性を目指したフリーのOSである ****** 、REHLの後継として開発が進められたFedoraなどが有名。

Answer: CentOS

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Red Hat系のディストリビューションは、Red Hat社によって開発されたRed Hat Linuxをベースに開発されたディストリビューション。バランスに特化したディストリビューションで、サーバなどの用途で利用されることが多い。

有償のRed Hat Enterprise Linux(RHEL)や、RHELとの互換性を目指したフリーのOSであるCentOS、REHLの後継として開発が進められた ****** などが有名。

Answer: Fedora

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ******* のディストリビューションは、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発されたディストリビューション。見た目の美しさや、Linuxに不慣れなユーザにも使いやすいことから人気が高い。

Debian GNU/LinuxやUbuntu、Linux Mintなどが有名で、デスクトップ用途での人気が高い。

Answer: Debian系

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Debian系のディストリビューションは、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発されたディストリビューション。見た目の美しさや、Linuxに不慣れなユーザにも使いやすいことから人気が高い。

 **************** やUbuntu、Linux Mintなどが有名で、デスクトップ用途での人気が高い。

Answer: Debian GNU/Linux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Debian系のディストリビューションは、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発されたディストリビューション。見た目の美しさや、Linuxに不慣れなユーザにも使いやすいことから人気が高い。

Debian GNU/Linuxや ****** 、Linux Mintなどが有名で、デスクトップ用途での人気が高い。

Answer: Ubuntu

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Debian系のディストリビューションは、ユーザフレンドリな考えのもと開発されているDebian Linuxをベースに開発されたディストリビューション。見た目の美しさや、Linuxに不慣れなユーザにも使いやすいことから人気が高い。

Debian GNU/LinuxやUbuntu、 ********** などが有名で、デスクトップ用途での人気が高い。

Answer: Linux Mint

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ********** のディストリビューションは、最古のディストリビューションであるSlackwareをベースに開発されたディストリビューション。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。

SlackwareやopenSUSEなどが有名。

Answer: Slackware系

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ********* 系のディストリビューションは、最古のディストリビューションである ********* をベースに開発されたディストリビューション。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。

 ********* やopenSUSEなどが有名。

Answer: Slackware

Source: ../../note/computer/linux/_/chapters/linux.md

====================

Slackware系のディストリビューションは、最古のディストリビューションであるSlackwareをベースに開発されたディストリビューション。シンプルゆえに安全性が高く、セキュリティが強固であるという特徴がある。

Slackwareや ******** などが有名。

Answer: openSUSE

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *** のディストリビューションは、独自の進歩を遂げたディストリビューションの総称で、個性的なものも多い。

Arch Linuxは、シンプリシティ、ミニマリズム、エレガンスに焦点を当てて開発されたLinux。

Answer: 独立系

Source: ../../note/computer/linux/_/chapters/linux.md

====================

独立系のディストリビューションは、独自の進歩を遂げたディストリビューションの総称で、個性的なものも多い。

 ********** は、シンプリシティ、ミニマリズム、エレガンスに焦点を当てて開発されたLinux。

Answer: Arch Linux

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ***** は、Linuxで利用可能なアプリケーションを、ユーザが容易に利用できるようにディストリビュータによって提供されたもの。 ***** を利用しない場合は、ユーザ自身でソースコードをダウンロードしてそれをビルドする必要がある。

Answer: パッケージ

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 ********** は、パッケージの導入や管理を容易にするためのツール。パッケージが依存しているライブラリの解決を行ったり、 ********** を通して導入したパッケージの更新などを補助したりする。Linuxディストリビューションには ********** が備えられている。

Answer: パッケージマネージャ

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *** ( ***  Package Manager)は、Red Hat系のディストリビューションで利用されるパッケージマネージャ。

Answer: RPM

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *** (Yellowdog Updater Modified)は、Red Hat系のディストリビューションで利用されるパッケージマネージャ。RPMの機能に加えて、パッケージ間の依存関係を管理する機能を持っている。

Answer: yum

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *** (Dandified yum)は、Red Hat系のディストリビューションで利用されるパッケージマネージャ。yumの後継ツールで、yumの欠点を改善していたり、パフォーマンス面で優れている。

Answer: dnf

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 **** は、Debian系のディストリビューションで利用されているパッケージマネージャ。

Answer: dpkg

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 *** は、Debian系のディストリビューションで利用されているパッケージマネージャ。dpkgの機能に加えて、パッケージ間の依存関係を管理する機能を持っている。

Answer: apt

Source: ../../note/computer/linux/_/chapters/linux.md

====================

 **** は、メモリ上で実行状態にあるプログラム。Linuxカーネルはストレージ装置からメモリにプログラムを読み出し、そのメモリの内容に従ってCPUがプログラムを実行する。 **** はシステム上で一意のPIDによって識別される。

ひとつのプログラムやコマンドが複数の **** を生成したり、 **** がさらに **** を生成することもある。ある **** によって生み出された別の **** は、その **** の子 **** となる。

 **** はオペレーティングシステムのタスクスケジューラによって制御され、実行可能状態、実行状態、待ち状態といった状態を遷移しながら処理が進められる。

Answer: プロセス

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

プロセスは、メモリ上で実行状態にあるプログラム。Linuxカーネルはストレージ装置からメモリにプログラムを読み出し、そのメモリの内容に従ってCPUがプログラムを実行する。プロセスはシステム上で一意の *** によって識別される。

ひとつのプログラムやコマンドが複数のプロセスを生成したり、プロセスがさらにプロセスを生成することもある。あるプロセスによって生み出された別のプロセスは、そのプロセスの子プロセスとなる。

プロセスはオペレーティングシステムのタスクスケジューラによって制御され、実行可能状態、実行状態、待ち状態といった状態を遷移しながら処理が進められる。

Answer: PID

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、親プロセスから子プロセスを生成するシステムコールのひとつ。親プロセスから **** が呼び出されると、システムは親プロセスの複製を作成し、それが子プロセスとなる。子プロセスは親プロセスの状態を複製することによって生成されるため、実行されるプログラムは親プロセスと共通となる。子プロセスは親プロセスとは独立して動作し、親プロセスと異なるPIDを持つ。

Answer: fork

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ***** は、親プロセスから子プロセスを生成するためのシステムコールのひとつ。forkと同様に、親プロセスの複製を子プロセスとして生成する。 ***** では、親プロセスと子プロセスの間で共有されるリソースを指定することができ、複数のプロセスを協調させることができる。

Answer: clone

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、現在のプロセスを新しいプロセスに置き換えるシステムコール。 **** を使用することで、プロセスの実行中にプログラムを切り替えたりプロセスの状態を維持したままプログラムをリロードしたりすることができる。

Answer: exec

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ** は、プロセスの状態を表示するためのコマンド。  **  は"process status"の略語。

コマンドの書式は以下の通り。

 **  [OPTION]...

 **  コマンドを実行すると、このコマンドを実行したユーザが起動しているプロセスのリストが表示される。

$  ** 
    PID TTY          TIME CMD
    425 pts/0    00:00:00 zsh
    689 pts/0    00:00:00  ** 

 **  の主要なオプションは以下の通り。

| オプション | 概要                                               | | ---------- | :------------------------------------------------- | | a        | 全てのユーザのプロセスの状態を表示する             | | f        | プロセスの親子関係をツリー上にして表示する         | | u        | プロセスのユーザ名と開始時刻を表示内容に付加する   | | x        | 制御端末を持たないデーモンなどのプロセスも表示する | | l        | 詳細情報を表示する                                 | | -e       | 全プロセスの情報を表示する　                       |

オプションは、以下の例のように複数個まとめて指定することもできる。

$  **  aux

Answer: ps

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ****** は、プロセスの親子関係をツリー形式で表示するためのコマンド。

コマンドの書式は以下の通り。

 ******  [OPTION]...

 ******  の主要なオプションは以下の通り。

| オプション | 概要                                            | | ---------- | :---------------------------------------------- | | -p       | 各プロセスのPIDを表示する                       | | -u       | 各プロセスの実行ユーザ名を表示する              | | -h       | ルートプロセスを表示しない                      | | -a       | 各プロセスのコマンドライン引数も表示する        | | -n       | 各プロセスの名前をソートせず、PIDの順に表示する | | -c       | 同じ名前のプロセスをまとめて表示する            | | -G       | 指定したグループIDを持つプロセスのみ表示する    | | -U       | 指定したユーザIDを持つプロセスのみ表示する      |

Answer: pstree

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 *** は、Linuxシステムで実行されているプロセスをリアルタイムで監視するためのコマンド。  ***  コマンドで確認できる情報は以下の通り。

| ラベル | 概要                                                                                        | | ------ | :------------------------------------------------------------------------------------------ | | PID    | 各プロセスのPID                                                                             | | USER   | 各プロセスを発行しているユーザ                                                              | | PR     | プロセスの優先度                                                                            | | NI     | プロセスの優先度を調整するために使用されるニース値                                          | | VIRT   | プロセスが使用している仮想メモリサイズ                                                      | | RES    | プロセスが使用している物理メモリサイズ                                                      | | SHR    | プロセスが使用している共有メモリサイズ                                                      | | S      | プロセスの現在の状態（D: 割込み不能、R: 実行中、S: スリープ、T: 停止中、Z: ゾンビプロセス） | | %CPU   | プロセスが使用しているCPUの割合                                                             | | %MEM   | プロセスが使用している物理メモリの割合                                                      | | TIME+  | プロセスが起動している時間                                                                  |

Answer: top

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、実行中のプロセスにシグナルを送信するコマンド。プロセスを強制終了する場合などによく用いられる。

コマンドの書式は以下の通り。

 ****  [SIGNAL] PID

例えば以下のコマンドを実行すると、PIDが1234のプロセスに TERM シグナルを送信する。

$  ****  -TERM 1234

 ****  はプロセスを強制終了するために用いられることが多いが、プロセスを停止したり再開したりするための他のオプションもある。

また、 p ****  はプロセス名指定でプロセスを強制終了するコマンド、  **** all はプロセス名指定で全てのプロセスを強制終了するコマンドとなっている。

Answer: kill

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、メモリの使用状況を表示するためのコマンド。主に以下の情報を表示する。

| ラベル       | 概要                                           | | ------------ | :--------------------------------------------- | | total      | システム全体の物理メモリ量                     | | useed      | 使用中の物理メモリ量                           | |  ****        | 空き物理メモリ量                               | | shared     | 共有メモリ量                                   | | buff/cache | バッファやキャッシュに使われている物理メモリ量 | | available  | アプリケーションに使用可能な物理メモリ量       |

コマンドの書式は以下の通り。

 ****  [OPTION]...

 ****  の主要なオプションは以下の通り。

| オプション       | 概要                                         | | ---------------- | :------------------------------------------- | | -b --bytes   | 結果をバイト単位で表示する                   | | -k --kilo    | 結果をキロバイト単位で表示する（デフォルト） | | -m --mega    | 結果をメガバイト単位で表示する               | | -g --giga    | 結果をギガバイト単位で表示する               | | -h --human   | より読みやすい形式で表示する                 | | -t --total   | 全体のメモリ使用量のみを表示する             | | -s --seconds | 指定した秒数ごとに繰り返し表示する           | | -c --count   | 指定した回数繰り返し表示する                 |

Answer: free

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 *** は、1つのプログラムやコマンドといった実行単位のことで、1つ以上のプロセスをまとめたもの。シェルに入力された1行分が1つの *** に対応し、 *** は必要に応じてプロセスに分解されて処理される。

Answer: ジョブ

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 *********** は、シェルによって起動されるジョブ。通常、コマンドを実行するとフォアグラウンドでジョブが生成され、そのジョブが終了するまではシェルはプロンプトを返さない。 *********** はシェルへの入力を受け付ける状態となり、ユーザは対話的にプロセスに対してシグナルを送信することができる。

Answer: フォアグラウンドジョブ

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 *********** は、シェルとは切り離して実行されるジョブ。コマンドの末尾に & を追加して実行すると、そのコマンドは *********** として実行される。 *********** （プロセス）にシグナルを送信するには、 kill コマンドを使用する。

Answer: バックグラウンドジョブ

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、アクティブなジョブの一覧を確認するためのコマンド。

例えば以下の例では、バックグラウンドで実行中の sleep コマンドの状態を  ****  によって確認している。バックグラウンドジョブの処理が終わると、プロンプトにその旨が表示される。

$ sleep 60 &
[1] 2400

$  **** 
[1]  + running    sleep 10

$
[1]  + done       sleep 10

Answer: jobs

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ** は、ジョブをフォアグラウンドジョブとして実行するコマンド。

以下の例では、バックグラウンドで実行中の sleep をフォアグラウンドに切り替えている。

$ sleep 60 &
[1] 2744

$ jobs
[1]    running    sleep 20

$  **  %1
[1]    running    sleep 20

Answer: fg

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ** は、ジョブをバックグラウンドジョブとして実行するコマンド。

以下の例では、フォアグラウンドで実行していた sleep を Ctrl + z で一度バックグラウンドにサスペンドし、それを改めてバックグラウンドジョブとして再開している。

$ sleep 60

Answer: bg

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、1つのプロセスから生成される実行単位で、プロセス内で複数のタスクを並行して実行するなどの目的で使用される。複数の **** は同じプログラムコード、データ、ヒープなどを共有している。 **** はプロセスよりも軽量で、プロセス間通信に比べて **** 通信は高速である。

Answer: スレッド

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、メインメモリ上に常駐して特定の機能を提供するプログラム。 **** はinitプロセスやsystemdによってシステムの起動時に実行され、バックグラウンドで動作しながら処理要求があったときに処理を実行する。Webサーバやバッチプログラムなどがこれに該当し、プログラム名の末尾に d がつくのが慣例となっている（ httpd 、 crond など）。

Answer: デーモン

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ******** は、Linuxシステムが起動された時に最初に実行され、システムの全てのプロセスの親プロセスとして機能するプロセス。システムのランレベルの設定や各種サービス、デーモンの起動などを行う。 ******** のPIDは必ず1となる。

 ******** は /sbin/init ファイルから起動され、起動時に設定されたランレベルに応じて必要なサービスやプロセスを開始する。通常は、ランレベルは ０ から 6 までの7段階があり、ランレベル 0 はシャットダウン、ランレベル 6 は再起動を表す。管理者はそれぞれのランレベルに合わせたスクリプトを用意して、必要なデーモンの起動処理などを記述する。

新しいLinuxディストリビューションの多くでは、 ******** に代わってsystemdが利用される場合が多い。

Answer: initプロセス

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ******* は、Linuxシステムが起動された時に最初に実行されるプロセスで、システムのブートプロセスやサービス管理を行うシステム管理デーモン。従来のinitプロセスの代替として設計されており、プロセスの開始、監視、制御、終了等を行うことができる。 ******* では、デーモンやサービスの依存関係や起動順序、停止順序などを管理することができる。 ******* のPIDは必ず1となる。

 ******* では各サービスがユニットファイルとして定義され、 ******* によって自動的に管理される。また、 systemctl コマンドを利用してサービスのステータス確認や起動、停止、再起動、有効化、無効化などを行うことができる。

Answer: systemd

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、Linuxシステムが起動された時に開始されるデーモンプロセス。デーモンと同じ意味で使用される場合も多い。

Answer: サービス

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ********* は、systemdを制御するために使用されるコマンド。サービスの起動や停止、有効化、無効化などを行うサービスマネージャであり、システムの管理に必要なサブコマンドが用意されている。

コマンドの書式は以下の通り。

 *********  [OPTIONS...] COMMAND [UNIT...]

Answer: systemctl

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ************** は、systemdを使用してLinuxシステム上のサービスを開始するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスを開始する。

$ systemctl start httpd

ただし、システムを再起動した際には開始したサービスは起動されないので、自動で開始したい場合は systemctl enable を使用する。

Answer: systemct start

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ************** は、systemdを使用してLinuxシステム上のサービスを停止するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスを停止する。

$  **************  httpd

ただし、自動的に開始されるように設定されているサービスは、システムを再起動したときに開始されてしまうので、完全に停止したい場合は systemctl disable を使用する。

Answer: systemctl stop

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ***************** は、systemdを使用してLinuxシステム上のサービスを再起動するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスを再起動する。

$  *****************  httpd

これは、サービスの設定ファイルを変更して、再度その内容を読み込みたい場合などによく用いられる。

Answer: systemctl restart

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **************** は、systemdを使用してLinuxシステム上のサービスの状態を確認するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスの状態を表示する。

$  ****************  httpd

Answer: systemctl status

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **************** は、systemdを使用してLinuxシステム上のサービスが起動時に自動的に開始されるように登録するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスが次回のシステムの起動時に自動的に開始される。

$  ****************  httpd

Answer: systemctl enable

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ***************** は、systemdを使用してLinuxシステム上で自動的に起動されるように登録されたサービスを解除するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスが次回のシステムの起動時に自動的に開始されないようにする。

$  *****************  httpd

Answer: systemctl disable

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ******************** は、systemdを使用して指定したサービスが自動起動に登録されているかを確認するコマンド。

例えば以下のコマンドを実行すると、 httpd サービスが登録されているかを表示する。

$  ********************  httpd

Answer: systemctl is-enabled

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** は、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスに **** を送信して強制終了させる
•  **** を送信してプロセスの処理を一時停止、再開させる
•  **** 受信時にユーザ定義の処理（ **** ハンドラ）を実行する

主な **** は以下の通り。

|  **** 番号 |  **** 名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動する **** 。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了する **** 。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了する **** 。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開する **** 。                                                    | | 19         | STOP               | プロセスを一時停止する **** 。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断する **** 。                                                              |

Answer: シグナル

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（ ******** ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: シグナルハンドラ

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          |  *** (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: HUP

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          |  *** (Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: INT

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          |  ****                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: KILL

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         |  **** (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: TERM

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         |  **** (Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: CONT

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         |  ****                | プロセスを一時停止するシグナル。                                                          | | 20         | TSTP(Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: STOP

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

シグナルは、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

• プロセスにシグナルを送信して強制終了させる
• シグナルを送信してプロセスの処理を一時停止、再開させる
• シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名             | 概要                                                                                      | | ------------ | ---------------------- | :---------------------------------------------------------------------------------------- | | 1          | HUP(Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                  | | 2          | INT(Interrupt)     | キーボードからの割込み( Ctrl + C )                                                      | | 9          | KILL               | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。  | | 15         | TERM(Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                        | | 18         | CONT(Continue)     | 一時停止のプロセスを再開するシグナル。                                                    | | 19         | STOP               | プロセスを一時停止するシグナル。                                                          | | 20         |  **** (Teminal stop) | プロセスを中断するシグナル。                                                              |

Answer: TSTP

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 ******* (IPC: InterProcess Communication)は、実行中の複数のプロセス間でデータをやり取りするための仕組み。あるプログラムから別のプログラムへデータやメッセージを通知したり、プログラム同士で協調して処理を行うための技術や手段のことを指す。

Answer: プロセス間通信

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

プロセス間通信( *** : InterProcess Communication)は、実行中の複数のプロセス間でデータをやり取りするための仕組み。あるプログラムから別のプログラムへデータやメッセージを通知したり、プログラム同士で協調して処理を行うための技術や手段のことを指す。

Answer: IPC

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

 **** (Socket)は、ネットワークを介してプロセス間通信を行うためのAPI。 **** には、TCPやUDPなどのプロトコルに対応した種類がある。

サーバは以下のような手順で通信を行う。

1. socket: 待ち受け用の **** を作成する
2. bind: 待ち受けるIPアドレスやポート番号といった情報を **** に紐づける
3. listen: クライアントからの通信を待ち受ける
4. accept: 接続要求を受け入れ、通信用に新しい **** を作成する
5. read/write: acceptで作成した **** を用いて、クライアントとのデータのやり取りを行う

クライアントは以下のような手順で通信を行う。

1. socket: サーバとの通信用の **** を作成する
2. connect: サーバが待ち受けているIPアドレスのポートに対して接続を試みる
3. read/write: 接続が確立したら、 **** を介してサーバとのデータのやり取りを行う

Answer: ソケット

Source: ../../note/computer/linux/_/chapters/process_and_job.md

====================

ソケット(Socket)は、ネットワークを介してプロセス間通信を行うためのAPI。ソケットには、TCPやUDPなどのプロトコルに対応した種類がある。

サーバは以下のような手順で通信を行う。

1.  ****** : 待ち受け用のソケットを作成する
2. bind: 待ち受けるIPアドレスやポート番号といった情報をソケットに紐づける
3. listen: クライアントからの通信を待ち受ける
4. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する
5. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う

クライアントは以下のような手順で通信を行う。

1.  ****** : サーバとの通信用のソケットを作成する
2. connect: サーバが待ち受けているIPアドレスのポートに対して接続を試みる
3. read/write: 接続が確立したら、ソケットを介してサーバとのデータのやり取りを行う

Answer: socket

Source: ../../note/computer/linux/_/chapters/process_and_job.md

