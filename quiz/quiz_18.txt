====================

 ************* は、ガードされたメソッドを持つクラス。ガード条件が満たされていればこのメソッドを実行し、満たされていなければスキップする。

Answer: GuardedObject

Source: ../../note/development/design_pattern/multi_thread/_/chapters/balking.md

====================

 ********** は、非同期プログラミングにおいて、将来のある時点で結果が利用可能になる処理を表現して扱うためのデザインパターン。準備に時間のかかるデータを別スレッドで処理しつつ、そのデータが実際に必要になった段階で準備が完了するのを待機することで、効率よくリソースを利用することを目的としている。

 ********** は、Host、VirtualData、RealData、Futureから構成される。

Answer: Futureパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/future.md

====================

 **** は、Futureパターンにおいて、新しいスレッドを作成してRealDataを作成する役。RealDataを要求するスレッドにはFutureを返し、RealDataが準備できた時点でその値を利用できるようにする。

Answer: Host

Source: ../../note/development/design_pattern/multi_thread/_/chapters/future.md

====================

 *********** は、Futureパターンにおいて、RealDataとFutureを同一視して扱うためのインタフェース。

Answer: VirtualData

Source: ../../note/development/design_pattern/multi_thread/_/chapters/future.md

====================

 ******** は、Futureパターンにおいて、Hostによって処理された実際のデータを表す役。 ******** を用意するのには時間を要するため、Futureを引換券としてHostから返却する。

Answer: RealData

Source: ../../note/development/design_pattern/multi_thread/_/chapters/future.md

====================

 ****** は、 ****** パターンにおいて、HostがRealDataを準備するまでの間、仮で渡される引換券のような役。RealDataが要求された場合は、それが準備できるまで待機する。

Answer: Future

Source: ../../note/development/design_pattern/multi_thread/_/chapters/future.md

====================

 ********************** は、ある条件が整うまでスレッドをブロックしておき、その条件が満たされた時に処理を実行するデザインパターン。類似のBalkingパターンでは、ガード条件が満たされていない場合に処理をスキップするが、このパターンでは待機する。

 ********************** はGuardedObjectの役のみからなる。

Answer: Guarded Suspentionパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/guarded_suspention.md

====================

 ************* は、ガードされたメソッドを持つクラス。ガード条件が満たされていればこのメソッドを実行し、満たされていなければ満たされるまで待機する。

Answer: GuardedObject

Source: ../../note/development/design_pattern/multi_thread/_/chapters/guarded_suspention.md

====================

 ************* は、データへの書き込みを禁止することで、複数のスレッドから共有リソースにアクセスしても問題ないようにするデザインパターン。

 ************* はImmutableの役のみで構成される。

Answer: Immutableパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/immutable.md

====================

 ********* は、 ********* パターンにおいて、変更不可能な変数やクラス。クラスを使用する場合は、setter（メンバ変数の変更用のメソッド）を持たず、getter（メンバ変数の取得用のメソッド）のみを持つように設計する。また、メンバ変数は全てコンストラクタで設定する。

Answer: Immutable

Source: ../../note/development/design_pattern/multi_thread/_/chapters/immutable.md

====================

 ********************* は、データを生成するスレッドと、生成されたデータを消費するスレッドが協力して、データを安全に共有し処理を行うデザインパターン。

 ********************* は、Producer、Consumer、Data、Channelから構成される。

Answer: Producer-Consumerパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/producer_consumer.md

====================

 ******** は、 ******** -Consumerパターンにおいて、Dataを生成してChannelに追加する役。Channelの容量がいっぱいであれば、ConsumerがDataを消費するまで待機する。

Answer: Producer

Source: ../../note/development/design_pattern/multi_thread/_/chapters/producer_consumer.md

====================

 ******** は、Producer- ******** パターンにおいて、ChannelからDataを取得して処理をする役。Channelが空であれば、ProducerがDataを生成するまで待機する。

Answer: Consumer

Source: ../../note/development/design_pattern/multi_thread/_/chapters/producer_consumer.md

====================

 **** は、Producer-Consumerパターンにおいて、Producerによって生み出されてChannelに保持され、Consumerによって取り出されて処理される役。

Answer: Data

Source: ../../note/development/design_pattern/multi_thread/_/chapters/producer_consumer.md

====================

 ******* は、producer-consumerパターンにおいて、producerによって生み出されたdataを、Consumerによって取り出されるまで一時的に保持する役。

Answer: channel

Source: ../../note/development/design_pattern/multi_thread/_/chapters/producer_consumer.md

====================

 ******************* は、共有リソースに対して、単一の書き込みスレッド、もしくは複数の読み込みスレッドがアクセスすることができるというデザインパターン。また、読み込みと書き込みは同時にできないようにすることで、レースコンディションを防ぎながらパフォーマンスを向上させることができる。

 ******************* は、Reader、Writer、SharedResource、ReadWriteLockから構成される。

Answer: Read-Write Lockパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/read_write_lock.md

====================

 ****** は、Read-Write Lockパターンにおいて、SharedResourceに対する読み込みを行うクラスやスレッド。同時に複数の ****** がSharedResourceにアクセスすることができる。

Answer: Reader

Source: ../../note/development/design_pattern/multi_thread/_/chapters/read_write_lock.md

====================

 ****** は、Read-Write Lockパターンにおいて、SharedResourceに対する書き込みを行うクラスやスレッド。同時にひとつの ****** がSharedResourceにアクセスでき、書き込み中はReaderも読み込みができない。

Answer: Writer

Source: ../../note/development/design_pattern/multi_thread/_/chapters/read_write_lock.md

====================

 ************** は、Read-Write Lockパターンにおいて、ReaderとWriterによって共有されている資源。 ************** は、内部状態を変更する処理(Write)と、内部状態を変更しない処理(Read)を提供する。

Answer: SharedResource

Source: ../../note/development/design_pattern/multi_thread/_/chapters/read_write_lock.md

====================

 ************* は、Read-Write Lockパターンにおいて、SharedResourceが読み込み処理と書き込み処理を実現するためのロックを提供する役。

Answer: ReadWriteLock

Source: ../../note/development/design_pattern/multi_thread/_/chapters/read_write_lock.md

====================

 *************************** は、複数のスレッドから同時に実行されると問題になるような箇所に対して排他制御を行い、1つのスレッドからのみ実行されるようにするデザインパターン。複数のスレッドが共有リソースに同時にアクセスすることで、レースコンディションが発生することを避け、データの整合性を保つことができる。

Answer: Single Thread Executionパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/single_thread_execution.md

====================

 ********************** は、時間のかかる処理要求に対して、1つ1つスレッドを割り当てることで、応答速度の向上を目的とするデザインパターン。

 ********************** は、HostとHelperから構成される。

Answer: Thread-Per-Messageパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/thread_per_message.md

====================

 **** は、Thread-Per-Messageパターンにおいて、処理要求を受けて新しいスレッドを起動するクラス。また、起動されたスレッドはHelperを使用して要求を処理する。

Answer: Host

Source: ../../note/development/design_pattern/multi_thread/_/chapters/thread_per_message.md

====================

 ****** は、Thread-Per-Messageパターンにおいて、要求を処理する機能をHostに提供する役。Hostによって起動されたスレッドは、 ****** を利用して処理を実行する。

Answer: Helper

Source: ../../note/development/design_pattern/multi_thread/_/chapters/thread_per_message.md

====================

 *************************** （Thread Local Storageパターン）は、複数のスレッドを用いるプログラムにおいて、各スレッドが個別のデータ領域を持つことで、排他処理を行わずに並列実行を可能にするデザインパターン。

スレッドごとに個別のログファイルを管理するといった、スレッド固有のデータの隔離に利用される。

Answer: Thread-Specific Storageパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/thread_specific_storage.md

====================

Thread-Specific Storageパターン（ ************************ ）は、複数のスレッドを用いるプログラムにおいて、各スレッドが個別のデータ領域を持つことで、排他処理を行わずに並列実行を可能にするデザインパターン。

スレッドごとに個別のログファイルを管理するといった、スレッド固有のデータの隔離に利用される。

Answer: Thread Local Storageパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/thread_specific_storage.md

====================

 ************************* は、外部からスレッドに対して終了要求を送り、スレッドが自身の都合の良いタイミングで処理を終えることで、安全にスレッドを終了するデザインパターン。

 ************************* は、TerminationRequestとTerminatorから構成される。

Answer: Two-Phase Terminationパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/two_phase_termination.md

====================

 ****************** は、Two-Phase Terminationパターンにおいて、Terminatorへスレッドの終了要求を出す役。Terminatorは即座にスレッドを終了するのではなく、都合の良いタイミングまで処理を進めてから終了処理に進む。

Answer: TerminationRequest

Source: ../../note/development/design_pattern/multi_thread/_/chapters/two_phase_termination.md

====================

 ********** は、Two-Phase Terminationパターンにおいて、TerminationRequestの終了要求を受けて、実際に終了処理を行う役。 ********** は終了要求を受け取るためのメソッドと自身が終了要求を受けたかどうかを表すフラグを持っている。

Answer: Terminator

Source: ../../note/development/design_pattern/multi_thread/_/chapters/two_phase_termination.md

====================

 ***************** （Thread Poolパターン）は、一般的に生成・破棄コストの高いスレッドをあらかじめ起動しておき、それを使いまわすデザインパターン。Producer-Consumerパターンに基づき、キューを使用してWorkerスレッドに処理させたいタスクを送受信する。

Thread-Per-Messageでは処理要求がある度に新しいスレッドを生成するが、 ***************** ではこの際に発生するコストを抑えることができ、スループットの向上が期待できる。

 ***************** は、Channel、Worker、Requestから構成される。

Answer: Worker Threadパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/worker_thread.md

====================

Worker Threadパターン（ *************** ）は、一般的に生成・破棄コストの高いスレッドをあらかじめ起動しておき、それを使いまわすデザインパターン。Producer-Consumerパターンに基づき、キューを使用してWorkerスレッドに処理させたいタスクを送受信する。

Thread-Per-Messageでは処理要求がある度に新しいスレッドを生成するが、Worker Threadパターンではこの際に発生するコストを抑えることができ、スループットの向上が期待できる。

Worker Threadパターンは、Channel、Worker、Requestから構成される。

Answer: Thread Poolパターン

Source: ../../note/development/design_pattern/multi_thread/_/chapters/worker_thread.md

====================

 ******* は、Worker Threadパターンにおいて、Workerで処理したいRequestを一時的に保持しておく役。

Answer: Channel

Source: ../../note/development/design_pattern/multi_thread/_/chapters/worker_thread.md

====================

 ****** は、 ******  Threadパターンにおいて、ChannelからRequestを拾って実際に処理を行う役。Channelが空である場合は、新しいRequestが生成されるまで待機する。

Answer: Worker

Source: ../../note/development/design_pattern/multi_thread/_/chapters/worker_thread.md

====================

 ******* は、Worker Threadパターンにおいて、Workerによって処理されることを期待されるタスク。

Answer: Request

Source: ../../note/development/design_pattern/multi_thread/_/chapters/worker_thread.md

====================

 **** は、ホストOS上で独立したプロセスとして実行されるアプリケーション環境。OSの基本コマンドやアプリケーションの実行バイナリ、ライブラリなどの実行環境全体をパッケージ化し、それらをホストOS上の分離された空間で実行できる技術。

Answer: コンテナ

Source: ../../note/development/docker/_/chapters/container.md

====================

 ******** は、コンテナを稼働させ、管理するためのソフトウェア。中でも、実際にコンテナを実行するプログラムのことをコンテナランタイムという。

Answer: コンテナエンジン

Source: ../../note/development/docker/_/chapters/container.md

====================

コンテナエンジンは、コンテナを稼働させ、管理するためのソフトウェア。中でも、実際にコンテナを実行するプログラムのことを ********* という。

Answer: コンテナランタイム

Source: ../../note/development/docker/_/chapters/container.md

====================

 ********** は、イメージを元にしてコンテナを起動するコマンド。

Answer: docker run

Source: ../../note/development/docker/_/chapters/container.md

====================

 ********* は、起動中のコンテナの一覧を確認するコマンド。また、 -a オプションをつけることで、停止中のコンテナも表示することができる。

起動中のコンテナは STATUS に Up と表示され、停止中のコンテナは Exit と表示される。

$  *********  -a
CONTAINER ID   IMAGE          COMMAND       CREATED        STATUS                       PORTS     NAMES
c2d63875bf6a   ubuntu:22.10   "/bin/bash"   2 hours ago    Exited (137) 6 seconds ago             ubuntu_linux_01

Answer: docker ps

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************** は、コンテナの情報を確認するコマンド。

Answer: docker inspect

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************ は、コンテナのリソース使用状況を追跡するコマンド。 -a オプションを指定すると、停止しているコンテナを含めてすべてのリソース使用状況を表示する。 --no-stream オプションを指定すると、リソースの使用状況を追跡するのではなく、一度だけ表示する。 --no-trunc オプションを指定すると完全なコンテナIDを表示。

$  ************ 
CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT   MEM %     NET I/O   BLOCK I/O   PIDS

Answer: docker stats

Source: ../../note/development/docker/_/chapters/container.md

====================

 *********** は、コンテナ内で作業した命令をログとして確認するコマンド。 -t オプションを指定すると、時刻付きでログを出力できる。

Answer: docker logs

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************* は、コンテナをイメージとして保存するコマンド。コンテナIDとイメージ名、タグを指定する。

Answer: docker commit

Source: ../../note/development/docker/_/chapters/container.md

====================

 ********* は、停止中のコンテナを削除するコマンド。コンテナのIDあるいはコンテナ名を指定することで削除することができる。起動中のコンテナを停止したい場合は、 -f オプションを付与する。

Answer: docker rm

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************ は、停止中のコンテナを起動するコマンド。

Answer: docker start

Source: ../../note/development/docker/_/chapters/container.md

====================

 *********** は、コンテナを停止するコマンド。

Answer: docker stop

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************* は、バックグラウンドで起動中のコンテナのシェルに接続するコマンド。コンテナ内でシェルが動作していない場合は接続することはできず、 exit コマンドを用いるとコンテナは停止する。

Answer: docker attach

Source: ../../note/development/docker/_/chapters/container.md

====================

 *********** は、コンテナ内でコマンドを実行するためのコマンド。シェルを起動してコンテナに接続する際に用いる場合が多い。

Answer: docker exec

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************* は、コンテナを tar 形式のアーカイブに変換するコマンド。

Answer: docker export

Source: ../../note/development/docker/_/chapters/container.md

====================

 ************* は、エクスポートしたコンテナのアーカイブを元にイメージを取り込むコマンド。

Answer: docker import

Source: ../../note/development/docker/_/chapters/container.md

====================

 ******* は、データ専用のコンテナ。アプリケーションのコンテナとデータのコンテナを分離して、データの再利用性を高めたり、バックアップやリストアに利用したりする。 ******* には、busyboxイメージがよく用いられる。

Answer: データコンテナ

Source: ../../note/development/docker/_/chapters/container.md

====================

データコンテナは、データ専用のコンテナ。アプリケーションのコンテナとデータのコンテナを分離して、データの再利用性を高めたり、バックアップやリストアに利用したりする。データコンテナには、 ******* イメージがよく用いられる。

Answer: busybox

Source: ../../note/development/docker/_/chapters/container.md

====================

 ****** は、2013年にリリースされたOSSで、アプリケーションやOSの開発・配信を行うためのコンテナエンジン。 ****** を利用することで、ソフトウェア開発者はハードウェア資源を意識せずに、容易にアプリケーションの開発・実行環境を構築することができる。ハイパーバイザ型の仮想化ソフトウェアに比べて、ハードウェア資源の消費が少なく、アプリケーションに必要な環境のみを集約して再現することができる。

ソフトウェア開発においては、アプリケーション単位での環境の分離や、開発環境の作成と廃棄を容易に行えるというメリットがある。また、運用管理の面で見ても、ITインフラで ****** を運用することにより、開発したアプリケーションを素早く展開することができるDevOps環境やイミュータブルインフラストラクチャが実現しやすくなる。

Answer: Docker

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ********** は、Dockerのコンテナエンジン。デーモンとしてホストOSに常駐し、コンテナの管理や実行を担う。

Answer: Dockerエンジン

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ************ は、Dockerエンジンを操作するためのインタフェース。ホストOS上でデーモンとして起動しているDockerエンジンに対して命令を与える。遠隔でDockerデーモンと通信することも可能。

Answer: Dockerクライアント

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ********** は、Dockerイメージのレジストリサービス。Dockerイメージがリポジトリとして管理されており、Dockerイメージの検索や変更履歴の管理、取得、アップロードといったことが可能。

公開されているDockerイメージにマルウェアが含まれていたという事例もあるため、慎重なセキュリティ対策が必要となる側面もある。

Answer: Docker Hub

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ********** は、Dockerのデフォルトのエンジンモード。

Answer: Rootfulモード

Source: ../../note/development/docker/_/chapters/docker.md

====================

 *********** は、Dockerをroot権限を必要とせずに一般ユーザとして利用できるモード。

Answer: Rootlessモード

Source: ../../note/development/docker/_/chapters/docker.md

====================

 **** （ネームスペース）は、Linuxが持つ機能で、コンテナをホストOS上で分離（隔離）するために利用されている。プロセスやネットワーク、ディレクトリ、ユーザなどを分離する機能となっている。

|  ****  | 概要                                                                                     | | -------- | ---------------------------------------------------------------------------------------- | | UTS      | ホスト名、ドメイン名などを分離                                                           | | PID      | 実行するプロセスIDを分離し、異なる **** のプロセス同士は互いにアクセスできない         | | マウント | ファイルシステムのマウント                                                               | | ユーザ   | ユーザやグループの管理を分離                                                             | | IPC      | 共有メモリやセマフォ、メッセージキューなどを分離                                         | | Network  | ネットワークデバイスやIPアドレス、ルーティングテーブル、フィルタリング、ポート番号を分離 |

Answer: 名前空間

Source: ../../note/development/docker/_/chapters/docker.md

====================

名前空間（ ******* ）は、Linuxが持つ機能で、コンテナをホストOS上で分離（隔離）するために利用されている。プロセスやネットワーク、ディレクトリ、ユーザなどを分離する機能となっている。

| 名前空間 | 概要                                                                                     | | -------- | ---------------------------------------------------------------------------------------- | | UTS      | ホスト名、ドメイン名などを分離                                                           | | PID      | 実行するプロセスIDを分離し、異なる名前空間のプロセス同士は互いにアクセスできない         | | マウント | ファイルシステムのマウント                                                               | | ユーザ   | ユーザやグループの管理を分離                                                             | | IPC      | 共有メモリやセマフォ、メッセージキューなどを分離                                         | | Network  | ネットワークデバイスやIPアドレス、ルーティングテーブル、フィルタリング、ポート番号を分離 |

Answer: ネームスペース

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ******** は、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

 ******** としては、Red Hat Enterprise Linux CoreOS(RHCOS)、Fedora CoreOS、FlatcarContainer Linux、k3OSといったものが有名。

Answer: コンテナ専用OS

Source: ../../note/development/docker/_/chapters/docker.md

====================

コンテナ専用OSは、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

コンテナ専用OSとしては、 ******************************* (RHCOS)、Fedora CoreOS、FlatcarContainer Linux、k3OSといったものが有名。

Answer: Red Hat Enterprise Linux CoreOS

Source: ../../note/development/docker/_/chapters/docker.md

====================

コンテナ専用OSは、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

コンテナ専用OSとしては、Red Hat Enterprise Linux CoreOS( ***** )、Fedora CoreOS、FlatcarContainer Linux、k3OSといったものが有名。

Answer: RHCOS

Source: ../../note/development/docker/_/chapters/docker.md

====================

コンテナ専用OSは、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

コンテナ専用OSとしては、Red Hat Enterprise Linux CoreOS(RHCOS)、 ************* 、FlatcarContainer Linux、k3OSといったものが有名。

Answer: Fedora CoreOS

Source: ../../note/development/docker/_/chapters/docker.md

====================

コンテナ専用OSは、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

コンテナ専用OSとしては、Red Hat Enterprise Linux CoreOS(RHCOS)、Fedora CoreOS、 ********************** 、k3OSといったものが有名。

Answer: FlatcarContainer Linux

Source: ../../note/development/docker/_/chapters/docker.md

====================

コンテナ専用OSは、Dockerなどのコンテナ利用に特化して開発された専用OS。コンテナを稼働させることに目的を絞った、アプライアンスOSのため、管理方法も一般的なLinuxとは異なる。アプリケーションや稼働するデーモン、パッケージマネージャなどが削られており、コンテナの稼働に必要最低限のコンポーネントで構成されている。一般のサーバOSに比べて強固なセキュリティ、性能面での優位性、高い保守性を確保できるとされている。

コンテナ専用OSとしては、Red Hat Enterprise Linux CoreOS(RHCOS)、Fedora CoreOS、FlatcarContainer Linux、 **** といったものが有名。

Answer: k3OS

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ********* (Docker Community Edition)は、無償版のDockerエンジンで、コミュニティによってメンテナンスされているため、Docker社やDocker純正製品の提供を行うベンダの保守サポートは得られない。

Answer: Docker CE

Source: ../../note/development/docker/_/chapters/docker.md

====================

 *** (Mirantis Container Runtime)は、Docker EE(Docker Enterprise Edition)をベースとしたエンタープライズ向けのDockerエンジン。Mirantis社が製品提供を行っている。

Answer: MCR

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ************** は、Linux、Windows、macOSに対応したGUI画面付属のデスクトップ版アプリケーション。

Answer: Docker Desktop

Source: ../../note/development/docker/_/chapters/docker.md

====================

 ************** は、複数のコンテナを一括で管理、構築、連携することができるツール。複数のコンテナが連携して動作するようなアプリケーションにおいて、それぞれのコンテナのDockerfileやVolume、ネットワークといったものの管理をまとめて行いたい場合などに有用。 ************** を利用するには、コンテナの設定を記述したYAMLファイル（ docker-compose.yml という名前にするのが一般的）を用意する必要がある。

version: '3'

services:

    # nginxコンテナ
    nginx:
        image: 'nginx:latest'
        ports:
            - 80:80
        volumes:
            - ./src:/var/www
            - ./nginx/app.conf:/etc/nginx/conf.d/app.conf

    # phpコンテナ
    php:
        image: 'php-fpm:latest'
        ports:
            - 9000:9000
        volumes:
            - ./src:/var/www
            - ./php/php.ini:/etc/php/php.ini
        depends_on: mysql

    # mysqlコンテナ
    mysq:
        image: 'mysql:latest'
        ports:
            - 3306:3306
        environment:
            MYSQL_ROOT_PASSWORD: 'password'
            MYSQL_DATABASE: 'my_app'
            MYSQL_USER: 'my_app'
            MYSQL_PASSWORD: 'password'
            TZ: 'Asia/Tokyo'
        command:
            mysqld --default-authentication-plugin=mysql_native_password
        volumes:
            - ./mysql/my.cnf:/etc/mysql/conf.d/my.cnf
            - my_app_data:/var/lib/mysql

Answer: Docker Compose

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ******************** は、YAMLファイルに記述された定義を元に、Dockerfileからイメージをビルドするコマンド。

$  ******************** 

Answer: docker compose build

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ***************** は、YAMLファイルに記述された定義を元に、コンテナを起動するコマンド。 -d オプションを付与すると、バックグラウンドで起動する。 --build オプションを付与すると、ビルド後に起動する。

$  ***************** 
$  *****************  -d
$  *****************  --build

docker compose startは、すでに作成されているコンテナを再起動するコマンド。

Answer: docker compose up

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

docker compose upは、YAMLファイルに記述された定義を元に、コンテナを起動するコマンド。 -d オプションを付与すると、バックグラウンドで起動する。 --build オプションを付与すると、ビルド後に起動する。

$ docker compose up
$ docker compose up -d
$ docker compose up --build

 ******************** は、すでに作成されているコンテナを再起動するコマンド。

Answer: docker compose start

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ******************* は、YAMLファイルに記述された定義を元に、コンテナを停止するコマンド。

$  ******************* 

Answer: docker compose stop

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ******************* は、起動中のコンテナのサービス名を指定してコマンドを実行するコマンド。

Answer: docker compose exec

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ***************** は、停止されているコンテナを削除するコマンド。

$  ***************** 

docker compose downは、起動中のコンテナを停止して削除するコマンド。

$ docker compose down

Answer: docker compose rm

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

docker compose rmは、停止されているコンテナを削除するコマンド。

$ docker compose rm

 ******************* は、起動中のコンテナを停止して削除するコマンド。

$  ******************* 

Answer: docker compose down

Source: ../../note/development/docker/_/chapters/docker_compose.md

====================

 ************ は、Dockerが開発しているオープンソースのコンテナオーケストレーションツール。 ************ がインストールされたホストOSは、Dockerクラスタ構成のマスタノード（Swarm Manager）となり、他のDockerがインストールされたワーカノードをまとめる役割を持つ。 ************ のインタフェースは通常のDockerコマンドとほぼ同じで、APIを通じて各ノードのDockerを操作することができる。

Answer: Docker Swarm

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

Docker Swarmは、Dockerが開発しているオープンソースのコンテナオーケストレーションツール。Docker SwarmがインストールされたホストOSは、Dockerクラスタ構成のマスタノード（ ************* ）となり、他のDockerがインストールされたワーカノードをまとめる役割を持つ。Docker Swarmのインタフェースは通常のDockerコマンドとほぼ同じで、APIを通じて各ノードのDockerを操作することができる。

Answer: Swarm Manager

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ***************** は、Docker Swarmのマスタノードを起動するコマンド。Swarm Managerのホストで実行する。

$  ***************** 

Answer: docker swarm init

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ***************** は、Docker Swarmのクラスタに参加するためのコマンド。Swarm Managerが管理する各ワーカノードとなるホストで実行する。トークンには、Docker Swarmの起動時に生成されたものを指定する。

$  *****************  <master node ip>:<master node port> --token <token>

Answer: docker swarm join

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 *********************** は、ノードを追加するためのトークンを再度表示するためのコマンド。Swarm Managerのホストで実行することができる。

$  ***********************  worker

Answer: docker swarm join-token

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ******************** は、Swarm Managerが管理するノードを確認するコマンド。

$  ******************** 

Answer: docker swarm node ls

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 **** は、Docker Swarmが管理するコンテナの単位。

Answer: サービス

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ********************* は、Docker Swarmが扱うサービスを作成するコマンド。 --name オプションにはサービス名を、 --hostname にはコンテナのホスト名を、 --network には使用するoverlayネットワークを、 --replicas には起動時のコンテナの複製の数を指定する。また、 --update-delay オプションを指定すると、ローリングアップデート時にすべてのレプリカが同時に停止してまわないように遅延時間を設けることができる。

$  *********************  <image>:<tag> \
> --name <service> \
> --hostname <hostname> \
> --network <network> \
> --replicas <replica num>

Answer: docker service create

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ***************** は、 Docker Swarmが扱うサービスの一覧を確認するコマンド。

$  ***************** 

Answer: docker service ls

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ***************** は、Docker Swarmが扱うサービスの状態を確認するコマンド。

$  *****************  <service>

Answer: docker service ps

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ********************* は、Docker Swarmのサービスをローリングアップデートするコマンド。

$  *********************  --image <image>:<tag> <service>

Answer: docker service update

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ***************** は、Docker Swarmのサービスを破棄するコマンド。

$  *****************  <service>

Answer: docker service rm

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ******************** は、Docker Swarmのサービスをスケールするコマンド。

$  ********************  <service>=<replica num>

Answer: docker service scale

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 **** は、Docker Swarmのサービスをまとめて管理するための単位。 **** の設定には、Docker Composeと同様のYAML形式のファイルを用いる。

Answer: スタック

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ******************* は、Docker Swarmのスタックをデプロイするコマンド。スタックの定義ファイルから、サービスを生成する。

$  *******************  <stack> --compose-file <filename>

Answer: docker stack deploy

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 *************** は、Docker Swarmのスタックを一覧で確認するコマンド。

$  *************** 

Answer: docker stack ls

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 *************** は、Docker Swarmのスタックの状態を確認するコマンド。

$  ***************  <stack>

Answer: docker stack ps

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ******************* は、Docker Swarmのスタックを削除するコマンド。

$  *******************  <stack>

Answer: docker stack remove

Source: ../../note/development/docker/_/chapters/docker_swarm.md

====================

 ********** は、イメージを作成するための手順を示した定義書。イメージがどのようなアプリケーションで構成されているのか、どのような手順で構築されるのかといった情報を含んでおり、イメージのメンテナンス性を向上させる。

FROM python:3.6

WORKDIR /app
ADD . /app
RUN pip install --trusted-host pypi.python.org -r requirements.txt
EXPOSE 80
ENV DISTRIBUTION dev
CMD ["python", "app.py"]

Answer: Dockerfile

Source: ../../note/development/docker/_/chapters/dockerfile.md

====================

 ********* は、イメージのビルド時に与える付加情報。Dockerfile内でホストOSを参照する命令において、参照先となるパスを指定する。

Answer: ビルドコンテキスト

Source: ../../note/development/docker/_/chapters/dockerfile.md

====================

 ************ は、Dockerfileからイメージを生成するコマンド。コンテキストには、Dockerfileが参照するホストOSのディレクトリパスを指定する。デフォルトではカレントディレクトリにある Dockerfile という名前のファイルを元にビルドを行うが、 -f オプションで任意のDockerfileを使用できる。また、 -t オプションを付与して、イメージ名やタグを指定できる。

Answer: docker build

Source: ../../note/development/docker/_/chapters/dockerfile.md

====================

 ********** は、Dockerfile内に、処理対象とするイメージを複数記述して、それらから生成されたファイルやバイナリを最終的なDockerイメージに埋め込む方法。 ********** を利用することにより、開発用のDockerイメージと本番環境用のDockerイメージを1つのDockerfileで記述できたり、イメージのファイルサイズを減らすことができる。

以下は、Rustによって開発環境でビルドしたリリースバイナリを、リリース用のイメージにコピーする ********** Dockerfileの例。

Answer: マルチステージビルド

Source: ../../note/development/docker/_/chapters/dockerfile.md

====================

 **** は、コンテナの生成時のテンプレートとなるもので、コンテナ内で使用する実行ファイルやライブラリ、コンテナ起動時に実行させたいコマンドなどが含まれる。Docker **** により、アプリケーションの実行環境を容易に入手したり、開発環境と本番環境のランタイムシステムの違いを吸収したりすることができる。また、1つのDocker **** から複数のコンテナを素早く起動することができるため、アプリケーションのスケールを容易に行うことができるというメリットもある。

Answer: イメージ

Source: ../../note/development/docker/_/chapters/image.md

