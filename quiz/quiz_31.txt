====================

Rustは、C言語やC++に代わるシステムプログラミング言語を目指すプログラミング言語。静的型付け言語・コンパイラ言語に分類される。また、ガベージコレクションを用いない独特のメモリ管理（ ******** による参照の有効性の検証）によって、メモリ安全性を確保している。パフォーマンスや信頼性の高さからLinuxのカーネルプログラムにも採用されたり、GoogleやFacebookといった企業でも一部取り入れられたりと、注目の集まる言語となっている。開発者に最も愛されているプログラミング言語としても知られるが、習得難易度はC言語やC++と同程度かそれ以上に高い。

Answer: ボローチェッカー

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ** は、高負荷がかかるシステムなどには必須の並行プログラミングがシンプルに記述できるように、 ** ogleが開発したプログラミング言語。静的型付け言語・コンパイラ言語に分類され、メモリ管理にはガベージコレクションを用いる。Webアプリケーションやモバイルアプリなどの開発に適しており、標準ライブラリが豊富であるという特徴がある。実行速度はC言語やRustには劣るものの、同じ分野で活躍するPHPなどの言語に比べると圧倒的に高速である。

Answer: Go

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ******** は、プログラムの動作や振る舞いを変えることなく、内部の設計や構造を見直すことで、コードを理解や修正がしやすいように整える作業。システムを長期的に運用したり、仕様変更に強くしたりするために重要な工程。

Answer: リファクタリング

Source: ../../note/programming/_/chapters/techniques.md

====================

 **** （アーリーリターン、早期リターン）は、プログラミングのテクニックのひとつで、ある条件が満たされていない場合にコードの実行を中断し、特定の制御を行う仕組み。主に反復処理や関数の中で使用される。

例えば、条件を満たしている場合にポイントを付与する、以下のような関数を考える。

function give_family_point( member_, point_ = 100 )
{
    if( member_.is_gold_rank() )
    {
        if( member_.has_children() )
        {
            if( member_.with_family() )
            {
                member_.give_point(point_);
            }
        }
    }
}

これは条件分岐のネストが深く、非常に読みづらいコードとなっている。そこで、 **** を用いてこの関数をリファクタリングすると、以下のようになる。

function give_family_point( member_, point_ = 100 )
{
    //  **** によるアーリーリターン
    if( member_.is_gold_rank() === false ) return;
    if( member_.has_children() === false ) return;
    if( member_.with_family() === false ) return;

    member_.give_point(point_);
}

 **** を用いると、可読性が向上する他に、条件ブロックと処理ブロックを分離できるというメリットがある。また、 return だけではなく、 break や continue を用いても同様のリファクタリングが可能。

Answer: ガード節

Source: ../../note/programming/_/chapters/techniques.md

====================

ガード節（ ******** 、早期リターン）は、プログラミングのテクニックのひとつで、ある条件が満たされていない場合にコードの実行を中断し、特定の制御を行う仕組み。主に反復処理や関数の中で使用される。

例えば、条件を満たしている場合にポイントを付与する、以下のような関数を考える。

function give_family_point( member_, point_ = 100 )
{
    if( member_.is_gold_rank() )
    {
        if( member_.has_children() )
        {
            if( member_.with_family() )
            {
                member_.give_point(point_);
            }
        }
    }
}

これは条件分岐のネストが深く、非常に読みづらいコードとなっている。そこで、ガード節を用いてこの関数をリファクタリングすると、以下のようになる。

function give_family_point( member_, point_ = 100 )
{
    // ガード節による ******** 
    if( member_.is_gold_rank() === false ) return;
    if( member_.has_children() === false ) return;
    if( member_.with_family() === false ) return;

    member_.give_point(point_);
}

ガード節を用いると、可読性が向上する他に、条件ブロックと処理ブロックを分離できるというメリットがある。また、 return だけではなく、 break や continue を用いても同様のリファクタリングが可能。

Answer: アーリーリターン

Source: ../../note/programming/_/chapters/techniques.md

====================

ガード節（アーリーリターン、 ****** ）は、プログラミングのテクニックのひとつで、ある条件が満たされていない場合にコードの実行を中断し、特定の制御を行う仕組み。主に反復処理や関数の中で使用される。

例えば、条件を満たしている場合にポイントを付与する、以下のような関数を考える。

function give_family_point( member_, point_ = 100 )
{
    if( member_.is_gold_rank() )
    {
        if( member_.has_children() )
        {
            if( member_.with_family() )
            {
                member_.give_point(point_);
            }
        }
    }
}

これは条件分岐のネストが深く、非常に読みづらいコードとなっている。そこで、ガード節を用いてこの関数をリファクタリングすると、以下のようになる。

function give_family_point( member_, point_ = 100 )
{
    // ガード節によるアーリーリターン
    if( member_.is_gold_rank() === false ) return;
    if( member_.has_children() === false ) return;
    if( member_.with_family() === false ) return;

    member_.give_point(point_);
}

ガード節を用いると、可読性が向上する他に、条件ブロックと処理ブロックを分離できるというメリットがある。また、 return だけではなく、 break や continue を用いても同様のリファクタリングが可能。

Answer: 早期リターン

Source: ../../note/programming/_/chapters/techniques.md

====================

 ***** *(Don't Repeat Yourself)は，同じコードを繰り返し記述するべきではない、というプログラミングにおける原則。これを厳守することにより、コードの可読性や保守性を向上させることができ、バグの発生を防止することができる。

何度も使用する処理を関数にまとめたり、値をハードコーディングせずに変数として定義することで ***** を適用することができる。

Answer: DRY原則

Source: ../../note/programming/_/chapters/techniques.md

====================

 ******* (You aren't going to need it)は、必要なもの以外は実装するべきではない、というプログラミングにおける原則。無駄なコードを書かないようにすることで開発コストを削減し、システムをシンプルに保つことができる。実際の開発において、将来の仕様を予想して先回りして作り込むというのは、現実にはほとんど使われないばかりか、バグを引き起こす原因となってしまう場合もある。

 ******* を破って実装されたコードは、デッドコードとなってしまうパターンも多い。

Answer: YAGNI原則

Source: ../../note/programming/_/chapters/techniques.md

====================

 ******* は、関数などの仕様は、使用者の予想を裏切るような処理を可能な限り行わないようにするべきである、というプログラミングにおける原則。命名に関する原則であり、ひとつの関数が担う役割が十分に小さくない場合や、あまり一般的ではない単語を用いた場合に、この原則に反してしまう結果となる。

Answer: 驚き最小の原則

Source: ../../note/programming/_/chapters/techniques.md

====================

 ******** は、プログラミングにおいて、問題が発生した際に第三者（あるいは架空の相手（ラバーダックはゴム製のアヒルのおもちゃのこと））にそれを説明することで頭の中を整理し、問題の解決を図る方法。

Answer: ラバーダッキング

Source: ../../note/programming/_/chapters/techniques.md

====================

 *** (Command Query Separation)は、オブジェクト指向のクラス設計において、コマンド（変更操作）とクエリ（取得操作）を明確に分離するアプローチ。コマンドはデータの変更を行い、副作用を持つことがあるが、戻り値を返さない。クエリはデータの取得を行い、副作用を持たず、戻り値を返す。

Answer: CQS

Source: ../../note/programming/_/chapters/techniques.md

====================

 **** (Command Query Responsibility Segregation)は、CQSの考え方をベースとしており、データモデルとなるクラスを変更操作用と取得操作用に分けるような設計。変更操作用のクラスをコマンドモデル、取得操作用のクラスをクエリモデルとし、クエリモデルは読み取り専用にする。

Answer: CQRS

Source: ../../note/programming/_/chapters/techniques.md

====================

 ** は、プログラム中で用いるデータに固有の名前をつけたもの。物理的にはデータはメモリに格納されており、メモリ上のデータにはアドレスを使ってアクセスすることができる。しかし、メモリアドレスはただの数値の羅列であり、人間にはわかりずらいため、ソースコード中では格納しているデータの性質や役割を表す識別子をつけた ** を用いる。

Answer: 変数

Source: ../../note/programming/_/chapters/variable.md

====================

 ******* は、グローバルスコープに宣言された変数。

Answer: グローバル変数

Source: ../../note/programming/_/chapters/variable.md

====================

 ****** （自動変数、局所変数）は、ローカルスコープに宣言された変数。

同じ識別子の変数を複数回宣言できないプログラミング言語においても、スコープが異なれば同じ識別子を用いることができる。

Answer: ローカル変数

Source: ../../note/programming/_/chapters/variable.md

====================

ローカル変数（ **** 、局所変数）は、ローカルスコープに宣言された変数。

同じ識別子の変数を複数回宣言できないプログラミング言語においても、スコープが異なれば同じ識別子を用いることができる。

Answer: 自動変数

Source: ../../note/programming/_/chapters/variable.md

====================

ローカル変数（自動変数、 **** ）は、ローカルスコープに宣言された変数。

同じ識別子の変数を複数回宣言できないプログラミング言語においても、スコープが異なれば同じ識別子を用いることができる。

Answer: 局所変数

Source: ../../note/programming/_/chapters/variable.md

====================

 ** は、プログラム中で用いる変数の名前を明示する操作。静的型付け言語の多くは、 ** 時に変数の型も指定する必要がある。

プログラミング言語によっては、同じ変数名を複数回 ** しようとするとエラーとなる。一方で、新しい変数で前の変数を上書きする（シャドーイング）仕様のプログラミング言語もある。

Answer: 宣言

Source: ../../note/programming/_/chapters/variable.md

====================

宣言は、プログラム中で用いる変数の名前を明示する操作。静的型付け言語の多くは、宣言時に変数の型も指定する必要がある。

プログラミング言語によっては、同じ変数名を複数回宣言しようとするとエラーとなる。一方で、新しい変数で前の変数を上書きする（ ******* ）仕様のプログラミング言語もある。

Answer: シャドーイング

Source: ../../note/programming/_/chapters/variable.md

====================

 ** は、宣言した変数に対してデータを関連付ける操作。既にデータが紐づけられている変数に対して別のデータを紐づけることもでき、これを再 ** という。 ** のための演算子としては = が用いられる場合が多い（数学的な意味では = は「等価」であるが、多くのプログラミング言語では等価は == で表される）。

変数名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、プログラミングでは束縛（バインド）という。

Answer: 代入

Source: ../../note/programming/_/chapters/variable.md

====================

代入は、宣言した変数に対してデータを関連付ける操作。既にデータが紐づけられている変数に対して別のデータを紐づけることもでき、これを *** という。代入のための演算子としては = が用いられる場合が多い（数学的な意味では = は「等価」であるが、多くのプログラミング言語では等価は == で表される）。

変数名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、プログラミングでは束縛（バインド）という。

Answer: 再代入

Source: ../../note/programming/_/chapters/variable.md

====================

代入は、宣言した変数に対してデータを関連付ける操作。既にデータが紐づけられている変数に対して別のデータを紐づけることもでき、これを再代入という。代入のための演算子としては = が用いられる場合が多い（数学的な意味では = は「等価」であるが、多くのプログラミング言語では等価は == で表される）。

変数名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、プログラミングでは ** （バインド）という。

Answer: 束縛

Source: ../../note/programming/_/chapters/variable.md

====================

代入は、宣言した変数に対してデータを関連付ける操作。既にデータが紐づけられている変数に対して別のデータを紐づけることもでき、これを再代入という。代入のための演算子としては = が用いられる場合が多い（数学的な意味では = は「等価」であるが、多くのプログラミング言語では等価は == で表される）。

変数名に対してデータを関連付けるように、何かに対して別の何かを紐づけることを、プログラミングでは束縛（ **** ）という。

Answer: バインド

Source: ../../note/programming/_/chapters/variable.md

====================

 *** は、変数の宣言と同時に代入を行う操作。定数のような、後から変更することを許可しない変数を宣言したい場合は、 *** が必須となる。

Answer: 初期化

Source: ../../note/programming/_/chapters/variable.md

====================

 ** は、変数名に紐づくデータを取り出す操作。データが代入されていない変数（未初期化状態の変数）を ** することは不正な操作となり、プログラミング言語によっては未定義動作となる。これを防ぐため、宣言時や実行時に自動的に初期値（整数型であれば 0 、文字列型であれば空文字など）を割り当てるプログラミング言語もある。

Answer: 参照

Source: ../../note/programming/_/chapters/variable.md

====================

参照は、変数名に紐づくデータを取り出す操作。データが代入されていない変数（ ****** の変数）を参照することは不正な操作となり、プログラミング言語によっては未定義動作となる。これを防ぐため、宣言時や実行時に自動的に初期値（整数型であれば 0 、文字列型であれば空文字など）を割り当てるプログラミング言語もある。

Answer: 未初期化状態

Source: ../../note/programming/_/chapters/variable.md

====================

 ** は、初期化した後に別のデータを再代入できない変数。変数は後からデータを紐づけることができるが、 ** はできないので、必ず初期化する必要がある。 ** の初期化には const キーワードが用いられる場合が多い。プログラム中で変更されてはいけないデータや、数学的・物理的な ** に用いられるのが一般的。

// C言語

// 変数の初期化時にconstキーワードをつけることで ** にすることができる
const int max_num = 1000;
const float pi = 3.14159;

// JavaScript

// letの代わりにconstを用いることで ** を初期化する
const max_num = 1000;
const pi = 3.14159;

 ** は紐づくデータは変わらないが、ポインタ経由などでデータ自体を書き換えることができてしまうため、必ずしも参照した中身が一致するとは限らない点に注意が必要である。

また const  ** と似たような使われ方をする機能として、 define を利用できるプログラミング言語もある。これは一般的には、ソースコード中の文字列をコンパイル時に別の値に置き替える機能のことを指す。

// C言語

// defineマクロを用いて値を定義する

Answer: 定数

Source: ../../note/programming/_/chapters/variable.md

====================

 ***** は、プログラムが同期的な流れに依存せず、独立して進行する処理方法。プロセスの処理が完了するのを待たずに他のタスクを実行できるため、効率性とレスポンシブ性が向上する。

 ***** の例として、特定のイベントの発生時に非同期的に関数を実行したり、コールバック関数を用いて非同期的に完了時の処理を実行したり、ネットワーク通信などの時間のかかる操作を待たずに他の処理を実行したり、といったものが挙げられる。

Answer: 非同期処理

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

 ***** は、一時停止と再開が可能な関数で、非同期処理やマルチスレッドプログラミングにおいて、処理の制御と効率の向上を実現することができる。 ***** を用いると、[非同期処理]](#非同期処理)をより高度に抽象化して簡潔に記述することができる。

• 対称 ***** : 各 ***** が処理を停止する際に、次に実行する ***** を明示的に指定する
• 非対称 ***** : 各 ***** は処理の停止のみを明示し、処理の開始や再開といった役割はスケジューラに移譲する

Answer: コルーチン

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

コルーチンは、一時停止と再開が可能な関数で、非同期処理やマルチスレッドプログラミングにおいて、処理の制御と効率の向上を実現することができる。コルーチンを用いると、[非同期処理]](#非同期処理)をより高度に抽象化して簡潔に記述することができる。

•  ******* : 各コルーチンが処理を停止する際に、次に実行するコルーチンを明示的に指定する
• 非 ******* : 各コルーチンは処理の停止のみを明示し、処理の開始や再開といった役割はスケジューラに移譲する

Answer: 対称コルーチン

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

コルーチンは、一時停止と再開が可能な関数で、非同期処理やマルチスレッドプログラミングにおいて、処理の制御と効率の向上を実現することができる。コルーチンを用いると、[非同期処理]](#非同期処理)をより高度に抽象化して簡潔に記述することができる。

• 対称コルーチン: 各コルーチンが処理を停止する際に、次に実行するコルーチンを明示的に指定する
•  ******** : 各コルーチンは処理の停止のみを明示し、処理の開始や再開といった役割はスケジューラに移譲する

Answer: 非対称コルーチン

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

 ****** は、非対称コルーチンを用いた非同期処理において、コルーチンの実行と制御を管理するためのコンポーネント。複数のコルーチンの実行順序を制御し、待機中のコルーチンがリソースを無駄に消費しないように適切な管理を行う。

Answer: スケジューラ

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

 *********** は、非同期プログラミングにおいて、より効率的に非同期処理を記述するために多くのプログラミング言語に取り入れられている機能。

asyncキーワードは、関数に付与することでコルーチンを簡単に作ることができる。awaitキーワードは、コルーチン内で別のコルーチンの完了を待つために使用される。

Answer: async/await

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

 ***** /awaitは、非同期プログラミングにおいて、より効率的に非同期処理を記述するために多くのプログラミング言語に取り入れられている機能。

 ***** キーワードは、関数に付与することでコルーチンを簡単に作ることができる。awaitキーワードは、コルーチン内で別のコルーチンの完了を待つために使用される。

Answer: async

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

async/ ***** は、非同期プログラミングにおいて、より効率的に非同期処理を記述するために多くのプログラミング言語に取り入れられている機能。

asyncキーワードは、関数に付与することでコルーチンを簡単に作ることができる。 ***** キーワードは、コルーチン内で別のコルーチンの完了を待つために使用される。

Answer: await

Source: ../../note/programming/parallel_programming/_/chapters/asynchronous_processing.md

====================

 ****** は、並行プログラミングやマルチスレッド環境において、複数のプロセスが互いに必要なリソースを獲得できず、停滞状態に陥る問題。 ****** は次の4つの条件が同時に成立すると発生する。

• 相互排他条件: 少なくとも1つのリソースが排他的に利用される状態（一度に1つのプロセスしかリソースを利用できない状態）
• 保持・待ち条件: プロセスが少なくとも1つのリソースを獲得している状態で、さらに別のリソースを要求する状態（リソースの保持と新しいリソースの待ちが同時に発生する状態）
• 無駄な待ち条件: プロセスが保持しているリソースを他のプロセスから強制的に奪うことができない状態
• 循環待ち条件: 複数のプロセスが循環的に互いのリソースを待っている状態

Answer: デッドロック

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 ****** は、並行プログラミングやマルチスレッド環境において、複数のプロセスが一貫して動作を続けているものの、全体として進行が停滞している状態。デッドロックとは異なり、リソースの待機状態による停滞は発生しない。

典型的な例として、2つ以上のプロセスが共有リソースにアクセスし、それらのリソースを獲得するために互いに優先権を譲り合い、進行できなくなる状況が考えられる。この場合、プロセスがリソースへのアクセス権を持ち続けてしまうことは防げている一方で、全体としては処理が進まない。

Answer: ライブロック

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 ***** は、並行プログラミングやマルチスレッド環境において、リソースを獲得中のプロセスが、そのリソースを解放する前に再度そのリソースを獲得しようとすることによって、処理が進まなくなる問題。 ***** を行っても処理が続行可能であるようなロックを再入可能ロックという。

Answer: 再帰ロック

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

再帰ロックは、並行プログラミングやマルチスレッド環境において、リソースを獲得中のプロセスが、そのリソースを解放する前に再度そのリソースを獲得しようとすることによって、処理が進まなくなる問題。再帰ロックを行っても処理が続行可能であるようなロックを ******* という。

Answer: 再入可能ロック

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 ** (Starvation)は、並行プログラミングやマルチスレッド環境において、特定のプロセスがリソースをほぼ永久的に獲得できない状況。 ** 状態は、リソースの割当やスケジューリングの不公平な扱いに起因する。例えば、優先度の低いプロセスが優先度の高いものに比べてリソースを獲得する機会が極端に少ない場合などに発生し得る。

Answer: 飢餓

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 **** は、並行プログラミングやマルチスレッド環境において、ある条件が満たされるまで待機しているプロセスが、条件が満たされていないにも関わらず実行状態へ遷移する現象。例えば、プロセスの外側から送信されるシグナルによって **** が発生する可能性がある。このような理由もあり、マルチスレッドとシグナルは一般的に悪いとされる。

Answer: 疑似覚醒

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 ****** （メモリフェンス）は、メモリアクセスの順番を制御するための処理。

CPUの最適化手法のひとつであるアウトオブオーダ実行では、メモリの読み込みや保存の順序を入れ替えて実行する場合がある。これは並行プログラミングやマルチスレッド環境において、予測不能の動作を生じる原因となる。 ****** は、このようなアウトオブオーダ実行の弊害からプログラムを保護するために使用される。

Answer: メモリバリア

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

メモリバリア（ ******* ）は、メモリアクセスの順番を制御するための処理。

CPUの最適化手法のひとつであるアウトオブオーダ実行では、メモリの読み込みや保存の順序を入れ替えて実行する場合がある。これは並行プログラミングやマルチスレッド環境において、予測不能の動作を生じる原因となる。メモリバリアは、このようなアウトオブオーダ実行の弊害からプログラムを保護するために使用される。

Answer: メモリフェンス

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

メモリバリア（メモリフェンス）は、メモリアクセスの順番を制御するための処理。

CPUの最適化手法のひとつである ********** では、メモリの読み込みや保存の順序を入れ替えて実行する場合がある。これは並行プログラミングやマルチスレッド環境において、予測不能の動作を生じる原因となる。メモリバリアは、このような ********** の弊害からプログラムを保護するために使用される。

Answer: アウトオブオーダ実行

Source: ../../note/programming/parallel_programming/_/chapters/bugs_and_challenges.md

====================

 **** は、何らかの計算を行う抽象的な計算実行体（OS **** とは別）であり、計算を完了させるためにいくつかのステップを経た後に、最終的に計算を停止する。 **** は実行前状態から開始し、実行状態と待機状態を経て終了状態へと遷移する。 **** が待機状態になる理由としては以下のようなものが挙げられる。

• 演算対象となるデータが存在しない、もしくは到着していない
• 計算リソース（CPUやメモリなど）の空きがない
• 自発的に待機状態となる（タイマを使った処理など）

Answer: プロセス

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 ***** は、プロセスの状態の1つで、計算を実行する前の状態。実行状態へ遷移することができる。

Answer: 実行前状態

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 **** は、プロセスの状態の1つで、計算を実行中の状態。待機状態か終了状態へ遷移することができる。

Answer: 実行状態

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 **** は、プロセスの状態の1つで、計算を一時停止中の状態。実行状態へ遷移することができる。

Answer: 待機状態

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 **** は、プロセスの状態の1つで、計算が終了した状態。他のどの状態へも遷移しない。

Answer: 終了状態

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 *** は、2つ以上のプロセスが同時に計算を進めている状態を表す言葉。2つ以上の実行状態か待機状態のプロセスを同時に処理できる計算モデルや計算基盤は *** を持っているといえる。現在普及しているOSの多くはマルチタスクOSであり、複数のプロセスを並行処理可能である。

Answer: 並行性

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 *** は、2つ以上のプロセスが同時に計算を実行している状態を表す言葉。2つ以上の実行状態のプロセスを同時に処理できる計算モデルや計算基盤は *** を持っているといえる。ハードウェアから見た *** には、タスク *** 、データ *** 、インストラクションレベル *** がある。

Answer: 並列性

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 ****** は、複数のタスク（プロセス）を同時に実行する方法。OSは計算処理をOSプロセスやスレッドと呼ばれるプロセスで抽象化しているが、マルチタスクOSではこれらを複数のCPUを用いて同時に動作させることで ****** を実現している。

Answer: タスク並列性

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 ****** は、データを複数に分割して、分割したデータに対して並列に処理を行う方法。これはベクトル演算などにおいてよく用いられており、GPU内部ではベクトル演算を基礎とした演算が行われている。

Answer: データ並列性

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 *************** は、CPUの命令語レベルで並列化を行う方法。主にハードウェアやコンパイラが暗黙的に行う並列化であり、プログラミングの際に意識することはほとんどない。パイプライン処理も *************** の1つ。

Answer: インストラクションレベル並列性

Source: ../../note/programming/parallel_programming/_/chapters/concurrency_and_parallelism.md

====================

 ********** （競合状態）は、複数のプロセスが並行して共有リソースにアクセスした結果引き起こされる、予期しない異常な状態。並行プログラミングにおいては、いかに ********** を引き起こさずに正しくプログラミングするかが課題の1つとなる。

Answer: レースコンディション

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

レースコンディション（ **** ）は、複数のプロセスが並行して共有リソースにアクセスした結果引き起こされる、予期しない異常な状態。並行プログラミングにおいては、いかにレースコンディションを引き起こさずに正しくプログラミングするかが課題の1つとなる。

Answer: 競合状態

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 *********** は、レースコンディションを引き起こすプログラムのコードブロック。 *********** を正しく実装するためには、排他制御などの同期処理を適切に使用する必要がある。

Answer: クリティカルセクション

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 **** は、複数のプロセスが協調して動作する際に、クリティカルセクションの実行順序やタイミングを制御するための手段。レースコンディションやデータの不整合を回避し、安定した並行処理を実現するために用いられる。ただし、過度な **** の適用は性能低下を引き起こす場合もあるため、注意が必要となる。 **** 機構には、ミューテックスやセマフォ、条件変数などがある。

Answer: 同期処理

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ****** は、共有リソースのロックが獲得できるまで、空きができているかをポーリングして確認する方法で、ミューテックスの実装などに用いられる。 ****** 用のAPIは典型的に、ロック獲得用とロック解放用の2つが提供されており、それぞれ以下のような処理を行う。

• ロック獲得用: 共有変数へのポインタを受け取り、TASを用いてロックを獲得できるまでループする
• ロック解放用: 共有変数へのポインタを受け取り、tas_releaseを呼び出す

単純な ****** の実装は以下のようになる。

void spinlock_acquire( bool *look )
{
    while( test_and_set(lock) );
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

アトミック処理は実行速度上のペナルティが大きいので、TASをループで呼び出すのではなく、事前にロックの状態をループでチェックしておいてから最後にTASを呼び出すTest and Test and Set(TTAS)を利用した実装が多い。この場合の実装は以下のようになる。

void spinlock_acquire( volatile bool *lock )
{
    for(;;)
    {
        while( *lock );
        if( test_and_set(lock) == false )
        {
            break;
        }
    }
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

Answer: スピンロック

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

スピンロックは、共有リソースのロックが獲得できるまで、空きができているかをポーリングして確認する方法で、ミューテックスの実装などに用いられる。スピンロック用のAPIは典型的に、ロック獲得用とロック解放用の2つが提供されており、それぞれ以下のような処理を行う。

• ロック獲得用: 共有変数へのポインタを受け取り、TASを用いてロックを獲得できるまでループする
• ロック解放用: 共有変数へのポインタを受け取り、tas_releaseを呼び出す

単純なスピンロックの実装は以下のようになる。

void spinlock_acquire( bool *look )
{
    while( test_and_set(lock) );
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

アトミック処理は実行速度上のペナルティが大きいので、TASをループで呼び出すのではなく、事前にロックの状態をループでチェックしておいてから最後にTASを呼び出す ********************* (TTAS)を利用した実装が多い。この場合の実装は以下のようになる。

void spinlock_acquire( volatile bool *lock )
{
    for(;;)
    {
        while( *lock );
        if( test_and_set(lock) == false )
        {
            break;
        }
    }
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

Answer: Test and Test and Set

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

スピンロックは、共有リソースのロックが獲得できるまで、空きができているかをポーリングして確認する方法で、ミューテックスの実装などに用いられる。スピンロック用のAPIは典型的に、ロック獲得用とロック解放用の2つが提供されており、それぞれ以下のような処理を行う。

• ロック獲得用: 共有変数へのポインタを受け取り、TASを用いてロックを獲得できるまでループする
• ロック解放用: 共有変数へのポインタを受け取り、tas_releaseを呼び出す

単純なスピンロックの実装は以下のようになる。

void spinlock_acquire( bool *look )
{
    while( test_and_set(lock) );
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

アトミック処理は実行速度上のペナルティが大きいので、TASをループで呼び出すのではなく、事前にロックの状態をループでチェックしておいてから最後にTASを呼び出すTest and Test and Set( **** )を利用した実装が多い。この場合の実装は以下のようになる。

void spinlock_acquire( volatile bool *lock )
{
    for(;;)
    {
        while( *lock );
        if( test_and_set(lock) == false )
        {
            break;
        }
    }
}

void spinlock_release( bool *lock )
{
    tas_release(lock);
}

Answer: TTAS

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ******* (mutex: Mutual exclusion)は、クリティカルセクションを実行可能なプロセスの数を1つに制限する同期処理。共有リソースへのアクセスを制御するためのフラグを使用し、ロックの獲得・解放を行う。 ******* は、同時アクセスプロセス数を1にしたセマフォと同じである（バイナリセマフォ）。

単純な ******* の実装は以下のようになる。

bool lock = false;

void some_func()
{
    retry:
        if( test_and_set(&lock) == false )
        {
            // ロックの獲得
            lock = true;

            // クリティカルセクション
        }
        else
        {
            goto retry;
        }

    // ロックの解放
    tas_releae(&lock);
}

Answer: ミューテックス

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

ミューテックス( ***** : Mutual exclusion)は、クリティカルセクションを実行可能なプロセスの数を1つに制限する同期処理。共有リソースへのアクセスを制御するためのフラグを使用し、ロックの獲得・解放を行う。ミューテックスは、同時アクセスプロセス数を1にしたセマフォと同じである（バイナリセマフォ）。

単純なミューテックスの実装は以下のようになる。

bool lock = false;

void some_func()
{
    retry:
        if( test_and_set(&lock) == false )
        {
            // ロックの獲得
            lock = true;

            // クリティカルセクション
        }
        else
        {
            goto retry;
        }

    // ロックの解放
    tas_releae(&lock);
}

Answer: mutex

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

ミューテックス(mutex: Mutual exclusion)は、クリティカルセクションを実行可能なプロセスの数を1つに制限する同期処理。共有リソースへのアクセスを制御するためのフラグを使用し、ロックの獲得・解放を行う。ミューテックスは、同時アクセスプロセス数を1にしたセマフォと同じである（ ******** ）。

単純なミューテックスの実装は以下のようになる。

bool lock = false;

void some_func()
{
    retry:
        if( test_and_set(&lock) == false )
        {
            // ロックの獲得
            lock = true;

            // クリティカルセクション
        }
        else
        {
            goto retry;
        }

    // ロックの解放
    tas_releae(&lock);
}

Answer: バイナリセマフォ

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 **** (semaphore)は、ミューテックスをより一般化したものであり、同時に複数のプロセスが共有リソースにアクセスできるようにする同期処理。複数のプロセスが共有リソースにアクセスできるため、ミューテックスでは防げたレースコンディションが防げなくなる可能性がある。

単純な **** の実装は以下のようになる。

void semaphore_acquire( volatile int *cnt )
{
    for(;;)
    {
        while( *cnt >= NUM );
        __sync_fetch_and_add(cnt, 1);
        if( *cnt <= NUM )
        {
            break;
        }
        __sync_fetch_and_sub(cnt, 1);
    }
}

void semaphore_release( int *cnt )
{
    __sync_fetch_and_sub(cnt, 1);
}

Answer: セマフォ

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

セマフォ( ********* )は、ミューテックスをより一般化したものであり、同時に複数のプロセスが共有リソースにアクセスできるようにする同期処理。複数のプロセスが共有リソースにアクセスできるため、ミューテックスでは防げたレースコンディションが防げなくなる可能性がある。

単純なセマフォの実装は以下のようになる。

void  ********* _acquire( volatile int *cnt )
{
    for(;;)
    {
        while( *cnt >= NUM );
        __sync_fetch_and_add(cnt, 1);
        if( *cnt <= NUM )
        {
            break;
        }
        __sync_fetch_and_sub(cnt, 1);
    }
}

void  ********* _release( int *cnt )
{
    __sync_fetch_and_sub(cnt, 1);
}

Answer: semaphore

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 **** は、プロセス間で共有しているリソースが特定の条件を満たすまで待機する同期処理。ミューテックスで保護されるデータ構造が特定条件を満たすまで効率的に待機するためのメカニズムを提供し、実行時のオーバヘッドも削減することができる。

Answer: 条件変数

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ***** は、並行処理において、複数のプロセスを特定のポイントで同期するための同期処理。複数のプロセスで段階別に処理を行う際に有効で、全てのプロセスが1ステップ目の計算を終了するのを待ち、それが終わったら次のステップに進む、といった使い方がされる。

Answer: バリア同期

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ***************** は、レースコンディションの原因となる書き込みに対してのみ排他制御を行うような同期処理。読み込みのみを行うプロセス(Reader)と、読み込みと書き込みを行うプロセスに分類し、以下の制約を満たすように制御を行う。

• ロックを獲得中のReaderが同時に複数存在可能
• ロックを獲得中のWriterが同時に最大1つのみ存在可能
• ReaderとWriterが同時にロック状態にならない

Answer: Readers-Writerロック

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ******* （不可分操作）は、それ以上は分割不可能な処理で、その処理の途中状態をシステム的に観測することができず、もしその処理が失敗した場合は完全に処理前の状態に復元される。現代的な同期処理のほとんどはこの ******* を利用している。

Answer: アトミック処理

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

アトミック処理（ ***** ）は、それ以上は分割不可能な処理で、その処理の途中状態をシステム的に観測することができず、もしその処理が失敗した場合は完全に処理前の状態に復元される。現代的な同期処理のほとんどはこのアトミック処理を利用している。

Answer: 不可分操作

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 **************** (CAS)は、アトミック処理のひとつで、共有変数の値を比較して条件が成立する場合に新しい値を設定するという操作。この操作は次のようなステップで構成される。

1. 共有変数の現在の値を読み込む
2. 読み込んだ値と目的の値を比較する
3. もし読み込んだ値と目的の値が一致する場合、新しい値を共有変数に設定する

CASの意味を示したソースコードは以下の通りとなる（ただしこのソースコードは一般的にアトミックではない）。

bool compare_and_swap( uint64_t* p, uint64_t val, uint64_t newval )
{
    if( *p != val )
    {
        return false;
    }
    *p = newval;
    return true;
}

Answer: Compare and Swap

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

Compare and Swap( *** )は、アトミック処理のひとつで、共有変数の値を比較して条件が成立する場合に新しい値を設定するという操作。この操作は次のようなステップで構成される。

1. 共有変数の現在の値を読み込む
2. 読み込んだ値と目的の値を比較する
3. もし読み込んだ値と目的の値が一致する場合、新しい値を共有変数に設定する

 *** の意味を示したソースコードは以下の通りとなる（ただしこのソースコードは一般的にアトミックではない）。

bool compare_and_swap( uint64_t* p, uint64_t val, uint64_t newval )
{
    if( *p != val )
    {
        return false;
    }
    *p = newval;
    return true;
}

Answer: CAS

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ************ (TAS)は、アトミック処理のひとつで、共有変数の値を読み込んで、その値を設定するという操作。この操作は次のようなステップで構成される。

1. 共有変数の現在の値を読み込む
2. 読み込んだ値を保存する
3. 新しい値を共有変数に設定する

TASの意味を示したソースコードは以下の通りとなる（ただしこのソースコードは一般的にアトミックではない）。

bool test_and_set( bool *p )
{
    if( *p )
    {
        return true;
    }
    else
    {
        *p = true;
        return false;
    }
}

void tas_release( bool *p )
{
    *p = false;
}

Answer: Test and Set

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

Test and Set( *** )は、アトミック処理のひとつで、共有変数の値を読み込んで、その値を設定するという操作。この操作は次のようなステップで構成される。

1. 共有変数の現在の値を読み込む
2. 読み込んだ値を保存する
3. 新しい値を共有変数に設定する

 *** の意味を示したソースコードは以下の通りとなる（ただしこのソースコードは一般的にアトミックではない）。

bool test_and_set( bool *p )
{
    if( *p )
    {
        return true;
    }
    else
    {
        *p = true;
        return false;
    }
}

void tas_release( bool *p )
{
    *p = false;
}

Answer: TAS

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 *************************** (LL/SC)は、アトミック処理のひとつで、共有メモリへのアクセス制御やロックフリーな構造の実装に利用される。この操作は次のようなステップで構成される。

1. Load-Link: 共有メモリの値を読み込み、リンクを設定する
2. 読み込んだ値に対して任意の操作を行う（この間、他のプロセスも値にアクセスすることができる）
3. Store-Conditional: 共有メモリの値を更新する前に、リンクが変化していないかを確認し、変化していなければ更新を行う

Store-Conditionalにおいて、書き込みが失敗した場合にのみ、再度Load-Linkしてから書き込みを試みれば、見かけ上アトミックな処理を実現できる。

Answer: Load-Link/Store-Conditional

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

Load-Link/Store-Conditional( ***** )は、アトミック処理のひとつで、共有メモリへのアクセス制御やロックフリーな構造の実装に利用される。この操作は次のようなステップで構成される。

1. Load-Link: 共有メモリの値を読み込み、リンクを設定する
2. 読み込んだ値に対して任意の操作を行う（この間、他のプロセスも値にアクセスすることができる）
3. Store-Conditional: 共有メモリの値を更新する前に、リンクが変化していないかを確認し、変化していなければ更新を行う

Store-Conditionalにおいて、書き込みが失敗した場合にのみ、再度Load-Linkしてから書き込みを試みれば、見かけ上アトミックな処理を実現できる。

Answer: LL/SC

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 ********* /Store-Conditional(LL/SC)は、アトミック処理のひとつで、共有メモリへのアクセス制御やロックフリーな構造の実装に利用される。この操作は次のようなステップで構成される。

1.  ********* : 共有メモリの値を読み込み、リンクを設定する
2. 読み込んだ値に対して任意の操作を行う（この間、他のプロセスも値にアクセスすることができる）
3. Store-Conditional: 共有メモリの値を更新する前に、リンクが変化していないかを確認し、変化していなければ更新を行う

Store-Conditionalにおいて、書き込みが失敗した場合にのみ、再度 ********* してから書き込みを試みれば、見かけ上アトミックな処理を実現できる。

Answer: Load-Link

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

Load-Link/ ***************** (LL/SC)は、アトミック処理のひとつで、共有メモリへのアクセス制御やロックフリーな構造の実装に利用される。この操作は次のようなステップで構成される。

1. Load-Link: 共有メモリの値を読み込み、リンクを設定する
2. 読み込んだ値に対して任意の操作を行う（この間、他のプロセスも値にアクセスすることができる）
3.  ***************** : 共有メモリの値を更新する前に、リンクが変化していないかを確認し、変化していなければ更新を行う

 ***************** において、書き込みが失敗した場合にのみ、再度Load-Linkしてから書き込みを試みれば、見かけ上アトミックな処理を実現できる。

Answer: Store-Conditional

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 **** は、複数のプロセスが協調して動作する際に、共有リソースや共有データへのあ同時アクセスを制限し、レースコンディションやデータの不整合を防ぐための手法。 **** は、正確なタイミングで適切な同期処理を使用することによって実現できる。

Answer: 排他制御

Source: ../../note/programming/parallel_programming/_/chapters/synchronous_processing.md

====================

 *** は、プログラム中に型を明示せずとも、いくつかの型情報から自動で変数の型を推論するRustコンパイラの機能。これにより、コンパイル時のエラー検出というメリットを残したまま、動的型付け言語の可読性の高さという恩恵を受けることができる。

Answer: 型推論

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ****** は、反復的なコードを記述する必要性を減らすための機能で、引数や戻り値として複数の種類の型を取りうるような関数を1つの定義で表現することができるようになる。

JavaScriptやPythonといった動的型付け言語では、すべての関数が自然とこのよう動作となる。関数は、その関数が必要とするプロパティやメソッドを持つすべてのオブジェクトを引数として取ることができる（引数として取りうるオブジェクトを明示的に制限しない）。このような性質をダックタイピングといい、これによりプログラムが効率的になる一方で、エラーやバグの原因ともなりうる。

Rustでは ****** 機構を利用することで、厳密なコンパイル時の型チェックと柔軟性を両立している。

Answer: ジェネリック

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

Rustの整数型に関する特徴は以下の通り。

• Rustの符号付き整数は2の補数表現となっている。
• Rustでは、バイト値に対して u8 型を用いる。バイナリファイルやソケットからデータを読み取ると、 u8 の値のストリームが得られる。
• CやC++では数値と文字の型を区別しない（ u8 と char は同じ）が、Rustではこれらを区別する。ただし、バイトリテラルの機能が用意されており、例えば b'X' は、文字"X"に対するASCIIコードの u8 値になる。
• usize と isize は、実行対象の計算機のアドレス空間サイズに依存しており、32ビットアーキテクチャでは32ビット、64ビットアーキテクチャでは64ビットとなる。
• 0x 、 0o 、 0b を接頭辞としてつけると、それぞれ16進数、8進数、2進数のリテラルになる。
• 整数型から別の整数型への変換は as 演算子を用いて行う。RustはCやC++とは異なり、数値型の ****** をほとんど行わないので、プログラマ自身が明示する必要がある。

Answer: 暗黙の型変換

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ******** は、演算結果を Option 型で返却する。数学的に正しい答えが得られた場合には Some(v) を、そうでない場合は None を返す。これによって、計算結果がオーバフローした場合などの挙動を制御することができる。

演算子名に接頭辞 check_ をつけることで利用できる。

Answer: チェック付き演算

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ***** は、オーバフローが発生した場合に、溢れた桁を無視した結果を返却する。

演算子名に接頭辞 wrapping_ をつけることで利用できる。

Answer: ラップ演算

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 **** は、オーバフローが発生した場合に、計算結果としてその型の最大値（もしくは最小値）を返却する。

演算子名に接頭辞 saturating_ をつけることで利用できる。

Answer: 飽和演算

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ******** は、ラップ演算の結果（ result ）と、オーバフローが発生したか否かの真偽値（ overflowed ）を、 (result, overflowed) という形式のタプルで返却する。

演算子名に接頭辞 overflowing_ をつけることで利用できる。

Answer: オーバフロー演算

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 **** は、様々な型の組み合わせを表現するための型。要素へのアクセスには定数のインデックスを用いる。

let profile: (&str, usize, usize, usize) = ("ichigo", 2001, 8, 21);
println!("Birth year: {}", profile.1);

タプルは配列とよく似ているが、配列は同じ型の要素を複数格納するコンテナであるのに対し、タプルは異なる型の要素をまとめることができる。また、配列は変数インデックスによる要素へのアクセス( array[i] )ができるのに対して、タプルは定数インデックスしか用いることができない。

タプルは関数の返り値などに頻繁に用いられる。関数は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。

また、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 (height, width) や (latitude, longitude) などである。

0要素のタプルもタプルの典型的な活用例で、 () のように記述され、ユニット型と呼ばれる。

Answer: タプル型

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

タプル型は、様々な型の組み合わせを表現するための型。要素へのアクセスには定数のインデックスを用いる。

let profile: (&str, usize, usize, usize) = ("ichigo", 2001, 8, 21);
println!("Birth year: {}", profile.1);

タプルは配列とよく似ているが、配列は同じ型の要素を複数格納するコンテナであるのに対し、タプルは異なる型の要素をまとめることができる。また、配列は変数インデックスによる要素へのアクセス( array[i] )ができるのに対して、タプルは定数インデックスしか用いることができない。

タプルは関数の返り値などに頻繁に用いられる。関数は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。

また、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 (height, width) や (latitude, longitude) などである。

0要素のタプルもタプルの典型的な活用例で、 () のように記述され、 ***** と呼ばれる。

Answer: ユニット型

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ** は、Rustの最も基本的なポインタ型。

String 型の値への ** は &String であり、これは String のアドレスを保持した1ワード長のデータとなる。

RustのポインタはCとは異なり、決して null になることはない。また、値の所有権とライフタイムの管理により、ダングリングポインタや多重開放（多重フリー）、ポインタの無効化（nullポインタ）といったバグをコンパイル時に取り除くことができる。

 ** には、共有 ** と可変 ** がある。

Answer: 参照

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ******* は、C++が扱うポインタとよく似ており、Rustが管理するポインタとは異なってメモリ安全ではない(unsafe Rust)。

Answer: rawポインタ

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 **** は、配列やベクタのうちの特定の領域を指す参照。 **** はファットポインタであり、 **** が指す最初の要素へのポインタと **** に含まれる要素数という2ワード長で表される。

let even: [i32; 5] = [2, 4, 6, 8, 10];
let evel_slice: &[i32] = &even;

通常の参照はメモリ上の独立の値に対する所有権のないポインタであるのに対し、 **** の参照（あるいは単に **** ）はメモリ上の独立した値の領域に対する参照であると考えることができる。

同じ型のデータ列に対する関数を実装する際には、引数として **** をとるように設計すると、配列に対してもベクタに対しても適用できるようになる。

fn print_num( n: &[i32] )
{
    for elm in n
    {
        println!("{}", elm);
    }
}

Answer: スライス

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ******* は、プログラム中でダブルクォーテーションで囲まれた文字列。 ******* には改行を含めることができ、文字列の行の最後にバックスラッシュをつけた場合は、改行文字と次の行の空白文字が無視される。

"Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aenean commodo ligula eget dolor.
Aenean massa.
Cum sociis natoque penatibus et magnis dis parturient montes, \
nascetur ridiculus mus."

文字列中の意味のある文字をエスケープするのが面倒なケース（Windowsのパスを記述するときなど）は、生文字列(raw string)を用いることができる。

r"C:\Program Files\App"

さらに、ダブルクォーテーションのエスケープすらも省略したい場合には、開始と終了のダブルクォーテーションを任意の数のハッシュ文字で挟む（ハッシュ文字の数は、わかりやすいように決めればよい）。

r###"She said "Hello"."###

Answer: 文字列リテラル

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

文字列リテラルは、プログラム中でダブルクォーテーションで囲まれた文字列。文字列リテラルには改行を含めることができ、文字列の行の最後にバックスラッシュをつけた場合は、改行文字と次の行の空白文字が無視される。

"Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aenean commodo ligula eget dolor.
Aenean massa.
Cum sociis natoque penatibus et magnis dis parturient montes, \
nascetur ridiculus mus."

文字列中の意味のある文字をエスケープするのが面倒なケース（Windowsのパスを記述するときなど）は、 **** (raw string)を用いることができる。

r"C:\Program Files\App"

さらに、ダブルクォーテーションのエスケープすらも省略したい場合には、開始と終了のダブルクォーテーションを任意の数のハッシュ文字で挟む（ハッシュ文字の数は、わかりやすいように決めればよい）。

r###"She said "Hello"."###

Answer: 生文字列

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 ****** は、ある型に対して別名をつける機能。 type キーワードを用いると、既存の型に対して別名をつけることができる。

type Bytes = Vec<u8>;

Answer: 型エイリアス

Source: ../../note/programming/rust/_/chapters/data_type.md

====================

 *** は、Rustが持つメモリ管理のための機能で、確保したメモリを使用が終わった時点で自動的に破棄する機能。C++においても、オブジェクトに所有されているメモリに対してポインタを作った場合に、オブジェクトがメモリ領域を破棄する前に、ポインタを破棄する義務がある、という考え方のことを *** という。このような考え方をもとに実装されたC++の機能をスマートポインタという。Rustでは *** の考え方が言語そのものに組み込まれており、すべてのデータに対してコンパイラが *** をチェックすることによってメモリのクリーンアップを強制する。Rustにおけるすべての値は、そのライフタイムを決定する唯一の所有者を持ち、所有者が解放（ドロップ）されたときに所有されていた値もドロップされる。

ベクタや文字列などの可変長の変数を扱う際には、その変数のファットポインタがスタックフレーム上に保持され、そのポインタの先のバッファだけがヒープ上に取られる。このような状態を、バッファがスタックフレーム上のポインタに所有されているという。

複雑な所有関係にある要素（ベクタの中に文字列が格納されている場合など）では、所有者と所有される値はツリー構造をなす。変数がスコープから外れると、それより下のツリー全体が順次ドロップされる。

Rustの *** には他にも以下のような特徴がある。

• 値を1つの所有者から別の所有者へmove（移動）することができる
• 整数、浮動小数点数、文字などのプリミティブ型（ヒープ上に領域を確保する必要のない固定長変数）については、 *** のルールが適用されない
• 標準ライブラリの Rc や Arc を利用することで、参照カウントが利用できる
• 値への参照の借用（参照を関数の引数として渡す操作）ができる

Answer: 所有権

Source: ../../note/programming/rust/_/chapters/ownership_and_move.md

====================

 ** (move)は、Rustが持つメモリ管理のための機能で、ある所有者によって所有されている値を、別の所有者に渡す操作。Rustではほとんどの型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却の際に、データはディープコピーされずに ** が発生する。ディープコピーが必要な場合は明示的に変数に対して clone() メソッドを呼ぶ。

Rustのコンパイラはこれらの ** を推測することができ、機械語レベルで見たときに最終的に値が ** される場所にはじめからオブジェクトが作られることも多い。

ベクタのようにインデックスにより参照される値については、インデックスを指定してその要素だけを ** するということができない。このような操作を実現したい場合は、次のような3つの方法がある。

let mut v = Vec::new();
for i in 1..100
{
    v.push(i.to_string());
}

// 1. ベクタの最後の要素をポップして取り出す
let x = v.pop().expect("vector empty");

// 2. ベクタの指定したインデックスの場所から要素を取り出し、代わりに最後の要素をそこに入れる
let index = 8;
let y = v.swap_remove(index);

// 3. 取り出した値の代わりに別の値を入れる
let index = 10;
let z = std::mem::replace(&mut v[index], "substitute".to_string());

特に Option<T> を要素として持つベクタから値を取り出したい場合には、値を ** して代わりに None を入れるという使い方が多い。これを実現するための take() メソッドも用意されている。

コレクション型は一般に、すべての要素をループで消費するためのメソッドを用意している。次のようにしてループにベクタを直接渡すと、ベクタは v から ** されて v は未初期化状態となり、繰り返しごとにループは次の要素を変数 s に ** する。

let v = vec!["hello".to_string(), "world".to_string(), "rust".to_string()];

for mut s in v
{
    s.push('!');
    println!("{}", s);
}

Answer: 移動

Source: ../../note/programming/rust/_/chapters/ownership_and_move.md

====================

移動( **** )は、Rustが持つメモリ管理のための機能で、ある所有者によって所有されている値を、別の所有者に渡す操作。Rustではほとんどの型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却の際に、データはディープコピーされずに移動が発生する。ディープコピーが必要な場合は明示的に変数に対して clone() メソッドを呼ぶ。

Rustのコンパイラはこれらの移動を推測することができ、機械語レベルで見たときに最終的に値が移動される場所にはじめからオブジェクトが作られることも多い。

ベクタのようにインデックスにより参照される値については、インデックスを指定してその要素だけを移動するということができない。このような操作を実現したい場合は、次のような3つの方法がある。

let mut v = Vec::new();
for i in 1..100
{
    v.push(i.to_string());
}

// 1. ベクタの最後の要素をポップして取り出す
let x = v.pop().expect("vector empty");

// 2. ベクタの指定したインデックスの場所から要素を取り出し、代わりに最後の要素をそこに入れる
let index = 8;
let y = v.swap_re **** (index);

// 3. 取り出した値の代わりに別の値を入れる
let index = 10;
let z = std::mem::replace(&mut v[index], "substitute".to_string());

特に Option<T> を要素として持つベクタから値を取り出したい場合には、値を移動して代わりに None を入れるという使い方が多い。これを実現するための take() メソッドも用意されている。

コレクション型は一般に、すべての要素をループで消費するためのメソッドを用意している。次のようにしてループにベクタを直接渡すと、ベクタは v から移動されて v は未初期化状態となり、繰り返しごとにループは次の要素を変数 s に移動する。

let v = vec!["hello".to_string(), "world".to_string(), "rust".to_string()];

for mut s in v
{
    s.push('!');
    println!("{}", s);
}

Answer: move

Source: ../../note/programming/rust/_/chapters/ownership_and_move.md

====================

 **** は、Rustにおいて、移動の代わりにディープコピーが行われるような型。ヒープ領域のリソースを伴う値は、ディープコピーするのに大きなコストが必要になるが、プリミティブ型のように移動を意識するメリットが少ない型については、移動のルールを適用しないために **** とする場合がある。

変数が **** であるかを判断する簡単な指標として、値をドロップする際になにか特別なことをしなければいけない型は **** ではない、と考えるとよい。

独自定義の型については、デフォルトで **** ではないものの、フィールドがすべて **** である場合には次のように属性を付与することで **** にすることができる。

Answer: コピー型

Source: ../../note/programming/rust/_/chapters/ownership_and_move.md

====================

参照は、Rustが所有権を持たないポインタ型。参照は参照先よりも長生きしてはいけないので、これを強調するためにRustではある参照を作ることを ** と呼ぶ。

関数に引数を渡す時に所有権を移動してしまうと、それ以降は引数に使った値が使えなくなってしまう（値渡し）。そのため、関数の引数として参照を用いるのが適切な場合も多い（参照渡し）。

Answer: 借用

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

