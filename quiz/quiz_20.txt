====================

 *** (Hank)は、ファイルの差分ブロック。

Answer: ハンク

Source: ../../note/development/git/_/chapters/record_history.md

====================

 *********** は、指定したファイルの変更内容を取り消し、元の状態を復元するコマンド。

Answer: git restore

Source: ../../note/development/git/_/chapters/record_history.md

====================

 **** は、ファイルやディレクトリの変更を履歴に記録する操作、あるいはその変更履歴。リポジトリの変更履歴はリビジョンと呼ぶ場合もある。

Gitでは、 **** ごとに差分のみ記録するのではなく、毎回すべてのファイルのスナップショット（ある時点でのソースコードやファイル、ディレクトリなどの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンのファイルを復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。

 **** には、git commitコマンドを用いる。

Answer: コミット

Source: ../../note/development/git/_/chapters/record_history.md

====================

コミットは、ファイルやディレクトリの変更を履歴に記録する操作、あるいはその変更履歴。リポジトリの変更履歴は ***** と呼ぶ場合もある。

Gitでは、コミットごとに差分のみ記録するのではなく、毎回すべてのファイルのスナップショット（ある時点でのソースコードやファイル、ディレクトリなどの状態を抜き出したもの）を作成している。差分のみを記録していると、古い ***** のファイルを復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。

コミットには、git commitコマンドを用いる。

Answer: リビジョン

Source: ../../note/development/git/_/chapters/record_history.md

====================

コミットは、ファイルやディレクトリの変更を履歴に記録する操作、あるいはその変更履歴。リポジトリの変更履歴はリビジョンと呼ぶ場合もある。

Gitでは、コミットごとに差分のみ記録するのではなく、毎回すべてのファイルの ******** （ある時点でのソースコードやファイル、ディレクトリなどの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンのファイルを復元するために履歴を全てたどる必要があるが、 ******** を保存しておくことで高速に再現することができる。

コミットには、git commitコマンドを用いる。

Answer: スナップショット

Source: ../../note/development/git/_/chapters/record_history.md

====================

コミットは、ファイルやディレクトリの変更を履歴に記録する操作、あるいはその変更履歴。リポジトリの変更履歴はリビジョンと呼ぶ場合もある。

Gitでは、コミットごとに差分のみ記録するのではなく、毎回すべてのファイルのスナップショット（ある時点でのソースコードやファイル、ディレクトリなどの状態を抜き出したもの）を作成している。差分のみを記録していると、古いリビジョンのファイルを復元するために履歴を全てたどる必要があるが、スナップショットを保存しておくことで高速に再現することができる。

コミットには、 ********** コマンドを用いる。

Answer: git commit

Source: ../../note/development/git/_/chapters/record_history.md

====================

 ******** は、コミットごとに生成される、40桁の文字列。 ******** を指定することで、コミットの履歴から特定のコミットを絞り込むことができる。

Answer: コミットハッシュ

Source: ../../note/development/git/_/chapters/record_history.md

====================

 ********* は、コミット時に履歴に対してつけるコメントで、作業内容などを記録しておくことができる。 ********* の書き方には、開発チームごとに文化やルールなどが存在するが、次のようなフォーマットで記述するのが一般的。

• 1行目にコミットの概要を50文字以内（マルチバイト文字なら25文字）で記述
• 2行目は空行
• 3行目以降にコミットの詳細説明を記述
•  ********* を英語で記述する場合、現在系の文章を使用
• コミットの概要には、適切なプレフィックスや絵文字をつける

Answer: コミットメッセージ

Source: ../../note/development/git/_/chapters/record_history.md

====================

 ********** は、紐づくリモートリポジトリの確認や、新たな接続の追加、既存の接続の削除などを行うコマンド。ローカルリポジトリには、複数のリモートリポジトリを紐づけることができ、それぞれのリポジトリと相互に同期ができる。

リモートリポジトリのエントリリストは、 .git/config に記載されている。

Answer: git remote

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 ***** （ショートカット）は、紐づくリモートリポジトリのURLに対してつけることができる任意の名前。

Answer: エイリアス

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

エイリアス（ ******* ）は、紐づくリモートリポジトリのURLに対してつけることができる任意の名前。

Answer: ショートカット

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 ****** は、クローン元のリモートリポジトリを指すエイリアスで、クローンを行った際にローカルリポジトリに自動的にエントリが追加される。

Answer: origin

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 ************** コマンドを用いることで、ローカルリポジトリに新たなリモートリポジトリのエントリを追加できる。エントリの追加の際には、任意のエイリアスとリモートリポジトリのURLを指定する必要がある。

Answer: git remote add

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 ************* コマンドを用いることで、ローカルリポジトリに紐づくリモートリポジトリのエントリを削除できる。削除対象のエイリアスを指定して接続を削除する。

Answer: git remote rm

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 ***************** コマンドを用いることで、リモートリポジトリのエントリのエイリアスを変更できる。また、リモートリポジトリのURLを変更するには、 git remote set-url コマンドを用いる。

Answer: git remote rename

Source: ../../note/development/git/_/chapters/remote_repository.md

====================

 **** (Push)は、自身のローカルリポジトリのコミット履歴を、リモートリポジトリにアップロードする操作。

 **** は、git pushコマンドを用いて、リモートリポジトリとブランチを指定して行う。

Answer: プッシュ

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

プッシュ(Push)は、自身のローカルリポジトリのコミット履歴を、リモートリポジトリにアップロードする操作。

プッシュは、 ******** コマンドを用いて、リモートリポジトリとブランチを指定して行う。

Answer: git push

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

 **** (Fetch)は、リモートリポジトリのコミット履歴を、ローカルリポジトリのトピックブランチにダウンロードする操作。

 **** は、git fetchコマンドを用いて、リモートリポジトリとブランチを指定して行う。 **** を行うと、変更は即座に同名のブランチに反映されるわけではなく、 <remote>/<branch> という名前のトピックブランチに取り込まれる。任意のブランチに変更を取り込みたい場合、マージを行う必要がある。

Answer: フェッチ

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

フェッチ(Fetch)は、リモートリポジトリのコミット履歴を、ローカルリポジトリのトピックブランチにダウンロードする操作。

フェッチは、 ********* コマンドを用いて、リモートリポジトリとブランチを指定して行う。フェッチを行うと、変更は即座に同名のブランチに反映されるわけではなく、 <remote>/<branch> という名前のトピックブランチに取り込まれる。任意のブランチに変更を取り込みたい場合、マージを行う必要がある。

Answer: git fetch

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

 ** (Pull)は、リモートリポジトリのコミット履歴を、ローカルリポジトリの同名ブランチに即座にダウンロードする操作。

 ** は、git pullコマンドを用いて、リモートリポジトリとブランチを指定して行う。 ** はフェッチとマージを組み合わせた操作で、リモートリポジトリの変更を <remote>/<branch> という名前のトピックブランチに一時的に取り込み、ローカルリポジトリの同名のブランチにマージする。

Answer: プル

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

プル(Pull)は、リモートリポジトリのコミット履歴を、ローカルリポジトリの同名ブランチに即座にダウンロードする操作。

プルは、 ******** コマンドを用いて、リモートリポジトリとブランチを指定して行う。プルはフェッチとマージを組み合わせた操作で、リモートリポジトリの変更を <remote>/<branch> という名前のトピックブランチに一時的に取り込み、ローカルリポジトリの同名のブランチにマージする。

Answer: git pull

Source: ../../note/development/git/_/chapters/repository_sync.md

====================

 ******* は、API向けのデータ取得・操作のための言語仕様および実行環境。Facebookによって開発され、2015年にオープンソースとして公開された。サーバ側はデータの構成や受け付けるリクエストをスキーマ定義言語で定義し、クライアントがクエリ言語によって必要なデータのみを明示的に要求する、という構成になっており、Schema次第で柔軟にデータをフェッチすることが可能となる。

モバイルアプリケーションやSPAとの相性がよく、活躍の場を広げている。

Answer: GraphQL

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ******** (SDL: Schema Definition Language)は、GraphQLにおいて、Schemaを記述してAPI仕様を定めるための言語。クエリ言語のリクエストは、Schemaに従って処理され、レスポンスが生成される。

GraphQLの ******** は型システムを内包しており、Queryに対するレスポンスのバリデーションや、リゾルバの適用のために使用される。

Answer: スキーマ定義言語

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

スキーマ定義言語( *** : Schema Definition Language)は、GraphQLにおいて、Schemaを記述してAPI仕様を定めるための言語。クエリ言語のリクエストは、Schemaに従って処理され、レスポンスが生成される。

GraphQLのスキーマ定義言語は型システムを内包しており、Queryに対するレスポンスのバリデーションや、リゾルバの適用のために使用される。

Answer: SDL

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ****** は、GraphQLにおいて、データの構造とクエリのエンドポイントを定義するもの。クエリの構造や利用可能なデータ型、データの取得・変更方法を定義し、GraphQLの通信のルールを確立する。

Answer: Schema

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 **** は、GraphQLにおいて、Schemaで定義されるデータ型。データ型を表す **** には、スカラー型とオブジェクト型がある。

以下は、独自のオブジェクト型の **** を定義するSchemaの例。型名に ! を付けた場合は必須となる。また、 [ **** ] のように記述することで、配列として扱うことができる。

type Person
{
    name: String!
    age: Int
    favoirtes: [String]
}

Answer: Type

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 **** は、GraphQLにおいて、データソースに対する操作を表現する型。あらかじめ決められた Query 、 Mutation 、 Subscription というType名が **** として扱われる。

 **** のType名は、以下のようにして任意に変更することができる。

schema
{
    query: Root
}

type Root
{
    person( id: ID ): Person
}

type Person
{
    id: ID!
    name: String!
}

Answer: ルート型

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ***** は、GraphQLのTypeのひとつで、文字列や数値、ブール値などのプリミティブなデータを表す型。以下の型が定義されている。

| 型名      | 概要                                                             | | --------- | ---------------------------------------------------------------- | | ID      | オブジェクトの一意な識別子で、実際には String が格納されている | | String  | 文字列型                                                         | | Int     | 整数型                                                           | | Float   | 浮動小数点数型                                                   | | Boolean | 真偽値型                                                         |

また、独自の ***** を定義するには、以下のように記述する。こうして定義された型に対しては、GraphQLを利用する環境で必要に応じてシリアライズ・デシリアライズの処理を記述する。

scalar Date

Answer: スカラー型

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ******* は、GraphQLのTypeのひとつで、1つ以上のFieldを持つ複合的なデータを表す型。Typeによって独自の ******* を定義することができる。

type Person
{
    name: String!
    age: Int
    favoirtes: [String]
}

Answer: オブジェクト型

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ***** は、GraphQLのオブジェクト型において、名前と型によって表現されるもので、プロパティやリレーションを表す。 ***** には引数を設定することができ、引数に応じてQueryやMutationの動作を制御することができる。

type Query
{
    person( id: ID ): Person
}

type Person
{
    id: ID!
    name: String!
}

Answer: Field

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ********* は、GraphQLにおいて、具体的なリソースを持たない抽象的なデータ型。Typeは ********* を実装することで、共通の構造を表現することができる。

interface Person
{
    id: ID!
    name: String!
}

type Employee implements Person
{
    id: ID!
    name: String!
    company: String!
}

Answer: Interface

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ***** は、GraphQLにおいて、指定された複数の型のうちいずれかの型を示す抽象的なデータ型。

type Post
{
    id: ID!
    content: String!
    author: String
}

type Comment
{
    id: ID!
    content: String!
}

union Searchable = Post | Comment;

type Query
{
    search( q: String! ) [Searchable!]!
}

Answer: Union

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 **** は、GraphQLにおいて、スカラー型と同様、特定の値のみを持つ型。とり得る値の範囲をあらかじめ限定することができる。

type Comment
{
    id: ID!
    content: String!
}

type Reply
{
    id: ID!
    content: String!
    comment_id: ID!
}

enum CommentNode
{
    Comment
    Reply
}

Answer: Enum

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ********* は、GraphQLにおいて、SchemaやQueryに対してメタデータを与えるための宣言。GraphQLの処理系やツールによって解釈され、様々な効果を持つ。サポート状況はライブラリによって異なる。

Answer: Directive

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 **** は、GraphQLにおいて、Queryを解析して処理を行う関数。GraphQLを扱う実行環境で、外部のプログラムが **** として扱われる場合が多い。

以下は、TypeScript（Apolloを使用した場合）にて **** を記述する例。

import { ApolloServer } from '@apollo/server';

// GraphQL
const gql = `#graphql
    type Person
    {
        name: String!
        age: Int
    }

    type Query
    {
        persons: [Person]
    }
`;

// Data source
const persons =
[
    {
        "name": "Smith",
        "age": 20,
    },
    {
        "name": "Johnson",
        "age": 40,
    },
];

// Resolver
const resolvers =
{
    Query:
    {
        persons: () => persons,
    },
};

// GraphQL server
const server = new ApolloServer(
{
    gql,
    resolvers,
});

Answer: リゾルバ

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ***** は、GraphQLにおいて、クライアントからのリクエストを記述するための言語。GraphQLには、取得系のQuery、更新系のMutation、イベント通知を受け取るためのSubscriptionの3種類のリクエスト形式がある。

REST APIとは異なり、リクエストの形式は複雑になる。

Answer: クエリ言語

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ***** は、GraphQLにおけるデータ取得系のクエリで、対応するルート型は  *****  となる。クエリを受けてどのようなデータを取得するかは、リゾルバの実装次第となる。

例えば、スキーマ定義言語側で以下のような ***** が定義されている場合を考える。

type Person
{
    name: String!
    age: Int
}

type Company
{
    name: String!
    office: String
}

type  ***** 
{
    persons: [Person]
    company( name: String! ): [Company]
}

この時、 persons を実行する ***** は以下のようになる。 ***** に取得したい対象のデータだけでなく、その中のFieldを指定する必要があり、これはスカラー型かEnumに解決されなければならない。

query
{
    persons
    {
        name
    }
}

また、次の例のようにして、複数の ***** を1つのリクエストで同時に実行することもできる。

query
{
    persons
    {
        name
    }

    company( name: "Example Company" )
    {
        office
    }
}

 ***** にはオペレーション名を付けることで、解析や再利用を容易にすることができる。

query getPersonList
{
    persons
    {
        name
        age
    }
}

Answer: Query

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ******** は、GraphQLにおけるデータ更新系のクエリで、対応するルート型は  ********  となる。クエリを受けてどのようにデータを更新するかは、リゾルバの実装次第となる。

例えば、スキーマ定義言語側で以下のような ******** が定義されている場合を考える。

type Person
{
    name: String!
    age: Int
}

type  ******** 
{
    increaseAge( name: String!, age: Int ): Person
}

この時、 increaseAge を実行する ******** は以下のようになる。

mutation
{
    increaseAge( name: "Smith" )
    {
        age
    }
}

その他、主な記法についてはQueryと同様となる。

Answer: Mutation

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ************ は、GraphQLにおけるイベント監視のためのクエリで、対応するルート型は  ************  となる。 ************ 機能を利用する場合、WebSocketなどのクライアントとサーバの間での相互通信が可能な環境が必要となる。

例えば、スキーマ定義言語側で以下のような ************ が定義されている場合を考える。

type Person
{
    name: String!
    age: Int
}

type  ************ 
{
    personChanged( name: String! ): Person
}

この時、 personChanged を実行する ************ は以下のようになる。

subscription
{
    personChanged( name: "Smith" )
    {
        name
        age
    }
}

その他、主な記法についてはQueryと同様となる。

Answer: Subscription

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 ******** は、複数のQueryやMutationなどで利用される共通部分をまとめることができる機能。

例えば、スキーマ定義言語側が以下のように定義されている場合を考える。

type Person
{
    name: String!
    age: Int
    weight: Int
    height: Int
    country: String
}

type Query
{
    persons: [Person]
}

このとき、複数のQueryで利用するFieldが共通している場合、以下のような ******** を用意するとよい。

fragment Person ********  on Person
{
    name
    country
}

Queryでこの ******** を利用する場合、次のように記述する。

query
{
    persons
    {
        ...Person ******** 
    }
}

Answer: Fragment

Source: ../../note/development/graphql/_/chapters/graphql.md

====================

 **** (Deploy)は、ソフトウェアを開発環境から実稼働環境に展開する工程。開発者や運用チームによって実施され、新しいバージョンのソフトウェアが利用可能となる。

Answer: デプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 ********** は、稼働中のサーバに対して直接アプリケーションを配置、再起動する方法。最も直感的ではあるが、異常時のロールバックやダウンタイムといったユーザへの影響が発生する可能性がある。

Answer: インプレースデプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 *********** は、既存の環境に影響を与えず、新しい環境に新しいバージョンをデプロイする方法。既存の環境とは分離された新しい環境にデプロイするため、安全性が高く十分なテストを実施することができる。また、ダウンタイムが発生せず、即時ロールバックが可能というメリットもある。一方で、同時に2つの環境を動作させる必要があるため、高コストである。

Answer: ブルーグリーンデプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 *********** は、ブルーグリーンデプロイと同様、既存の環境とは分離された新しい環境にデプロイする方法。ただし、新環境への切り替え後に旧環境を削除することでコスをと抑える、という違いがある。ロールバックの際には、再度新しい環境を作り、古いバージョンをデプロイして切り替える。

Answer: イミュータブルデプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 ********* は、一度にすべてのインスタンスに対して更新を行うのではなく、可用性を維持しながら順次更新を行うデプロイ手法。稼働中のサーバが複数台で負荷分散されていることが前提。一部を切り離してデプロイを行い、再びオンラインに戻す（インプレースデプロイ）、もしくは新しい環境にデプロイしてから旧環境を削除する（イミュータブルデプロイ）、という操作を繰り返す。

Answer: ローリングデプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 ******** は、稼働中のサーバの一部だけにアプリケーションをデプロイする方法。特定のユーザだけに新しいアプリケーションを利用してもらい、新サービスの検証を行う、という目的で行われる。

Answer: カナリアデプロイ

Source: ../../note/development/management/_/chapters/deployment_strategy.md

====================

 ************ は、伝統的なソフトウェア開発手法で、開発プロジェクトを時系列にいくつかの作業工程に分割し、それを順番に進めていく。要件定義、設計、開発、テストという具合に階層的に工程が分けられ、1つの工程が完了すると次の工程に進む。一度進んだ工程は基本的に戻ることはないため、各工程の最後にレビューを行うなどして信頼性を上げる。この開発手法は、事前に要件が明確に定義されていることを前提として行われ、計画の正確さとスケジュールの厳守が鍵となる。そのため、要件の変更や修正が頻繁に起きるプロジェクトには向いていない。

Answer: ウォーターフォールモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 *********** は、ソフトウェア開発手法のひとつで、開発の早い段階で試作品（プロトタイプ）を作成し、それをユーザが確認して評価することで、システムの仕様を確定していく手法。ユーザのフィードバックをもとに設計の詳細化を進めていくことで、開発を行う。ユーザとのコミュニケーションが重視されており、柔軟な開発プロセスが求められる場合に有効。

Answer: プロトタイピングモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******** は、システム全体をいくつかの部分（サブシステムなど）に分け、分割した単位で開発のサイクルを繰り返す手法。部分ごとに開発を行い、ユーザがそれを確認して評価することで、大規模なシステムであっても早い段階でフィードバックを反映することができる。仕様変更に対して柔軟に対応できる一方で、初期の想定よりも仕様が肥大化してコストが増大する可能性もある。

Answer: スパイラルモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 *** (Rapid Application Development)は、迅速なアプリケーション開発手法のひとつで、ソフトウェア開発のプロセスを迅速化し、開発者が素早くアプリケーションを設計・開発・展開できるようにすることを目的としている。このモデルでは、ユーザの要件を迅速に理解してプロトタイプを作成することで、要件の検証やフィードバックを容易に行う。また、事前に作成されたソフトウェアコンポーネントを利用してアプリケーションを構築することで、再利用性を向上し、開発時間の短縮が図られる。

Answer: RAD

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******* は、ソフトウェア開発手法のひとつで、柔軟性と迅速な反応性を重視するスタイル。継続的な改善とユーザのフィードバックに基づいて、進化的にソフトウェアの開発を進める。プロジェクトを複数の短い開発サイクル（イテレーション）に分割し、各イテレーションごとに機能を追加、改善していく。テスト駆動開発や自動化テストなどの手法を活用したり、CI、CDを実践することで、ソフトウェアの品質を維持する。この開発手法には、ユーザのニーズに合わせた柔軟な開発や早期の価値提供、進化的な要求変更への対応が可能であるといった利点があるが、開発チームには十分なコミュニケーションや協力が求められる。

Answer: アジャイル開発

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ** (Extreme Programmingl)は、アジャイル開発の手法のひとつで、事前計画よりも柔軟性を重視する。難易度の高い開発や状況が刻々と変わるような開発に適しており、コミュニケーション、シンプル、フィードバック、勇気、尊重の5つに価値が置かれる。短い反復周期（イテレーション）で開発を繰り返し、テスト駆動開発やCI、ペアプログラミングといったプラクティスを取り入れることが多い。

Answer: XP

Source: ../../note/development/management/_/chapters/development_method.md

====================

 **** は、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、 **** マスタという3つの役割から **** チームを形成する。

• プロダクトオーナ: 作成するプロダクトに最終的に責任を持つメンバー
•  **** マスタ: プロジェクトの推進に責任を持つメンバー

 **** の工程の単位はスプリントで、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログというバックログを作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。

Answer: スクラム

Source: ../../note/development/management/_/chapters/development_method.md

====================

スクラムは、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割から ******* を形成する。

• プロダクトオーナ: 作成するプロダクトに最終的に責任を持つメンバー
• スクラムマスタ: プロジェクトの推進に責任を持つメンバー

スクラムの工程の単位はスプリントで、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログというバックログを作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。

Answer: スクラムチーム

Source: ../../note/development/management/_/chapters/development_method.md

====================

スクラムは、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、 ******** 、開発チーム、スクラムマスタという3つの役割からスクラムチームを形成する。

•  ******** : 作成するプロダクトに最終的に責任を持つメンバー
• スクラムマスタ: プロジェクトの推進に責任を持つメンバー

スクラムの工程の単位はスプリントで、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログというバックログを作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。

Answer: プロダクトオーナ

Source: ../../note/development/management/_/chapters/development_method.md

====================

スクラムは、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、 ******* という3つの役割からスクラムチームを形成する。

• プロダクトオーナ: 作成するプロダクトに最終的に責任を持つメンバー
•  ******* : プロジェクトの推進に責任を持つメンバー

スクラムの工程の単位はスプリントで、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログとスプリントバックログというバックログを作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。

Answer: スクラムマスタ

Source: ../../note/development/management/_/chapters/development_method.md

====================

スクラムは、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割からスクラムチームを形成する。

• プロダクトオーナ: 作成するプロダクトに最終的に責任を持つメンバー
• スクラムマスタ: プロジェクトの推進に責任を持つメンバー

スクラムの工程の単位は ***** で、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクトバックログと ***** バックログというバックログを作成し、製品に必要な要素や、 ***** で実現する仕様をまとめて管理する。

Answer: スプリント

Source: ../../note/development/management/_/chapters/development_method.md

====================

スクラムは、アジャイル開発の手法のひとつで、チームの効率性と生産性を向上させるための方法論。この方法では、プロダクトオーナ、開発チーム、スクラムマスタという3つの役割からスクラムチームを形成する。

• プロダクトオーナ: 作成するプロダクトに最終的に責任を持つメンバー
• スクラムマスタ: プロジェクトの推進に責任を持つメンバー

スクラムの工程の単位はスプリントで、開発、まとめ、レビュー、調整などの作業を繰り返す。また、プロダクト ***** とスプリント ***** という ***** を作成し、製品に必要な要素や、スプリントで実現する仕様をまとめて管理する。

Answer: バックログ

Source: ../../note/development/management/_/chapters/development_method.md

====================

 *********** は、製造業の現場から生まれた考え方をアジャイル開発のプラクティスに適用したもので、次の7つの原則を重視しながら開発を進める。

1. ムダをなくす
2. 品質を作り込む
3. 知識を作り出す
4. 決定を遅らせる
5. 早く提供する
6. 人を尊重する
7. 全体を最適化する

Answer: リーンソフトウェア開発

Source: ../../note/development/management/_/chapters/development_method.md

====================

 *********** は、ソフトウェア開発手法のひとつで、プロジェクトを複数の段階（インクリメント）に分割し、各段階ごとに機能を追加、拡張していく開発プロセス。最初の段階では基本的な機能やコアの機能を実装し、その後の段階で追加の機能や機能の改善を行う。段階的な開発とリリースを繰り返すことで、早期に動作するソフトウェアを提供することができる。また、各段階での機能の追加や変更は以前の段階に影響を与えないように実装を進めるため、可逆性のある柔軟な開発が可能となる。

Answer: インクリメンタルモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ************ は、ソフトウェア開発手法のひとつで、ソフトウェアの要件や設計を進化させながら開発を進める方法。ウォーターフォールモデルと比較して、より柔軟で迅速な開発を可能とする。このモデルでは、ソフトウェア開発を複数の短いイテレーションに分割し、各イテレーションごとに要件定義、設計、実装、テストを行う。各イテレーションの結果やフィードバックをもとに、次のイテレーションで改善や変更を行いながらソフトウェアを進化させていく。また、開発の早期にプロトタイプを使用することで、ユーザとのコミュニケーションや要件の検証を行う。

Answer: エボリューショナルモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ****** は、ソフトウェア開発手法のひとつで、開発(Development)と運用(Operations)を組み合わせた言葉。開発担当者と運用担当者が連携して協力し、両者の境目を曖昧にした開発手法。ソフトウェアを迅速にビルドおよびテストする文化と環境により、確実なリリースを、以前よりも迅速に高い頻度で可能とする組織体制の構築を目指している。

Answer: DevOps

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******* (TDD: Test-Drive Development)は、ソフトウェア開発手法のひとつで、テストを中心にソフトウェアを開発するプロセス。このモデルでは、最初にテストを作成し、その後にテストをパスするように実装コードを書く。最初にテストケースを作成することで、ソフトウェアの振る舞いや期待される結果を明確にすることができる。また、テストは自動化されており、実装を行う前にテストケースを実行して失敗することを確認してからテストをパスするように実装を行う。テストが成功することを確認したら、コードをリファクタリングすることで、品質や保守性を向上させる。

Answer: テスト駆動開発

Source: ../../note/development/management/_/chapters/development_method.md

====================

テスト駆動開発( *** : Test-Drive Development)は、ソフトウェア開発手法のひとつで、テストを中心にソフトウェアを開発するプロセス。このモデルでは、最初にテストを作成し、その後にテストをパスするように実装コードを書く。最初にテストケースを作成することで、ソフトウェアの振る舞いや期待される結果を明確にすることができる。また、テストは自動化されており、実装を行う前にテストケースを実行して失敗することを確認してからテストをパスするように実装を行う。テストが成功することを確認したら、コードをリファクタリングすることで、品質や保守性を向上させる。

Answer: TDD

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******** (DDD: Domain-Drive Development)は、ソフトウェア開発手法のひとつで、ソフトウェアが解決しようとしている業務や専門領域（ドメイン）の専門家と開発者が協力して、ソフトウェアの設計に反映させる方法。業務仕様やビジネスルールの複雑さを紐解き、顧客の課題を正しく理解することを目的としている。

Answer: ドメイン駆動開発

Source: ../../note/development/management/_/chapters/development_method.md

====================

ドメイン駆動開発( *** : Domain-Drive Development)は、ソフトウェア開発手法のひとつで、ソフトウェアが解決しようとしている業務や専門領域（ドメイン）の専門家と開発者が協力して、ソフトウェアの設計に反映させる方法。業務仕様やビジネスルールの複雑さを紐解き、顧客の課題を正しく理解することを目的としている。

Answer: DDD

Source: ../../note/development/management/_/chapters/development_method.md

====================

 **** は、 **** 駆動設計において、ソフトウェアがシステム化の対象とする業務や専門領域。物流システムなら物流業務、会計システムなら経理業務などが **** に当たる。

Answer: ドメイン

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******* は、ドメイン駆動設計において、業務仕様やビジネスルールといったドメイン知識をシステム開発の観点から図や文章に落とし込んだもの。システムの主要な構成要素を構造化し、それらの要素が持つべき情報（プログラミングにおけるフィールド）や役割（プログラミングにおけるメソッド）を洗い出すことを目的としている。 ******* は開発者とドメインのエキスパートとの共通言語としても用いられる。

Answer: ドメインモデル

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******* は、ドメイン駆動設計において、全てのステークホルダ（開発者やそのドメインのエキスパートなど）が理解できる共通言語。プロジェクトを進行する上で円滑なコミュニケーションを行うために、開発者とドメインのエキスパートとの間で作り上げ共有される。

Answer: ユキビタス言語

Source: ../../note/development/management/_/chapters/development_method.md

====================

 **** は、ドメイン駆動設計において、ドメインモデルを実装に落とし込む際の典型的な手法。過去の開発者が編み出した設計ノウハウを蓄積し、名前をつけて再利用しやすいように特定の規則に従ってカタログ化されている。

Answer: パターン

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ** （継続的インテグレーション: Continuous Integration）は、ソフトウェア開発のプラクティスのひとつで、開発者がコードを中央のリポジトリに統合し、その変更を自動的にビルドしたりテストしたりする手法。これによりビルドやテストを自動化することができ、早期のバグ検出が期待できるなどコード品質を向上させることができる。CDと組み合わせる場合も多い。

Answer: CI

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ** （継続的デプロイメント: Continuous Deployment、継続的デリバリー: Continuous Delivery）は、ソフトウェア開発のプラクティスのひとつで、ソフトウェアのビルドやテストが成功した場合に自動的に本番環境へのデプロイを行う手法。ビルドやテストが完了した段階で自動的にデプロイを実施する、あるいは、デプロイを自動化するプロセス（承認フローなど）を提供することにより、ヒューマンエラーの発生を減らすことができる。リリースを迅速に行い、高い品質と安定性が期待できる。CIと組み合わせる場合も多い。

Answer: CD

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ********* は、ソフトウェア開発手法のひとつで、2人の開発者が1つのコンピュータで協力してコードを書く方法。1人がドライバとしてキーボードを操作し、もう1人がナビゲータとしてドライバをサポートする。

 ********* の実施により、コードを早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。

Answer: ペアプログラミング

Source: ../../note/development/management/_/chapters/development_method.md

====================

ペアプログラミングは、ソフトウェア開発手法のひとつで、2人の開発者が1つのコンピュータで協力してコードを書く方法。1人が **** としてキーボードを操作し、もう1人がナビゲータとして **** をサポートする。

ペアプログラミングの実施により、コードを早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。

Answer: ドライバ

Source: ../../note/development/management/_/chapters/development_method.md

====================

ペアプログラミングは、ソフトウェア開発手法のひとつで、2人の開発者が1つのコンピュータで協力してコードを書く方法。1人がドライバとしてキーボードを操作し、もう1人が ***** としてドライバをサポートする。

ペアプログラミングの実施により、コードを早期にレビューして品質を向上させることができたり、知識共有やスキル向上、リファクタリングによる設計の改善などにつながる。

Answer: ナビゲータ

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ************ は、既存の製品やシステムを解析して、内部の仕組みや設計を理解するための手法。通常は、逆コンパイルや逆アセンブルといった手法や、関数の呼び出し関係をグラフで表現したコールグラフを利用して解析を行う。

 ************ の目的には、システムの理解やドキュメント化、セキュリティ評価、脆弱性解析などがある。

Answer: リバースエンジニアリング

Source: ../../note/development/management/_/chapters/development_method.md

====================

リバースエンジニアリングは、既存の製品やシステムを解析して、内部の仕組みや設計を理解するための手法。通常は、逆コンパイルや逆アセンブルといった手法や、関数の呼び出し関係をグラフで表現した ****** を利用して解析を行う。

リバースエンジニアリングの目的には、システムの理解やドキュメント化、セキュリティ評価、脆弱性解析などがある。

Answer: コールグラフ

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ******* (Mashup)は、複数の異なる情報や機能を組み合わせて新しいアプリケーションやサービスを作成する手法や技術。異なるデータソースやAPIを統合し、それらを利用して新しい情報や機能を提供することが特徴。主にWebプログラミングで用いられており、複数のWebサービスを組み合わせてあたかもひとつのWebサービスのように提供する。

Answer: マッシュアップ

Source: ../../note/development/management/_/chapters/development_method.md

====================

 ****** は、ソフトウェア、システム、サービスの構想から開発、運用、保守、破棄に至るまでのライフサイクルを通じて必要な作業項目、役割などを包括的にまとめたガイドライン。 ****** では、各プロセスをアクティビティ、タスク、注記と徐々に詳細化していく。

Answer: 共通フレーム

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ***** は、開発からテスト、リリースまでの一連の流れをV字型に並べ、対応関係を表現したモデル。図の左側が開発工程、右側がテスト工程で、それぞれの段階に対応したテストケースを用意することによって、要件を明確化し、品質や信頼性の向上を図ることができる。

 ***** 

Answer: V字モデル

Source: ../../note/development/management/_/chapters/development_process.md

====================

 **** は、ソフトウェア開発プロセスの初期段階で行われる重要な工程で、システムやソフトウェアの目的や機能、制約条件などを明確に定義する。

Answer: 要件定義

Source: ../../note/development/management/_/chapters/development_process.md

====================

 **** は、ソフトウェアやシステムに求められる具体的な機能や振る舞いの要件。そのシステムがどのような機能を提供しなければならないかを明確に定義し、開発やテストの基準となる。

アカウント登録、ログイン、プロフィール編集、メッセージ送信、ファイルアップロード、検索機能、レポート生成、通知機能、といったものは **** の例である。

Answer: 機能要件

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ***** は、ソフトウェアやシステムに対して機能以外の要求や制約を表す要件。そのシステムの品質や性能、セキュリティ、信頼性、使いやすさなどの側面に関わる要求を定義する。

パフォーマンス、可用性、セキュリティ、拡張性、ユーザビリティ、メンテナンス性、といったものは ***** の例である。

Answer: 非機能要件

Source: ../../note/development/management/_/chapters/development_process.md

====================

 **** は、システムの設計ドキュメントやアーティファクトを評価し、問題や改善点を特定するプロセス。設計が要件を満たしており、システムが適切に構築されることを確認するために行われる。

Answer: レビュー

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ******* は、システム開発におけるレビュー手法のひとつで、開発チームや関係者が実際のソフトウェアやドキュメントを順に見ていき、問題や改善点を特定するための対話的なセッションが行われる。 ******* は、問題の早期発見や、理解と共有の促進、チームのコラボレーションを目的として行われる。

Answer: ウォークスルー

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ******** は、システム開発におけるレビュー手法のひとつで、ソフトウェアやドキュメントの品質を向上させるために、経験豊富なチームメンバーや専門家が詳細な検査を行う。 ******** は、問題の早期発見や、品質の向上、レビューの効率化を目的として行われる。

Answer: インスペクション

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ******* （流れ図）は、プロセスや手順をグラフィカルに表現する図。図やシンボルを使って、タスクの流れや意思決定のフロー、プロセスの手順を表現する。 ******* では、順次、選択、繰り返しといったプログラムにおける基本的な制御構文を表現することができる。

Answer: フローチャート

Source: ../../note/development/management/_/chapters/development_process.md

====================

 *** （プロセス中心アプローチ: Process Oriented Approach）は、ソフトウェアの機能（プロセス）を中心としたアプローチで、システムをサブシステムに、さらに段階的に詳細化指定木、最終的には最小機能の単位であるモジュールに分割する。データの流れを表現するDFDやプロセスの状態遷移を表現する状態遷移図が用いられたり、プログラミング言語としてC言語などの構造化言語がよく採用される。

Answer: POA

Source: ../../note/development/management/_/chapters/development_process.md

====================

 *** (Data Flow Diagram)は、POAにおいてよく用いられる、プロセスを中心にデータの流れをグラフィカルに表現する図。システムの入出力がどのような情報なのかを示し、データがどこから来てどこへ行くのか、どこに格納されるのかといったことを示す。プロセス、ターミネータ、データストア、データフローという要素によって描かれる。

 *** の例

Answer: DFD

Source: ../../note/development/management/_/chapters/development_process.md

====================

 **** は、DFDにおいて、入力データに対して何かしらの処理を施し、データを出力する要素。必ず入力と出力のデータフローが存在する。

Answer: プロセス

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ****** （外部実体）は、DFDにおいて、データの入力先、または出力先となる外部要素。

Answer: ターミネータ

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ****** は、DFDにおいて、データの保存先となる要素。データベースに限らず、ファイルなどのデータを保管する媒体全体を指す。

Answer: データストア

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ****** は、DFDにおいて、データの移動経路や方向を矢印で表したもの。

Answer: データフロー

Source: ../../note/development/management/_/chapters/development_process.md

====================

 *** （データ中心アプローチ: Data Oriented Approach）は、業務で扱うデータに着目したアプローチで、業務で扱うデータ全体をER図を用いてモデル化する。個々のシステムはこのデータベースを中心に設計することによって、データの整合性や一貫性が保たれ、システム間でのやり取りが容易になる。プログラミングとデータベースを分離するデータ独立の考え方となっている。

Answer: DOA

Source: ../../note/development/management/_/chapters/development_process.md

====================

 *** （オブジェクト指向アプローチ: Object Oriented Approach）は、プログラムやデータをオブジェクトとして捉え、それを組み合わせてシステムを構築するアプローチ。オブジェクトを表現するために、クラス図やシーケンス図といったUMLが用いられたり、プログラミング言語としてJavaなどのオブジェクト指向言語がよく採用される。

Answer: OOA

Source: ../../note/development/management/_/chapters/development_process.md

====================

 *** （統一モデリング言語: Unified Modeling Language）は、オブジェクト指向で用いられる表記法で、クラス図やシーケンス図などの様々な図が定義されている。

Answer: UML

Source: ../../note/development/management/_/chapters/development_process.md

====================

 **** は、クラスの仕様とクラス間の関係を表現する図。ER図の発展形のようになっており、データのエンティティだけでなく、プログラムの持つプロセス（メソッド）も表現する。

Answer: クラス図

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ****** は、インスタンス間の相互作用を時系列で表現する図。

Answer: シーケンス図

Source: ../../note/development/management/_/chapters/development_process.md

====================

 ***** (Project Management Body of Knowledge)は、プロジェクト管理に関する知識体系をまとめたもので、プロジェクトマネジメントの標準的なガイドラインとして広く使用されている。プロジェクトマネジメントの領域、プロセス、ツール、テクニックなどについて包括的な知識を提供し、プロジェクトの計画、実行、監視、制御、閉鎖などのフェーズでの最適なプラクティスを示す。 ***** は5つのプロセスグループと10の知識エリアからなる。

Answer: PMBOK

Source: ../../note/development/management/_/chapters/management.md

====================

 ******** は、プロジェクトマネジメントにおける活動やタスクを特定のカテゴリに分類するためのグループ。PMBOKにおいて、プロジェクトのライフサイクルを管理するために5つの ******** が定義されている。

• 立上げプロセス群: プロジェクトの認可を得て、新しいフェーズを明確に定める
• 計画プロセス群: プロジェクトのスコープを定義し、目標を洗い出し、一連の行動を規定する
• 実行プロセス群: プロジェクトの作業を実行する
• 監視コントロール・プロセス群: プロジェクトの進捗やパフォーマンスを追跡し、統制し、変更を開始する
• 終結プロセス群: プロジェクトを公式に完結し、すべてのアクティビティを終了する

Answer: プロセスグループ

Source: ../../note/development/management/_/chapters/management.md

