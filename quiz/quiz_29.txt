====================

 ******* は、オブジェクト指向のプログラミング言語において、クラスから生成されたオブジェクトを指すデータ型。

Answer: オブジェクト型

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******* は、メモリ上のデータの実体を別のメモリアドレスにそのまま複製する方法。多くのプログラミング言語では、プリミティブ型のデータの複製は ******* によって行われる。

コンテナ型やオブジェクト型のデータは多くのメモリ領域を必要とするため、 ******* のコストが大きくなる。そのため、明示しない限りはシャローコピーとなるプログラミング言語が多い。このような特徴から、 ******* は高価なコピーであるとされ、無駄な ******* は避けるべきである。

可変長配列のデータを追加するときに、メモリ不足が発生した場合、より広いメモリ領域がアロケートされ、確保した領域に元のデータが ******* される。

Answer: ディープコピー

Source: ../../note/programming/_/chapters/data_type.md

====================

ディープコピーは、メモリ上のデータの実体を別のメモリアドレスにそのまま複製する方法。多くのプログラミング言語では、プリミティブ型のデータの複製はディープコピーによって行われる。

コンテナ型やオブジェクト型のデータは多くのメモリ領域を必要とするため、ディープコピーのコストが大きくなる。そのため、明示しない限りはシャローコピーとなるプログラミング言語が多い。このような特徴から、ディープコピーは ****** であるとされ、無駄なディープコピーは避けるべきである。

可変長配列のデータを追加するときに、メモリ不足が発生した場合、より広いメモリ領域がアロケートされ、確保した領域に元のデータがディープコピーされる。

Answer: 高価なコピー

Source: ../../note/programming/_/chapters/data_type.md

====================

 ******* は、メモリ上のデータアドレスを指すポインタを取得する方式。コピー元と同じデータを指し示すポインタを取得する見かけ上のコピーであるため、データの実体が書き換えられると、コピー元もコピー先もデータが置き換わったように見える。そのため、コピー元かコピー先のどちらかのデータだけを変更したいような場合にはディープコピーを用いる必要がある。

コンテナ型やオブジェクト型のデータはディープコピーにかかるコストが大きいため、 ******* を用いることで複製のコストが抑えられる。

Answer: シャローコピー

Source: ../../note/programming/_/chapters/data_type.md

====================

 ** （サブルーチン、手続き、プロシージャ）は、データを受け取り、定められた特定の処理を実行して、その結果を返す命令ブロック。 ** にはプログラマが任意の識別子をつけることができる（ main  ** のような特別な意味を持つ ** については除く）。 ** につけられた識別子をソースコード中に記すことで、その命令ブロックを呼び出すことができる。

 ** を用いることで、プログラムの再利用性やメンテナンス性が向上するという利点がある。

Answer: 関数

Source: ../../note/programming/_/chapters/function.md

====================

関数（ ****** 、手続き、プロシージャ）は、データを受け取り、定められた特定の処理を実行して、その結果を返す命令ブロック。関数にはプログラマが任意の識別子をつけることができる（ main 関数のような特別な意味を持つ関数については除く）。関数につけられた識別子をソースコード中に記すことで、その命令ブロックを呼び出すことができる。

関数を用いることで、プログラムの再利用性やメンテナンス性が向上するという利点がある。

Answer: サブルーチン

Source: ../../note/programming/_/chapters/function.md

====================

関数（サブルーチン、 *** 、プロシージャ）は、データを受け取り、定められた特定の処理を実行して、その結果を返す命令ブロック。関数にはプログラマが任意の識別子をつけることができる（ main 関数のような特別な意味を持つ関数については除く）。関数につけられた識別子をソースコード中に記すことで、その命令ブロックを呼び出すことができる。

関数を用いることで、プログラムの再利用性やメンテナンス性が向上するという利点がある。

Answer: 手続き

Source: ../../note/programming/_/chapters/function.md

====================

関数（サブルーチン、手続き、 ****** ）は、データを受け取り、定められた特定の処理を実行して、その結果を返す命令ブロック。関数にはプログラマが任意の識別子をつけることができる（ main 関数のような特別な意味を持つ関数については除く）。関数につけられた識別子をソースコード中に記すことで、その命令ブロックを呼び出すことができる。

関数を用いることで、プログラムの再利用性やメンテナンス性が向上するという利点がある。

Answer: プロシージャ

Source: ../../note/programming/_/chapters/function.md

====================

 ** （パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮 ** を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実 ** として関数に渡すことで、仮 ** 部分がデータに置き替えられて処理が実行される。

 ** は複数受け取ることも可能。また、仮 ** にデフォルト値を指定しておくことで、関数呼び出しの際に実 ** を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような ** をオプション ** （デフォルト ** 、任意 ** ）という。関数定義の際に ** を固定せず、呼び出し側で任意の数の ** を渡して処理を実行するような、可変長 ** をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: 引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（ ***** ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（デフォルト引数、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: パラメータ

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた *** を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、 *** 部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、 *** にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（デフォルト引数、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: 仮引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を *** として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に *** を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（デフォルト引数、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: 実引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数を ******* （デフォルト引数、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: オプション引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（ ******* 、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: デフォルト引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（デフォルト引数、 **** ）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、可変長引数をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: 任意引数

Source: ../../note/programming/_/chapters/function.md

====================

引数（パラメータ）は、関数が呼び出されるときに、関数の呼び出し元から受け取るデータ。関数を定義する際には、受け取る情報に任意の識別子を用いた仮引数を用いて処理を記述する。関数呼び出しの際に実際に処理したい情報を実引数として関数に渡すことで、仮引数部分がデータに置き替えられて処理が実行される。

引数は複数受け取ることも可能。また、仮引数にデフォルト値を指定しておくことで、関数呼び出しの際に実引数を渡さなかった場合にデフォルト値で置き替えて処理を実行することもできる。このような引数をオプション引数（デフォルト引数、任意引数）という。関数定義の際に引数を固定せず、呼び出し側で任意の数の引数を渡して処理を実行するような、 ***** をサポートしている言語もある（文字列のフォーマットなどによく利用される）。

Answer: 可変長引数

Source: ../../note/programming/_/chapters/function.md

====================

 *** は、関数の命令ブロックが実行された結果として、関数の呼び出し元に返されるデータ。関数の *** は return キーワードを用いて記述する。 *** は通常1つしか返すことができないため、複数の値を返したいような場合には、値をオブジェクトとして返却したり、引数として受け取ったポインタに直接結果を書き込んだりする。

関数内部で宣言されたローカル変数は、関数の処理ブロック内部のみで有効な変数であり、 *** として使用するには注意が必要となる。 *** として返却されるデータがプリミティブ型の場合はデータがディープコピーされるが、複合型の値を返却しようとした場合にシャローコピーが発生する可能性がある。このような場合、ローカル変数は関数の実行が終了されると破棄されるため、 *** がダングリングポインタとなってしまう場合がある。そのため、明示的に確保したメモリに格納したデータのポインタを返却したり、引数として受け取ったポインタに直接データを格納したりといった工夫が必要となる。

Answer: 戻り値

Source: ../../note/programming/_/chapters/function.md

====================

 **** には、関数につけられた識別子、処理内容、仮引数リスト、戻り値を記述する。

// C言語

//  **** 
int add( int a_, int b_ )
{
    int result = a_ + b_;
    return result;
}

<?php

// PHP

//  **** 
function add( $a_, $b_ )
{
    $result = $a_ + $b_;
    return $result;
}

?>

// JavaScript

function add( a_, b_ )
{
    let result = a_ + b_;
    return result;
}

Answer: 関数定義

Source: ../../note/programming/_/chapters/function.md

====================

 ****** （コール、キック）では、関数の識別子を記述して処理を引用し、仮引数リストに対応した実引数を渡す。

// C言語

// 関数プロトタイプ宣言
int add( int, int );

// メイン関数
int main()
{
    int a = 5;
    int b = 10;

    //  ****** 
    int result = add(a, b);
    printf("Result: %d\n", result);

    return 0;
}

// 関数定義
int add( int a_, int b_ )
{
    int result = a_ + b_;
    return result;
}

<?php

// PHP

// 関数定義
function add( $a_, $b_ )
{
    $result = $a_ + $b_;
    return $result;
}

$a = 5;
$b = 10;

//  ****** 
$result = add($a, $b);
echo("Result: " . $result);

?>

// JavaScript

// 関数定義
function add( a_, b_ )
{
    let result = a_ + b_;
    return result;
}

let a = 5;
let b = 10;

//  ****** 
let result = add(a, b);
console.log("Result: " + result);

Answer: 関数呼び出し

Source: ../../note/programming/_/chapters/function.md

====================

関数呼び出し（ *** 、キック）では、関数の識別子を記述して処理を引用し、仮引数リストに対応した実引数を渡す。

// C言語

// 関数プロトタイプ宣言
int add( int, int );

// メイン関数
int main()
{
    int a = 5;
    int b = 10;

    // 関数呼び出し
    int result = add(a, b);
    printf("Result: %d\n", result);

    return 0;
}

// 関数定義
int add( int a_, int b_ )
{
    int result = a_ + b_;
    return result;
}

<?php

// PHP

// 関数定義
function add( $a_, $b_ )
{
    $result = $a_ + $b_;
    return $result;
}

$a = 5;
$b = 10;

// 関数呼び出し
$result = add($a, $b);
echo("Result: " . $result);

?>

// JavaScript

// 関数定義
function add( a_, b_ )
{
    let result = a_ + b_;
    return result;
}

let a = 5;
let b = 10;

// 関数呼び出し
let result = add(a, b);
console.log("Result: " + result);

Answer: コール

Source: ../../note/programming/_/chapters/function.md

====================

関数呼び出し（コール、 *** ）では、関数の識別子を記述して処理を引用し、仮引数リストに対応した実引数を渡す。

// C言語

// 関数プロトタイプ宣言
int add( int, int );

// メイン関数
int main()
{
    int a = 5;
    int b = 10;

    // 関数呼び出し
    int result = add(a, b);
    printf("Result: %d\n", result);

    return 0;
}

// 関数定義
int add( int a_, int b_ )
{
    int result = a_ + b_;
    return result;
}

<?php

// PHP

// 関数定義
function add( $a_, $b_ )
{
    $result = $a_ + $b_;
    return $result;
}

$a = 5;
$b = 10;

// 関数呼び出し
$result = add($a, $b);
echo("Result: " . $result);

?>

// JavaScript

// 関数定義
function add( a_, b_ )
{
    let result = a_ + b_;
    return result;
}

let a = 5;
let b = 10;

// 関数呼び出し
let result = add(a, b);
console.log("Result: " + result);

Answer: キック

Source: ../../note/programming/_/chapters/function.md

====================

 ********** は、関数をソースコードの冒頭で宣言しておき、後から具体的な関数定義を行う記法。C言語などにおいては、関数呼び出しよりも前に関数の存在が明示されている必要があるため、関数呼び出しを含む部分を関数定義よりも前に記述したい場合に用いる。

Answer: 関数プロトタイプ宣言

Source: ../../note/programming/_/chapters/function.md

====================

 *** は、関数が関数外のプログラム上のデータを変化させる性質。代表的な *** としては以下のような操作が上げられる。

• オブジェクトのプロパティの変更
• グローバル変数の変更
• 引数の変更
• ファイルの読み書きなどのI/O操作

Answer: 副作用

Source: ../../note/programming/_/chapters/function.md

====================

 *** は、同じ関数を繰り返し呼び出しても同じ結果が得られるという性質。

Answer: 冪等性

Source: ../../note/programming/_/chapters/function.md

====================

 ***** は、関数やメソッドの名前、引数の数やデータ型、戻り値の型などの組み合わせ。オブジェクト指向のプログラミング言語においてクラスのインタフェースを定義する際などに用いられる。

Answer: シグネチャ

Source: ../../note/programming/_/chapters/function.md

====================

 **** （組込み関数）は、各プログラミング言語の仕様としてあらかじめ用意されている関数。使い方は通常の関数と同様で、仕様として定義されているため、プログラマが定義し実装する必要はない。用意されている関数の詳細については、各プログラミング言語のドキュメントなどを参照する必要がある。

Answer: 標準関数

Source: ../../note/programming/_/chapters/function.md

====================

標準関数（ ***** ）は、各プログラミング言語の仕様としてあらかじめ用意されている関数。使い方は通常の関数と同様で、仕様として定義されているため、プログラマが定義し実装する必要はない。用意されている関数の詳細については、各プログラミング言語のドキュメントなどを参照する必要がある。

Answer: 組込み関数

Source: ../../note/programming/_/chapters/function.md

====================

 **** （クロージャ）は、識別子を持たない関数。ラムダ式を用いて、関数を変数に格納したり、高階関数の引数として渡したりすることができる。

Answer: 無名関数

Source: ../../note/programming/_/chapters/function.md

====================

無名関数（ ***** ）は、識別子を持たない関数。ラムダ式を用いて、関数を変数に格納したり、高階関数の引数として渡したりすることができる。

Answer: クロージャ

Source: ../../note/programming/_/chapters/function.md

====================

無名関数（クロージャ）は、識別子を持たない関数。 **** を用いて、関数を変数に格納したり、高階関数の引数として渡したりすることができる。

Answer: ラムダ式

Source: ../../note/programming/_/chapters/function.md

====================

 **** は、関数の引数や戻り値として関数を用いるような関数。

Answer: 高階関数

Source: ../../note/programming/_/chapters/function.md

====================

 ******** は、高階関数の引数としてとられる関数。高階関数の呼び出し元が定義した関数を、高階関数の処理の中から呼び出し返すことからコールバックと呼ばれる。

例えば、非同期処理を扱う高階関数に、非同期操作が完了した後に行いたい処理をコールバックとして渡しておくといった使い方がある（非同期コールバック）。

Answer: コールバック関数

Source: ../../note/programming/_/chapters/function.md

====================

コールバック関数は、高階関数の引数としてとられる関数。高階関数の呼び出し元が定義した関数を、高階関数の処理の中から呼び出し返すことからコールバックと呼ばれる。

例えば、非同期処理を扱う高階関数に、非同期操作が完了した後に行いたい処理をコールバックとして渡しておくといった使い方がある（ ********* ）。

Answer: 非同期コールバック

Source: ../../note/programming/_/chapters/function.md

====================

 **** は、ある関数の内部でその関数自身を呼び出す（再帰呼び出し）ような関数。例えば、 0 から引数として受け取った整数までの総和を求める関数などに用いられる。呼び出される側でどれほど処理を繰り返せばいいかわからない場合や、引数として受け取るデータの階層が不明な場合などに **** を用いることで、実装がシンプルになったりする。

 **** を実装する場合には、再帰呼び出しを停止する条件を考慮する必要がある。再帰呼び出しを打ち切る条件が満たされないような実装になると、無限ループが発生してしまう。また、無限ループでなくとも、再帰呼び出しされる回数が多いとスタックオーバフローが発生してしまう可能性がある。

よくある **** の実装は次のような形式となっている。関数内部で再帰呼び出しを行っており、ベースケースの条件に合致した段階で再帰呼び出しが停止する。ベースケースに達すると、再帰的に呼び出された関数に結果を返却していき、最終的な結果が呼び出し元に返される。

function example_func( 引数 )
{
    if( ベースケース )
    {
        return ベースケースに対する値;
    }

    // 再帰呼び出し
    example_func();
    return 結果;
}

Answer: 再帰関数

Source: ../../note/programming/_/chapters/function.md

====================

再帰関数は、ある関数の内部でその関数自身を呼び出す（再帰呼び出し）ような関数。例えば、 0 から引数として受け取った整数までの総和を求める関数などに用いられる。呼び出される側でどれほど処理を繰り返せばいいかわからない場合や、引数として受け取るデータの階層が不明な場合などに再帰関数を用いることで、実装がシンプルになったりする。

再帰関数を実装する場合には、再帰呼び出しを停止する条件を考慮する必要がある。再帰呼び出しを打ち切る条件が満たされないような実装になると、無限ループが発生してしまう。また、無限ループでなくとも、再帰呼び出しされる回数が多いとスタックオーバフローが発生してしまう可能性がある。

よくある再帰関数の実装は次のような形式となっている。関数内部で再帰呼び出しを行っており、 ****** の条件に合致した段階で再帰呼び出しが停止する。 ****** に達すると、再帰的に呼び出された関数に結果を返却していき、最終的な結果が呼び出し元に返される。

function example_func( 引数 )
{
    if(  ******  )
    {
        return  ****** に対する値;
    }

    // 再帰呼び出し
    example_func();
    return 結果;
}

Answer: ベースケース

Source: ../../note/programming/_/chapters/function.md

====================

 **** は、複数の引数をとる関数があったときに、いくつかの引数を共通化して、内部で元の関数を呼び出すような新しい関数をつくること。 **** した関数を用いることで、元の関数に渡す引数の一部を省略することができ、ソースコードをシンプルに保つことができる。

Answer: カリー化

Source: ../../note/programming/_/chapters/function.md

====================

 ****** は、プログラムが使い終わったメモリの解放を忘れることで、使用できなくなるメモリ領域ができてしまうこと。メモリ管理に関するバグの一種。

Answer: メモリリーク

Source: ../../note/programming/_/chapters/memory_management.md

====================

 ****** （メモリの二重解放、多重フリー）は、既に解放されたヒープ領域のメモリを、再度解放しようとすること。メモリ管理に関するバグの一種。

Answer: ダブルフリー

Source: ../../note/programming/_/chapters/memory_management.md

====================

 ********** は、ヒープ領域に格納されたデータのアドレスを格納したスタック領域のポインタにおいて、既に解放されたヒープ領域を指し示すポインタ。メモリ管理に関するバグの一種。

Answer: ダングリングポインタ

Source: ../../note/programming/_/chapters/memory_management.md

====================

 ********** （GC）は、ヒープ領域のデータを定期的に確認し、不要になったデータを解放するプログラム。 ********** を用いる場合、ソースコード中でヒープ領域の解放を明示する必要はない。

メモリリークやダブルフリー、ダングリングポインタといったメモリに関するバグを回避するこおとができる。ただし、プログラマ自身がメモリ管理をするプログラミング言語に比べてパフォーマンスは低く、プログラムの実行に関係のないソフトウェア（ ********** ）を動作させる必要があるというデメリットがある。また、 ********** が動くタイミングでソフトウェアの動作が遅くなる可能性がある。

Answer: ガベージコレクション

Source: ../../note/programming/_/chapters/memory_management.md

====================

ガベージコレクション（ ** ）は、ヒープ領域のデータを定期的に確認し、不要になったデータを解放するプログラム。ガベージコレクションを用いる場合、ソースコード中でヒープ領域の解放を明示する必要はない。

メモリリークやダブルフリー、ダングリングポインタといったメモリに関するバグを回避するこおとができる。ただし、プログラマ自身がメモリ管理をするプログラミング言語に比べてパフォーマンスは低く、プログラムの実行に関係のないソフトウェア（ガベージコレクション）を動作させる必要があるというデメリットがある。また、ガベージコレクションが動くタイミングでソフトウェアの動作が遅くなる可能性がある。

Answer: GC

Source: ../../note/programming/_/chapters/memory_management.md

====================

 ***** （アロケーション）は、データを配置するために必要なメモリ領域を確保すること。可変長データを拡張しようとしたときに、あらかじめ確保したメモリ領域が不足した場合、改めて十分な空き領域を ***** する必要がある。基本的に ***** は低速な操作であるため、 ***** が発生する回数が少なくなるようにすることでプログラムを高速化することができる場合がある。

Answer: アロケート

Source: ../../note/programming/_/chapters/memory_management.md

====================

アロケート（ ******* ）は、データを配置するために必要なメモリ領域を確保すること。可変長データを拡張しようとしたときに、あらかじめ確保したメモリ領域が不足した場合、改めて十分な空き領域をアロケートする必要がある。基本的にアロケートは低速な操作であるため、アロケートが発生する回数が少なくなるようにすることでプログラムを高速化することができる場合がある。

Answer: アロケーション

Source: ../../note/programming/_/chapters/memory_management.md

====================

 ******** は、プログラミングパラダイムのひとつで、非常に多くのプログラミング言語に取り入れられている概念である。相互に作用するオブジェクトを組み合わせることでプログラムを設計する手法で、クラスベースの ******** に則ったプログラミング言語が多い（JavaScriptのように、プロトタイプベースの ******** もある）。

// C++

Answer: オブジェクト指向

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ****** は、あらゆるものをコンピュータが扱うデータとして抽象化したもの。 ****** はプロパティやメソッドを持っており、他の ****** との相互に作用しあって成り立っている。

Answer: オブジェクト

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 *** は、オブジェクトが持つプロパティやメソッド。

Answer: メンバ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ***** （属性、メンバ変数、フィールド変数）は、オブジェクトが持つデータや情報。

Answer: プロパティ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

プロパティ（ ** 、メンバ変数、フィールド変数）は、オブジェクトが持つデータや情報。

Answer: 属性

Source: ../../note/programming/_/chapters/object_oriented.md

====================

プロパティ（属性、 ***** 、フィールド変数）は、オブジェクトが持つデータや情報。

Answer: メンバ変数

Source: ../../note/programming/_/chapters/object_oriented.md

====================

プロパティ（属性、メンバ変数、 ******* ）は、オブジェクトが持つデータや情報。

Answer: フィールド変数

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 **** （操作、メンバ関数）は、オブジェクトの機能や振る舞い。

Answer: メソッド

Source: ../../note/programming/_/chapters/object_oriented.md

====================

メソッド（ ** 、メンバ関数）は、オブジェクトの機能や振る舞い。

Answer: 操作

Source: ../../note/programming/_/chapters/object_oriented.md

====================

メソッド（操作、 ***** ）は、オブジェクトの機能や振る舞い。

Answer: メンバ関数

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ********* は、入れ子になっているオブジェクトのプロパティに次々にアクセスするための記法。一般的には、プロパティとして扱われるオブジェクトとそのプロパティを . 記号でつなぐことが多い。

Answer: プロパティチェーン

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******** は、メソッドの戻り値として返されたオブジェクトに対して、次々とメソッドの呼び出しを行うための記法。一般的には、メソッドの後ろに . 記号をつけて更にその戻り値に対するメソッドの呼び出しを記述することが多い。

Answer: メソッドチェーン

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 *** は、オブジェクトを生成するための設計図のようなもの。オブジェクトの実体は *** を元にして生成される。同じ *** から生成されたオブジェクトは、共通のプロパティとメソッドを持つ（ただし、それぞれのオブジェクトが持つプロパティは独立しており、オブジェクトごとに固有）。 *** は実体を持たない設計図であるため、そのままではプロパティやメソッドを利用することはできない。

Answer: クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ****** は、クラスから生成されたオブジェクトの実体。クラスという概念からオブジェクトという実体を生成することを、 ****** 化という。

Answer: インスタンス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

インスタンスは、クラスから生成されたオブジェクトの実体。クラスという概念からオブジェクトという実体を生成することを、 ******* という。

Answer: インスタンス化

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ****** は、 ****** ベースのオブジェクト指向において用いられる概念。オブジェクトを生成する際に、その元となる ****** オブジェクトを指定することで、 ****** オブジェクトの共通の機能を利用することができる。このようにして、あるオブジェクトから ****** オブジェクトの機能を参照することを ****** チェーンと呼ぶ。

 ****** ベースのオブジェクト指向にはクラスの概念はなく、全てが実体（オブジェクト、 ****** オブジェクト）から成る。クラスベースにおける設計図であるクラスは静的なものであり、一度定義されたクラスはプログラム中で変更されることはない。一方で ****** は、設計図自体をプログラム中で拡張したり変更したりすることができる。

Answer: プロトタイプ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

プロトタイプは、プロトタイプベースのオブジェクト指向において用いられる概念。オブジェクトを生成する際に、その元となる ************ を指定することで、 ************ の共通の機能を利用することができる。このようにして、あるオブジェクトから ************ の機能を参照することをプロトタイプチェーンと呼ぶ。

プロトタイプベースのオブジェクト指向にはクラスの概念はなく、全てが実体（オブジェクト、 ************ ）から成る。クラスベースにおける設計図であるクラスは静的なものであり、一度定義されたクラスはプログラム中で変更されることはない。一方でプロトタイプは、設計図自体をプログラム中で拡張したり変更したりすることができる。

Answer: プロトタイプオブジェクト

Source: ../../note/programming/_/chapters/object_oriented.md

====================

プロトタイプは、プロトタイプベースのオブジェクト指向において用いられる概念。オブジェクトを生成する際に、その元となるプロトタイプオブジェクトを指定することで、プロトタイプオブジェクトの共通の機能を利用することができる。このようにして、あるオブジェクトからプロトタイプオブジェクトの機能を参照することを ********** と呼ぶ。

プロトタイプベースのオブジェクト指向にはクラスの概念はなく、全てが実体（オブジェクト、プロトタイプオブジェクト）から成る。クラスベースにおける設計図であるクラスは静的なものであり、一度定義されたクラスはプログラム中で変更されることはない。一方でプロトタイプは、設計図自体をプログラム中で拡張したり変更したりすることができる。

Answer: プロトタイプチェーン

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ***** は、オブジェクトが持つ情報を隠蔽することによって、不正な操作ができないようにする仕組み。オブジェクトが持つメソッドやプロパティは、アクセス指定子によってアクセスできる範囲を制限できる。

 ***** には、オブジェクトの外部からのアクセスを制限することで、オブジェクト内部のデータを保護して、直接書き換えられないようにする目的がある。オブジェクト内部のデータに直接アクセスできないようにする代わりに、保護されたデータを間接的に操作できるインタフェースとなるようなメソッドを用意しておくという使い方が多い。

// C++

Answer: カプセル化

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******* は、オブジェクトが持つプロパティやメソッドの公開範囲を指定するためのキーワード。これにより、オブジェクトの内部からしかアクセスできないデータと、オブジェクトの外側からでもアクセスできるデータを切り分けることができる。

// C++

class Monster
{
    // 外部にも公開されるメンバ
    public:

        int level_up( int diff_ )
        {
            return this->level_up_inner(diff_);
        }

    // 外部からは見えないが、子クラスからは見えるメンバ
    protected:

        int level_up_inner( int idff_ )
        {
            this->m_level += diff_;
            return this->m_level;
        }

        int m_level = 1;

    // 外部からも子クラスからも見えないメンバ
    private:

        int m_index = 0;
};

class Dragon : public Monster
{
    public:

        void power_up()
        {
            // level_up_innerは子クラスからもアクセス可能
            this->level_up_inner(1);
        }
};

int main()
{
    Dragon dragon;

    // level_upは外部からもアクセス可能
    int level = dragon.level_up(10);

    return 0;
}

Answer: アクセス指定子

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ** （インヘリタンス）は、 ** 元（親）となるクラスの持つプロパティやメソッドを引き継いだ、別のクラスを定義できる仕組み。複数の類似したクラスにおいて、共通部分をまとめた親クラスを定義することで、コードの再利用が高まる。

// C++

Answer: 継承

Source: ../../note/programming/_/chapters/object_oriented.md

====================

継承（ ******* ）は、継承元（親）となるクラスの持つプロパティやメソッドを引き継いだ、別のクラスを定義できる仕組み。複数の類似したクラスにおいて、共通部分をまとめた親クラスを定義することで、コードの再利用が高まる。

// C++

Answer: インヘリタンス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 **** （スーパークラス、基底クラス）は、あるクラスの継承元となったクラス。

Answer: 親クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

親クラス（ ******* 、基底クラス）は、あるクラスの継承元となったクラス。

Answer: スーパークラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

親クラス（スーパークラス、 ***** ）は、あるクラスの継承元となったクラス。

Answer: 基底クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 **** （サブクラス、派生クラス）は、別のクラスを継承したクラス。

Answer: 子クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

子クラス（ ***** 、派生クラス）は、別のクラスを継承したクラス。

Answer: サブクラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

子クラス（サブクラス、 ***** ）は、別のクラスを継承したクラス。

Answer: 派生クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ********** は、親クラスで定義されたメソッドと同じ識別子を持つメソッドを子クラス側でも定義することで、動作が上書きできる機能。

Answer: メソッドオーバライド

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******** （ポリモルフィズム、多相性）は、同じ識別子のメソッドで複数の異なる振る舞いを定義することができる性質。

例えば、異なるクラスが同じ名前のメソッドを共通して持つことによって、そのメソッドを通して、暗黙的に複数のオブジェクトを切り替えることができる。この性質を利用することで、オブジェクトを利用している側のソースコードを変更することなくクラスを切り替えることが可能となり、メンテナンス性の向上に繋がる。インタフェースや仮想関数の機能を用いることで、クラスのメソッドのシグネチャを共通化することができ、 ******** の性質を利用しやすくなる。

// C++

Answer: ポリモーフィズム

Source: ../../note/programming/_/chapters/object_oriented.md

====================

ポリモーフィズム（ ******** 、多相性）は、同じ識別子のメソッドで複数の異なる振る舞いを定義することができる性質。

例えば、異なるクラスが同じ名前のメソッドを共通して持つことによって、そのメソッドを通して、暗黙的に複数のオブジェクトを切り替えることができる。この性質を利用することで、オブジェクトを利用している側のソースコードを変更することなくクラスを切り替えることが可能となり、メンテナンス性の向上に繋がる。インタフェースや仮想関数の機能を用いることで、クラスのメソッドのシグネチャを共通化することができ、ポリモーフィズムの性質を利用しやすくなる。

// C++

Answer: ポリモルフィズム

Source: ../../note/programming/_/chapters/object_oriented.md

====================

ポリモーフィズム（ポリモルフィズム、 *** ）は、同じ識別子のメソッドで複数の異なる振る舞いを定義することができる性質。

例えば、異なるクラスが同じ名前のメソッドを共通して持つことによって、そのメソッドを通して、暗黙的に複数のオブジェクトを切り替えることができる。この性質を利用することで、オブジェクトを利用している側のソースコードを変更することなくクラスを切り替えることが可能となり、メンテナンス性の向上に繋がる。インタフェースや仮想関数の機能を用いることで、クラスのメソッドのシグネチャを共通化することができ、ポリモーフィズムの性質を利用しやすくなる。

// C++

Answer: 多相性

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******** は、関数やメソッドが、特定のインタフェース（プロパティやメソッド）を持つ全てのオブジェクトを引数として受け取ることができる性質。ポリモーフィズムの恩恵のひとつで、呼び出される関数（メソッド）は、引数として渡されたデータがどのクラスのオブジェクトであるかを意識する必要がない。

Answer: ダックタイピング

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ** （Dependency Injection: 依存性の注入）は、引数として受け取るオブジェクトがどのクラスのものかに依存せずに、関数やメソッドを実行するという考え方。ダックタイピングにより、共通のインタフェースを持つオブジェクト全てを引数として受け取れるようになり、オブジェクトへの依存性を関数側から縛るのではなく、外部から指定できるようになる。

Answer: DI

Source: ../../note/programming/_/chapters/object_oriented.md

====================

DI（Dependency Injection:  ****** ）は、引数として受け取るオブジェクトがどのクラスのものかに依存せずに、関数やメソッドを実行するという考え方。ダックタイピングにより、共通のインタフェースを持つオブジェクト全てを引数として受け取れるようになり、オブジェクトへの依存性を関数側から縛るのではなく、外部から指定できるようになる。

Answer: 依存性の注入

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ***** は、具体的な実装を持たず、継承されることを前提としたクラス。具象クラスからは直接インスタンスを生成することはできない。オーバライドされることが前提となるメソッドを抽象メソッド（C++では仮想関数）といい、関数のシグネチャのみを記述する。

Answer: 抽象クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

抽象クラスは、具体的な実装を持たず、継承されることを前提としたクラス。具象クラスからは直接インスタンスを生成することはできない。オーバライドされることが前提となるメソッドを ****** （C++では仮想関数）といい、関数のシグネチャのみを記述する。

Answer: 抽象メソッド

Source: ../../note/programming/_/chapters/object_oriented.md

====================

抽象クラスは、具体的な実装を持たず、継承されることを前提としたクラス。具象クラスからは直接インスタンスを生成することはできない。オーバライドされることが前提となるメソッドを抽象メソッド（C++では **** ）といい、関数のシグネチャのみを記述する。

Answer: 仮想関数

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ***** は、抽象クラスを継承して抽象メソッドをオーバライドし、具体的な実装を施したクラス。

Answer: 具象クラス

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******* は、クラスが定義するべきメソッドのシグネチャを示したもので、具体的な実装は持たない。 ******* を実装するクラスは、 ******* に定義されているメソッドを全て実装している必要がある（ default キーワードにより、 ******* にデフォルトの実装を定義することができるプログラミング言語もある）。継承では1つの親クラスからしか性質を引き継げないが、1つのクラスが複数の ******* を実装することは可能。

// Java

//  ******* 
interface RaceMonster
{
    public int level_up( int diff_ );
}

interface RaceDragon
{
    public void powerup();

    default public void bark()
    {
        System.out.println("Growl!!");
    }
}
 
//  ******* を実装したクラス
class Slime implements RaceMonster
{
    public void level_up( int diff_ )
    {
        System.out.println("Level up!");
        this.m_level += diff_;
        return this.m_level;
    }

    private int m_level = 1;
}

// 複数の ******* を実装したクラス
class Dragon implements RaceMonster, RaceDragon
{
    public void level_up( int diff_ )
    {
        System.out.println("Level up!");
        this.m_level += diff_;
        return this.m_level;
    }

    public void powerup()
    {
        System.out.println("Power up!");
        this.m_power += 100;
    }

    private int m_level = 1;
    private int m_power = 100;
}

<?php

// PHP

//  ******* 
interface RaceMonster
{
    public function level_up( $diff_ );
}

interface RaceDragon
{
    public function powerup();
}

//  ******* を実装したクラス
class Slime implements RaceMonster
{
    public function level_up( $diff_ )
    {
        echo("Level up!");
        $this->m_level += $diff_;
        return $this->m_level;
    }

    private $m_level = 1;
}

// 複数の ******* を実装したクラス
class Dragon implements RaceMonster, RaceDragon
{
    public function level_up( $diff_ )
    {
        echo("Level up!");
        $this->m_level += $diff_;
        return $this->m_level;
    }

    public function powerup()
    {
        echo("Power up!");
        $this->m_power += 100;
    }

    private $m_level = 1;
    private $m_power = 100;
}

?>

Answer: インタフェース

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******* は、オブジェクトの初期化を行うための特別なメソッドで、インスタンスの生成時に自動的に実行される。プロパティの初期化や、オブジェクトごとの特別な初期化処理が必要な場合などに用いる。

// C++

Answer: コンストラクタ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ********* は、オブジェクトをインスタンス化した時点で、全てのプロパティが正しく初期化されるようなコンストラクタ。生焼けオブジェクトを防止したり、オブジェクトに不正値が混入しないようにしたりするだけではなく、コードの可読性や保守性も向上させることができる。

 ********* を実装するには、プロパティの初期化に必要な値をコンストラクタの引数として取り、それらの値に対してバリデーションを行った上でプロパティに代入する。

Answer: 完全コンストラクタ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ****** は、オブジェクトの終了処理を行うための特別なメソッドで、インスタンスが破棄されるときに自動的に実行される。ガベージコレクションを用いるプログラミング言語では、 ****** が実行されるタイミングが予測できないため、複雑な処理を行おうとするとバグの発生原因となってしまう場合がある。一方で、C言語のようにプログラマが変数の生存期間を管理する言語においては、インスタンスが管理するヒープ領域の解放を行うなど重要な役割を持っている。

// C++

Answer: デストラクタ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ***** は、メモリ上に静的に配置され、インスタンスとの直接的な関連を持たないメンバ。多くのプログラミング言語では、 static キーワードをつけることでメンバを ***** にすることができる。

Answer: 静的メンバ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 *********** は、オブジェクトに依存せずに独立した変数のように扱えるプロパティ。クラスに属するグローバル変数のようなものとして扱われる。

// C++

Answer: staticプロパティ

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ********** （静的メソッド）は、オブジェクトのメンバとして定義されているものの、インスタンスを必要としないメソッド。全てのインスタンスで共通する処理や、クラスに関連するような関数を使用したい場合に用いる。静的メソッドはインスタンスに依存しないため、 this によるメンバへのアクセスができない。

// C++

Answer: staticメソッド

Source: ../../note/programming/_/chapters/object_oriented.md

====================

staticメソッド（ ****** ）は、オブジェクトのメンバとして定義されているものの、インスタンスを必要としないメソッド。全てのインスタンスで共通する処理や、クラスに関連するような関数を使用したい場合に用いる。 ****** はインスタンスに依存しないため、 this によるメンバへのアクセスができない。

// C++

Answer: 静的メソッド

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ********* は、インスタンス化されたものの、コンストラクタによって必要な初期化が行われていないオブジェクト。通常はオブジェクトをインスタンス化しただけでは、プロパティには値が格納されていない状態であり、この状態でオブジェクトを使用すると、意図しない結果やエラーが発生する可能性がある。

Answer: 生焼けオブジェクト

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ******* は、オブジェクト指向における設計ガイドラインのひとつで、オブジェクトがチェーンするべきなのは、オブジェクトの直接のプロパティだけである、とする考え方。これにより、クラス間の結合を弱くし、変更に対して強い構造にすることができる。

Answer: デメテルの法則

Source: ../../note/programming/_/chapters/object_oriented.md

====================

 ** は、加算や減算、比較といった計算処理。各種 ** を表す記号・シンボルのことを ** 子（オペレータ）、 ** 対象となるデータのことを被 ** 子（オペランド）という。各プログラミング言語で用いられる ** 子は基本的に共通しているものが多い。

Answer: 演算

Source: ../../note/programming/_/chapters/operation.md

====================

演算は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを *** （オペレータ）、演算対象となるデータのことを被 *** （オペランド）という。各プログラミング言語で用いられる *** は基本的に共通しているものが多い。

Answer: 演算子

Source: ../../note/programming/_/chapters/operation.md

====================

演算は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを演算子（ ***** ）、演算対象となるデータのことを被演算子（オペランド）という。各プログラミング言語で用いられる演算子は基本的に共通しているものが多い。

Answer: オペレータ

Source: ../../note/programming/_/chapters/operation.md

====================

演算は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを演算子（オペレータ）、演算対象となるデータのことを **** （オペランド）という。各プログラミング言語で用いられる演算子は基本的に共通しているものが多い。

Answer: 被演算子

Source: ../../note/programming/_/chapters/operation.md

====================

演算は、加算や減算、比較といった計算処理。各種演算を表す記号・シンボルのことを演算子（オペレータ）、演算対象となるデータのことを被演算子（ ***** ）という。各プログラミング言語で用いられる演算子は基本的に共通しているものが多い。

Answer: オペランド

Source: ../../note/programming/_/chapters/operation.md

====================

 **** は、加算や減算、乗算、除算、剰余（モジュロ演算）といった数学的な演算処理。 **** の優先度に関するルールについては、通常の数学で用いられるものと同様である場合が多い。

| 演算                 | 演算子 | |----------------------|--------| | 加算                 | +    | | 減算                 | -    | | 乗算                 | *    | | 除算                 | /    | | 剰余（モジュロ演算） | %    |

Answer: 算術演算

Source: ../../note/programming/_/chapters/operation.md

====================

 **** （関係演算）は、左右のオペランドを比較して、結果として真偽値を返却するような演算。プログラミング言語によっては、等価・非等価の演算は型の比較を行わず、曖昧な結果を返却する場合もある（文字型の '1' と整数型の 1 を同値として扱うなど）。このような言語では、型の比較も同時に行う厳密な等価・非等価の演算子として、 === および !== を用いることが一般的である。

| 演算                     | 演算子 | |--------------------------|--------| | 大なり                   | >    | | 大なりイコール           | >=   | | 小なり                   | <    | | 小なりイコール           | <=   | | イコール（同値）         | ==   | | ノットイコール（非同値） | !=   |

Answer: 比較演算

Source: ../../note/programming/_/chapters/operation.md

====================

比較演算（ **** ）は、左右のオペランドを比較して、結果として真偽値を返却するような演算。プログラミング言語によっては、等価・非等価の演算は型の比較を行わず、曖昧な結果を返却する場合もある（文字型の '1' と整数型の 1 を同値として扱うなど）。このような言語では、型の比較も同時に行う厳密な等価・非等価の演算子として、 === および !== を用いることが一般的である。

| 演算                     | 演算子 | |--------------------------|--------| | 大なり                   | >    | | 大なりイコール           | >=   | | 小なり                   | <    | | 小なりイコール           | <=   | | イコール（同値）         | ==   | | ノットイコール（非同値） | !=   |

Answer: 関係演算

Source: ../../note/programming/_/chapters/operation.md

