====================

 **** は、2進数において負の数を表現する際に用いられる表現方法。2進数では、符号ビットを含めた全てのビットを反転したものが1の補数（ある数に対して足し合わせても桁が上がらない最大の数）となるので、それに1を加算することで求めることができる。

 **** を使用する理由は、1の補数を用いるよりも表現できる数の範囲が $1$ 広いためである。nビットの2進数が表現できる数の範囲は、1の補数を用いた場合は $-(2^{n-1} - 1) \sim (2^{n-1} - 1)$ 、 **** を用いた場合は $-2^{n-1} \sim (2^{n-1} - 1)$ となる。これは1の補数では $0$ が正と負の2種類存在してしまうためであり、通常はこれらを区別する必要はないため、 **** が利用される。

Answer: 2の補数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

2の補数は、2進数において負の数を表現する際に用いられる表現方法。2進数では、符号ビットを含めた全てのビットを反転したものが **** （ある数に対して足し合わせても桁が上がらない最大の数）となるので、それに1を加算することで求めることができる。

2の補数を使用する理由は、 **** を用いるよりも表現できる数の範囲が $1$ 広いためである。nビットの2進数が表現できる数の範囲は、 **** を用いた場合は $-(2^{n-1} - 1) \sim (2^{n-1} - 1)$ 、2の補数を用いた場合は $-2^{n-1} \sim (2^{n-1} - 1)$ となる。これは **** では $0$ が正と負の2種類存在してしまうためであり、通常はこれらを区別する必要はないため、2の補数が利用される。

Answer: 1の補数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ****** は、コンピュータ上で小数を表現する方法のひとつで、整数部と小数部の桁数をあらかじめ決めておいて、それぞれを固定したビット幅で表現する数値。あらかじめ小数点の位置を決めておくので扱いやすい一方で、表現できる数値の範囲が限定されてしまう。一方で、浮動小数点数よりも高速で処理できるという利点がある。

Answer: 固定小数点数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ****** は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

 ****** では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された ****** には単精度形式と倍精度形式があり、単精度形式では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、倍精度形式では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 浮動小数点数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{ *** }^{\rm{指数部}}$ の形式で考える。

•  *** は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には単精度形式と倍精度形式があり、単精度形式では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、倍精度形式では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 基数部

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{ *** }) \rm{仮数部} \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
•  *** は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には単精度形式と倍精度形式があり、単精度形式では32ビット（ *** 1ビット、指数部8ビット、仮数部23ビット）、倍精度形式では64ビット（ *** 1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 符号部

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す *** を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{基数部}^{\rm{ *** }}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
•  *** には基数に対する *** 分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して *** で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と *** を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には単精度形式と倍精度形式があり、単精度形式では32ビット（符号部1ビット、 *** 8ビット、仮数部23ビット）、倍精度形式では64ビット（符号部1ビット、 *** 11ビット、仮数部52ビット）で表現する。

Answer: 指数部

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す *** と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{ *** } \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
•  *** には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、 *** で有効桁数を確保して指数部で大きさを表現する。 *** の最上位ビットが $0$ にならないように *** と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には単精度形式と倍精度形式があり、単精度形式では32ビット（符号部1ビット、指数部8ビット、 *** 23ビット）、倍精度形式では64ビット（符号部1ビット、指数部11ビット、 *** 52ビット）で表現する。

Answer: 仮数部

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には *** した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、 *** という。

IEEE754によって規定された浮動小数点数には単精度形式と倍精度形式があり、単精度形式では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、倍精度形式では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 正規化

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には ***** と倍精度形式があり、 ***** では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、倍精度形式では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 単精度形式

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

浮動小数点数は、コンピュータ上で小数を表現する方法のひとつで、桁の並びを表す仮数部と、小数点の位置を表す指数部を用いて数を表現する。限られたバイト数の中で効率よく小数を表現するための方法で、固定小数点数に比べて同じビット数でも広い範囲の数を表すことができる。

浮動小数点数では数を $\rm{数値} = (\rm{符号部}) \rm{仮数部} \times \rm{基数部}^{\rm{指数部}}$ の形式で考える。

• 基数部は2進数であれば必ず $2$ となる（n進数では $n$ となる）
• 符号部は数の正負を表す
• 指数部には基数に対する指数部分を2進数で表記したものを格納する
• 仮数部には正規化した小数点数以下の値を格納する

小数点数の演算では精度が重要になるため、仮数部で有効桁数を確保して指数部で大きさを表現する。仮数部の最上位ビットが $0$ にならないように仮数部と指数部を調整することで有効桁数を最大にすることを、正規化という。

IEEE754によって規定された浮動小数点数には単精度形式と ***** があり、単精度形式では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、 ***** では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

Answer: 倍精度形式

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ****** (Binary Coded Decimal)は、10進数の1桁を2進数の4桁（1ビット=1ニブル）に対応させて表現する符号化形式。これは、数字を表すコードの基本となっている。

 ****** は10進数を直接扱うことができるため、10進数の計算を行う際に、丸め誤差を気にする必要がなくなる。

| 10進数 |  ******  | | -----: | --------: | |    $0$ |    $0000$ | |    $1$ |    $0001$ | |    $2$ |    $0010$ | |    $3$ |    $0011$ | |    $4$ |    $0100$ | |    $5$ |    $0101$ | |    $6$ |    $0110$ | |    $7$ |    $0111$ | |    $8$ |    $1000$ | |    $9$ |    $1001$ |

Answer: BCDコード

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ******* （アンパック10進数）は、10進数を1バイトで表現する方法で、上位4ビット（ゾーン部）は文字コードの種類や特別な情報を表し、下位4ビットは数値を表すBCDコードが入る。また、最下位桁のゾーン部は符号部として使用される。

JISコード形式では数字を表す文字の上位4ビットを $0011$ としている。また符号部は数が正の場合は $1100$ (C)、負の場合は $1101$ (D)となる。

Answer: ゾーン10進数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

ゾーン10進数（ ********* ）は、10進数を1バイトで表現する方法で、上位4ビット（ゾーン部）は文字コードの種類や特別な情報を表し、下位4ビットは数値を表すBCDコードが入る。また、最下位桁のゾーン部は符号部として使用される。

JISコード形式では数字を表す文字の上位4ビットを $0011$ としている。また符号部は数が正の場合は $1100$ (C)、負の場合は $1101$ (D)となる。

Answer: アンパック10進数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

ゾーン10進数（アンパック10進数）は、10進数を1バイトで表現する方法で、上位4ビット（ **** ）は文字コードの種類や特別な情報を表し、下位4ビットは数値を表すBCDコードが入る。また、最下位桁の **** は符号部として使用される。

JISコード形式では数字を表す文字の上位4ビットを $0011$ としている。また符号部は数が正の場合は $1100$ (C)、負の場合は $1101$ (D)となる。

Answer: ゾーン部

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ******* は、10進数1桁をBCDコードで表現し、最下位の4ビットに符号を付加する。 ******* は必ずバイト単位で扱われ、偶数桁の場合は符号部を含めて8ビットの倍数にならないため、先頭に $0000$ を追加する。

Answer: パック10進数

Source: ../../note/basics/discrete_mathematics/_/chapters/numeric_representation.md

====================

 ****** (Positional notation)は、数値を表現する方法のひとつで、あらかじめ決められた $n$ 種類の記号により数を表現する。一般的には、記号としてアラビア数字やアルファベットを使用するが、それ以外のもの（漢数字など）を用いてもよい。

位取り基数法のなかでも一般的に利用されているのは10進法で、コンピュータの世界では2進法や8進法、16進法もよく利用される。

基数となる自然数 $n$ に対して、

$$ 0, 1, \cdots, n-1 $$

の数字に任意の記号を対応させる。これを、

$$ a_m a_{m-1} \cdots a_0.b_1 b_2 \cdots b_k $$

という数値列で表現すると、この基数で表される数字列は、n進数で次の数字を表す。

$$ a_m \times n^m + a_{m-1} \times n^{m-1} + \cdots a_1 \times n + a_0 + \frac{b_1}{n} + \frac{b_2}{n^2} +\cdots + \frac{b_k}{n^k} $$

Answer: 位取り記数法

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 ** (Radix)は、位取り記数法で数を表現する際に、各桁の重み付けの基本となる数。 ** が $n$ のときの位取り記数法のことをn進数（n進法）という。

10進数の $123$ は ** が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。

位取り記数法で表された数の各桁には ** による重みがかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $\frac{1}{n}$ 倍となる。

 ** が異なる数値同士の演算を行う場合には、最初に ** をどちらかに揃える（ ** 変換を行う）必要がある。

Answer: 基数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

基数(Radix)は、位取り記数法で数を表現する際に、各桁の重み付けの基本となる数。基数が $n$ のときの位取り記数法のことを *** （n進法）という。

10進数の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。

位取り記数法で表された数の各桁には基数による重みがかかっており、 *** においては1桁目から順番に $n^0, n^1, n^2 \cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $\frac{1}{n}$ 倍となる。

基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（基数変換を行う）必要がある。

Answer: n進数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

基数(Radix)は、位取り記数法で数を表現する際に、各桁の重み付けの基本となる数。基数が $n$ のときの位取り記数法のことをn進数（ *** ）という。

10進数の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。

位取り記数法で表された数の各桁には基数による重みがかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \cdots$ という重みになる。ある桁の1つ上の桁の重みは $n$ 倍となり、1つ下の桁の重みは $\frac{1}{n}$ 倍となる。

基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（基数変換を行う）必要がある。

Answer: n進法

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

基数(Radix)は、位取り記数法で数を表現する際に、各桁の ** 付けの基本となる数。基数が $n$ のときの位取り記数法のことをn進数（n進法）という。

10進数の $123$ は基数が10であり、100の位が $1$ 、10の位が $2$ 、1の位が $3$ となっている。

位取り記数法で表された数の各桁には基数による ** がかかっており、n進数においては1桁目から順番に $n^0, n^1, n^2 \cdots$ という ** になる。ある桁の1つ上の桁の ** は $n$ 倍となり、1つ下の桁の ** は $\frac{1}{n}$ 倍となる。

基数が異なる数値同士の演算を行う場合には、最初に基数をどちらかに揃える（基数変換を行う）必要がある。

Answer: 重み

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 **** は、最も身近な位取り記数法で、 $0$ から $9$ までの10つの数字を用いて数を表現する。1つの桁は $10$ になると位が上がる。ある桁の1つ上の桁は重みが $10$ 倍になり、1つ下の桁は重みが $\frac{1}{10}$ 倍になる。

例えば、 $123.456_{10}$ は、位取り記数法の定義より次のように表現できる。

$$ 1 \times 10^2 + 2 \times 10^1 + 3 \times 10^0 + 4 \times 10^{-1} + 5 \times 10^{-2} + 6 \times 10^{-3} = 123.456 $$

Answer: 10進数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 *** は、コンピュータ内部のデータを表現するために使用されてる位取り記数法で、 $0$ と $1$ の2つの数字を用いて数を表現する。1つの桁は $2$ になると位が上がる。ある桁の1つ上の桁は重みが $2$ 倍になり、1つ下の桁は重みが $\frac{1}{2}$ 倍になる。

 ***  $n$ 桁で表現できる数は、1桁なら2通り、2桁なら4通り、3桁なら8通り、8桁なら256通りといった具合に、 $2^n$ 通りとなる。

例えば、 $101.001_2$ は10進数で次の数を表している。

$$ 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} = 5.125 $$

Answer: 2進数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 *** は、コンピュータ内部のデータを表現するために使用されることのある位取り記数法で、 $0$ から $7$ までの8つの数字を用いて数を表現する。1つの桁は $8$ になると位が上がる。ある桁の1つ上の桁は重みが $8$ 倍になり、1つ下の桁は重みが $\frac{1}{8}$ 倍になる。

2進数の3桁を1つにまとめたものと等価となり、2進数との基数変換が容易である。

例えば、 $123.456_8$ は10進数で次の数を表している。

$$ 1 \times 8^2 + 2 \times 8^1 + 3 \times 8^0 + 4 \times 8^{-1} + 5 \times 8^{-2} + 6 \times 8^{-3} \simeq 83.590 $$

Answer: 8進数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 **** は、コンピュータ内部のデータを表現するために使用されることのある位取り記数法で、 $0$ から $9$ までの10つの数字と $\rm{A}$ から $\rm{F}$ までのアルファベットを用いて数を表現する。1つの桁は $16$ になると位が上がる。ある桁の1つ上の桁は重みが $16$ 倍になり、1つ下の桁は重みが $\frac{1}{16}$倍になる。

2進数の4桁を1つにまとめたものと等価となり、2進数との基数変換が容易である。

例えば $123.\rm{ABC}_{16}$ は10進数で次の数を表している。

$$ 1 \times 16^2 + 2 \times 16^1 + 3 \times 16^0 + 10 \times 16^{-1} + 11 \times 16^{-2} + 12 \times 16^{-3} \simeq 291.671 $$

Answer: 16進数

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 **** は、ある基数で表された数を別の基数で表現するための計算。一般的には数を10進数で表現することが多いため、10進数とn進数との変換が重要となる。

Answer: 基数変換

Source: ../../note/basics/discrete_mathematics/_/chapters/radix.md

====================

 ** は、一定の規則に従ってまとめられた要素の集まり。要素の数や種類、順序などには一切意味を持たない。

 ** は中括弧を用いて表現される。例えば、 $\lbrace 1, 2, 3 \rbrace$ という ** は、要素が $1, 2, 3$ からなっていることを表す。

 ** には和 ** や積 ** 、差 ** 、補 ** などの演算があり、これらを用いてより複雑な ** を表現することができる。

Answer: 集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 ** は、集合において、その集合に属する個々のもののことで、数字や文字、形、色、音などどのようなものでもよい。

Answer: 要素

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** は、複数の集合同士の関係や、集合の範囲を図として表現したもの。 *** を用いることで、複数の集合がどのように重なり合い、共通する要素を持つのかといったことを可視化することができる。

 *** は一般的に円や楕円といった閉曲線を用いて表現される。それぞれの円や楕円は1つの集合を表し、集合の要素をその中に表記する。2つ以上の集合が共通する要素を持つ場合、それらの円や楕円は重なり合う図となる。

Answer: ベン図

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 **** は、考える対象となる要素をすべて含む、包括的な集合。例えば、自然数を集めた集合の **** は $0$ を含む正の整数全体を含み、実数を集めた集合の **** は、有理数と無理数を含む全ての数を含む。

Answer: 全体集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 **** は、ある集合から取り出され、その要素全てが元の集合の一部であるような集合。2つの集合 $A, B$ の要素が全て同じであるとき、 $A$ は $B$ の **** であると同時に、 $B$ も $A$ の **** となる。

$A$ が $B$ の **** で、 $A$ と $B$ が同じ集合ではない時、 $A$ は $B$ の真 **** であるという。

 **** のベン図

Answer: 部分集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

部分集合は、ある集合から取り出され、その要素全てが元の集合の一部であるような集合。2つの集合 $A, B$ の要素が全て同じであるとき、 $A$ は $B$ の部分集合であると同時に、 $B$ も $A$ の部分集合となる。

$A$ が $B$ の部分集合で、 $A$ と $B$ が同じ集合ではない時、 $A$ は $B$ の ***** であるという。

部分集合のベン図

Answer: 真部分集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** は、全体集合の要素のうち、ある集合が持っていない全ての要素を含む集合。

 *** のベン図

Answer: 補集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** は、複数の集合のうち、少なくともいずれかひとつに属している要素を集めた集合。

 *** のベン図

Answer: 和集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** は、複数の集合のうち、全ての集合に属している要素を集めた集合。

 *** のベン図

Answer: 積集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** は、2つの集合のうち、一方の集合の要素からもう一方の集合に含まれる要素を除いた集合。

 *** のベン図

Answer: 差集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 ***** は、2つの集合のうち、どちらか一方だけに属する要素を集めた集合。

 ***** のベン図

Answer: 対称差集合

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 ** は、正誤が明確にできる文章や条件式のことで、真偽値をとる。例えば、 $1 + 1 = 2$ という数式は、真である ** 。

Answer: 命題

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 *** （ブール値）は、真(true)または偽(false)のどちらかをとるような値。2進数においては $0$ を真、 $1$ を偽（あるいはその逆）として1ビットで表現することができる。

Answer: 真偽値

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

真偽値（ **** ）は、真(true)または偽(false)のどちらかをとるような値。2進数においては $0$ を真、 $1$ を偽（あるいはその逆）として1ビットで表現することができる。

Answer: ブール値

Source: ../../note/basics/discrete_mathematics/_/chapters/set_and_proposition.md

====================

 ****** は、入力とその時の状態によって出力が決定される機会をモデル化したもの。コンピュータの動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。 ****** のうち、初期状態からいくつかの状態を遷移して受理状態で終了するものを有限 ****** という。

Answer: オートマトン

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

オートマトンは、入力とその時の状態によって出力が決定される機会をモデル化したもの。コンピュータの動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、 **** からいくつかの状態を遷移して受理状態で終了するものを有限オートマトンという。

Answer: 初期状態

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

オートマトンは、入力とその時の状態によって出力が決定される機会をモデル化したもの。コンピュータの動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、初期状態からいくつかの状態を遷移して **** で終了するものを有限オートマトンという。

Answer: 受理状態

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

オートマトンは、入力とその時の状態によって出力が決定される機会をモデル化したもの。コンピュータの動きを数学的な観点からモデル化することで、問題解決のための処理手順を定式化することができる。オートマトンのうち、初期状態からいくつかの状態を遷移して受理状態で終了するものを ******** という。

Answer: 有限オートマトン

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

 ***** は、オートマトンの状態遷移を表で表したもの。

以下は、A～Eまでの状態をとり得るオートマトンの ***** の例である。

| 遷移元 \ 遷移先 |  A     |  B  |  C  |  D  |  E  | | --------------- | ------ | --- | --- | --- | --- | | A               | $0$    | $1$ |     |     |     | | B               | $0$    |     |     | $1$ |     | | C               | $0$    |     |     |     | $1$ | | D               | $0$    |     | $1$ |     |     | | E               | $0, 1$ |     |     |     |     |

Answer: 状態遷移表

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

 ***** は、オートマトンの状態遷移を図で表したもの。矢印と丸のセットで表したものが初期状態で、二重丸で表したものが受理状態。

以下は、A～Eまでの状態をとり得るオートマトンの ***** の例である。

オートマトンの ***** 

Answer: 状態遷移図

Source: ../../note/basics/information_theory/_/chapters/automaton.md

====================

 ***** は、コンピュータ内部で文字を2進数のビットパターンに割り当てたもの。 ***** には複数の体系が存在しており、情報をやり取りするためにはコード体系が合致している必要がある。

Answer: 文字コード

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ******** は、コンピュータ上で1文字を複数バイトで表現するような体系。アルファベットや数字、一部の記号は、ASCIIコードにより1バイトで表現することができるが、全角カナや漢字などは1バイトでは表現しきれないため ******** を用いる。

Answer: マルチバイト文字

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ******** は、1文字を7ビットの符号と誤り検出用のパリティビット1ビットで表現した文字コード。基本的にはアルファベットと数字、記号に用いられており、日本語などは文字種が多いため7ビットでは多くの文字は表現しきれない。

Answer: ASCIIコード

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ****** は、UNIX上で2バイト文字と1バイト文字を混在して用いる文字コード。

Answer: EUCコード

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ****** は、漢字やひらがなを含む文字コードで、漢字やひらがなは2バイト、英数字や記号は1バイトで表現される。

Answer: JISコード

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ********* は、JISコードをシフトすることでASCIIコードとの混在を可能とした文字コード。日本語を扱うパソコンで標準的に利用されている。

Answer: シフトJISコード

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ******* は、世界各国の文字体系全てに対応するための文字コード。すべての文字を2バイトで表現する。

UTF-8、UTF-16、UTF-32の3つのエンコーディング方式により符号化される。

Answer: Unicode

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

Unicodeは、世界各国の文字体系全てに対応するための文字コード。すべての文字を2バイトで表現する。

 ***** 、UTF-16、UTF-32の3つのエンコーディング方式により符号化される。

Answer: UTF-8

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

Unicodeは、世界各国の文字体系全てに対応するための文字コード。すべての文字を2バイトで表現する。

UTF-8、 ****** 、UTF-32の3つのエンコーディング方式により符号化される。

Answer: UTF-16

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

Unicodeは、世界各国の文字体系全てに対応するための文字コード。すべての文字を2バイトで表現する。

UTF-8、UTF-16、 ****** の3つのエンコーディング方式により符号化される。

Answer: UTF-32

Source: ../../note/basics/information_theory/_/chapters/character_representation.md

====================

 ** は、データの意味を変えずにデータの容量を小さくする処理。 ** を行うことで、記憶容量の節減や、伝送時間の短縮ができる。

Answer: 圧縮

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 *** は、圧縮によってデータの容量をどれだけ小さくできるかという指標。

Answer: 圧縮率

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 **** は、圧縮したデータを解凍したときに完全に元の状態に戻せるような圧縮。ただし、圧縮には限界があるため、非 **** に比べて圧縮率は小さくなる。

Answer: 可逆圧縮

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ***** は、圧縮したデータを解凍したときにデータが品質劣化を起こすような圧縮。圧縮率は可逆圧縮に比べて高いものの、完全に元のデータに戻すことはできない。

Answer: 非可逆圧縮

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ** （伸張、展開）は、圧縮したデータを元の状態に復元する処理。

Answer: 解凍

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

解凍（ ** 、展開）は、圧縮したデータを元の状態に復元する処理。

Answer: 伸張

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

解凍（伸張、 ** ）は、圧縮したデータを元の状態に復元する処理。

Answer: 展開

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ****** は、圧縮したデータの解凍をそのデータの情報自身でできるような形式。

Answer: 自己解凍形式

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ***** は、情報源で転送前にデータを効率的に圧縮することを目的とする符号化。

Answer: 情報源符号

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ******* は、ファイル圧縮の技術のひとつで、可逆圧縮。出現回数の多い文字を短いビット列に、出現回数の少ない文字を長いビット列に置き換えることでファイルサイズを小さくする。

Answer: ハフマン符号化

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ********* は、主に画像ファイルに用いられる圧縮技術のひとつで、可逆圧縮。連続する同一の値を、 $\rm{値} \times \rm{回数}$ という情報に置き換える。単純な画像データほど圧縮率が高い。

Answer: ランレングス符号化

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ***** （通信路符号）とは、データ伝送時に通信路上のノイズに対応するために冗長ビットを付加する符号化。

• 通信理論 - 伝送理論 - 誤り検出と訂正

Answer: 伝送路符号

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

伝送路符号（ ***** ）とは、データ伝送時に通信路上のノイズに対応するために冗長ビットを付加する符号化。

• 通信理論 - 伝送理論 - 誤り検出と訂正

Answer: 通信路符号

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 **** とは、データを連続的に変化していく量（連続値）で表したもの。 **** データは、通信の際にノイズの影響を受けやすく、完全な複製を行うことができないため、時間の経過やコピーによって情報が劣化する。

Answer: アナログ

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 **** とは、データを一定の間隔で区切った値（離散値）で表したもの。 **** データは、コンピュータによる処理がしやすく、通信時のノイズによる情報の劣化にも強い。ただし値を近似値として記録しているため、正確な値をデータにすることはできない。

自然界に存在するほとんどの情報は、人間が観測するスケールにおいてはアナログであるが、アナログデータはコンピュータでは扱いにくいので **** データへの変換（A/D変換）がよく行われる。

アナログと **** 

Answer: デジタル

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ****** （バイトオーダ）は、複数のバイトなどを並べる際の方式。 ****** はCPUによって決まっており、異なる機器間でデータをやり取りする際は ****** に留意する必要がある。

Answer: エンディアン

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

エンディアン（ ****** ）は、複数のバイトなどを並べる際の方式。エンディアンはCPUによって決まっており、異なる機器間でデータをやり取りする際はエンディアンに留意する必要がある。

Answer: バイトオーダ

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ********* は、複数のバイトで構成されるデータを上位バイトから下位バイトの順に取り扱う手法。

Answer: ビッグエンディアン

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 ********* は、複数のバイトで構成されるデータを下位バイトから上位バイトの順に取り扱う手法。

Answer: リトルエンディアン

Source: ../../note/basics/information_theory/_/chapters/coding_theory.md

====================

 *** は、コンピュータが直接処理することができる、バイナリで記述された命令の集まり。 *** の命令パターン1つのことをオペコードという。

2進数は人間にとっては直接記述するのに向いていないので、プログラミング言語のソースコードを作成し、それを言語プロセッサによって *** に変換するのが一般的。

Answer: 機械語

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

機械語は、コンピュータが直接処理することができる、バイナリで記述された命令の集まり。機械語の命令パターン1つのことを ***** という。

2進数は人間にとっては直接記述するのに向いていないので、プログラミング言語のソースコードを作成し、それを言語プロセッサによって機械語に変換するのが一般的。

Answer: オペコード

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 ******* は、機械語のオペコードに1対1で対応する、英単語や記号によって命令を記述した言語。オペコードに対応した ******* の各命令のことをニーモニックという。

Answer: アセンブリ言語

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

アセンブリ言語は、機械語のオペコードに1対1で対応する、英単語や記号によって命令を記述した言語。オペコードに対応したアセンブリ言語の各命令のことを ****** という。

Answer: ニーモニック

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 ******* は、ソースコードを機械語に変換するためのプログラム。 ******* には、アセンブラやコンパイラ、インタプリタなどがある。

Answer: 言語プロセッサ

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 ***** は、アセンブリ言語を機械語に変換するためのプログラム。アセンブリ言語を機械語に変換することをアセンブルという。

Answer: アセンブラ

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

アセンブラは、アセンブリ言語を機械語に変換するためのプログラム。アセンブリ言語を機械語に変換することを ***** という。

Answer: アセンブル

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 ***** は、ソースコードを解析して機械語に変換するためのプログラム。 ***** によってソースコード単位で生成された機械語プログラムのことをオブジェクトコードという。

プログラミング言語で書かれたソースコードを機械語に変換することをコンパイルという。

Answer: コンパイラ

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

コンパイラは、ソースコードを解析して機械語に変換するためのプログラム。コンパイラによってソースコード単位で生成された機械語プログラムのことを ********* という。

プログラミング言語で書かれたソースコードを機械語に変換することをコンパイルという。

Answer: オブジェクトコード

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

コンパイラは、ソースコードを解析して機械語に変換するためのプログラム。コンパイラによってソースコード単位で生成された機械語プログラムのことをオブジェクトコードという。

プログラミング言語で書かれたソースコードを機械語に変換することを ***** という。

Answer: コンパイル

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 **** は、ソースコードを最小の単位の語句であるトークンに分解する処理。

Answer: 字句解析

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

字句解析は、ソースコードを最小の単位の語句である **** に分解する処理。

Answer: トークン

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 **** は、トークンの並びを定められた文法によって解析する処理。

Answer: 構文解析

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 **** は、トークンの並びを意味を考慮して解析する処理。

Answer: 意味解析

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 *** は、プログラムの高速化やサイズの縮小のための処理。

Answer: 最適化

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 *** は、コンパイラが生成したオブジェクトコードをつなぎ合わせてコンピュータが実行できるようにするためのプログラム。

 *** によってオブジェクトコードをつなぎ合わせる処理をリンクという。

Answer: リンカ

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

リンカは、コンパイラが生成したオブジェクトコードをつなぎ合わせてコンピュータが実行できるようにするためのプログラム。

リンカによってオブジェクトコードをつなぎ合わせる処理を *** という。

Answer: リンク

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 ****** は、ソースコードを部分的に解釈しながら並行して実行するためのプログラム。

Answer: インタプリタ

Source: ../../note/basics/information_theory/_/chapters/compiler_theory.md

====================

 *** （オーダ）は、アルゴリズムの性能を評価するための指標。 *** は、扱うデータの件数が増えるにつれてどのような割合で計算回数が増加するかを評価する。

単に *** というと、時間 *** のことを指す場合が多い。

Answer: 計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

計算量（ *** ）は、アルゴリズムの性能を評価するための指標。計算量は、扱うデータの件数が増えるにつれてどのような割合で計算回数が増加するかを評価する。

単に計算量というと、時間計算量のことを指す場合が多い。

Answer: オーダ

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

 ***** は、アルゴリズムの計算回数を基にアルゴリズムの性能を評価するための指標。

Answer: 時間計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

 ***** （領域計算量）は、アルゴリズムのメモリ使用量を基にアルゴリズムの性能を評価するための指標。

Answer: 空間計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

空間計算量（ ***** ）は、アルゴリズムのメモリ使用量を基にアルゴリズムの性能を評価するための指標。

Answer: 領域計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

 ***** は、アルゴリズムが扱うデータ数が同じであってもケースによって計算回数が変動する場合や、アルゴリズムが乱数を使う場合において、最も悪いケースの計算量。一般的には計算時間を ***** によって見積もることが多い。

Answer: 最悪計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

====================

 ***** は、アルゴリズムが扱うデータ数が同じであってもケースによって計算回数が変動する場合や、アルゴリズムが乱数を使う場合において、平均となる計算量。大半のアルゴリズムでは、最悪計算量と一致する。

Answer: 平均計算量

Source: ../../note/basics/information_theory/_/chapters/computational_complexity.md

