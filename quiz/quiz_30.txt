====================

 **** は、左側のオペランドに対して右側のオペランドの値を代入する演算。また代入の際に、左側のオペランドの元の値と右側のオペランドの算術演算を行った結果の再代入を行う、複合 **** をサポートするプログラミング言語もある。

| 演算         | 演算子 | |--------------|--------| | 代入         | =    | | 加算して代入 | +=   | | 減算して代入 | -=   | | 乗算して代入 | *=   | | 除算して代入 | /=   | | 剰余を代入   | %=   |

Answer: 代入演算

Source: ../../note/programming/_/chapters/operation.md

====================

代入演算は、左側のオペランドに対して右側のオペランドの値を代入する演算。また代入の際に、左側のオペランドの元の値と右側のオペランドの算術演算を行った結果の再代入を行う、 ****** をサポートするプログラミング言語もある。

| 演算         | 演算子 | |--------------|--------| | 代入         | =    | | 加算して代入 | +=   | | 減算して代入 | -=   | | 乗算して代入 | *=   | | 除算して代入 | /=   | | 剰余を代入   | %=   |

Answer: 複合代入演算

Source: ../../note/programming/_/chapters/operation.md

====================

 **** は、オペランドに真偽値をとり、複数の条件を組み合わせた新しい条件を評価する演算。 **** 子を組み合わせることで、複雑な条件を表現することができる。

| 演算        | 演算子 | 概要                                                            | |-------------|--------|-----------------------------------------------------------------| | 論理積(AND) | &&   | 左右のオペランドが両方 true であれば true                   | | 論理和(OR)  | ||   | 左右のオペランドの一方でも true であれば true               | | 否定(NOT)   | !    | オペランドが true であれば false 、 false であれば true |

Answer: 論理演算

Source: ../../note/programming/_/chapters/operation.md

====================

 *********** （短絡評価)は、論理演算において、左辺を評価した段階で式全体の値が定まらない場合のみ右辺を評価する方法。例として、論理積の左辺が false であれば式全体は必ず false になり、論理和の左辺が true であれば式全体は必ず true になることから、右辺は評価する必要がない。このような性質を利用して評価を途中で打ち切ることで、効率的にプログラムを実行するのがこの方法を利用する利点である。

Answer: ショートサーキット評価

Source: ../../note/programming/_/chapters/operation.md

====================

ショートサーキット評価（ **** )は、論理演算において、左辺を評価した段階で式全体の値が定まらない場合のみ右辺を評価する方法。例として、論理積の左辺が false であれば式全体は必ず false になり、論理和の左辺が true であれば式全体は必ず true になることから、右辺は評価する必要がない。このような性質を利用して評価を途中で打ち切ることで、効率的にプログラムを実行するのがこの方法を利用する利点である。

Answer: 短絡評価

Source: ../../note/programming/_/chapters/operation.md

====================

 ***** は、オペランドをビット列とみなして、ビット単位での演算を行う。

| 演算           | 演算子 | 概要                                                                                        | |----------------|--------|---------------------------------------------------------------------------------------------| | ビットAND      | &    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           | | ビットOR       | |    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す | | ビットXOR      | ^    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  | | ビットNOT      | ~    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   | | 右ビットシフト | >>   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          | | 左ビットシフト | <<   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |

右ビットシフトは1ビットシフトするごとに値が元の $1/2$ 倍になり、左ビットシフトは1ビットシフトするごとに値が元の $2$ 倍になる。

論理ビットシフトでは、シフト演算後の空きビットを常に 0 で初期化する。算術ビットシフトでは、右シフトを行った後の空きビットを符号ビットで初期化する。

Answer: ビット演算

Source: ../../note/programming/_/chapters/operation.md

====================

ビット演算は、オペランドをビット列とみなして、ビット単位での演算を行う。

| 演算           | 演算子 | 概要                                                                                        | |----------------|--------|---------------------------------------------------------------------------------------------| | ビットAND      | &    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           | | ビットOR       | |    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す | | ビットXOR      | ^    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  | | ビットNOT      | ~    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   | |  *******  | >>   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          | | 左ビットシフト | <<   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |

 ******* は1ビットシフトするごとに値が元の $1/2$ 倍になり、左ビットシフトは1ビットシフトするごとに値が元の $2$ 倍になる。

論理ビットシフトでは、シフト演算後の空きビットを常に 0 で初期化する。算術ビットシフトでは、右シフトを行った後の空きビットを符号ビットで初期化する。

Answer: 右ビットシフト

Source: ../../note/programming/_/chapters/operation.md

====================

ビット演算は、オペランドをビット列とみなして、ビット単位での演算を行う。

| 演算           | 演算子 | 概要                                                                                        | |----------------|--------|---------------------------------------------------------------------------------------------| | ビットAND      | &    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           | | ビットOR       | |    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す | | ビットXOR      | ^    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  | | ビットNOT      | ~    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   | | 右ビットシフト | >>   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          | |  *******  | <<   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |

右ビットシフトは1ビットシフトするごとに値が元の $1/2$ 倍になり、 ******* は1ビットシフトするごとに値が元の $2$ 倍になる。

論理ビットシフトでは、シフト演算後の空きビットを常に 0 で初期化する。算術ビットシフトでは、右シフトを行った後の空きビットを符号ビットで初期化する。

Answer: 左ビットシフト

Source: ../../note/programming/_/chapters/operation.md

====================

ビット演算は、オペランドをビット列とみなして、ビット単位での演算を行う。

| 演算           | 演算子 | 概要                                                                                        | |----------------|--------|---------------------------------------------------------------------------------------------| | ビットAND      | &    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           | | ビットOR       | |    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す | | ビットXOR      | ^    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  | | ビットNOT      | ~    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   | | 右ビットシフト | >>   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          | | 左ビットシフト | <<   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |

右ビットシフトは1ビットシフトするごとに値が元の $1/2$ 倍になり、左ビットシフトは1ビットシフトするごとに値が元の $2$ 倍になる。

 ******** では、シフト演算後の空きビットを常に 0 で初期化する。算術ビットシフトでは、右シフトを行った後の空きビットを符号ビットで初期化する。

Answer: 論理ビットシフト

Source: ../../note/programming/_/chapters/operation.md

====================

ビット演算は、オペランドをビット列とみなして、ビット単位での演算を行う。

| 演算           | 演算子 | 概要                                                                                        | |----------------|--------|---------------------------------------------------------------------------------------------| | ビットAND      | &    | 左右のオペランドをビット列として比較し、両方1のビットのみを1にしたビット列を返す           | | ビットOR       | |    | 左右のオペランドをビット列として比較し、どちらか一方が1のビットのみを1にしたビット列を返す | | ビットXOR      | ^    | 左右のオペランドをビット列として比較して、異なる値を持つビットのみを1にしたビット列を返す  | | ビットNOT      | ~    | オペランドをビット列として識別し、全てのビットを反転させたビット列を返す                   | | 右ビットシフト | >>   | オペランドをビット列として識別し、全てのビットを右に1ビットずらしたビット列を返す          | | 左ビットシフト | <<   | オペランドをビット列として識別し、全てのビットを左に1ビットずらしたビット列を返す          |

右ビットシフトは1ビットシフトするごとに値が元の $1/2$ 倍になり、左ビットシフトは1ビットシフトするごとに値が元の $2$ 倍になる。

論理ビットシフトでは、シフト演算後の空きビットを常に 0 で初期化する。 ******** では、右シフトを行った後の空きビットを符号ビットで初期化する。

Answer: 算術ビットシフト

Source: ../../note/programming/_/chapters/operation.md

====================

 ******* は、整数型のオペランドの値を1増加させる演算。カウンタ変数のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。 ******* 演算子をサポートしていないプログラミング言語もある。

前置 ******* は、データを ******* してからその値を返却する。後置 ******* は、データを返却してから ******* する。微妙な動作のずれに繋がるため注意が必要。

// C言語

// 前置 ******* 
++x;

// 後置 ******* 
x++;

Answer: インクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

インクリメントは、整数型のオペランドの値を1増加させる演算。カウンタ変数のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。インクリメント演算子をサポートしていないプログラミング言語もある。

 ********* は、データをインクリメントしてからその値を返却する。後置インクリメントは、データを返却してからインクリメントする。微妙な動作のずれに繋がるため注意が必要。

// C言語

//  ********* 
++x;

// 後置インクリメント
x++;

Answer: 前置インクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

インクリメントは、整数型のオペランドの値を1増加させる演算。カウンタ変数のカウントアップなどに用いられ、表記が非常にシンプルであるのが特徴。インクリメント演算子をサポートしていないプログラミング言語もある。

前置インクリメントは、データをインクリメントしてからその値を返却する。 ********* は、データを返却してからインクリメントする。微妙な動作のずれに繋がるため注意が必要。

// C言語

// 前置インクリメント
++x;

//  ********* 
x++;

Answer: 後置インクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

 ****** は、整数型のオペランドの値を1減少させる演算。カウンタ変数のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。 ****** 演算子をサポートしていないプログラミング言語もある。

前置 ****** は、データを ****** してからその値を返却する。後置 ****** は、データを返却してから ****** する。微妙な動作のずれに繋がるため注意が必要。

// C言語

// 前置 ****** 
--x;

// 後置 ****** 
x--;

Answer: デクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

デクリメントは、整数型のオペランドの値を1減少させる演算。カウンタ変数のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。デクリメント演算子をサポートしていないプログラミング言語もある。

 ******** は、データをデクリメントしてからその値を返却する。後置デクリメントは、データを返却してからデクリメントする。微妙な動作のずれに繋がるため注意が必要。

// C言語

//  ******** 
--x;

// 後置デクリメント
x--;

Answer: 前置デクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

デクリメントは、整数型のオペランドの値を1減少させる演算。カウンタ変数のカウントダウンなどに用いられ、表記が非常にシンプルであるのが特徴。デクリメント演算子をサポートしていないプログラミング言語もある。

前置デクリメントは、データをデクリメントしてからその値を返却する。 ******** は、データを返却してからデクリメントする。微妙な動作のずれに繋がるため注意が必要。

// C言語

// 前置デクリメント
--x;

//  ******** 
x--;

Answer: 後置デクリメント

Source: ../../note/programming/_/chapters/operation.md

====================

 **** は、条件式に応じて返却する値を切り替えるような演算。通常の演算がオペランドを1つあるいは2つしかとらないのに対して、 **** では3つのオペランドをとるのが特徴。

一般的には次のような記法を用いる。

<条件式> ? <真式> : <偽式>

<?php

// PHP

// 代入演算子の右側のオペランドが **** で構成されているパターン
// $yが20以下なら$y + 5の結果が、20より大きければ20が$xに代入される
$y = $_POST["input_num"];
$x = $y <= 20 ? $y + 5 : 20;

?>

 **** 子をサポートしていないプログラミング言語もある。

Answer: 三項演算

Source: ../../note/programming/_/chapters/operation.md

====================

 ******* は、プログラムを記述してコンピュータへ命令を行い、目的とするタスクを解決すること。

プログラマには、世の中の様々なタスクや問題を ******* によって解決するという役割がある。毎日の単純作業のくり返しを減らしたり（表計算ソフトなど）、ミスが許されない場面で正確に動作することが保証されたシステムを利用したり（銀行のシステムや信号機など）、さらに人間には難しいタスクの解決を行ったり（AIによる異常検知など）と、 ******* スキルの応用範囲は多岐にわたる。

Answer: プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、コンピュータが処理を行う手順や内容を示したもの。

Answer: プログラム

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、プログラムを記述する職業。

Answer: プログラマ

Source: ../../note/programming/_/chapters/programming.md

====================

 ********* は、プログラムを記述する際に用いられる言語。 ********* に対して、人間が日常生活で用いる言語のことを自然言語という。

Answer: プログラミング言語

Source: ../../note/programming/_/chapters/programming.md

====================

プログラミング言語は、プログラムを記述する際に用いられる言語。プログラミング言語に対して、人間が日常生活で用いる言語のことを **** という。

Answer: 自然言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ****** （ソース、コード）は、プログラミング言語で書かれたプログラム。

Answer: ソースコード

Source: ../../note/programming/_/chapters/programming.md

====================

 *** コード（ *** 、コード）は、プログラミング言語で書かれたプログラム。

Answer: ソース

Source: ../../note/programming/_/chapters/programming.md

====================

ソース *** （ソース、 *** ）は、プログラミング言語で書かれたプログラム。

Answer: コード

Source: ../../note/programming/_/chapters/programming.md

====================

 *** （マシン語、オブジェクトコード、ネイティブコード）は、コンピュータが直接解釈できるプログラムで、2進数の羅列からなる。 *** は次の例のようなプログラムとなっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいようにプログラミング言語を用いてソースコードを作成し、専用のプログラムによってソースコードを *** に変換するのが一般的。プロセッサごとに対応する *** も異なるので注意が必要。

0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000

...(以下略)

Answer: 機械語

Source: ../../note/programming/_/chapters/programming.md

====================

機械語（ **** 、オブジェクトコード、ネイティブコード）は、コンピュータが直接解釈できるプログラムで、2進数の羅列からなる。機械語は次の例のようなプログラムとなっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいようにプログラミング言語を用いてソースコードを作成し、専用のプログラムによってソースコードを機械語に変換するのが一般的。プロセッサごとに対応する機械語も異なるので注意が必要。

0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000

...(以下略)

Answer: マシン語

Source: ../../note/programming/_/chapters/programming.md

====================

機械語（マシン語、 ********* 、ネイティブコード）は、コンピュータが直接解釈できるプログラムで、2進数の羅列からなる。機械語は次の例のようなプログラムとなっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいようにプログラミング言語を用いてソースコードを作成し、専用のプログラムによってソースコードを機械語に変換するのが一般的。プロセッサごとに対応する機械語も異なるので注意が必要。

0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000

...(以下略)

Answer: オブジェクトコード

Source: ../../note/programming/_/chapters/programming.md

====================

機械語（マシン語、オブジェクトコード、 ******** ）は、コンピュータが直接解釈できるプログラムで、2進数の羅列からなる。機械語は次の例のようなプログラムとなっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいようにプログラミング言語を用いてソースコードを作成し、専用のプログラムによってソースコードを機械語に変換するのが一般的。プロセッサごとに対応する機械語も異なるので注意が必要。

0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000

...(以下略)

Answer: ネイティブコード

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、プロセッサに与える機械語の命令の識別番号。

Answer: オペコード

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** （低級言語）は、プログラミング言語の中でも機械語に近い言語。 ***** はコンピュータ資源を効率よく使うことができ、高速に動作するという利点があるが、プログラムが長くなりやすく柔軟性に乏しいことから、組込みやファームウェアといった分野など、限られたコンピュータ資源で性能を最大限引き出すという目的がない限りは高水準言語が用いられることがほとんどとなる。

Answer: 低水準言語

Source: ../../note/programming/_/chapters/programming.md

====================

低水準言語（ **** ）は、プログラミング言語の中でも機械語に近い言語。低水準言語はコンピュータ資源を効率よく使うことができ、高速に動作するという利点があるが、プログラムが長くなりやすく柔軟性に乏しいことから、組込みやファームウェアといった分野など、限られたコンピュータ資源で性能を最大限引き出すという目的がない限りは高水準言語が用いられることがほとんどとなる。

Answer: 低級言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ******* は、ニーモニックという命令を組み合わせて記述するプログラミング言語。ニーモニックは、機械語の命令に1対1で対応する、英単語や記号で表記した命令。プロセッサごとに対応する ******* も異なるので注意が必要。

 ******* の一種であるNetwide Assemblerを用いて Hello, world を出力するプログラムを以下に示す。

section .data
    msg db      "Hello, world"      ; データセクションで文字列を宣言

section .text
    global _start                   ; プログラムのエントリポイントとして_startを呼び出し

_start:
    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット
    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット
    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット
    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット
    syscall                         ; システムコールを発行
    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット
    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット
    syscall                         ; システムコールを発行

Answer: アセンブリ言語

Source: ../../note/programming/_/chapters/programming.md

====================

アセンブリ言語は、 ****** という命令を組み合わせて記述するプログラミング言語。 ****** は、機械語の命令に1対1で対応する、英単語や記号で表記した命令。プロセッサごとに対応するアセンブリ言語も異なるので注意が必要。

アセンブリ言語の一種であるNetwide Assemblerを用いて Hello, world を出力するプログラムを以下に示す。

section .data
    msg db      "Hello, world"      ; データセクションで文字列を宣言

section .text
    global _start                   ; プログラムのエントリポイントとして_startを呼び出し

_start:
    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット
    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット
    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット
    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット
    syscall                         ; システムコールを発行
    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット
    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット
    syscall                         ; システムコールを発行

Answer: ニーモニック

Source: ../../note/programming/_/chapters/programming.md

====================

アセンブリ言語は、ニーモニックという命令を組み合わせて記述するプログラミング言語。ニーモニックは、機械語の命令に1対1で対応する、英単語や記号で表記した命令。プロセッサごとに対応するアセンブリ言語も異なるので注意が必要。

アセンブリ言語の一種である ***************** を用いて Hello, world を出力するプログラムを以下に示す。

section .data
    msg db      "Hello, world"      ; データセクションで文字列を宣言

section .text
    global _start                   ; プログラムのエントリポイントとして_startを呼び出し

_start:
    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット
    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット
    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット
    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット
    syscall                         ; システムコールを発行
    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット
    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット
    syscall                         ; システムコールを発行

Answer: Netwide Assembler

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、アセンブリ言語で書かれたプログラムを機械語に変換する操作。

Answer: アセンブル

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、アセンブルを行うためのソフトウェア。

Answer: アセンブラ

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** （高級言語）は、低水準言語に比べて抽象度が高く、人間にとってわかりやすいプログラミング言語。機械語を意識することなく記述することができ、プロセッサに依存しないプログラムを作ることができる（機械語への変換の段階で様々なプロセッサに対応させることができるため）。

代表的な ***** としては、C系言語（C, C#, C++等）やJava、Python、PHP、JavaScriptなどがある。それぞれの言語には得手不得手があり、C言語であれば処理速度が高速であることからCPUやサーバなどの低レイヤの実装に向いており、JavaScriptであれば一般的なWebブラウザで動作することからWebフロントエンド向けとなっている。

 ***** は種類が多く、ソースコードのコンパイル・実行方式や、データ型の決定方式などによって分類することができる。

Answer: 高水準言語

Source: ../../note/programming/_/chapters/programming.md

====================

高水準言語（ **** ）は、低水準言語に比べて抽象度が高く、人間にとってわかりやすいプログラミング言語。機械語を意識することなく記述することができ、プロセッサに依存しないプログラムを作ることができる（機械語への変換の段階で様々なプロセッサに対応させることができるため）。

代表的な高水準言語としては、C系言語（C, C#, C++等）やJava、Python、PHP、JavaScriptなどがある。それぞれの言語には得手不得手があり、C言語であれば処理速度が高速であることからCPUやサーバなどの低レイヤの実装に向いており、JavaScriptであれば一般的なWebブラウザで動作することからWebフロントエンド向けとなっている。

高水準言語は種類が多く、ソースコードのコンパイル・実行方式や、データ型の決定方式などによって分類することができる。

Answer: 高級言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、高水準言語で書かれたソースコードを機械語に変換する操作。

Answer: コンパイル

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、コンパイルを行うためのソフトウェア。

Answer: コンパイラ

Source: ../../note/programming/_/chapters/programming.md

====================

 ******* は、プログラムを実行する前に、あらかじめソースコード全体のコンパイルを行う方式の言語。プログラムを利用する際には、機械語に変換された実行ファイルを実行する。

事前にコンパイルを済ませているため、実行前に不具合を発見できたり、実行時のコンパイルコストがないため実行速度が速いといった利点がある。一方で、実行時に起こりうる様々なパターンに対応できるようにプログラミングする必要があり、インタプリタ言語と比較しても難易度が高い言語が多い。また、コンパイル済みの実行ファイルはプロセッサに依存するため、マルチプラットフォームに対応できないという欠点もある（それぞれのプラットフォーム用にコンパイルする必要がある）。

代表的な ******* には、C言語やSwift、Go、Rustといったものがある。

Answer: コンパイラ言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ******** は、プログラムの実行時にソースコードを1行ずつコンパイルしながら処理を進める方式の言語。実行時に毎回コンパイルを行うコストが発生するため、実行速度はコンパイラ言語に劣る。しかし、コンパイルを行わずに実行結果をすぐに確認できるため、デバッグが容易で、開発にかかるコストは小さくなる。

代表的な ******** には、PythonやPHP、JavaScript、Rubyなどがある。

Answer: インタプリタ言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ******** (Just-In Time Compiler)は、ソースコードを環境に依存しない中間コード（バイトコード）に変換しておき、実行時にバイトコードをコンパイルして実行する方式をとる。実行時にコンパイルする点ではインタプリタ言語と似ているが、字句解析などのコストを省けるため、インタプリタ言語より高速に動作する。また、コンパイラ言語では直接機械語のコードを生成するため、プログラムが実行環境（プロセッサなど）に依存してしまうが、この方式ではプログラムの実行機であるランタイム（フレームワーク）が利用できる環境であればひとつの中間コードで実行できるというメリットもある。

 ******** を用いる代表的な言語には、JavaやC#などがある。

Answer: JITコンパイラ

Source: ../../note/programming/_/chapters/programming.md

====================

JITコンパイラ(Just-In Time Compiler)は、ソースコードを環境に依存しない ***** （バイトコード）に変換しておき、実行時にバイトコードをコンパイルして実行する方式をとる。実行時にコンパイルする点ではインタプリタ言語と似ているが、字句解析などのコストを省けるため、インタプリタ言語より高速に動作する。また、コンパイラ言語では直接機械語のコードを生成するため、プログラムが実行環境（プロセッサなど）に依存してしまうが、この方式ではプログラムの実行機であるランタイム（フレームワーク）が利用できる環境であればひとつの ***** で実行できるというメリットもある。

JITコンパイラを用いる代表的な言語には、JavaやC#などがある。

Answer: 中間コード

Source: ../../note/programming/_/chapters/programming.md

====================

JITコンパイラ(Just-In Time Compiler)は、ソースコードを環境に依存しない中間コード（ ****** ）に変換しておき、実行時に ****** をコンパイルして実行する方式をとる。実行時にコンパイルする点ではインタプリタ言語と似ているが、字句解析などのコストを省けるため、インタプリタ言語より高速に動作する。また、コンパイラ言語では直接機械語のコードを生成するため、プログラムが実行環境（プロセッサなど）に依存してしまうが、この方式ではプログラムの実行機であるランタイム（フレームワーク）が利用できる環境であればひとつの中間コードで実行できるというメリットもある。

JITコンパイラを用いる代表的な言語には、JavaやC#などがある。

Answer: バイトコード

Source: ../../note/programming/_/chapters/programming.md

====================

 ******* は、プログラミング言語のうち比較的容易に記述・実行ができる言語。定義は曖昧であるが、プログラミングの初学者にとっても学びやすく、開発スピードが早いため小規模な開発に向いている。インタプリタ言語は ******* に分類されることが多く、PythonやPHP、JavaScript、Rubyなどが ******* に含まれる。

Answer: スクリプト言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ******* は、実行前にデータの型を決定する方式の言語。コンパイラ言語の多くは ******* となっており、プログラム中で使用するデータに対して、そのデータをどの型として扱うかを明示（型注釈）する必要がある。事前にデータの型を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、プログラムの信頼性が向上する。

また、RustやGoのような新しい ******* では、ソースコード中に型を明示せずとも、コンパイラが文脈から自動的に型を判断する型推論の機能が搭載されているものもあり、ソースコードの記述量が増え冗長になるという ******* の欠点を軽減できる。

Answer: 静的型付け言語

Source: ../../note/programming/_/chapters/programming.md

====================

静的型付け言語は、実行前にデータの型を決定する方式の言語。コンパイラ言語の多くは静的型付け言語となっており、プログラム中で使用するデータに対して、そのデータをどの型として扱うかを明示（ *** ）する必要がある。事前にデータの型を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、プログラムの信頼性が向上する。

また、RustやGoのような新しい静的型付け言語では、ソースコード中に型を明示せずとも、コンパイラが文脈から自動的に型を判断する型推論の機能が搭載されているものもあり、ソースコードの記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。

Answer: 型注釈

Source: ../../note/programming/_/chapters/programming.md

====================

静的型付け言語は、実行前にデータの型を決定する方式の言語。コンパイラ言語の多くは静的型付け言語となっており、プログラム中で使用するデータに対して、そのデータをどの型として扱うかを明示（型注釈）する必要がある。事前にデータの型を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、プログラムの信頼性が向上する。

また、RustやGoのような新しい静的型付け言語では、ソースコード中に型を明示せずとも、コンパイラが文脈から自動的に型を判断する *** の機能が搭載されているものもあり、ソースコードの記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。

Answer: 型推論

Source: ../../note/programming/_/chapters/programming.md

====================

 ******* は、実行時にデータの型を決定する方式の言語。ソースコード中で型を明示する必要はなく、コンパイラが文脈から全てのデータの型を自動的に判断する。ソースコードがシンプルになり読みやすくなる一方で、データが読み込まれるたびにそのデータの型を推測する必要があるため、実行速度は静的型付け言語に劣る。また、データが想定していない型として扱われる可能性もあるため注意する必要がある。

実行時に型を決定するという抽象化の性質から、関数がとる引数の型も柔軟に判断することができるため、同じインタフェースを持つ異なるオブジェクトをひとつの関数で扱える。これを利用したプログラミングスタイルとしてダックタイピングがある。

Answer: 動的型付け言語

Source: ../../note/programming/_/chapters/programming.md

====================

 *********** は、広い用途で利用される高水準言語。

Answer: 汎用プログラミング言語

Source: ../../note/programming/_/chapters/programming.md

====================

 *********** は、限られた分野で活躍する高水準言語。

Answer: 専用プログラミング言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ********* は、あるプログラミング言語で書かれたソースコードを、別のプログラミング言語のコードに変換する処理。

Answer: トランスコンパイル

Source: ../../note/programming/_/chapters/programming.md

====================

 ************ は、プログラミングの考え方や記述方法の枠組み。ひとつのプログラミング言語は、複数の ************ を組み合わせている場合（マルチパラダイム言語）が多い。

Answer: プログラミングパラダイム

Source: ../../note/programming/_/chapters/programming.md

====================

 ********** （手続き型プログラミング）は、識別子をつけた命令ブロック（関数）の定義と呼び出しを組み合わせることでプログラム全体を組み立てることを土台としたプログラミングパラダイム。手続きは、プログラム内のあらゆるポイントから呼び出すことができ、手続き内の命令コード行の終端に到達すると、その手続きを呼び出したポイントの次の命令に制御が移される（復帰）。C言語やC++、PHP、Pythonなど、多くのプログラミン言語は ********** をサポートしている。

Answer: 命令型プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

命令型プログラミング（ *********** ）は、識別子をつけた命令ブロック（関数）の定義と呼び出しを組み合わせることでプログラム全体を組み立てることを土台としたプログラミングパラダイム。手続きは、プログラム内のあらゆるポイントから呼び出すことができ、手続き内の命令コード行の終端に到達すると、その手続きを呼び出したポイントの次の命令に制御が移される（復帰）。C言語やC++、PHP、Pythonなど、多くのプログラミン言語は命令型プログラミングをサポートしている。

Answer: 手続き型プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

命令型プログラミング（手続き型プログラミング）は、識別子をつけた命令ブロック（関数）の定義と呼び出しを組み合わせることでプログラム全体を組み立てることを土台としたプログラミングパラダイム。手続きは、プログラム内のあらゆるポイントから呼び出すことができ、手続き内の命令コード行の終端に到達すると、その手続きを呼び出したポイントの次の命令に制御が移される（ ** ）。C言語やC++、PHP、Pythonなど、多くのプログラミン言語は命令型プログラミングをサポートしている。

Answer: 復帰

Source: ../../note/programming/_/chapters/programming.md

====================

 ********** は、達成したい目的を記述し、その命令の実行手順についてはコンパイラに任せるような言語。プログラムの本質がわかりやすく、記述がシンプルになるものの、複雑な処理を行うことはできない。データベースに対するクエリを記述するSQLは宣言型に準拠した言語である。

または、数学論理学に根ざした流れをくむ、関数型プログラミングや論理プログラミング、制約プログラミングを総称して ********** と呼ぶこともある。

Answer: 宣言型プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

 ********** は、プログラムの処理手順を明確にし、判読性を向上させることを目的としたプログラミングパラダイム。一般的には、順次、分岐、反復といった3つの制御構文によって処理の流れを記述する。また、プログラムを任意に分割した部分プログラム（サブルーチンとコードブロック）の階層的な組み合わせによる構造化も指している。C言語やC++、Java、PHPといった多くの言語は ********** をサポートしている。

Answer: 構造化プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

 *************** は、あらゆるものをオブジェクトとして表現するプログラミングパラダイム。プログラムを手順ではなく、モノの作成と操作として見る考え方。C++やJava、PHP、Pythonなどはオブジェクト指向を取り入れたプログラミング言語に分類される。オブジェクト指向をサポートするプログラミング言語は大抵の場合、命令型プログラミングとの組み合わせで用いられる。

Answer: オブジェクト指向プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

 ********** は、数学的な関数を主軸としてプログラミングを行うプログラミングパラダイム。 ********** では、参照透過性（入力が決まると出力が一意に決まり、他のデータへの副作用がない）を満たした関数を使って組み立てた式が主役となる。オブジェクト指向プログラミングでは状態と振る舞いをオブジェクトによって管理していたが、 ********** では状態と振る舞いを切り離している。ClojureやElang、Haskell、Scala、Rustなどは ********** に分類される。

Answer: 関数型プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

関数型プログラミングは、数学的な関数を主軸としてプログラミングを行うプログラミングパラダイム。関数型プログラミングでは、 ***** （入力が決まると出力が一意に決まり、他のデータへの副作用がない）を満たした関数を使って組み立てた式が主役となる。オブジェクト指向プログラミングでは状態と振る舞いをオブジェクトによって管理していたが、関数型プログラミングでは状態と振る舞いを切り離している。ClojureやElang、Haskell、Scala、Rustなどは関数型プログラミングに分類される。

Answer: 参照透過性

Source: ../../note/programming/_/chapters/programming.md

====================

 ********* は、あらかじめ事実やルールを定義しておき、最終的に問い合わせを行うことで解を得るプログラミングパラダイム。既知の理論を基にして、新たな仮説を説明できるかといったことがプログラム的に証明できる。代表的な ********* 言語には、Prologがある。

Answer: 論理プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

 ********* は、変数間の関係を制約という形で記述し、制約ソルバーにより与えた制約を満たす解を探索するプログラミングパラダイム。ツールキットのような形でライブラリとして各プログラミング言語に提供されている場合が多く、代表的なプログラミング言語と言えるものは少ない。

Answer: 制約プログラミング

Source: ../../note/programming/_/chapters/programming.md

====================

制約プログラミングは、変数間の関係を制約という形で記述し、 ****** により与えた制約を満たす解を探索するプログラミングパラダイム。ツールキットのような形でライブラリとして各プログラミング言語に提供されている場合が多く、代表的なプログラミング言語と言えるものは少ない。

Answer: 制約ソルバー

Source: ../../note/programming/_/chapters/programming.md

====================

 ********** は、複数のプログラミングパラダイムに対応するプログラミング言語の総称。命令型プログラミングや構造化プログラミングといったパラダイムは、他のパラダイムと組み合わせて用いられることが多い。

Answer: マルチパラダイム言語

Source: ../../note/programming/_/chapters/programming.md

====================

 ** （シンタックス）は、各プログラミング言語が規定しているプログラムの書き方。 ** が誤っていると、コンパイラがソースコードを正しく解析できず、エラーとなる。プログラミング言語の ** は、自然言語の ** に比べて非常に厳密であるため、プログラミングを行うときには常に正しい ** を心掛けなくてはならない。

 ** はプログラミング言語ごとに様々であるが、例として次のようなものがある。

• プログラムは半角アルファベットと数字、各種記号によって記述する
• { と } は対応しており、 {} で囲まれた部分は処理のひとつのまとまりを表す
• ひとつの文は ; で終わらなければならない
• プログラムは上から下へと順次実行される

Answer: 文法

Source: ../../note/programming/_/chapters/programming.md

====================

文法（ ****** ）は、各プログラミング言語が規定しているプログラムの書き方。文法が誤っていると、コンパイラがソースコードを正しく解析できず、エラーとなる。プログラミング言語の文法は、自然言語の文法に比べて非常に厳密であるため、プログラミングを行うときには常に正しい文法を心掛けなくてはならない。

文法はプログラミング言語ごとに様々であるが、例として次のようなものがある。

• プログラムは半角アルファベットと数字、各種記号によって記述する
• { と } は対応しており、 {} で囲まれた部分は処理のひとつのまとまりを表す
• ひとつの文は ; で終わらなければならない
• プログラムは上から下へと順次実行される

Answer: シンタックス

Source: ../../note/programming/_/chapters/programming.md

====================

 **** （注釈）は、ソースコード中でコンパイル時に無視される部分。プログラムの内容や補足を記述したり、一時的に無効化したいプログラムを **** アウトしたりといった使い方がある。

一般的なプログラミング言語における **** の書き方は次のようになっている。

; アセンブリ言語などで用いられる1行の **** 

// 高水準言語でよく用いられる1行の **** 

/*

    高水準言語でよく用いられる
    複数行に対応した **** 

*/

Answer: コメント

Source: ../../note/programming/_/chapters/programming.md

====================

コメント（注釈）は、ソースコード中でコンパイル時に無視される部分。プログラムの内容や補足を記述したり、一時的に無効化したいプログラムを ******* したりといった使い方がある。

一般的なプログラミング言語におけるコメントの書き方は次のようになっている。

; アセンブリ言語などで用いられる1行のコメント

// 高水準言語でよく用いられる1行のコメント

/*

    高水準言語でよく用いられる
    複数行に対応したコメント

*/

Answer: コメントアウト

Source: ../../note/programming/_/chapters/programming.md

====================

 *** は、コンパイル時・実行時にプログラムが正常に処理を続行できなくなるような致命的な問題の発生により中断・終了されることを指す。シンタックスの誤りや、アルゴリズムのバグ等により発生する。

代表的な *** には次のようなものがある。

• ゼロ除算（整数を0で割るような演算を試みた）
• 配列の要素数より大きいインデックスにアクセスを試みた
• 存在しないファイルを参照しようとした
• ユーザが想定外の入力を行った
• データベースやサーバへの接続に失敗した

Answer: エラー

Source: ../../note/programming/_/chapters/programming.md

====================

エラーは、コンパイル時・実行時にプログラムが正常に処理を続行できなくなるような致命的な問題の発生により中断・終了されることを指す。シンタックスの誤りや、アルゴリズムのバグ等により発生する。

代表的なエラーには次のようなものがある。

•  **** （整数を0で割るような演算を試みた）
• 配列の要素数より大きいインデックスにアクセスを試みた
• 存在しないファイルを参照しようとした
• ユーザが想定外の入力を行った
• データベースやサーバへの接続に失敗した

Answer: ゼロ除算

Source: ../../note/programming/_/chapters/programming.md

====================

 ** は、プログラミング言語が想定可能なエラーのことで、 ** 発生時の処理をソースコード中に記述しておき、プログラムが止まらないようにすることができる。プログラムが想定できないエラーが発生した場合は、プログラムがOSによって強制的に終了される。

Answer: 例外

Source: ../../note/programming/_/chapters/programming.md

====================

 ** は、プログラム上の誤りや不具合。文法上のエラーや、エラーではないもののプログラムが仕様通りに動作しないような欠陥のことをいう。

Answer: バグ

Source: ../../note/programming/_/chapters/programming.md

====================

 **** は、プログラムのバグを見つけて修正すること。

Answer: デバッグ

Source: ../../note/programming/_/chapters/programming.md

====================

 ***** は、プログラミング言語の仕様において動作が予測できないと規定されているプログラムを実行した結果のことで、C言語やC++といった言語ではいくつかの ***** が定められている。 ***** を設けることにより、パフォーマンスの高いコンパイラを作成することが容易になる。一方で、 ***** はプログラムのバグとなる可能性が高く、実行環境によって結果が変わることもあるため発見が難しい。

Answer: 未定義動作

Source: ../../note/programming/_/chapters/programming.md

====================

 *** （シンボル）は、ソースコード中でデータや処理のまとまりに対してプログラマがつける名前。 *** には、そのデータの性質や状態、役割を表す名前をつけるのが一般的。

 *** の命名に関しては、各プログラミング言語ごとにルールが存在する。次に示すのは、多くのプログラミング言語に共通しているルールの一部。

• 変数名にはアルファベット、数字、アンダースコアが使用できる
• アルファベットの大文字と小文字は区別される
• 1文字目はアルファベットかアンダースコアが使用できる（数字から始まる変数名は使用できない）
• 予約語は使用できない（予約語を含む変数名は使用できる）
•  *** 中にスペースを含むことはできない（複数の単語からなる *** において、単語間にスペースを用いるなど）

プログラミングにおいて良い *** を命名することは、ソースコードの可読性やメンテナンス性を向上させるために非常に重要である。言語ごとのコミュニティや開発チームごとのルール・文化に従い、一般的な単語を用いた、誰が見てもわかりやすい *** を心掛けるべきである。

Answer: 識別子

Source: ../../note/programming/_/chapters/programming.md

====================

識別子（ **** ）は、ソースコード中でデータや処理のまとまりに対してプログラマがつける名前。識別子には、そのデータの性質や状態、役割を表す名前をつけるのが一般的。

識別子の命名に関しては、各プログラミング言語ごとにルールが存在する。次に示すのは、多くのプログラミング言語に共通しているルールの一部。

• 変数名にはアルファベット、数字、アンダースコアが使用できる
• アルファベットの大文字と小文字は区別される
• 1文字目はアルファベットかアンダースコアが使用できる（数字から始まる変数名は使用できない）
• 予約語は使用できない（予約語を含む変数名は使用できる）
• 識別子中にスペースを含むことはできない（複数の単語からなる識別子において、単語間にスペースを用いるなど）

プログラミングにおいて良い識別子を命名することは、ソースコードの可読性やメンテナンス性を向上させるために非常に重要である。言語ごとのコミュニティや開発チームごとのルール・文化に従い、一般的な単語を用いた、誰が見てもわかりやすい識別子を心掛けるべきである。

Answer: シンボル

Source: ../../note/programming/_/chapters/programming.md

====================

 *** は、各プログラミング言語において規定されている、識別子として利用できない文字列。データの型や制御構文に用いられる単語などがこれにあたり、プログラムの構文解析の妨げになるなどの理由から使用できなくなっている。また、将来的にプログラミング言語に取り入れられる予定の機能に関するキーワードも *** となっている場合もある。

 *** ではなくとも、他のプログラミング言語で *** になっているものや、将来的に使用できなくなる可能性のある文字列は識別子としてふさわしくないので、避けた方がよい。

以下に示すのは、C言語の *** の一部。

auto, break, case, char, const, continue, default, do, double, else, enum,
extern, float, for, goto, if, int, long, register, return, signed, sizeof,
...

Answer: 予約語

Source: ../../note/programming/_/chapters/programming.md

====================

プログラミングを始めるために必要なものは、各種プログラミング言語の **** と、プログラムを記述するためのテキストエディタのみで、基本的には特別なものは必要としない。 **** は、プログラムをコンパイルして実行するための環境。テキストエディタには、プログラミングを便利に行うための補助機能を提供するものや、 **** が搭載された統合開発環境など様々なものがあるが、PCにデフォルトでインストールされているようなもの（Windowsのメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。

• サクラエディタ
• 秀丸エディタ（有料）
• Visual Studio Code
• Neovim

Answer: 実行環境

Source: ../../note/programming/_/chapters/programming.md

====================

プログラミングを始めるために必要なものは、各種プログラミング言語の実行環境と、プログラムを記述するための ******** のみで、基本的には特別なものは必要としない。実行環境は、プログラムをコンパイルして実行するための環境。 ******** には、プログラミングを便利に行うための補助機能を提供するものや、実行環境が搭載された統合開発環境など様々なものがあるが、PCにデフォルトでインストールされているようなもの（Windowsのメモ帳など）でも問題ない。代表的な ******** には次のようなものがある。

• サクラエディタ
• 秀丸エディタ（有料）
• Visual Studio Code
• Neovim

Answer: テキストエディタ

Source: ../../note/programming/_/chapters/programming.md

====================

プログラミングを始めるために必要なものは、各種プログラミング言語の実行環境と、プログラムを記述するためのテキストエディタのみで、基本的には特別なものは必要としない。実行環境は、プログラムをコンパイルして実行するための環境。テキストエディタには、プログラミングを便利に行うための補助機能を提供するものや、実行環境が搭載された ****** など様々なものがあるが、PCにデフォルトでインストールされているようなもの（Windowsのメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。

• サクラエディタ
• 秀丸エディタ（有料）
• Visual Studio Code
• Neovim

Answer: 統合開発環境

Source: ../../note/programming/_/chapters/programming.md

====================

 *** は、1972年に開発された汎用プログラミング言語で、高水準言語ではあるがハードウェア寄りの記述が可能な低水準言語のような特徴も持っている。コンパイラ言語・静的型付け言語に分類される。OSやデバイスドライバなど、低レイヤを中心にあらゆる分野で利用されており、プログラミング言語の中でも実行速度は最速の部類となる。また、習得難易度はスクリプト言語に比べて高く、限られたハードウェア資産で効率的に実行できるプログラムを要するケースに適している。

メモリ管理にガベージコレクションを用いず、プログラマがメモリ管理の責務を負うため、メモリに関する様々なエラーを回避してプログラムを記述する必要がある。

Answer: C言語

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ***  は、C言語の機能や特徴を継承しつつ表現力を向上させた汎用プログラミング言語で、複数のプログラミングパラダイムが組み合わされている。オブジェクト指向やテンプレートといったC言語にはない機能を有しており、柔軟性に優れている。C言語のようにハードウェアを直接扱うような低レイヤ向けの言語としても、複雑なアプリケーションソフトウェアを開発するような高レイヤ向けの言語としても活躍している。習得難易度は比較的高く、パフォーマンスが求められる場合やハードウェア資源を効率的に利用したい場合に適している。

C言語と同様、メモリ管理にガベージコレクションを用いず、プログラマがメモリ管理の責務を負う。

Answer: C++

Source: ../../note/programming/_/chapters/programming_language.md

====================

 **  は、C言語やC++に影響を受けMicrosoftが開発した、汎用プログラミング言語。Windowsとの相性がよく、.NET Frameworkを用いたWindowsアプリケーション開発などに適している。また、ゲーム開発エンジンとして有名なUnityとも相性が良い。

C言語やC++とは異なり、ガベージコレクションによりメモリを管理できるため、習得難易度は比較的低い。

Answer: C#

Source: ../../note/programming/_/chapters/programming_language.md

====================

C# は、C言語やC++に影響を受けMicrosoftが開発した、汎用プログラミング言語。Windowsとの相性がよく、 ************** を用いたWindowsアプリケーション開発などに適している。また、ゲーム開発エンジンとして有名なUnityとも相性が良い。

C言語やC++とは異なり、ガベージコレクションによりメモリを管理できるため、習得難易度は比較的低い。

Answer: .NET Framework

Source: ../../note/programming/_/chapters/programming_language.md

====================

C# は、C言語やC++に影響を受けMicrosoftが開発した、汎用プログラミング言語。Windowsとの相性がよく、.NET Frameworkを用いたWindowsアプリケーション開発などに適している。また、ゲーム開発エンジンとして有名な ***** とも相性が良い。

C言語やC++とは異なり、ガベージコレクションによりメモリを管理できるため、習得難易度は比較的低い。

Answer: Unity

Source: ../../note/programming/_/chapters/programming_language.md

====================

 *********** は、C言語をベースにしてSmalltalk（オブジェクト指向の起源ともいえるプログラミング言語）の機能を取り込んだプログラミング言語。Appple社のmacOSやiOS向けのソフトウェア開発における標準言語。近年ではMacOS、iOSアプリの開発用言語はSwiftに置き換えられつつある。

Answer: Objective-C

Source: ../../note/programming/_/chapters/programming_language.md

====================

Objective-Cは、C言語をベースにして ********* （オブジェクト指向の起源ともいえるプログラミング言語）の機能を取り込んだプログラミング言語。Appple社のmacOSやiOS向けのソフトウェア開発における標準言語。近年ではMacOS、iOSアプリの開発用言語はSwiftに置き換えられつつある。

Answer: Smalltalk

Source: ../../note/programming/_/chapters/programming_language.md

====================

 **** は、C言語に影響を受けた汎用プログラミング言語で、静的型付け言語に分類され、メモリ管理にはガベージコレクションを用いる。様々なプラットフォームで実行できるようにJITコンパイラ方式を用いており、 **** プログラムを実行するためのソフトウェアをJVM（ **** 仮想マシン）という。また、オブジェクト指向を取り入れた言語でもある。非常に人気が高く、世界で最も使用されているプログラミング言語のひとつとなっている。

import java.util.Scanner;

public class Oddeven
{
    public static void main( String[] args )
    {
        Scanner scanner = new Scanner(System.in);
        System.out.print("> ");
        int input_num = scanner.nextInt();

        if( input_num % 2 == 0 )
        {
            System.out.println("It is an even number : " + input_num);
        }
        else
        {
            System.out.println("It is an odd number : " + input_num);
        }

        scanner.close();
    }
}

Answer: Java

Source: ../../note/programming/_/chapters/programming_language.md

====================

Javaは、C言語に影響を受けた汎用プログラミング言語で、静的型付け言語に分類され、メモリ管理にはガベージコレクションを用いる。様々なプラットフォームで実行できるようにJITコンパイラ方式を用いており、Javaプログラムを実行するためのソフトウェアを *** （Java仮想マシン）という。また、オブジェクト指向を取り入れた言語でもある。非常に人気が高く、世界で最も使用されているプログラミング言語のひとつとなっている。

import java.util.Scanner;

public class Oddeven
{
    public static void main( String[] args )
    {
        Scanner scanner = new Scanner(System.in);
        System.out.print("> ");
        int input_num = scanner.nextInt();

        if( input_num % 2 == 0 )
        {
            System.out.println("It is an even number : " + input_num);
        }
        else
        {
            System.out.println("It is an odd number : " + input_num);
        }

        scanner.close();
    }
}

Answer: JVM

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ****** は、Androidアプリを開発するための比較的新しいプログラミング言語。Javaを簡潔に安全に記述できるように改良されており、JVM上で動作する。

Answer: Kotlin

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ***** は、Apple製品のアプリケーションを開発するためにつくられたプログラミング言語。Objective-Cに代わる新たな言語として設計されており、シンプルで直感的にプログラミングができるとして人気が高い。

Answer: Swift

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ****** は、インタプリタ方式の汎用プログラミング言語。動的型付け言語に分類され、メモリの管理にはガベージコレクションを用いる。可読性が高く記述が用意であるため、プログラミングの入門やスピード感のある開発に適している。機械学習分野のライブラリが充実しているほか、Web開発にも用いられる。

input_num = int(input("> "))

if ( input_num % 2 ) == 0:
    print("It is an even number : {0}".format(input_num))
else:
    print("It is an even number : {0}".format(input_num))

Answer: Python

Source: ../../note/programming/_/chapters/programming_language.md

====================

 *** は、動的なWebサイトを作成するためのツールから派生したスクリプト言語。Web開発に特化しており、HTMLに埋め込むような記法を用いることができるという特徴がある。そのほかにも、学習コストが低い点やデータベースアクセスを容易に行えるという強みもある。

<?php

$input_num = $_POST["input_num"];

if( $input_num % 2 === 0 )
{
    echo("It is an even number : " . $input_num);
}
else
{
    echo("It is an odd number : " . $input_num);
}

?>

Answer: PHP

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ********** は、一般的なWebブラウザ上で実行されるプログラミング言語。インタプリタ言語・動的型付け言語に分類される。Webページ上のコンテンツに動きを与える目的でよく用いられており、近年ではサーバサイドにおける実行環境の登場や、SPA(Single Page Application)の普及により活躍の幅が広がっている。習得難易度は比較的低く、ブラウザさえあれば実行環境が整うという手軽さもメリットのひとつである。

let input_num = document.getElementById('#input_num').value;

if( input_num % 2 === 0 )
{
    console.log("It is an even number : " + input_num);
}
else
{
    console.log("It is an even number : " + input_num);
}

Answer: JavaScript

Source: ../../note/programming/_/chapters/programming_language.md

====================

JavaScriptは、一般的なWebブラウザ上で実行されるプログラミング言語。インタプリタ言語・動的型付け言語に分類される。Webページ上のコンテンツに動きを与える目的でよく用いられており、近年ではサーバサイドにおける実行環境の登場や、 *** (Single Page Application)の普及により活躍の幅が広がっている。習得難易度は比較的低く、ブラウザさえあれば実行環境が整うという手軽さもメリットのひとつである。

let input_num = document.getElementById('#input_num').value;

if( input_num % 2 === 0 )
{
    console.log("It is an even number : " + input_num);
}
else
{
    console.log("It is an even number : " + input_num);
}

Answer: SPA

Source: ../../note/programming/_/chapters/programming_language.md

====================

 ********** は、Microsoftによって開発されたJavaScriptのスーパーセット。大規模アプリケーション開発のために設計されており、静的型付け言語のような型宣言などの機能が搭載されている。実行時は、JavaScriptにトランスコンパイルしたものをブラウザ上で動作させる。

Answer: TypeScript

Source: ../../note/programming/_/chapters/programming_language.md

====================

 **** は、C言語やC++に代わるシステムプログラミング言語を目指すプログラミング言語。静的型付け言語・コンパイラ言語に分類される。また、ガベージコレクションを用いない独特のメモリ管理（ボローチェッカーによる参照の有効性の検証）によって、メモリ安全性を確保している。パフォーマンスや信頼性の高さからLinuxのカーネルプログラムにも採用されたり、GoogleやFacebookといった企業でも一部取り入れられたりと、注目の集まる言語となっている。開発者に最も愛されているプログラミング言語としても知られるが、習得難易度はC言語やC++と同程度かそれ以上に高い。

Answer: Rust

Source: ../../note/programming/_/chapters/programming_language.md

