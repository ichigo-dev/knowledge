====================

 ****** は、同じカラムに格納するべきアトリビュートを複数持つレコードについては、アトリビュートの数だけ独立したレコードを用意した形。同じ候補キー（レコードを一意に特定するための属性）を持つレコードが複数存在する状態のため、候補キーをプライマリキーとして扱うことはできない。また、候補キーとなるカラムが複数存在する可能性がある。

Answer: 第1正規化形

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ****** は、同じテーブルの中で異なる候補キーに依存している部分を、別テーブルに分離した形。

Answer: 第2正規化形

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ****** は、同じテーブルの中で候補キーではないアトリビュートに依存している部分を、別テーブルに分離した形。

Answer: 第3正規化形

Source: ../../note/development/database/_/chapters/rdb.md

====================

 **** は、値がないことを表す値。値が不明であったり、未定義の場合にデータベースに代入される。

Answer: null

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ** は、テーブルの各カラムに格納されるデータに関する決まりごと。

Answer: 制約

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ******** は、データベースの制約のひとつで、カラムにnullが入ることを禁止する。この制約を設けたカラムには、レコードの作成時に必ず値を指定しなければならない。

Answer: NOT NULL

Source: ../../note/development/database/_/chapters/rdb.md

====================

 *********** は、データベースの制約のひとつで、そのテーブル内でレコードを一意に識別、特定することができるカラムとしなければならない。ひとつのテーブルには *********** 制約を持つカラムが必ず1つ（0でも2つ以上でも不可）ないといけない。 *********** 制約のついたカラムにnullを格納することも禁止されている。

Answer: PRIMARY KEY

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ********** は、データベースの制約のひとつで、PRIMARY KEYと同様、そのテーブル内でレコードを一意に識別、特定することができるカラムとしなければならない。 ********** は同一テーブル内に複数指定することができる。 ********** ではnullは禁止されていない。

Answer: UNIQUE KEY

Source: ../../note/development/database/_/chapters/rdb.md

====================

 *********** は、データベースの制約のひとつで、他のテーブルのカラムを参照して、そのカラムに存在する値以外は格納できない。結合の際に利用するカラムに対して指定する。 *********** 制約を用いる場合は、REFERENCESキーワードで参照するテーブルを指定する必要がある。

Answer: FOREIGN KEY

Source: ../../note/development/database/_/chapters/rdb.md

====================

 ***** は、データベースの制約のひとつで、指定した条件に合致しないデータが格納できなくなる。

Answer: CHECK

Source: ../../note/development/database/_/chapters/rdb.md

====================

 **** は、データベースにおいて、特定のテーブルに対する操作（挿入・更新・削除）をきっかけとして、あらかじめ定義された処理を自動的に実行する機能。複数テーブル間のデータ整合性を確保するためや、テーブル名の変更時などに利用する。

Answer: トリガー

Source: ../../note/development/database/_/chapters/rdb.md

====================

 *** は、リレーショナルデータベースを操作するための言語。各RDBMSごとに多少違いはあるものの、基本的には標準 *** の仕様に準拠している場合が多い。

Answer: SQL

Source: ../../note/development/database/_/chapters/sql.md

====================

 *** (Data Definition Language)は、データベースに格納されるデータ構造（スキーマ）を定義するためのSQL命令。テーブルの生成や削除、カラムの変更などを行うことができる。

Answer: DDL

Source: ../../note/development/database/_/chapters/sql.md

====================

 *** (Data Manipulation Language)は、DDLによってあらかじめ定義したデータ構造を操作するためのSQL命令。データの抽出や挿入、変更、削除を行うことができる。

Answer: DML

Source: ../../note/development/database/_/chapters/sql.md

====================

 *** (Data Control Language)は、複数のユーザにより同時にデータ要求を行っても矛盾が生じないようにするための、保全機能やデータ機密保護機能を提供するためのSQL命令。

Answer: DCL

Source: ../../note/development/database/_/chapters/sql.md

====================

 *** （問合せ）は、データベースに対するデータの抽出や更新といった処理要求の文字列。

Answer: クエリ

Source: ../../note/development/database/_/chapters/sql.md

====================

 ***** （副問合せ）は、SQLの命令文中で呼び出す別の命令文。

Answer: サブクエリ

Source: ../../note/development/database/_/chapters/sql.md

====================

インスタンスに存在するデータベースの一覧を表示するには、 ************** コマンドを使用する。

 ************** ;

Answer: SHOW DATABASES

Source: ../../note/development/database/_/chapters/sql.md

====================

インスタンスに新しいデータベースを作成するには、 *************** コマンドを使用する。

 ***************  [name];

Answer: CREATE DATABASE

Source: ../../note/development/database/_/chapters/sql.md

====================

インスタンスに存在するデータベースを削除するには、 ************* コマンドを使用する。

 *************  [name];

Answer: DROP DATABASE

Source: ../../note/development/database/_/chapters/sql.md

====================

操作したいデータベースを選択するには、 *** コマンドを使用する。

 ***  [name];

Answer: USE

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中のテーブルの一覧を表示するには、 *********** コマンドを使用する。

 *********** ;

Answer: SHOW TABLES

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中に新しいテーブルを作成するには、 ************ コマンドを使用する。

 ************  [name]
(
    [column1] [type] [restriction],
    [column2] [type] [restriction],
    ...
    PRIMARY KEY ([column])
);

-- テーブル作成の例
 ************  `user`
(
    `user_id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(64) NOT NULL,
    `address` VARCHAR(128) NOT NULL,
    PRIMARY KEY (`user_id`)
);

Answer: CREATE TABLE

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中のテーブルの定義を変更するには、 *********** コマンドを使用する。

-- カラムの追加
 ***********  [name] ADD COLUMN [column] [type] [restriction];
 ***********  [name] ADD
(
    [column1] [type] [restriction],
    [column2] [type] [restriction],
    ...
);

-- カラムの変更
 ***********  [name] MODIFY COLUMN [column] [type] [restriction];
 ***********  [name] MODIFY
(
    [column1] [type] [restriction],
    [column2] [type] [restriction],
    ...
);

-- カラムの削除
 ***********  [name] DROP COLUMN [column];
 ***********  [name] DROP ([column1], [column2], ...);

Answer: ALTER TABLE

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中のテーブルを削除するには、 ********** コマンドを使用する。

 **********  [name];

Answer: DROP TABLE

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルからデータを取得するには、 ****** コマンドを使用する。

 ****** 
    [column1],
    [column2],
    ...
FROM
    [table];

-- 重複を削除した検索
 ******  DISTINCT
    [column1],
    [column2],
    ...
FROM
    [table];

Answer: SELECT

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルに新しいデータを挿入するには、 ****** コマンドを使用する。

 ******  INTO [table]
(
    [column1],
    [column2],
    ...
)
VALUES
(
    [value1],
    [value2],
    ...
);

Answer: INSERT

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを更新するには、 ****** コマンドを使用する。

 ****** 
    [table]
SET
    [column1] = [value1],
    [column2] = [value2],
    ...;

Answer: UPDATE

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを削除するには、 ****** コマンドを使用する。

 ******  FROM [table];

Answer: DELETE

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを抽出して取得するには、 ***** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [condition];

-- OR条件
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [condition1] OR
    [condition2] OR
    ...;

-- AND条件
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [condition1] AND
    [condition2] AND
    ...;

-- NOT条件
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    NOT [condition];

-- 範囲条件
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [column] BETWEEN [value1] AND [value2];

-- 含有条件
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [column] IN ([value1], [value2], ...);

-- ワイルドカード
-- '%': 0文字以上の任意の文字列
-- '_': 任意の1文字
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [column] LIKE '%[value]%';

Answer: WHERE

Source: ../../note/development/database/_/chapters/sql.md

====================

操作するデータに別名をつけるには、 ** コマンドを使用する。複数のテーブルを組み合わせたクエリを記述する場合などに、長いテーブル名を繰り返し記述して冗長になることを避けるために用いられる。

SELECT
    [column]  **  [alias]
FROM
    [table]

Answer: AS

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータをソートして取得するには、 ******** コマンドを使用する。

-- 昇順
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ******** 
    [column];

-- 降順
SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ******** 
    [column] DESC;

Answer: ORDER BY

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータの取得数を制限するには、 ***** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ***** 
    [offset], [num];

Answer: LIMIT

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを集約して様々な統計データを取得するには、 *** 、AVG、MAX、MIN、COUNTといったコマンドを使用する。

-- 合計値
SELECT
     *** ([column])
FROM
    [table];

-- 平均値
SELECT
    AVG([column])
FROM
    [table];

-- 最大値
SELECT
    MAX([column])
FROM
    [table];

-- 最小値
SELECT
    MIN([column])
FROM
    [table];

-- データ数
SELECT
    COUNT([column])
FROM
    [table];

Answer: SUM

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを集約して様々な統計データを取得するには、SUM、 *** 、MAX、MIN、COUNTといったコマンドを使用する。

-- 合計値
SELECT
    SUM([column])
FROM
    [table];

-- 平均値
SELECT
     *** ([column])
FROM
    [table];

-- 最大値
SELECT
    MAX([column])
FROM
    [table];

-- 最小値
SELECT
    MIN([column])
FROM
    [table];

-- データ数
SELECT
    COUNT([column])
FROM
    [table];

Answer: AVG

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを集約して様々な統計データを取得するには、SUM、AVG、 *** 、MIN、COUNTといったコマンドを使用する。

-- 合計値
SELECT
    SUM([column])
FROM
    [table];

-- 平均値
SELECT
    AVG([column])
FROM
    [table];

-- 最大値
SELECT
     *** ([column])
FROM
    [table];

-- 最小値
SELECT
    MIN([column])
FROM
    [table];

-- データ数
SELECT
    COUNT([column])
FROM
    [table];

Answer: MAX

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを集約して様々な統計データを取得するには、SUM、AVG、MAX、 *** 、COUNTといったコマンドを使用する。

-- 合計値
SELECT
    SUM([column])
FROM
    [table];

-- 平均値
SELECT
    AVG([column])
FROM
    [table];

-- 最大値
SELECT
    MAX([column])
FROM
    [table];

-- 最小値
SELECT
     *** ([column])
FROM
    [table];

-- データ数
SELECT
    COUNT([column])
FROM
    [table];

Answer: MIN

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを集約して様々な統計データを取得するには、SUM、AVG、MAX、MIN、 ***** といったコマンドを使用する。

-- 合計値
SELECT
    SUM([column])
FROM
    [table];

-- 平均値
SELECT
    AVG([column])
FROM
    [table];

-- 最大値
SELECT
    MAX([column])
FROM
    [table];

-- 最小値
SELECT
    MIN([column])
FROM
    [table];

-- データ数
SELECT
     ***** ([column])
FROM
    [table];

Answer: COUNT

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを加工するには、 ***** 、FLOOR、CEILINGといったコマンドを使用する。

-- 四捨五入
SELECT
     ***** ([column], [valid digit])
FROM
    [table];

-- 切り捨て
SELECT
    FLOOR([column])
FROM
    [table];

-- 切り上げ
SELECT
    CEILING([column])
FROM
    [table];

Answer: ROUND

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを加工するには、ROUND、 ***** 、CEILINGといったコマンドを使用する。

-- 四捨五入
SELECT
    ROUND([column], [valid digit])
FROM
    [table];

-- 切り捨て
SELECT
     ***** ([column])
FROM
    [table];

-- 切り上げ
SELECT
    CEILING([column])
FROM
    [table];

Answer: FLOOR

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータを加工するには、ROUND、FLOOR、 ******* といったコマンドを使用する。

-- 四捨五入
SELECT
    ROUND([column], [valid digit])
FROM
    [table];

-- 切り捨て
SELECT
    FLOOR([column])
FROM
    [table];

-- 切り上げ
SELECT
     ******* ([column])
FROM
    [table];

Answer: CEILING

Source: ../../note/development/database/_/chapters/sql.md

====================

テーブルのデータをグループ化するには、 ******** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
 ******** 
    [column]

-- グループ化したカラムを元に集計
SELECT
    [column1],
    SUM([column2]),
    AVG([column3]),
    ...
FROM
    [table]
 ******** 
    [column1]

Answer: GROUP BY

Source: ../../note/development/database/_/chapters/sql.md

====================

 **** は、結合するテーブルのデータのうち、条件に指定したカラムの値が一致するデータのみを結合する。 **** を行うには、INNER JOINコマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
INNER JOIN
    [table2]
ON
    [condition];

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1],
    [table2],
    ...
WHERE
    [condition]

Answer: 内部結合

Source: ../../note/development/database/_/chapters/sql.md

====================

内部結合は、結合するテーブルのデータのうち、条件に指定したカラムの値が一致するデータのみを結合する。内部結合を行うには、 ********** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
 ********** 
    [table2]
ON
    [condition];

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1],
    [table2],
    ...
WHERE
    [condition]

Answer: INNER JOIN

Source: ../../note/development/database/_/chapters/sql.md

====================

 **** は、結合するテーブルのデータのうち、片方のテーブルのデータをすべて取り出し、条件に指定したカラムの値が一致するデータに関してのみ結合される。 **** を行うには、OUTER JOINコマンドを使用する。

-- 左 **** 
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
LEFT OUTER JOIN
    [table2]
ON
    [condition];

-- 右 **** 
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
RIGHT OUTER JOIN
    [table2]
ON
    [condition];

-- 完全 **** 
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
FULL OUTER JOIN
    [table2]
ON
    [condition];

Answer: 外部結合

Source: ../../note/development/database/_/chapters/sql.md

====================

外部結合は、結合するテーブルのデータのうち、片方のテーブルのデータをすべて取り出し、条件に指定したカラムの値が一致するデータに関してのみ結合される。外部結合を行うには、 ********** コマンドを使用する。

-- 左外部結合
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
LEFT  ********** 
    [table2]
ON
    [condition];

-- 右外部結合
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
RIGHT  ********** 
    [table2]
ON
    [condition];

-- 完全外部結合
SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
FULL  ********** 
    [table2]
ON
    [condition];

Answer: OUTER JOIN

Source: ../../note/development/database/_/chapters/sql.md

====================

 **** （直積結合）は、結合するテーブルのデータのすべての組み合わせを取り出す。 **** を行うには、CROSS JOINコマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
CROSS JOIN
    [table2]

Answer: 交差結合

Source: ../../note/development/database/_/chapters/sql.md

====================

交差結合（ **** ）は、結合するテーブルのデータのすべての組み合わせを取り出す。交差結合を行うには、CROSS JOINコマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
CROSS JOIN
    [table2]

Answer: 直積結合

Source: ../../note/development/database/_/chapters/sql.md

====================

交差結合（直積結合）は、結合するテーブルのデータのすべての組み合わせを取り出す。交差結合を行うには、 ********** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table1]
 ********** 
    [table2]

Answer: CROSS JOIN

Source: ../../note/development/database/_/chapters/sql.md

====================

クエリ中で条件分岐を行いたい場合は、 **** コマンドを使用する。

 **** 
    WHEN [condition1] THEN [value1]
    WHEN [condition2] THEN [value2]
    ...
    ELSE [value]
END

Answer: CASE

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中に新しいビューを作成するには、 *********** コマンドを使用する。

 ***********  [name]
(
    [column1],
    [column2],
    ...
) AS
SELECT
    [column1],
    [column2],
    ...
FROM
    [table];

Answer: CREATE VIEW

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中のビューを変更するには、 ********** コマンドを使用する。

-- ビュー名の変更
 **********  [old name] RENAME TO [new name];

-- ビュー定義の変更
 **********  [name]
(
    [column1],
    [column2],
    ...
) AS
SELECT
    [column1],
    [column2],
    ...
FROM
    [table];

Answer: ALTER VIEW

Source: ../../note/development/database/_/chapters/sql.md

====================

データベース中のビューを削除するには、 ********* コマンドを使用する。

 *********  [name];

Answer: DROP VIEW

Source: ../../note/development/database/_/chapters/sql.md

====================

トランザクションを開始するには、 ***************** コマンドを使用する。

 ***************** ;

Answer: START TRANSACTION

Source: ../../note/development/database/_/chapters/sql.md

====================

トランザクション中の実行結果をコミットするには、 ****** コマンドを使用する。

 ****** ;

Answer: COMMIT

Source: ../../note/development/database/_/chapters/sql.md

====================

トランザクション中の実行結果をロールバックするには、 ******** コマンドを使用する。

 ******** ;

Answer: ROLLBACK

Source: ../../note/development/database/_/chapters/sql.md

====================

トランザクション中にセーブポイントを設けるには、 ********* コマンドを使用する。

 *********  [name];

-- ロールバック時にセーブポイントを復元
ROLLBACK TO  *********  [name];

Answer: SAVEPOINT

Source: ../../note/development/database/_/chapters/sql.md

====================

レコードロックを獲得するには、 ********** コマンドを使用する。

SELECT
    [column1],
    [column2],
    ...
FROM
    [table]
WHERE
    [condition]
 ********** ;

Answer: FOR UPDATE

Source: ../../note/development/database/_/chapters/sql.md

====================

インスタンス中に新しいユーザを作成するには、 *********** コマンドを使用する。

 ***********  [name]@[host] IDENTIFIED BY [password];

Answer: CREATE USER

Source: ../../note/development/database/_/chapters/sql.md

====================

ユーザに権限を付与するには、 ***** コマンドを使用する。

 *****  [type] ON [database].[table] TO [user]@[host];

-- exampleデータベースに全権限を与える例
 *****  ALL ON example.* TO my_user@localhost;

Answer: GRANT

Source: ../../note/development/database/_/chapters/sql.md

====================

 ******** は、複数のSQLを1つの作業単位としてまとめて実行する処理。 ******** はSQL文をグループ化するためのメカニズムであり、すべての文が成功したか、すべての文が失敗したかの2つの結果しか起こり得ない。

 ******** 中はロック機構により他の ******** が実行できなくなるが、 ******** を並行して複数実行できるように意識することで処理は高速になる。

Answer: トランザクション

Source: ../../note/development/database/_/chapters/transaction.md

====================

 **** は、トランザクションが開始されてからの操作を確定し、トランザクションを終了する命令。

Answer: コミット

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ****** は、トランザクションが開始されてからの操作を取り消し、トランザクションを終了する命令。

Answer: ロールバック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******* は、トランザクションが異常終了してロールバックするときに、最初の状態まで戻すのではなく途中の状態に戻したいといった場合に用いる機能。

Answer: セーブポイント

Source: ../../note/development/database/_/chapters/transaction.md

====================

 *** は、データリソースが同時に使用されることで整合性が失われることを防ぐため、トランザクションがデータリソースを占有する機構。 *** されているデータに対して、別のトランザクションが *** をかけようとした場合、前の *** が解除されるまで待機する必要がある。

Answer: ロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ***** は、複数のトランザクションで共有することができるロックで、同じリソースの読み込みはできるが、書き込みはできない。

Answer: 共有ロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ***** は、ひとつのトランザクションによって占有されるロックで、他のトランザクションはリソースに対して読み込みも書き込みもできない。

Answer: 排他ロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******* は、テーブル内のすべてのデータを変更できないようにするロック。

Answer: テーブルロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ****** は、テーブル内の同じページ（一般に2〜16KBのメモリセグメント）のデータを変更できないようにするロック。

Answer: ページロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******* （行ロック）は、テーブル内の同じレコードを変更できないようにするロック。

Answer: レコードロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

レコードロック（ **** ）は、テーブル内の同じレコードを変更できないようにするロック。

Answer: 行ロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ********* は、ロック中のデータに別のトランザクションがロックをかけようとしてロック待ちの状態となった場合に、待ち時間の上限となる時間。 ********* がないと、デッドロックが発生したときにトランザクションが解除できなくなってしまう。

Answer: ロックタイムアウト

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ****** は、複数のトランザクションが互いにロックを掛け合うような状態となり、どちらのトランザクションもそれより先に処理を進めることができなくなる状態。 ****** の状態となると、トランザクションはロックタイムアウトに達し、トランザクションが解除される（ロックタイムアウト時は、設定に応じた挙動となる。自動的にロールバックするなど。）。

Answer: デッドロック

Source: ../../note/development/database/_/chapters/transaction.md

====================

 *********** は、トランザクションの分離性のレベル。制限が厳しいものは並行に実行できるトランザクションが少なくなるため、安全性は高い。制限が緩いものは並行性が高く、高速な処理ができる一方で、データの不整合性が発生しないように注意する必要がある。

Answer: アイソレーションレベル

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******** （直列化可能）は、最も厳しいアイソレーションレベルで、トランザクションは常に1つしか実行されない。データの整合性が失われたり、デッドロックとなるケースはない一方で、実行速度は遅い。

Answer: シリアライザブル

Source: ../../note/development/database/_/chapters/transaction.md

====================

シリアライザブル（ ***** ）は、最も厳しいアイソレーションレベルで、トランザクションは常に1つしか実行されない。データの整合性が失われたり、デッドロックとなるケースはない一方で、実行速度は遅い。

Answer: 直列化可能

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ********* （再読み込み可能読み取り）は、シリアライザブルの次に厳しいアイソレーションレベルで、データの読み取り時と変更時にロックがかかり、トランザクションが終わるまでロックは解除されない。

シリアライザブルでは発生しないファントムが発生する可能性がある。ただし、RDBMSによってはファントムが発生しない。

Answer: リピータブルリード

Source: ../../note/development/database/_/chapters/transaction.md

====================

リピータブルリード（ *********** ）は、シリアライザブルの次に厳しいアイソレーションレベルで、データの読み取り時と変更時にロックがかかり、トランザクションが終わるまでロックは解除されない。

シリアライザブルでは発生しないファントムが発生する可能性がある。ただし、RDBMSによってはファントムが発生しない。

Answer: 再読み込み可能読み取り

Source: ../../note/development/database/_/chapters/transaction.md

====================

 *********** （コミット済み読み取り）は、リードコミッテッドの次に緩いアイソレーションレベルで、データの読み取り時と変更時にロックがかかり、読み込み時はSQL実行後にロックが解除されるが、変更時はトランザクションが終わるまでロックが解除されない。

シリアライザブルでは発生しないファントムとファジーリードが発生する可能性がある。

Answer: リードアンコミッテッド

Source: ../../note/development/database/_/chapters/transaction.md

====================

リードアンコミッテッド（ ********** ）は、リードコミッテッドの次に緩いアイソレーションレベルで、データの読み取り時と変更時にロックがかかり、読み込み時はSQL実行後にロックが解除されるが、変更時はトランザクションが終わるまでロックが解除されない。

シリアライザブルでは発生しないファントムとファジーリードが発生する可能性がある。

Answer: コミット済み読み取り

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ********* （非コミット読み取り）は、最も緩いアイソレーションレベルで、データの変更時にロックがかかり、トランザクションが終わるまでロックが解除されない。読み込み時にはロックがかからない。

シリアライザブルでは発生しないファントムとファジーリードとダーティリードが発生する可能性がある。

Answer: リードコミッテッド

Source: ../../note/development/database/_/chapters/transaction.md

====================

リードコミッテッド（ ********* ）は、最も緩いアイソレーションレベルで、データの変更時にロックがかかり、トランザクションが終わるまでロックが解除されない。読み込み時にはロックがかからない。

シリアライザブルでは発生しないファントムとファジーリードとダーティリードが発生する可能性がある。

Answer: 非コミット読み取り

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ***** は、トランザクション中である範囲のデータを読み込むクエリを複数回実行したときに、2回目以降の実行で最初の実行時よりもデータが増減する現象。リピータブルリード（あるいはリードアンコミッテッド）よりも緩いアイソレーションレベルでは、データの読み込み時に読み込むデータのレコードロックを取るが、そのレコードロックの範囲外で別のトランザクションによりデータが挿入・削除される可能性があるため、 ***** が発生し得る。

Answer: ファントム

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******* （ノーリピータブルリード）は、トランザクション中で同じ読み込みのクエリを複数実行したときに、その結果が変わる現象。リードアンコミッテッドよりも緩いアイソレーションレベルでは、データの読み取り後にロックが解除されるため、別のトランザクションによってそのデータが変更されると ******* が発生する。

Answer: ファジーリード

Source: ../../note/development/database/_/chapters/transaction.md

====================

ファジーリード（ *********** ）は、トランザクション中で同じ読み込みのクエリを複数実行したときに、その結果が変わる現象。リードアンコミッテッドよりも緩いアイソレーションレベルでは、データの読み取り後にロックが解除されるため、別のトランザクションによってそのデータが変更されるとファジーリードが発生する。

Answer: ノーリピータブルリード

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******* は、あるトランザクションの変更がコミットされる前に、別のトランザクションから変更後の値を読み出せてしまう現象。リードコミッテッドでは、データの読み出し時にロックを獲得しようとしないため、 ******* が発生し得る。

Answer: ダーティリード

Source: ../../note/development/database/_/chapters/transaction.md

====================

 ******************** は、関連性のある一連のインスタンス群をまとめて生成する方法を提供するデザインパターン。このパターンを利用することで、関連するインスタンスのグループ単位での置き換えや追加が容易になる。Factory Methodパターンが、単体のインスタンス生成の枠組みを用意するのに対し、こちらは関連するインスタンスをまとめて管理することができる。

 ******************** は、AbstractProduct、ConcreteProduct、AbstractFactory、ConcreteFactoryから構成される。

Answer: Abstract Factoryパターン

Source: ../../note/development/design_pattern/_/chapters/abstract_factory.md

====================

 *************** （抽象的な製品）は、Abstract Factoryパターンにおいて、AbstractFactoryによって生成される抽象的なオブジェクトのインタフェースを定義する抽象クラス。 *************** は複数存在することができる。

Answer: AbstractProduct

Source: ../../note/development/design_pattern/_/chapters/abstract_factory.md

====================

 *************** （具体的な製品）は、Abstract Factoryパターンにおいて、AbstractProductが定義するインタフェースの具体的な実装を持つクラス。AbstractProductが複数存在する場合は、それぞれに対応した *************** の実装が必要となる。

Answer: ConcreteProduct

Source: ../../note/development/design_pattern/_/chapters/abstract_factory.md

====================

 *************** （抽象的な工場）は、Abstract Factoryパターンにおいて、グループ化された全てのAbstractProductを生成するためのインタフェースを定義する抽象クラス。それぞれのAbstractProductを生成するためのインタフェースを定義する。

Answer: AbstractFactory

Source: ../../note/development/design_pattern/_/chapters/abstract_factory.md

====================

 *************** （具体的な工場）は、Abstract Factoryパターンにおいて、AbstractFactoryが定義するインタフェースの具体的な実装を持つクラス。

Answer: ConcreteFactory

Source: ../../note/development/design_pattern/_/chapters/abstract_factory.md

====================

 *********** （Wrapperパターン）は、既存のクラスやコンポーネントを別のインタフェースに変換するためのデザインパターン。このパターンは、既存のクラスを利用したいが、そのインタフェースがプログラムとの互換性がない場合に非常に有用である。また、スーパクラスに欠けている機能を、対象となるオブジェクトをラップすることで動的に追加するという使い方もできる（Decoratorパターンのような使い方）。

 *********** は、Target、Adaptee、Adapterから構成される。

Answer: Adapterパターン

Source: ../../note/development/design_pattern/_/chapters/adapter.md

====================

Adapterパターン（ *********** ）は、既存のクラスやコンポーネントを別のインタフェースに変換するためのデザインパターン。このパターンは、既存のクラスを利用したいが、そのインタフェースがプログラムとの互換性がない場合に非常に有用である。また、スーパクラスに欠けている機能を、対象となるオブジェクトをラップすることで動的に追加するという使い方もできる（Decoratorパターンのような使い方）。

Adapterパターンは、Target、Adaptee、Adapterから構成される。

Answer: Wrapperパターン

Source: ../../note/development/design_pattern/_/chapters/adapter.md

====================

 ****** （対象）は、Adapterパターンにおいて、今必要となっているメソッド（インタフェース）を定める役割を持つ。継承を用いた場合はインタフェース、委譲を用いた場合はクラスがこの役を担う。

Answer: Target

Source: ../../note/development/design_pattern/_/chapters/adapter.md

====================

 ******* は、Adapterパターンにおいて、既存のメソッドの実装を提供する役割を持つクラス。この ******* が持つメソッドをTargetのメソッドに適合させるためにAdapterが必要となる。

Answer: Adaptee

Source: ../../note/development/design_pattern/_/chapters/adapter.md

====================

 ******* は、 ******* パターンにおいて、Adapteeの提供するメソッドを利用してTargetの要件を満たす役割を持つ。クラスを用いた ******* パターンの場合には、継承を使ってAdapteeを利用する。インスタンスを用いた ******* パターンの場合には、Adapteeのインスタンスをメンバ変数として保持し、それを介してAdapteeの機能を利用する（委譲）。

Answer: Adapter

Source: ../../note/development/design_pattern/_/chapters/adapter.md

====================

 ********** は、機能のクラス階層と実装のクラス階層を分離して継承させ、それぞれを独立して管理することで、拡張性を高めるデザインパターン。

クラス階層を分離しないアンチパターンとして、ある抽象クラスを実装した具象クラスがすでに存在するとする。その抽象クラスに機能を追加する目的で、そのクラスを継承した別の抽象クラスを新しく実装したとき、元のクラスの具象クラスの実装と同じものを再度作らなければならなくなる（新しく作った抽象クラスから、継承元の抽象クラスを実装した具象クラスは見えない）。そのため、機能を追加するたびに具象クラスの数が増えてしまう。

 ********** では、抽象クラスを用いずに、インスタンスの移譲を利用することでこのような問題を解決している。

 ********** は、Abstraction、RefinedAbstraction、Implementor、ConcreteImplementorから構成される。

Answer: Bridgeパターン

Source: ../../note/development/design_pattern/_/chapters/bridge.md

====================

 *********** （抽象化）は、Bridgeパターンの機能のクラス階層において、Implementorを介して具体的な実装を呼び出す抽象化クラス（抽象クラスではない）。メインプログラム等が実際に利用するのは、 *********** やそれを継承したRefined *********** となる。

 *********** は、実装のクラス階層の共通インタフェース（Implementor）を実装したクラスのインスタンス（ConcreteImplementor）をフィールドとして持つ。このインスタンスを介して具体的な実装を呼び出すことで、抽象クラスを用いずに抽象化を実現している。

Answer: Abstraction

Source: ../../note/development/design_pattern/_/chapters/bridge.md

====================

 ****************** （改善した抽象化）は、Bridgeパターンの機能のクラス階層において、Abstractionを継承して機能を拡充したクラス。Abstractionから直接継承するだけでなく、別の ****************** の機能を継承してさらに機能追加を行うこともできる。

Answer: RefinedAbstraction

Source: ../../note/development/design_pattern/_/chapters/bridge.md

====================

 *********** （実装者）は、Bridgeパターンの実装のクラス階層において、Abstractionが利用するメソッドを定義したインタフェース。AbstractionはImplementatorで宣言されたメソッドを介してのみ具体的な実装を利用することができる。

Answer: Implementor

Source: ../../note/development/design_pattern/_/chapters/bridge.md

