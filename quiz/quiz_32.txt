====================

参照は、Rustが所有権を持たないポインタ型。参照は参照先よりも長生きしてはいけないので、これを強調するためにRustではある参照を作ることを借用と呼ぶ。

関数に引数を渡す時に所有権を移動してしまうと、それ以降は引数に使った値が使えなくなってしまう（ *** ）。そのため、関数の引数として参照を用いるのが適切な場合も多い（参照渡し）。

Answer: 値渡し

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

参照は、Rustが所有権を持たないポインタ型。参照は参照先よりも長生きしてはいけないので、これを強調するためにRustではある参照を作ることを借用と呼ぶ。

関数に引数を渡す時に所有権を移動してしまうと、それ以降は引数に使った値が使えなくなってしまう（値渡し）。そのため、関数の引数として参照を用いるのが適切な場合も多い（ **** ）。

Answer: 参照渡し

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 **** は、読み取り専用の参照で、参照先の値を書き換えることはできない。ある値に対する **** は同時に複数取ることができる。 **** は、 &T のようにして記述する。

Answer: 共有参照

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 **** は、読み書き可能な参照で、参照先の値を読み書きできる。 **** は排他的であり、ある値に対して **** をとったときには他のあらゆる参照（共有参照も **** も）とることができない。 **** は、 &mut T のようにして記述する。

// show()は値を読んでいるだけなので、共有参照を取るようにすれば十分
fn show_table( table: &Table )
{
    // コレクション型に対して繰り返し実行すると、普通は所有権が移動されて値が消費されてしまう
    // 共有参照に対して繰り返し実行すると、個々のエントリのキーと値に対する共有参照が作られる
    for (key, values) in table
    {
        println!("key = {}:", key);

        for value in values
        {
            println!(" {}", value);
        }
    }
}

// sort()は値を書き換えるので、 **** を取る必要がある
fn sort_table( table: &mut Table )
{
    for (_key, values) in table
    {
        values.sort();
    }
}

Answer: 可変参照

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 ****** （生存期間）は、Rustコンパイラが参照型に対して割り当てるもので、プログラム実行中にその参照が安全に利用できる期間を指す。

ローカル変数の参照を借用して、その変数をスコープの外に持ち出すと、ダングリングポインタとなる。ライフライムの成約により、このような参照が作られることがなくなっている。

{
    let r;
    {
        let x = 1;
        r = &x;
    }
    assert_eq!(*r, 1);       // スコープの外ではxにアクセスできない
}

 ****** のルールは以下のとおり。

• ある変数の参照は、その変数よりも長生きしてはならない
• ある変数に格納した参照は、少なくともその変数と同じだけ生きていなければならない（変数の ****** は、その変数から借用した参照の ****** を包含していなければならない）

また、Rustは変数の ****** として可能な限り短い期間を想定する。

Answer: ライフタイム

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

ライフタイム（ **** ）は、Rustコンパイラが参照型に対して割り当てるもので、プログラム実行中にその参照が安全に利用できる期間を指す。

ローカル変数の参照を借用して、その変数をスコープの外に持ち出すと、ダングリングポインタとなる。ライフライムの成約により、このような参照が作られることがなくなっている。

{
    let r;
    {
        let x = 1;
        r = &x;
    }
    assert_eq!(*r, 1);       // スコープの外ではxにアクセスできない
}

ライフタイムのルールは以下のとおり。

• ある変数の参照は、その変数よりも長生きしてはならない
• ある変数に格納した参照は、少なくともその変数と同じだけ生きていなければならない（変数のライフタイムは、その変数から借用した参照のライフタイムを包含していなければならない）

また、Rustは変数のライフタイムとして可能な限り短い期間を想定する。

Answer: 生存期間

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 ******** は、Rustコンパイラがライフタイムを利用して参照の安全性を保証する機能。

Answer: ボローチェッカー

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 ************* は、プログラムの開始から終了まで存在するメモリリソースに割り当てられるライフタイム。

ある static な変数を更新する以下のような関数を考える。

static mut STASH: &i32 = &128;

fn update( p: &i32 )
{
    unsafe
    {
        STASH = p;
    }
}

このとき、関数のシグネチャはライフタイムパラメータを省略している（実際はRustのコンパイラが自動的に補完してくれるので省略可能）。これを明示的に記述すると以下のようになる。

fn update<'a>( p: &'a i32 ) { /* ... */ }

'a は任意のライフタイムであり、引数 p が任意のライフタイムパラメータを持っていることを示す。しかし、static変数である STASH に対して任意のライフタイムを持つ変数 p を代入するのは、ライフタイムのルールに反している（変数 p は少なくとも STASH と同じだけのライフタイムを持たなければならない）。そこで、関数の引数として取りうる値のライフタイムを ************* にすることでこの問題を解決できる。

fn update( p: &'static i32 ) { /* ... */ }

Answer: 'staticライフタイム

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

'staticライフタイムは、プログラムの開始から終了まで存在するメモリリソースに割り当てられるライフタイム。

ある static な変数を更新する以下のような関数を考える。

static mut STASH: &i32 = &128;

fn update( p: &i32 )
{
    unsafe
    {
        STASH = p;
    }
}

このとき、関数のシグネチャは *********** を省略している（実際はRustのコンパイラが自動的に補完してくれるので省略可能）。これを明示的に記述すると以下のようになる。

fn update<'a>( p: &'a i32 ) { /* ... */ }

'a は任意のライフタイムであり、引数 p が任意の *********** を持っていることを示す。しかし、static変数である STASH に対して任意のライフタイムを持つ変数 p を代入するのは、ライフタイムのルールに反している（変数 p は少なくとも STASH と同じだけのライフタイムを持たなければならない）。そこで、関数の引数として取りうる値のライフタイムを'staticライフタイムにすることでこの問題を解決できる。

fn update( p: &'static i32 ) { /* ... */ }

Answer: ライフタイムパラメータ

Source: ../../note/programming/rust/_/chapters/reference_and_lifetime.md

====================

 **** は、システムプログラミングのための言語であり、CやC++といった言語を置き替える次世代のプログラミング言語となることを目指している。

Answer: Rust

Source: ../../note/programming/rust/_/chapters/rust.md

====================

C++には ********** という、実行することに対して余計なコード（ガベージコレクションなど）でCPUを消費しない、という考え方がある。

Rustにはゼロコスト抽象化という、抽象化の処理に最小限のコストしか払わないという考え方がある。例えば、Rustの抽象型であるtraitはコンパイル時に静的ディスパッチ（具体的な型に変換）されるため、実行時のオーバヘッドがない。

RustはC++と同様に、プログラマがコンピュータの能力を最大限活用できるようなコードを書くことをサポートする言語である。

Answer: ゼロオーバヘッド原則

Source: ../../note/programming/rust/_/chapters/rust.md

====================

C++にはゼロオーバヘッド原則という、実行することに対して余計なコード（ガベージコレクションなど）でCPUを消費しない、という考え方がある。

Rustには ******** という、抽象化の処理に最小限のコストしか払わないという考え方がある。例えば、Rustの抽象型であるtraitはコンパイル時に静的ディスパッチ（具体的な型に変換）されるため、実行時のオーバヘッドがない。

RustはC++と同様に、プログラマがコンピュータの能力を最大限活用できるようなコードを書くことをサポートする言語である。

Answer: ゼロコスト抽象化

Source: ../../note/programming/rust/_/chapters/rust.md

====================

 ****** は、Rustのインストールやアップデートを行うためのツール。  ******  コマンドで、Rustのコンパイルに必要なツールチェーンやクロスコンパイル環境を構築することができる。

•  ****** のインストール

 ******  install は、Rustのツールチェーンをインストールするコマンド。配布用チャネルとして、安定リリース版の stable 、次期バージョンに向けたベータ版の beta 、開発版の nightly を指定できる。

Answer: rustup

Source: ../../note/programming/rust/_/chapters/rust.md

====================

 ***** は、Rustのビルドシステムとパッケージマネージャを兼ね備えたツール。 ***** を用いることで、ソースコードのビルドや、依存しているパッケージのダウンロードなどがコマンドひとつで完結するようになる。

cargo new および cargo init は、Rustのプロジェクトを作成するためのコマンド。 cargo new コマンドは引数にプロジェクト名を指定することで、新しいプロジェクトのディレクトリ内に開発のための環境が作成される。一方、 cargo init はカレントディレクトリをRustプロジェクトとするためのコマンド。 --bin オプションをつけることでバイナリ向けのプロジェクト、 --lib オプションをつけることでライブラリ向けのプロジェクトとして初期化される（デフォルトは --bin ）。

Answer: Cargo

Source: ../../note/programming/rust/_/chapters/rust.md

====================

 ***** は、Rustのコンパイラ。ビルドツールとしてCargoを利用しているプロジェクトでは、内部で自動的に ***** が実行されている。クロスコンパイルが可能で、Windows、Linux、macOS向けの実行ファイル他、AndroidやiOSで動作するライブラリをホストマシンで出力することができる。

Rustで書かれたプログラムを指定することで、それをコンパイルすることができる。

$  *****  <path>

Answer: rustc

Source: ../../note/programming/rust/_/chapters/rust.md

====================

 ******* は、Rustのドキュメンテーションツールで、ソースコード中のドキュメンテーションコメントを整形してHTMLを生成する。また、ドキュメンテーションコメント中に書かれたRustプログラムが正常に動作するかをテストすることができる。

Rustで書かれたプログラムを指定することで、そのソースコードに対するHTMLドキュメントを生成することができる。

$  *******  <path>

Cargoを用いたプロジェクトでは、次のコマンドで ******* を使用することができる。

$ cargo doc

Answer: rustdoc

Source: ../../note/programming/rust/_/chapters/rust.md

====================

 **** (Redundant Arrays of Inexpensive Disks)は、複数台のハードディスクを接続して全体でひとつの記憶装置として扱う冗長化の仕組み。複数台のディスクを組み合わせることによって、信頼性や性能が向上する。

Answer: RAID

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、複数のハードディスクにデータを分散することで高速化するRAIDの方式。これをストライピングといい、性能は上がるものの信頼性は1台のディスクに比べて低下する。

Answer: RAID0

Source: ../../note/system/_/chapters/raid.md

====================

RAID0は、複数のハードディスクにデータを分散することで高速化するRAIDの方式。これを ******* といい、性能は上がるものの信頼性は1台のディスクに比べて低下する。

Answer: ストライピング

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、複数のハードディスクに同時に同じデータを書き込むことで信頼性を向上させたRAIDの方式。これをミラーリングといい、2台のディスクはお互いに完全なバックアップとなっているため、性能は特に上がらない。

Answer: RAID1

Source: ../../note/system/_/chapters/raid.md

====================

RAID1は、複数のハードディスクに同時に同じデータを書き込むことで信頼性を向上させたRAIDの方式。これを ****** といい、2台のディスクはお互いに完全なバックアップとなっているため、性能は特に上がらない。

Answer: ミラーリング

Source: ../../note/system/_/chapters/raid.md

====================

 ******* やRAID1+0は、4台のディスクを用いてRAID0とRAID1を組み合わせることで性能と信頼性の両方を向上させるRAIDの方式。 ******* はストライピングされたディスクをミラーリングし、RAID1+0はミラーリングされたディスクをストライピングする。

Answer: RAID0+1

Source: ../../note/system/_/chapters/raid.md

====================

RAID0+1や ******* は、4台のディスクを用いてRAID0とRAID1を組み合わせることで性能と信頼性の両方を向上させるRAIDの方式。RAID0+1はストライピングされたディスクをミラーリングし、 ******* はミラーリングされたディスクをストライピングする。

Answer: RAID1+0

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、複数のディスクのうち1台を誤り訂正用のパリティディスクにし、誤りが発生した場合に復元するRAIDの方式。パリティディスクにほかのディスクの偶数パリティを計算したものを格納しておく。データの復元はビットごとに行う。

Answer: RAID3

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、複数のディスクのうち1台を誤り訂正用のパリティディスクにし、誤りが発生した場合に復元するRAIDの方式。パリティディスクにほかのディスクの偶数パリティを計算したものを格納しておく。データの復元はブロックごとにまとめて行う。

Answer: RAID4

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、データへのアクセス効率を上げるためにパリティをブロックごとに分散し、通常時にもすべてのディスクを用いるようにしたRAIDの方式。RAID3やRAID4と比べて信頼性は同等だが、性能面では優れている。ひとつのディスクが故障しても、他のディスクの排他的論理和を計算することで復元できる。

Answer: RAID5

Source: ../../note/system/_/chapters/raid.md

====================

 ***** は、冗長データを2種類作成することで、2台のディスクが故障しても支障をきたさないようにしたRAIDの方式。RAID3、RAID4、RAID5はパリティ用のディスクも含めて最低でもディスクが3台必要となるが、 ***** では4台必要となる。

Answer: RAID6

Source: ../../note/system/_/chapters/raid.md

====================

 *** (Direct Attached Storage)は、サーバにストレージを直接接続する従来の方式。SANやNASと区別するために *** と呼ばれる。

Answer: DAS

Source: ../../note/system/_/chapters/raid.md

====================

 *** (Storage Area Network)は、サーバとストレージを接続するために専用のネットワークを使用する方法。ファイバチャネルやIPネットワークを使って、あたかも内蔵したストレージのように使用することができる。ファイバチャネルとは、主にストレージネットワーク用に使用される高速ネットワークを構築する技術のひとつ。

Answer: SAN

Source: ../../note/system/_/chapters/raid.md

====================

SAN(Storage Area Network)は、サーバとストレージを接続するために専用のネットワークを使用する方法。 ******** やIPネットワークを使って、あたかも内蔵したストレージのように使用することができる。 ******** とは、主にストレージネットワーク用に使用される高速ネットワークを構築する技術のひとつ。

Answer: ファイバチャネル

Source: ../../note/system/_/chapters/raid.md

====================

 *** (Network Attached Storage)は、ファイルを格納するサーバをネットワークに直接接続することで、外部からファイルを利用できるようにする方法。複数のサーバやクライアントがストレージを共有できるため、資源を効率的に活用することができる。また、物理的なストレージの数が減らせることから、バックアップも取りやすくなる。

Answer: NAS

Source: ../../note/system/_/chapters/raid.md

====================

 ********** （耐障害性: Fault tolerance）は、システムの一部で障害が発生しても全体でカバーして機能停止を防ぐ設計手法。単一障害点を排除することで、耐障害性を向上させることができる。復旧後に復旧前よりもシステムが使いづらくなるようであれば、耐障害性はないと言える。

Answer: フォールトトレランス

Source: ../../note/system/_/chapters/reliability_design.md

====================

フォールトトレランス（ **** : Fault tolerance）は、システムの一部で障害が発生しても全体でカバーして機能停止を防ぐ設計手法。単一障害点を排除することで、 **** を向上させることができる。復旧後に復旧前よりもシステムが使いづらくなるようであれば、 **** はないと言える。

Answer: 耐障害性

Source: ../../note/system/_/chapters/reliability_design.md

====================

 *********** （障害回避: Fault avoidance）は、個々の機能の障害が起こる確率を下げて、全体として信頼性を上げるという考え方。

Answer: フォールトアボイダンス

Source: ../../note/system/_/chapters/reliability_design.md

====================

フォールトアボイダンス（ **** : Fault avoidance）は、個々の機能の障害が起こる確率を下げて、全体として信頼性を上げるという考え方。

Answer: 障害回避

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ******* は、システムに障害が発生したとき、安全な方に制御する方法。障害が新たな障害を生まない制御をしたり、場合によっては処理を停止させる。

Answer: フェールセーフ

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ******* は、システムに障害が発生したとき、障害が起こった部分を切り離すなどして最低限のシステムの稼働を続ける方法。このとき、機能を限定的にして稼働を続ける操作をフォールバック（縮退運転）という。

Answer: フェールソフト

Source: ../../note/system/_/chapters/reliability_design.md

====================

フェールソフトは、システムに障害が発生したとき、障害が起こった部分を切り離すなどして最低限のシステムの稼働を続ける方法。このとき、機能を限定的にして稼働を続ける操作を ******* （縮退運転）という。

Answer: フォールバック

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ********** は、機器などに障害が発生した時、その影響が外部に出ないようにする方法。システムの冗長化などによって、1台が故障しても全体に影響が出ないようにするなど。

Answer: フォールトマスキング

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ******* は、利用者が誤った操作を行っても危険な状態にならないようにする設計手法。押せてはいけないボタンを押せないようにしたり、危険な操作に対しては確認を行うなど。

Answer: フールプルーフ

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ******* は、障害発生時に運用系のシステムから待機系のシステムに自動的に切り替える機能や設計。サーバを ******* にするには、仮想IPアドレス(VIP: Virtual IP Address)を用いて障害発生時にVIPの引き継ぎを行う。

Answer: フェールオーバ

Source: ../../note/system/_/chapters/reliability_design.md

====================

フェールオーバは、障害発生時に運用系のシステムから待機系のシステムに自動的に切り替える機能や設計。サーバをフェールオーバにするには、 ******** (VIP: Virtual IP Address)を用いて障害発生時にVIPの引き継ぎを行う。

Answer: 仮想IPアドレス

Source: ../../note/system/_/chapters/reliability_design.md

====================

フェールオーバは、障害発生時に運用系のシステムから待機系のシステムに自動的に切り替える機能や設計。サーバをフェールオーバにするには、仮想IPアドレス( *** : Virtual IP Address)を用いて障害発生時に *** の引き継ぎを行う。

Answer: VIP

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ******* は、フェールオーバの実現やシステムの監視のために、運用系のシステムに異常が発生していないかを定期的にチェックする仕組みのこと。IPのレイヤではICMP監視、TCPのレイヤではポート監視、アプリケーションのレイヤではHTTPリクエストなどによるサービス監視が行われる。

Answer: ヘルスチェック

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ****** は、ネットワークのネットワーク層におけるヘルスチェックの手法で、ICMPのechoリクエストを投げてリプライが返ってくるかをチェックする。最も容易で軽いヘルスチェックではあるが、Webサービスの停止（ApacheやNginxの停止など）は検知することができない。

Answer: ICMP監視

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ***** は、ネットワークのトランスポート層におけるヘルスチェックの手法で、TCPでの接続を試みて、接続ができるかどうかをチェックする。サービスがダウンしたことを検知できるが、過負荷状態で応答できなくなっていたり、エラーを返していることは検知できない。

Answer: ポート監視

Source: ../../note/system/_/chapters/reliability_design.md

====================

 ****** は、ネットワークのアプリケーション層におけるヘルスチェックの手法で、HTTPリクエストなどを発行して、正常な応答が返ってくるかどうかをチェックする。ほとんどの異常を検知することができるが、場合によってはサーバに負荷をかけてしまうこともある。

Answer: サービス監視

Source: ../../note/system/_/chapters/reliability_design.md

====================

 **** は、個々の要素が互いに影響し合いながら、全体として機能するまとまりや仕組み。

Answer: システム

Source: ../../note/system/_/chapters/system.md

====================

 ****** は、システムを構成する要素の中の、より小さな単位のシステム。

Answer: サブシステム

Source: ../../note/system/_/chapters/system.md

====================

 ******** は、システムのコアとなる機能や、システムが目的とする処理を行う部分。

Answer: ビジネスロジック

Source: ../../note/system/_/chapters/system.md

====================

 *** (Redundancy)あるいは多重性はシステムに障害が発生した場合に備えて冗長な予備装置を運用する仕組み。システムに *** を持たせることを冗長化という。メインのサーバ（運用系）に加えて障害時に備えた予備のサーバ（待機系）を常に運用しておくのは、冗長化の例である。

Answer: 冗長性

Source: ../../note/system/_/chapters/system_architecture.md

====================

冗長性(Redundancy)あるいは *** はシステムに障害が発生した場合に備えて冗長な予備装置を運用する仕組み。システムに冗長性を持たせることを冗長化という。メインのサーバ（運用系）に加えて障害時に備えた予備のサーバ（待機系）を常に運用しておくのは、冗長化の例である。

Answer: 多重性

Source: ../../note/system/_/chapters/system_architecture.md

====================

冗長性(Redundancy)あるいは多重性はシステムに障害が発生した場合に備えて冗長な予備装置を運用する仕組み。システムに冗長性を持たせることを *** という。メインのサーバ（運用系）に加えて障害時に備えた予備のサーバ（待機系）を常に運用しておくのは、 *** の例である。

Answer: 冗長化

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ***** (SPOF: Single Point Of Failure)は、システムを構成する要素のうちそこが停止するとシステム全体が停止してしまう部分。可用性の高いシステムを構成するには、個々の構成要素を冗長化してフェールオーバの機構を用意しておくなど、 ***** を減らすことが重要となる。

Answer: 単一障害点

Source: ../../note/system/_/chapters/system_architecture.md

====================

単一障害点( **** : Single Point Of Failure)は、システムを構成する要素のうちそこが停止するとシステム全体が停止してしまう部分。可用性の高いシステムを構成するには、個々の構成要素を冗長化してフェールオーバの機構を用意しておくなど、単一障害点を減らすことが重要となる。

Answer: SPOF

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *** （タイムシェアリングシステム）は、1台のコンピュータを複数人で同時に使用するための構成。一定時間ごとにCPUの使用権を切り替えながら処理を実行する。

Answer: TSS

Source: ../../note/system/_/chapters/system_architecture.md

====================

TSS（ ************* ）は、1台のコンピュータを複数人で同時に使用するための構成。一定時間ごとにCPUの使用権を切り替えながら処理を実行する。

Answer: タイムシェアリングシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *********** は、オンラインシステムにおいて、予備機を持たずに1つのコンピュータで処理を行う構成。処理能力や信頼性は劣るが、運用コストが低くなる。

Answer: シンプレックスシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ******** は、オンラインシステムにおいて、処理するための機器を二重化した構成で、2つのコンピュータは同じ処理を行う。2系統の演算結果をクロスチェックしながら処理を進めるため信頼性が高く、一方のコンピュータが故障した場合でももう一方で処理を継続できる。

Answer: デュアルシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *********** は、処理系を2つ用意しておき、一方をメインのオンライン処理用、もう一方をバッチ処理や待機系として用いる構成。信頼性はデュアルシステムに比べると劣るが、コスト面では有利である。

Answer: デュプレックスシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ******** は、運用系のシステムと全く同じ環境にデータを常に同期し続け、障害発生時に即座に待機系（予備のサーバなど）を運用系と切り替える手法。保守性を高めることができる一方でコストが大きくなる。

Answer: ホットスタンバイ

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ********* は、待機系のシステムを最小限のリソースで起動しておき、障害発生時に運用系と切り換える手法。切り替えの際には運用系に比べてスペックが落ちるため、切り替え時にリソースを追加する必要がある場合もある。

Answer: ウォームスタンバイ

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ********* は、通常時は待機系のシステムに電源を供給せず、障害発生時に待機系のシステムを起動してリソースなどを用意した後に運用系と切り換える手法。最もコストが低いが復旧までに時間がかかり、保守性が下がってしまう。

Answer: コールドスタンバイ

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ********* は、システムが稼働不可能な状態となった場合などに備えておくための機器や場所。障害や災害が発生した際に、復旧作業を行うための場所として用いられる。

Answer: バックアップサイト

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************ は、複数のプロセッサを同時に使用することで、システム全体の処理能力と耐障害性を向上させる構成。

Answer: マルチプロセッサシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************** (SMP: Symmetric Multiple Processor)は、全てのプロセッサに対して均一に処理を振り分けて並列処理を行う構成。

Answer: 対称マルチプロセッサシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

対称マルチプロセッサシステム( *** : Symmetric Multiple Processor)は、全てのプロセッサに対して均一に処理を振り分けて並列処理を行う構成。

Answer: SMP

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *************** (ASMP: Asymmetirc Multiple Processor)は、各プロセッサが個別の役割を持っており、それぞれにかかる負荷が対称とならないような構成。

Answer: 非対称マルチプロセッサシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

非対称マルチプロセッサシステム( **** : Asymmetirc Multiple Processor)は、各プロセッサが個別の役割を持っており、それぞれにかかる負荷が対称とならないような構成。

Answer: ASMP

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *************** (TCMP: Tightly Coupled Multiprocessor)は、主記憶を共有しながら1つのOSによって制御されるような構成。1つのプロセッサパッケージに複数の独立したプロセッサコアが搭載されているマルチコアプロセッサは代表的なTCMPのひとつ。

Answer: 密結合マルチプロセッサシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

密結合マルチプロセッサシステム( **** : Tightly Coupled Multiprocessor)は、主記憶を共有しながら1つのOSによって制御されるような構成。1つのプロセッサパッケージに複数の独立したプロセッサコアが搭載されているマルチコアプロセッサは代表的な **** のひとつ。

Answer: TCMP

Source: ../../note/system/_/chapters/system_architecture.md

====================

密結合マルチプロセッサシステム(TCMP: Tightly Coupled Multiprocessor)は、主記憶を共有しながら1つのOSによって制御されるような構成。1つのプロセッサパッケージに複数の独立したプロセッサコアが搭載されている ********** は代表的なTCMPのひとつ。

Answer: マルチコアプロセッサ

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *************** (LCMP: Loosely Coupled Multiprocessor)またはクラスタシステムは、複数のプロセッサがそれぞれの主記憶装置を持ち、別々のOSによって制御されるような構成。多くの場合、単体で完結して動作する独立した複数のコンピュータを、通信インタフェースを介して連動させて全体をひとつのシステムとする構成となっている。

Answer: 疎結合マルチプロセッサシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

疎結合マルチプロセッサシステム( **** : Loosely Coupled Multiprocessor)またはクラスタシステムは、複数のプロセッサがそれぞれの主記憶装置を持ち、別々のOSによって制御されるような構成。多くの場合、単体で完結して動作する独立した複数のコンピュータを、通信インタフェースを介して連動させて全体をひとつのシステムとする構成となっている。

Answer: LCMP

Source: ../../note/system/_/chapters/system_architecture.md

====================

疎結合マルチプロセッサシステム(LCMP: Loosely Coupled Multiprocessor)または ******** は、複数のプロセッサがそれぞれの主記憶装置を持ち、別々のOSによって制御されるような構成。多くの場合、単体で完結して動作する独立した複数のコンピュータを、通信インタフェースを介して連動させて全体をひとつのシステムとする構成となっている。

Answer: クラスタシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************* は、複数のコンピュータを接続して単一のコンピュータとして使用する方式で、単にクラスタ、クラスタリングとも呼ばれる。負荷分散やHPCの手法として用いられる場合が多い。

Answer: クラスタコンピューティング

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** コンピューティングは、複数のコンピュータを接続して単一のコンピュータとして使用する方式で、単に **** 、 **** リングとも呼ばれる。負荷分散やHPCの手法として用いられる場合が多い。

Answer: クラスタ

Source: ../../note/system/_/chapters/system_architecture.md

====================

クラスタコンピューティングは、複数のコンピュータを接続して単一のコンピュータとして使用する方式で、単にクラスタ、 ******* とも呼ばれる。負荷分散やHPCの手法として用いられる場合が多い。

Answer: クラスタリング

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ******** は、それぞれ機能の異なる複数の専用プロセッサを直列に接続した構成。メッセージ処理専用のフロントエンドプロセッサ、データベース管理専用のバックエンドプロセッサなどからなる。

Answer: ダンデムシステム

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ****** は、各企業や個人が独自にサーバなどのインフラ環境を構築し、利用・運用する方式。

Answer: オンプレミス

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************* は、インターネットを介して、アプリケーションやデータベース、ストレージなどを利用する形態やサービス。場所や端末を選ばずにコンピュータに接続することができる。クラウドは仮想化技術により資源を自動的に提供する仕組みの応用である。

Answer: クラウドコンピューティング

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ********** は、仮想化されたシステム全体を必要に応じて自動的に制御する仕組み。

Answer: オーケストレーション

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** (Software as a Service)は、サーバ上のコンピュータにインストールされたソフトウェアを、インターネット経由でサービスとしてユーザに提供する形態。ユーザはアカウントさえ持っていれば、インターネットを通じてどこからでもソフトウェアを利用することができる。

Answer: SaaS

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** (Platform as a Service)は、サーバ上のコンピュータにインストールされたミドルウェアなどの開発プラットフォームを、インターネット経由でサービスとしてユーザに提供する形態。開発者はデータベースやオブジェクトストレージといったミドルウェアを利用することができる。

Answer: PaaS

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** (Infrastructure as a Service)は、ネットワークやサーバ（CPU、メモリ、ストレージ）などのコンピューティングリソースを提供するサービス形態。従来は自社のオンプレミス環境を利用してITシステムを運用する必要があったが、 **** を利用することで必要な時に必要なだけコンピューティングリソースを借りることができる。

Answer: IaaS

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** (Function as a Service)は、サーバレスの状態でアプリケーション開発を可能とするようなサービスの提供形態。サーバレスは、サービス提供者がコンピューティングリソースの管理を行うことで、開発者の負担を減らすことを目的としている。コストの削減やスケーラビリティの確保といった面でも有利。

Answer: FaaS

Source: ../../note/system/_/chapters/system_architecture.md

====================

 **** (Desktop as a Service)は、VDIを利用することでデスクトップ環境を提供するサービス形態。

Answer: DaaS

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************* は、インターネットなどを介してコンピュータを結び付け、高い処理能力を得る構成。

Answer: グリッドコンピューティング

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ************ は、サービスを提供するサーバとサービスの利用者の距離が物理的に近くなるような構成。ユーザの使用するIoTデバイスやモバイル端末といったエッジに処理を集中させることで、ネットワークのオーバヘッドを減らすことができる。

Answer: エッジコンピューティング

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *** コンピューティングは、サービスを提供するサーバとサービスの利用者の距離が物理的に近くなるような構成。ユーザの使用するIoTデバイスやモバイル端末といった *** に処理を集中させることで、ネットワークのオーバヘッドを減らすことができる。

Answer: エッジ

Source: ../../note/system/_/chapters/system_architecture.md

====================

 *** (Content Delivery Network)は、クラウドにおけるエッジコンピューティングの手法のひとつで、サーバを各所に分散して配置することで、クライアントに近いサーバからコンテンツを配信する仕組み。インターネット回線の負荷を軽減するために、動画や音声などの大容量データを *** によって配信することが多い。

Answer: CDN

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ***** は、仮想OSを用いて1台の物理サーバ上で複数の仮想マシンを走らせ、それを1台のコンピュータとして利用したり、クラスタリングにより複数台のマシンをひとつにまとめたりする技術。ソフトウェアを使って仮想的に必要な資源を割り当てる。

システムによっては、平日は利用者数が少ないが休日は利用者数が増える、一日の中でアクセスが多い時間帯と少ない時間帯がある、といった負荷のムラがある。 ***** は、こういったネットワーク資源の無駄を減らすために生まれた。

Answer: 仮想化技術

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ***** (VM: Virtual Machine)は、あるコンピュータ環境において、ソフトウェアなどによって作り出した別のコンピュータ環境のこと。別のOS向けのソフトウェアを動かしたり、1台のコンピュータで冗長化を実現したりすることができるようになる。エミュレータやJava ***** 、IaaSなども ***** のひとつ。

Answer: 仮想マシン

Source: ../../note/system/_/chapters/system_architecture.md

====================

仮想マシン( ** : Virtual Machine)は、あるコンピュータ環境において、ソフトウェアなどによって作り出した別のコンピュータ環境のこと。別のOS向けのソフトウェアを動かしたり、1台のコンピュータで冗長化を実現したりすることができるようになる。エミュレータやJava仮想マシン、IaaSなども仮想マシンのひとつ。

Answer: VM

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ****** の仮想マシンは、OS上に仮想化アプリケーションをインストールし、その上にゲストOSを導入する。ひとつのコンピュータ上に複数のOSが存在する状態となるのでオーバヘッドは大きいが、ゲストOSのカスタマイズが自由にできる利点がある。VMWareやVirtualBoxといったソフトウェアが有名。

Answer: ホストOS型

Source: ../../note/system/_/chapters/system_architecture.md

====================

ホストOS型の仮想マシンは、OS上に仮想化アプリケーションをインストールし、その上に ***** を導入する。ひとつのコンピュータ上に複数のOSが存在する状態となるのでオーバヘッドは大きいが、 ***** のカスタマイズが自由にできる利点がある。VMWareやVirtualBoxといったソフトウェアが有名。

Answer: ゲストOS

Source: ../../note/system/_/chapters/system_architecture.md

====================

ホストOS型の仮想マシンは、OS上に仮想化アプリケーションをインストールし、その上にゲストOSを導入する。ひとつのコンピュータ上に複数のOSが存在する状態となるのでオーバヘッドは大きいが、ゲストOSのカスタマイズが自由にできる利点がある。 ****** やVirtualBoxといったソフトウェアが有名。

Answer: VMWare

Source: ../../note/system/_/chapters/system_architecture.md

====================

ホストOS型の仮想マシンは、OS上に仮想化アプリケーションをインストールし、その上にゲストOSを導入する。ひとつのコンピュータ上に複数のOSが存在する状態となるのでオーバヘッドは大きいが、ゲストOSのカスタマイズが自由にできる利点がある。VMWareや ********** といったソフトウェアが有名。

Answer: VirtualBox

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ******** の仮想マシンは、サーバなどに直接ハイパーバイザと呼ばれる管理用のソフトウェアをインストールし、その上でゲストOSを動作させる。ホストOSが不要なため処理速度の低下を最低限に抑えられ、複数の仮想マシンをリソースの無駄なく効率的に動かすことができる。

Answer: ハイパーバイザ型

Source: ../../note/system/_/chapters/system_architecture.md

====================

 ***** の仮想マシンは、ホストOS上でコンテナエンジンを起動しておき、コンテナイメージを作成して独立したコンテナ環境でアプリケーションを動作させる。 ***** はゲストOSを必要とせず、それぞれのアプリケーションに対して個別のリソース領域を割り当てる。ホストOS型やハイパーバイザ型に比べてリソースの消費が抑えられ、高速に動作するというメリットがある。DockerやPodmanといったソフトウェアが有名。

Answer: コンテナ型

Source: ../../note/system/_/chapters/system_architecture.md

