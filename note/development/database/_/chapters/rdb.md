# 『RDB』ノート

（最終更新： 2023-10-18）


## 目次

1. [リレーショナルモデル](#リレーショナルモデル)
	1. [エンティティ](#エンティティ)
	1. [アトリビュート](#アトリビュート)
	1. [テーブル](#テーブル)
	1. [レコード](#レコード)
	1. [カラム](#カラム)
	1. [結果セット](#結果セット)
	1. [プライマリキー](#プライマリキー)
	1. [外部キー](#外部キー)
1. [ブロック](#ブロック)
1. [RDBの階層構造](#rdbの階層構造)
	1. [インスタンス](#インスタンス)
	1. [スキーマ](#スキーマ)
1. [ER図](#er図)
1. [正規化](#正規化)
	1. [非正規化形](#非正規化形)
	1. [第1正規化形](#第1正規化形)
	1. [第2正規化形](#第2正規化形)
	1. [第3正規化形](#第3正規化形)
1. [データ型](#データ型)
1. [null](#null)
1. [制約](#制約)
	1. [NOT NULL](#not-null)
	1. [PRIMARY KEY](#primary-key)
	1. [UNIQUE KEY](#unique-key)
	1. [FOREIGN KEY](#foreign-key)
	1. [CHECK](#check)
1. [フェッチ](#フェッチ)
1. [トリガー](#トリガー)
1. [物理削除](#物理削除)
1. [論理削除](#論理削除)


## リレーショナルモデル

**リレーショナルモデル**は、[リレーショナルデータベース](./database.md#リレーショナルデータベース)のデータモデル。

### エンティティ

**エンティティ**は、顧客、部品、地域などの、[データベース](./database.md#データベース)に格納される対象となるデータ。

### アトリビュート

**アトリビュート**は、[エンティティ](#エンティティ)が持つ属性。例えば、顧客という[エンティティ](#エンティティ)には、顧客番号、顧客名、顧客所属名などのアトリビュートを格納するといった具合。

### テーブル

**テーブル**は、関連する情報の集合を格納した表形式のデータ構造。[リレーショナルモデル](#リレーショナルモデル)における[エンティティ](#エンティティ)を、[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)が扱いやすいようにした形式で、データは[ストレージ](../../../../computer/hardware/_/chapters/hardware.md#記憶装置)に格納されて永続的に保持される。

### レコード

**レコード**（**行**）は、[テーブル](#テーブル)に格納された実際のデータ。[エンティティ](#エンティティ)の各データの[アトリビュート](#アトリビュート)を説明するための[カラム](#カラム)の集合。

### カラム

**カラム**（**列**）は、[テーブル](#テーブル)が持つ情報。[リレーショナルモデル](#リレーショナルモデル)における[アトリビュート](#アトリビュート)を、[テーブル](#テーブル)の概念に合わせて定義したもの。

### 結果セット

**結果セット**は、[クエリ](./sql.md#クエリ)の結果として得られる、非永続的な[テーブル](#テーブル)。

### プライマリキー

**プライマリキー**（**主キー**）は、[テーブル](#テーブル)内の各[レコード](#レコード)に与えられる一意のIDとして用いることができる、1つ以上の[カラム](#カラム)。各[テーブル](#テーブル)はプライマリキーとして利用できる[カラム](#カラム)を持つことがほとんどで、各[レコード](#レコード)は必ずこの[カラム](#カラム)に一意の値を持つ必要がある。

### 外部キー

**外部キー**は、ある[テーブル](#テーブル)が別の[テーブル](#テーブル)の[レコード](#レコード)を一意に特定するための情報を持つ[カラム](#カラム)。この[制約](#制約)のある[カラム](#カラム)には、参照先の[テーブル](#テーブル)の[プライマリキー](#プライマリキー)として存在する値しか格納することができない。


## ブロック

**ブロック**は、[データベース](./database.md#データベース)において、データを実際に格納するための[ディスク](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)領域。[コンピュータ](../../../../computer/_/chapters/computer.md#コンピュータ)はデータの読み書きを[ブロック](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ブロック)単位で行っており、ひとつの[ブロック](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ブロック)には複数の[レコード](#レコード)が格納される。


## RDBの階層構造

[リレーショナルデータベース](./database.md#リレーショナルデータベース)は、[インスタンス](#インスタンス)、[データベース](./database.md#データベース)、[スキーマ](#スキーマ)、オブジェクト（[テーブル](#テーブル)、[インデックス](./index.md#インデックス)、[ストアドプロシージャ](../../../../system/_/chapters/system_processing_model.md#ストアドプロシージャ)など）という4つの階層に分かれている。

### インスタンス

**インスタンス**は、[DBMS](./database.md#dbms)の動作単位で、[データベース](./database.md#データベース)よりも上の階層にある概念。[OS](../../../../computer/software/_/chapters/operating_system.md#オペレーティングシステム)からは[プロセス](../../../../computer/software/_/chapters/operating_system.md#プロセス)として見える。

### スキーマ

**スキーマ**は、[データベース](./database.md#データベース)の下の階層で、[テーブル](#テーブル)を格納してまとめる[ディレクトリ](../../../../computer/software/_/chapters/file_system.md#ディレクトリ)のような概念。スキーマごとにアクセス制限をかけてセキュリティを向上させたり、用途によって[テーブル](#テーブル)を分けて管理したりすることができる。[MySQL](./database.md#dbms)では、[データベース](./database.md#データベース)とスキーマを同一とみなしており、標準SQLの定める4階層構造ではなく3階層構造を採用している。


## ER図

**ER図**(Entity-Relationship deagram)は、現実の世界の[エンティティ](#エンティティ)とその関連性、[エンティティ](#エンティティ)が持つ[アトリビュート](#アトリビュート)を図で示したもの。


## 正規化

**正規化**は、[エンティティ](#エンティティ)や[アトリビュート](#アトリビュート)を[データベース](./database.md#データベース)で管理しやすいように、正しく[テーブル](#テーブル)を分割したり、重複した項目を削除する処理。1つのデータを1箇所で管理することで、データの整合性が保ちやすくなる。

### 非正規化形

**非正規化形**は、[エンティティ](#エンティティ)の情報をそのまま表現した形。1つの[レコード](#レコード)が同じ[カラム](#カラム)に格納するべき[アトリビュート](#アトリビュート)を複数持つ可能性があるため、通常はそのままでは[データベース](./database.md#データベース)に格納することはできない。

### 第1正規化形

**第1正規化形**は、同じ[カラム](#カラム)に格納するべき[アトリビュート](#アトリビュート)を複数持つ[レコード](#レコード)については、[アトリビュート](#アトリビュート)の数だけ独立した[レコード](#レコード)を用意した形。同じ候補キー（[レコード](#レコード)を一意に特定するための属性）を持つ[レコード](#レコード)が複数存在する状態のため、候補キーを[プライマリキー](#プライマリキー)として扱うことはできない。また、候補キーとなる[カラム](#カラム)が複数存在する可能性がある。

### 第2正規化形

**第2正規化形**は、同じ[テーブル](#テーブル)の中で異なる候補キーに依存している部分を、別[テーブル](#テーブル)に分離した形。

### 第3正規化形

**第3正規化形**は、同じ[テーブル](#テーブル)の中で候補キーではない[アトリビュート](#アトリビュート)に依存している部分を、別[テーブル](#テーブル)に分離した形。


## データ型

多くの[RDBMS](./database.md#rdbms)では次のようなデータ型がサポートされている。具体的な性質などは[RDBMS](./database.md#rdbms)によって異なるので注意が必要。

| 種別         | データ型    | 概要                                                                                 |
| ------------ | ----------- | ------------------------------------------------------------------------------------ |
| 文字型       | `char`      | 固定長文字列で、最大255バイトまで格納できる。定義時に最大長さを決める必要がある。    |
| 文字型       | `varchar`   | 可変長文字列で、最大65,535バイトまで格納できる。定義時に最大長さを決める必要がある。 |
| 文字型       | `text`      | より大きな文字列を扱うための型で、定義時に最大長さを決める必要がない。               |
| 整数型       | `tinyint`   | $-128 \sim 127$ の整数を扱う。                                                       |
| 整数型       | `samllint`  | $-32,768 \sim 32,767$ の整数を扱う。                                                 |
| 整数型       | `mediumint` | $-8,388,608 \sim 8,388,607$ の整数を扱う。                                           |
| 整数型       | `int`       | $-2,147,483,648 \sim 2,147,483,647$ の整数を扱う。                                   |
| 整数型       | `bigint`    | $-2^{63} sim 2^{63} - 1$ の整数を扱う。                                              |
| 浮動小数点型 | `float`     | 単精度の浮動小数点型を扱う。                                                         |
| 浮動小数点型 | `double`    | 倍精度の浮動小数点型を扱う。                                                         |
| 日時         | `date`      | `YYYY-MM-DD` 形式の日時を扱う。                                                      |
| 日時         | `datetime`  | `YYYY-MM-DD HH:MI:SS` 形式の日時を扱う。                                             |
| 日時         | `timestamp` | `YYYY-MM-DD HH:MI:SS` 形式の日時を扱う。 `datetime` よりも扱える範囲が狭い。         |
| 日時         | `year`      | `YYYY` 形式の日時を扱う。                                                            |
| 日時         | `time`      | `HH:MI:SS` 形式の日時を扱う。                                                        |
| 論理値型     | `boolean`   | 真偽値を扱う。                                                                       |


## null

**null**は、値がないことを表す値。値が不明であったり、未定義の場合に[データベース](./database.md#データベース)に代入される。


## 制約

**制約**は、[テーブル](#テーブル)の各[カラム](#カラム)に格納されるデータに関する決まりごと。

### NOT NULL

**NOT NULL**は、[データベース](./database.md#データベース)の[制約](#制約)のひとつで、[カラム](#カラム)に[null](#null)が入ることを禁止する。この[制約](#制約)を設けた[カラム](#カラム)には、[レコード](#レコード)の作成時に必ず値を指定しなければならない。

### PRIMARY KEY

**PRIMARY KEY**は、[データベース](./database.md#データベース)の[制約](#制約)のひとつで、その[テーブル](#テーブル)内で[レコード](#レコード)を一意に識別、特定することができる[カラム](#カラム)としなければならない。ひとつの[テーブル](#テーブル)にはPRIMARY KEY[制約](#制約)を持つ[カラム](#カラム)が必ず1つ（0でも2つ以上でも不可）ないといけない。PRIMARY KEY[制約](#制約)のついた[カラム](#カラム)に[null](#null)を格納することも禁止されている。

### UNIQUE KEY

**UNIQUE KEY**は、[データベース](./database.md#データベース)の[制約](#制約)のひとつで、[PRIMARY KEY](#primary-key)と同様、その[テーブル](#テーブル)内で[レコード](#レコード)を一意に識別、特定することができる[カラム](#カラム)としなければならない。UNIQUE KEYは同一[テーブル](#テーブル)内に複数指定することができる。UNIQUE KEYでは[null](#null)は禁止されていない。

### FOREIGN KEY

**FOREIGN KEY**は、[データベース](./database.md#データベース)の[制約](#制約)のひとつで、他の[テーブル](#テーブル)の[カラム](#カラム)を参照して、その[カラム](#カラム)に存在する値以外は格納できない。結合の際に利用する[カラム](#カラム)に対して指定する。FOREIGN KEY[制約](#制約)を用いる場合は、REFERENCESキーワードで参照する[テーブル](#テーブル)を指定する必要がある。

### CHECK

**CHECK**は、[データベース](./database.md#データベース)の[制約](#制約)のひとつで、指定した条件に合致しないデータが格納できなくなる。


## フェッチ

**フェッチ**(fetch)は、[データベース](./database.md#データベース)から、[レコード](#レコード)を1件ずつ取得する操作。


## トリガー

**トリガー**は、[データベース](./database.md#データベース)において、特定の[テーブル](#テーブル)に対する操作（挿入・更新・削除）をきっかけとして、あらかじめ定義された処理を自動的に実行する機能。複数[テーブル](#テーブル)間のデータ整合性を確保するためや、[テーブル](#テーブル)名の変更時などに利用する。


## 物理削除

**物理削除**（**ハードデリート**）は、[データベース](./database.md#データベース)からデータそのものを削除する操作。物理削除したデータは参照することができなくなる。


## 論理削除

**論理削除**（**ソフトデリート**）は、[データベース](./database.md#データベース)上のデータを[物理削除](#物理削除)するのではなく、削除フラグを用いるなどして、[レコード](#レコード)が削除されたかのように振る舞う操作。論理削除はトラブルが発生してもデータを復元できる反面、[クエリ](./sqlmd#クエリ)が複雑化したり、[UNIQUE KEY](#unique-key)が使えなくなったりするというデメリットがある。また、削除フラグは[カーディナリティ](./index.md#カーディナリティ)が低い上に必ず検索条件に含まれるため、[複合インデックス](./index.md#複合インデックス)を設定する必要があるなど、多用するのは控えたほうが良い。削除フラグを用いる論理削除の代替策として、削除済み[レコード](#レコード)を格納するための[テーブル](#テーブル)を別途用意する方法もある。
