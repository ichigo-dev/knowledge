# 『インデックス』ノート

（最終更新： 2023-10-27）


## 目次

1. [インデックス](#インデックス)
	1. [一意なインデックス](#一意なインデックス)
	1. [複合インデックス](#複合インデックス)
1. [テーブルスキャン](#テーブルスキャン)
1. [クエリ実行計画](#クエリ実行計画)
	1. [オプティマイザ](#オプティマイザ)
1. [カーディナリティ](#カーディナリティ)
1. [インデックスアルゴリズム](#インデックスアルゴリズム)
	1. [Bツリーインデックス](#bツリーインデックス)
	1. [ハッシュインデックス](#ハッシュインデックス)
	1. [ビットマップインデックス](#ビットマップインデックス)
1. [インデックスショットガン](#インデックスショットガン)
1. [MENTORの原則](#mentorの原則)



## インデックス

**インデックス**は、[データベース](./database.md#データベース)において、データの検索を高速化するための仕組み。通常、[データベース](./database.md#データベース)に格納されたデータは[ディスク](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)上にきれいに整列しているとは限らないため、検索[クエリ](./sql.md#クエリ)が発行されるとすべてのデータを調べなければならない。

データが更新されるとインデックスを作り直す必要が出てくるため、更新処理には時間がかかる。また、インデックスは通常のデータとは別に作られるデータ構造であるため複数のインデックスを作ることはできるが、作りすぎると更新するべきインデックスも増えるため、更新処理により時間がかかるようになる。

ある[テーブル](./rdb.md#テーブル)に1,000[レコード](./rdb.md#レコード)が存在し、1[ブロック](./rdb.md#ブロック)あたり10[レコード](./rdb.md#レコード)が格納されている場合を考える。仮にインデックスによるデータ位置の検索に3回の[ブロック](./rdb.md#ブロック)アクセスが必要だとすると、データを取得するまでには4回の[ブロック](./rdb.md#ブロック)I/Oが必要となる。1件のみデータを取得したい場合、同じ条件で[テーブルスキャン](#テーブルスキャン)を行うと100[ブロック](./rdb.md#ブロック)I/Oが必要なので、25倍高速化されていることがわかる。ただし、100件データを取得したいような場合では、インデックスを用いると $4 \times 100$ の400[ブロック](./rdb.md#ブロック)I/Oとなり、[テーブルスキャン](#テーブルスキャン)よりも不利になる。このように、インデックスはデータ数が非常に大きく、検索結果が非常に小さい（つまり、[カーディナリティ](#カーディナリティ)が高い）ほど有効であることがわかる。

また、インデックスは[データベース](./database.md#データベース)の苦手な[ORDER BY](./sql.md#データのソート)も高速化できる。

### 一意なインデックス

**一意なインデックス**は、一意制約([UNIQUE KEY](./rdb.md#unique-key))を指定した[カラム](./rdb.md#カラム)に適用される[インデックス](#インデックス)。

### 複合インデックス

**複合インデックス**は、複数の[カラム](./rdb.md#カラム)に対する[インデックス](#インデックス)。一方の[カラム](./rdb.md#カラム)を中心に[インデックス](#インデックス)を作成し、その中で重複しているものについてはもう一方の[カラム](./rdb.md#カラム)によって並べ替えられる。そのため、どちらの[カラム](./rdb.md#カラム)を中心に[インデックス](#インデックス)を作成するかで、有効な検索条件や性能を活かせる場面が変わるので注意が必要。


## テーブルスキャン

**テーブルスキャン**は、[データベース](./database.md#データベース)において、[インデックス](#インデックス)を用いずに[テーブル](./rdb.md#テーブル)内のデータ全てを順番に読み取る操作。テーブルスキャンが必要な[クエリ](./sql.md#クエリ)は実行速度が遅いため、頻繁に発生するようであれば[インデックス](#インデックス)を見直したほうが良い。

ある[テーブル](./rdb.md#テーブル)に1,000[レコード](./rdb.md#レコード)が存在し、1[ブロック](./rdb.md#ブロック)あたり10[レコード](./rdb.md#レコード)が格納されている場合、テーブルスキャンでは100回の[ブロック](./rdb.md#ブロック)I/Oが発生する（条件が[UNIQUE](./rdb.md#unique-key)であったり、[LIMIT](./sql.md#データの制限)が指定されていない限りは固定）。


## クエリ実行計画

**クエリ実行計画**は、ある[クエリ](./sql.md#クエリ)を受け取った時に、[オプティマイザ](#オプティマイザ)によって選択される、その[クエリ](./sql.md#クエリ)を実行するために用いられる[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。

### オプティマイザ

**オプティマイザ**は、ある[クエリ](./sql.md#クエリ)を受け取ったときに、どのような戦略でその[クエリ](./sql.md#クエリ)を実行するのが良いかを選択する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。[インデックス](#インデックス)を作成すると、通常の検索と[インデックス](#インデックス)を利用した検索という選択肢ができるため、オプティマイザはどちらを利用するのが良いかを判断して[クエリ](./sql.md#クエリ)を実行する。


## カーディナリティ

**カーディナリティ**は、ある[カラム](./rdb.md#カラム)に格納されるデータの種類。カーディナリティが高い（格納されるデータの種類が多い）[カラム](./rdb.md#カラム)に対する[インデックス](#インデックス)ほど効果が高い。


## インデックスアルゴリズム

### Bツリーインデックス

**Bツリーインデックス**は、多くの[RDBMS](./database.md#リレーショナルデータベース)でデフォルトで採用される[インデックス](#インデックス)。Bツリーは、1つのノードが3つ以上の子ノードを持つことができる[平衡木](../../../../programming/_/chapters/data_type.md#木)で、[木](../../../../programming/_/chapters/data_type.md#木)の深さが浅いため、データにたどり着くまでに必要な[ディスク](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)アクセスが少ない。

Bツリーインデックスを使うと、完全一致検索と範囲検索、前方一致検索が高速化される。一方で、部分一致検索や後方一致検索、否定検索はすべてのデータを[走査](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#走査)する必要があるため、高速化されない。

### ハッシュインデックス

**ハッシュインデックス**は、[ハッシュテーブル](../../../../programming/_/chapters/data_type.md#ハッシュテーブル)を利用した[インデックス](#インデックス)。データ自体に[ハッシュ関数](../../../../programming/_/chapters/data_type.md#ハッシュテーブル)を適用して格納する場所を決定するため、[Bツリー](#bツリーインデックス)よりも深さが浅く検索が速い。ただし、完全一致検索にしか用いることができない。

### ビットマップインデックス

**ビットマップインデックス**は、ある[カラム](./rdb.md#カラム)が特定の条件を満たす場合に、対応する[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)を1にした[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)列を用いる[インデックス](#インデックス)。[ビット演算](../../../../programming/_/chapters/operation.md#ビット演算)と同様のコストであるため、OR検索やAND検索との相性が良いのが特徴。[カーディナリティ](#カーディナリティ)が低い[カラム](./rdb.md#カラム)に対しても有効な[インデックス](#インデックス)であるが、更新に時間がかかるというデメリットがある。


## インデックスショットガン

**インデックスショットガン**は、闇雲に[インデックス](#インデックス)を作成してしまうことで、更新系[クエリ](./sql.md#クエリ)が遅くなったり、適切な[インデックス](#インデックス)が使われなくなったりするという、[データベース](./database.md#データベース)の[インデックス](#インデックス)に関する[アンチパターン](../../../../programming/_/chapters/anti_patterns.md#アンチパターン)のひとつ。[MENTORの原則](#mentorの原則)に従うなどして、適切な[インデックス](#インデックス)設計を行うことが重要となる。


## MENTORの原則

**MENTORの原則**は、[データベース](./database.md#データベース)の[インデックス](#インデックス)を適切に設定するための原則。下記の各項目の頭文字をとってMENTOR(Mesure, Explain, Nominate, Test, Optimize, Rebuild)と呼んでいる。

| 項目               | 詳細                                                                                                             |
| ------------------ | ---------------------------------------------------------------------------------------------------------------- |
| Mesure（測定）     | スロークエリログやデータベースのパフォーマンスなどをモニタリングすること                                         |
| Explain（解析）    | 実行計画を見てクエリが遅くなっている原因を追求すること                                                           |
| Nominate（指名）   | ボトルネックの原因（インデックス未定義など）を特定すること                                                       |
| Test（試験）       | ボトルネック改善（インデックス追加など）を実施して処理時間を測定し、改善後の全体的なパフォーマンスを確認すること |
| Optimize（最適化） | データベースパラメータの最適化を定期的に実施し、インデックスがキャッシュメモリに乗るようにすること               |
| Rebuild（再構築）  | 統計情報やインデックスを定期的に再構築すること                                                                   |
