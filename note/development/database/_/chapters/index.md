# 『インデックス』ノート

（最終更新： 2023-06-27）


## 目次

1. [インデックス](#インデックス)
	1. [一意なインデックス](#一意なインデックス)
	1. [複合インデックス](#複合インデックス)
1. [テーブルスキャン](#テーブルスキャン)
1. [クエリ実行計画](#クエリ実行計画)
	1. [オプティマイザ](#オプティマイザ)
1. [カーディナリティ](#カーディナリティ)
1. [Bツリーインデックス](#bツリーインデックス)
1. [ハッシュインデックス](#ハッシュインデックス)
1. [ビットマップインデックス](#ビットマップインデックス)



## インデックス

**インデックス**は、[データベース](./database.md#データベース)において、データの検索を高速化するための仕組み。通常、[データベース](./database.md#データベース)に格納されたデータは[ディスク](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)上にきれいに整列しているとは限らないため、検索[クエリ](./sql.md#クエリ)が発行されるとすべてのデータを調べなければならない。

データが更新されるとインデックスを作り直す必要が出てくるため、更新処理には時間がかかる。また、インデックスは通常のデータとは別に作られるデータ構造であるため複数のインデックスを作ることはできるが、作りすぎると更新するべきインデックスも増えるため、更新処理により時間がかかるようになる。

### 一意なインデックス

**一意なインデックス**は、一意制約([UNIQUE KEY](./rdb.md#unique-key))を指定した[カラム](./rdb.md#カラム)に適用される[インデックス](#インデックス)。

### 複合インデックス

**複合インデックス**は、複数の[カラム](./rdb.md#カラム)に対する[インデックス](#インデックス)。一方の[カラム](./rdb.md#カラム)を中心に[インデックス](#インデックス)を作成し、その中で重複しているものについてはもう一方の[カラム](./rdb.md#カラム)によって並べ替えられる。そのため、どちらの[カラム](./rdb.md#カラム)を中心に[インデックス](#インデックス)を作成するかで、有効な検索条件や性能を活かせる場面が変わるので注意が必要。


## テーブルスキャン

**テーブルスキャン**は、[データベース](./database.md#データベース)において、[インデックス](#インデックス)を用いずに[テーブル](./rdb.md#テーブル)内のデータ全てを順番に読み取る操作。テーブルスキャンが必要な[クエリ](./sqlmd#クエリ)は実行速度が遅いため、頻繁に発生するようであれば[インデックス](#インデックス)を見直したほうが良い。


## クエリ実行計画

**クエリ実行計画**は、ある[クエリ](./sql.md#クエリ)を受け取った時に、[オプティマイザ](#オプティマイザ)によって選択されたその[クエリ](./sql.md#クエリ)を実行するために用いられる[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。

### オプティマイザ

**オプティマイザ**は、ある[クエリ](./sql.md#クエリ)を受け取ったときに、どのような戦略でその[クエリ](./sql.md#クエリ)を実行するのが良いかを選択する[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。[インデックス](#インデックス)を作成すると、通常の検索と[インデックス](#インデックス)を利用した検索という選択肢ができるため、オプティマイザはどちらを利用するのが良いかを判断して[クエリ](./sql.md#クエリ)を実行する。


## カーディナリティ

**カーディナリティ**は、ある[カラム](./rdb.md#カラム)に格納されるデータの種類。カーディナリティが高い（格納されるデータの種類が多い）[カラム](./rdb.md#カラム)に対する[インデックス](#インデックス)ほど効果が高い。


## Bツリーインデックス

**Bツリーインデックス**は、多くの[RDBMS](./database.md#リレーショナルデータベース)でデフォルトで採用される[インデックス](#インデックス)。Bツリーは、1つのノードが3つ以上の子ノードを持つことができる[平衡木](../../../../programming/_/chapters/data_type.md#木)で、[木](../../../../programming/_/chapters/data_type.md#木)の深さが浅いため、データにたどり着くまでに必要な[ディスク](../../../../computer/hardware/_/chapters/auxiliary_memory_unit.md#ハードディスク)アクセスが少ない。

Bツリーインデックスを使うと、完全一致検索と範囲検索、前方一致検索が高速化される。一方で、部分一致検索や後方一致検索、否定検索はすべてのデータを[走査](../../../../basics/applied_mathematics/_/chapters/graph_theory.md#走査)する必要があるため、高速化されない。


## ハッシュインデックス

**ハッシュインデックス**は、[ハッシュテーブル](../../../../programming/_/chapters/data_type.md#ハッシュテーブル)を利用した[インデックス](#インデックス)。データ自体に[ハッシュ関数](../../../../programming/_/chapters/data_type.md#ハッシュテーブル)を適用して格納する場所を決定するため、[Bツリー](#bツリーインデックス)よりも深さが浅く検索が速い。ただし、完全一致検索にしか用いることができない。


## ビットマップインデックス

**ビットマップインデックス**は、ある[カラム](./rdb.md#カラム)が特定の条件を満たす場合に、対応する[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)を1にした[ビット](../../../../basics/_/chapters/computer_and_number.md#ビット)列を用いる[インデックス](#インデックス)。[ビット演算](../../../../programming/_/chapters/operation.md#ビット演算)と同様のコストであるため、OR検索やAND検索との相性が良いのが特徴。[カーディナリティ](#カーディナリティ)が低い[カラム](./rdb.md#カラム)に対しても有効な[インデックス](#インデックス)であるが、更新に時間がかかるというデメリットがある。
