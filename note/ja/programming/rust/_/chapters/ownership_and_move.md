# 『所有権と移動』ノート

（最終更新： 2023-04-18）


## 目次

1. [所有権](#所有権)
1. [移動](#移動)


## 所有権

**所有権**は、Rustが持つメモリ管理のための機能で、確保したメモリを使用が終わった時点で自動的に破棄する機能。C++においても、オブジェクトに所有されているメモリに対してポインタを作った場合に、オブジェクトがメモリ領域を破棄する前に、ポインタを破棄する義務がある、という考え方のことを所有権という。このような考え方をもとに実装されたC++の機能をスマートポインタという。Rustでは所有権の考え方が言語そのものに組み込まれており、すべてのデータに対してコンパイラが所有権をチェックすることによってメモリのクリーンアップを強制する。Rustにおけるすべての値は、そのライフタイムを決定する唯一の所有者を持ち、所有者が解放（ドロップ）されたときに所有されていた値もドロップされる。

ベクタや文字列などの可変長の変数を扱う際には、その変数のファットポインタがスタックフレーム上に保持され、そのポインタの先のバッファだけがヒープ上に取られる。このような状態を、バッファがスタックフレーム上のポインタに所有されているという。

複雑な所有関係にある要素（ベクタの中に文字列が格納されている場合など）では、所有者と所有される値はツリー構造をなす。変数がスコープから外れると、それより下のツリー全体が順次ドロップされる。

Rustの所有権には他にも以下のような特徴がある。

- 値を1つの所有者から別の所有者へmove（移動）することができる
- 整数、浮動小数点数、文字などのプリミティブ型（ヒープ上に領域を確保する必要のない固定長変数）については、所有権のルールが適用されない
- 標準ライブラリの `Rc` や `Arc` を利用することで、参照カウントが利用できる
- 値への参照の借用（参照を関数の引数として渡す操作）ができる


## 移動

**移動**(**move**)は、Rustが持つメモリ管理のための機能で、ある所有者によって所有されている値を、別の所有者に渡す操作。Rustではほとんどの型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却の際に、データはディープコピーされずに移動が発生する。ディープコピーが必要な場合は明示的に変数に対して `clone()` メソッドを呼ぶ。

Rustのコンパイラはこれらの移動を推測することができ、機械語レベルで見たときに最終的に値が移動される場所にはじめからオブジェクトが作られることも多い。
