# 『所有権と移動』ノート

（最終更新： 2023-04-18）


## 目次

1. [所有権](#所有権)
1. [移動](#移動)
1. [コピー型](#コピー型)
1. [RcとArc](#rcとarc)


## 所有権

**所有権**は、Rustが持つメモリ管理のための機能で、確保したメモリを使用が終わった時点で自動的に破棄する機能。C++においても、オブジェクトに所有されているメモリに対してポインタを作った場合に、オブジェクトがメモリ領域を破棄する前に、ポインタを破棄する義務がある、という考え方のことを所有権という。このような考え方をもとに実装されたC++の機能をスマートポインタという。Rustでは所有権の考え方が言語そのものに組み込まれており、すべてのデータに対してコンパイラが所有権をチェックすることによってメモリのクリーンアップを強制する。Rustにおけるすべての値は、そのライフタイムを決定する唯一の所有者を持ち、所有者が解放（ドロップ）されたときに所有されていた値もドロップされる。

ベクタや文字列などの可変長の変数を扱う際には、その変数のファットポインタがスタックフレーム上に保持され、そのポインタの先のバッファだけがヒープ上に取られる。このような状態を、バッファがスタックフレーム上のポインタに所有されているという。

複雑な所有関係にある要素（ベクタの中に文字列が格納されている場合など）では、所有者と所有される値はツリー構造をなす。変数がスコープから外れると、それより下のツリー全体が順次ドロップされる。

Rustの所有権には他にも以下のような特徴がある。

- 値を1つの所有者から別の所有者へmove（移動）することができる
- 整数、浮動小数点数、文字などのプリミティブ型（ヒープ上に領域を確保する必要のない固定長変数）については、所有権のルールが適用されない
- 標準ライブラリの `Rc` や `Arc` を利用することで、参照カウントが利用できる
- 値への参照の借用（参照を関数の引数として渡す操作）ができる


## 移動

**移動**(**move**)は、Rustが持つメモリ管理のための機能で、ある所有者によって所有されている値を、別の所有者に渡す操作。Rustではほとんどの型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却の際に、データはディープコピーされずに移動が発生する。ディープコピーが必要な場合は明示的に変数に対して `clone()` メソッドを呼ぶ。

Rustのコンパイラはこれらの移動を推測することができ、機械語レベルで見たときに最終的に値が移動される場所にはじめからオブジェクトが作られることも多い。

ベクタのようにインデックスにより参照される値については、インデックスを指定してその要素だけを移動するということができない。このような操作を実現したい場合は、次のような3つの方法がある。

```rust
let mut v = Vec::new();
for i in 1..100
{
    v.push(i.to_string());
}

// 1. ベクタの最後の要素をポップして取り出す
let x = v.pop().expect("vector empty");

// 2. ベクタの指定したインデックスの場所から要素を取り出し、代わりに最後の要素をそこに入れる
let index = 8;
let y = v.swap_remove(index);

// 3. 取り出した値の代わりに別の値を入れる
let index = 10;
let z = std::mem::replace(&mut v[index], "substitute".to_string());
```

特に `Option<T>` を要素として持つベクタから値を取り出したい場合には、値を移動して代わりに `None` を入れるという使い方が多い。これを実現するための `take()` メソッドも用意されている。

コレクション型は一般に、すべての要素をループで消費するためのメソッドを用意している。次のようにしてループにベクタを直接渡すと、ベクタは `v` から移動されて `v` は未初期化状態となり、繰り返しごとにループは次の要素を変数 `s` に移動する。

```rust
let v = vec!["hello".to_string(), "world".to_string(), "rust".to_string()];

for mut s in v
{
    s.push('!');
    println!("{}", s);
}
```


## コピー型

**コピー型**は、Rustにおいて、移動の代わりにディープコピーが行われるような型。ヒープ領域のリソースを伴う値は、ディープコピーするのに大きなコストが必要になるが、プリミティブ型のように移動を意識するメリットが少ない型については、移動のルールを適用しないためにコピー型とする場合がある。

変数がコピー型であるかを判断する簡単な指標として、値をドロップする際になにか特別なことをしなければいけない型はコピー型ではない、と考えるとよい。

独自定義の型については、デフォルトでコピー型ではないものの、フィールドがすべてコピー型である場合には次のように属性を付与することでコピー型にすることができる。

```rust
#[derive(Copy, Clone)]
struct Size
{
    height: usize,
    width: usize,
}
```


## RcとArc

Rustでは値が唯一の所有者を持っているが、複数の所有者のすべてがその値を使い終わるまで生存してほしいような値に対しては、 `Rc` や `Arc` といった参照カウントのポインタ型を利用することができる。

`Arc` はアトミックな参照カウンタであり、複数のスレッド間で値を直接共有しても安全なようにできている。だたし、そのような必要がない場合については、 `Rc` の方が高速である。

```rust
use std::rc::Rc;

let s: Rc<String> = Rc::new("Hello, world".to_string());
let t: Rc<String> = s.clone();
let u: Rc<String> = s.clone();
```

このようなコードを書いた場合、スタックフレーム上ではヒープ領域の `Rc` の参照カウントを指すポインタだけが保持される。 `Rc` は強い参照カウントを持ち、 `Rc<T>` がクローンされると参照カウントがインクリメントされる。 `Rc` 自身は `String` 型と同様に、値へのポインタとバッファの容量、長さからなるワード列でできている。

`Rc` ポインタに所有される値は不変である必要があるため、注意が必要。
