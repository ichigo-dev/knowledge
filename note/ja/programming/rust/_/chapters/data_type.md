# 『データ型』ノート

（最終更新： 2023-04-17）


## 目次

1. [Rustの型システム](#rustの型システム)
	1. [型推論](#型推論)
	1. [ジェネリック](#ジェネリック)
1. [固定長数値型](#固定長数値型)
	1. [整数型](#整数型)
	1. [浮動小数点数型](#浮動小数点数型)
	1. [チェック付き演算](#チェック付き演算)
	1. [ラップ演算](#ラップ演算)
	1. [飽和演算](#飽和演算)
	1. [オーバフロー演算](#オーバフロー演算)
1. [真偽値型](#真偽値型)
1. [文字型](#文字型)
1. [タプル型](#タプル型)
1. [ポインタ型](#ポインタ型)
	1. [参照](#参照)
	1. [共有参照](#共有参照)
	1. [可変参照](#可変参照)
	1. [Box](#box)
	1. [rawポインタ](#rawポインタ)
1. [配列](#配列)
1. [ベクタ](#ベクタ)
1. [スライス](#スライス)
1. [文字列型](#文字列型)
	1. [文字列リテラル](#文字列リテラル)
	1. [バイトリテラル](#バイトリテラル)
1. [型エイリアス](#型エイリアス)


## Rustの型システム

Rustは静的型付け言語であり、JavaScriptやPythonといった動的型付け言語とは異なり、変数の型がコンパイル時に確定する。静的型付け言語では、プログラム中の変数には明示的に型を示しておく必要があり、コードが煩雑になってしまう傾向がある。また、型を確定させてしまうことで、関数の汎用性が低下してしまう（ダックタイピングができない）というデメリットもある。

Rustではこれらのデメリットを軽減するために、型推論とジェネリックという機能を提供している。

### 型推論

**型推論**は、プログラム中に型を明示せずとも、いくつかの型情報から自動で変数の型を推論するRustコンパイラの機能。これにより、コンパイル時のエラー検出というメリットを残したまま、動的型付け言語の可読性の高さという恩恵を受けることができる。

### ジェネリック

**ジェネリック**は、反復的なコードを記述する必要性を減らすための機能で、引数や戻り値として複数の種類の型を取りうるような関数を1つの定義で表現することができるようになる。

JavaScriptやPythonといった動的型付け言語では、すべての関数が自然とこのよう動作となる。関数は、その関数が必要とするプロパティやメソッドを持つすべてのオブジェクトを引数として取ることができる（引数として取りうるオブジェクトを明示的に制限しない）。このような性質をダックタイピングといい、これによりプログラムが効率的になる一方で、エラーやバグの原因ともなりうる。

Rustではジェネリック機構を利用することで、厳密なコンパイル時の型チェックと柔軟性を両立している。


## 固定長数値型

Rustがサポートする固定長数値型は以下の通り。

| サイズ（ビット数） | 符号なし整数 | 符号付き整数 | 浮動小数点数 |
| ------------------ | ------------ | ------------ | ------------ |
| 8                  | `u8`         | `i8`         |              |
| 16                 | `u16`        | `i16`        |              |
| 32                 | `u32`        | `i32`        | `f32`        |
| 64                 | `u64`        | `i64`        | `f64`        |
| 128                | `u128`       | `i128`       |              |
| 計算機のワード長   | `usize`      | `isize`      |              |

### 整数型

Rustの整数型に関する特徴は以下の通り。

- Rustの符号付き整数は2の補数表現となっている。
- Rustでは、バイト値に対して `u8` 型を用いる。バイナリファイルやソケットからデータを読み取ると、 `u8` の値のストリームが得られる。
- CやC++では数値と文字の型を区別しない（ `u8` と `char` は同じ）が、Rustではこれらを区別する。ただし、バイトリテラルの機能が用意されており、例えば `b'X'` は、文字"X"に対するASCIIコードの `u8` 値になる。
- `usize` と `isize` は、実行対象の計算機のアドレス空間サイズに依存しており、32ビットアーキテクチャでは32ビット、64ビットアーキテクチャでは64ビットとなる。
- `0x` 、 `0o` 、 `0b` を接頭辞としてつけると、それぞれ16進数、8進数、2進数のリテラルになる。
- 整数型から別の整数型への変換は `as` 演算子を用いて行う。RustはCやC++とは異なり、数値型の**暗黙の型変換**をほとんど行わないので、プログラマ自身が明示する必要がある。

### 浮動小数点数型

Rustは、IEEE標準準拠の単精度と倍精度の浮動書数う点数をサポートしている。 `f32` と `f64` はそれぞれ、IEEE規格が要求する型関連定数である、 `INFINITY` 、 `NEG_INFINITY` 、 `NAN` 、 `MIN` 、 `MAX` を持つ。

### チェック付き演算

**チェック付き演算**は、演算結果を `Option` 型で返却する。数学的に正しい答えが得られた場合には `Some(v)` を、そうでない場合は `None` を返す。これによって、計算結果がオーバフローした場合などの挙動を制御することができる。

演算子名に接頭辞 `check_` をつけることで利用できる。

### ラップ演算

**ラップ演算**は、オーバフローが発生した場合に、溢れた桁を無視した結果を返却する。

演算子名に接頭辞 `wrapping_` をつけることで利用できる。

### 飽和演算

**飽和演算**は、オーバフローが発生した場合に、計算結果としてその型の最大値（もしくは最小値）を返却する。

演算子名に接頭辞 `saturating_` をつけることで利用できる。

### オーバフロー演算

**オーバフロー演算**は、ラップ演算の結果（ `result` ）と、オーバフローが発生したか否かの真偽値（ `overflowed` ）を、 `(result, overflowed)` という形式のタプルで返却する。

演算子名に接頭辞 `overflowing_` をつけることで利用できる。


## 真偽値型

Rustの真偽値型である `bool` は、 `true` と `false` という2種類の値を持つ。プログラム中で行われる比較演算は、結果として真偽値型を返却する。

真偽値を表現するのに必要なメモリは1ビットであるが、Rustでは `bool` に対するポインタを作れるようにするために1バイトを使用している。


## 文字型

RustはUnicodeの1文字を表現するために32ビットの `char` 型を用いる。C++における `char` 型は1バイト=8ビットのASCII文字のみ扱える。


## タプル型

**タプル型**は、様々な方の組み合わせを表現するための型。要素へのアクセスには定数のインデックスを用いる。

```rust
let profile: (&str, usize, usize, usize) = ("ichigo", 2001, 8, 21);
println!("Birth year: {}", profile.1);
```

タプルは配列とよく似ているが、配列は同じ型の要素を複数格納するコンテナであるのに対し、タプルは異なる型の要素をまとめることができる。また、配列は変数インデックスによる要素へのアクセス( `array[i]` )ができるのに対して、タプルは定数インデックスしか用いることができない。

タプルは関数の返り値などに頻繁に用いられる。関数は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。

また、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 `(height, width)` や `(latitude, longitude)` などである。

0要素のタプルもタプルの典型的な活用例で、 `()` のように記述され、**ユニット型**と呼ばれる。


## ポインタ型

Rustには、ポインタアドレスを表す型がいくつかある。

### 参照

**参照**は、Rustの最も基本的なポインタ型。

`String` 型の値への参照は `&String` であり、これは `String` のアドレスを保持した1ワード長のデータとなる。

RustのポインタはCとは異なり、決して `null` になることはない。また、値の所有権と生存期間の管理により、ダングリングポインタや多重開放（多重フリー）、ポインタの無効化（nullポインタ）といったバグをコンパイル時に取り除くことができる。

### 共有参照

**共有参照**は、読み取り専用の参照で、参照先の値を書き換えることはできない。ある値に対する共有参照は同時に複数取ることができる。共有参照は、 `&T` のようにして記述する。

### 可変参照

**可変参照**は、読み書き可能な参照で、参照先の値を読み書きできる。可変参照は排他的であり、ある値に対して可変参照をとったときには他のあらゆる参照（共有参照も可変参照も）とることができない。可変参照は、 `&mut T` のようにして記述する。

### Box

`Box` は、ヒープ上に値を確保するための型。 `Box<T>` の値は、事前に移動(move)されていない限りはスコープを抜けると自動的にメモリが解放される。

### rawポインタ

**rawポインタ**は、C++が扱うポインタとよく似ており、Rustが管理するポインタとは異なってメモリ安全ではない(unsafe Rust)。


## 配列

配列はメモリ上に値の列を表現する方法のひとつで、サイズがコンパイル時に決定され、動的に新しい要素を追加したり縮小したりすることはできない。

```rust
let prime_number: [u32; 6] = [2, 3, 5, 7, 11, 13];
```

同じ値で配列を埋めたいときは次のように書くことができる。この記法は、固定長バッファを初期化するためによく用いられる。

```rust
let true_array = [true; 100];
let buff = [0u8; 1024];
```


## ベクタ

ベクタは、動的にサイズを変更することができ、新しい要素を追加したり、既存の要素を削除したりできる配列。

```rust
let mut fibonacci_number = vec![0, 1, 1, 2, 3, 5, 8];
fibonacci_number.push(13);
fibonacci_number.push(21);
```

配列と同様、同じ値でベクタを埋めて初期化することもできる。

```rust
let mut false_vec = vec![false; 100];
```
空のベクタの初期化は次のように記述することもできる。

```rust
let mut empty_vec = Vec::new();
```

ベクタのデータの実体はヒープ上に確保される。スタックフレーム上には3ワード長のフレームが用意され、要素を保持しているヒープ上のバッファへのポインタ、バッファに保持できる容量、現在保持している要素数が格納される。

![Vectorのメモリレイアウト](../assets/images/memory_layout_vec.jpg)

バッファが容量の上限に達したときに新しい要素が追加されると、より大きいバッファが再確保（アロケート）され、中身がコピーされる。アロケートは処理に時間がかかるため、事前似必要な容量がわかっている場合は十分な大きさを確保して初期化しておくのが良い。

```rust
let mut v = Vec::with_capacity(100);
```

ベクタの任意の位置に要素を挿入したり削除したりすることもできるが、これはそれ以降の要素をすべてシフトする必要があるため、効率的ではない。このような操作が頻繁に行われるケースにおいては、ベクタの代わりにリスト( `LinkedList` )を用いたほうが良い。


## スライス

**スライス**は、配列やベクタのある領域を指す参照。スライスはファットポインタであり、スライスが指す最初の要素へのポインタとスライスに含まれる要素数という2ワード長で表される。

```rust
let even: [i32; 5] = [2, 4, 6, 8, 10];
let evel_slice: &[i32] = &even;
```

通常の参照はメモリ上の独立の値に対する所有権のないポインタであるのに対し、スライスの参照（あるいは単にスライス）はメモリ上の独立した値の領域に対する参照であると考えることができる。

同じ型のデータ列に対する関数を実装する際には、引数としてスライスをとるように設計すると、配列に対してもベクタに対しても適用できるようになる。

```rust
fn print_num( n: &[i32] )
{
    for elm in n
    {
        println!("{}", elm);
    }
}
```


## 文字列型

Rustの文字列型はUnicode文字のベクタとなっており、メモリ上には可変長のエンコーディングであるUTF-8で格納される。文字列を格納する型としては `String` が用いられ、文字列スライスは `&str` で表現される。

| 文字列の種類                                             | 可変長文字列型       | スライス |
| :------------------------------------------------------- | :------------------- | :------- |
| Unicode文字列                                            | `String`             | `&str`   |
| ファイル名                                               | `std::path::PathBuf` | `&Path`  |
| UTF-8でエンコードされていないバイナリデータ              | `Vec<u8>`            | `&[u8]`  |
| 環境変数名やコマンドライン引数などoSのネイティブな文字列 | `OsString`           | `&OsStr` |
| null文字終端の文字列                                     | `std::ffi::CString`  | `&Cstr`  |

### 文字列リテラル

**文字列リテラル**は、プログラム中でダブルクォーテーションで囲まれた文字列。文字列リテラルには改行を含めることができ、文字列の行の最後にバックスラッシュをつけた場合は、改行文字と次の行の空白文字が無視される。

```rust
"Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aenean commodo ligula eget dolor.
Aenean massa.
Cum sociis natoque penatibus et magnis dis parturient montes, \
nascetur ridiculus mus."
```

文字列中の意味のある文字をエスケープするのが面倒なケース（Windowsのパスを記述するときなど）は、**生文字列**(raw string)を用いることができる。

```rust
r"C:\Program Files\App"
```

さらに、ダブルクォーテーションのエスケープすらも省略したい場合には、開始と終了のダブルクォーテーションを任意の数のハッシュ文字で挟む（ハッシュ文字の数は、わかりやすいように決めればよい）。

```rust
r###"She said "Hello"."###
```

### バイトリテラル

文字列リテラルの冒頭に `b` をつけた場合はバイトリテラルとなり、Unicodeテキストからなるスライスではなく `u8` （バイト）値の列からなるスライスとなる。

```rust
let method = b"GET";
```

バイトリテラルにはUnicode文字を含めることはできず、ASCII文字とエスケープシーケンスのみを含むことができる。


## 型エイリアス

`type` キーワードを用いると、既存の型に対して別名をつけることができる。

```rust
type Bytes = Vec<u8>;
```
