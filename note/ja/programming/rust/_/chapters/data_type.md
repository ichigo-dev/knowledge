# 『データ型』ノート

（最終更新： 2023-04-15）


## 目次

1. [Rustの型システム](#rustの型システム)
	1. [型推論](#型推論)
	1. [ジェネリック](#ジェネリック)
1. [固定長数値型](#固定長数値型)
	1. [整数型](#整数型)
	1. [浮動小数点数型](#浮動小数点数型)
	1. [チェック付き演算](#チェック付き演算)
	1. [ラップ演算](#ラップ演算)
	1. [飽和演算](#飽和演算)
	1. [オーバフロー演算](#オーバフロー演算)
1. [真偽値型](#真偽値型)
1. [文字型](#文字型)
1. [タプル型](#タプル型)
1. [ポインタ型](#ポインタ型)
	1. [参照](#参照)


## Rustの型システム

Rustは静的型付け言語であり、JavaScriptやPythonといった動的型付け言語とは異なり、変数の型がコンパイル時に確定する。静的型付け言語では、プログラム中の変数には明示的に型を示しておく必要があり、コードが煩雑になってしまう傾向がある。また、型を確定させてしまうことで、関数の汎用性が低下してしまう（ダックタイピングができない）というデメリットもある。

Rustではこれらのデメリットを軽減するために、型推論とジェネリックという機能を提供している。

### 型推論

**型推論**は、プログラム中に型を明示せずとも、いくつかの型情報から自動で変数の型を推論するRustコンパイラの機能。これにより、コンパイル時のエラー検出というメリットを残したまま、動的型付け言語の可読性の高さという恩恵を受けることができる。

### ジェネリック

**ジェネリック**は、反復的なコードを記述する必要性を減らすための機能で、引数や戻り値として複数の種類の型を取りうるような関数を1つの定義で表現することができるようになる。

JavaScriptやPythonといった動的型付け言語では、すべての関数が自然とこのよう動作となる。関数は、その関数が必要とするプロパティやメソッドを持つすべてのオブジェクトを引数として取ることができる（引数として取りうるオブジェクトを明示的に制限しない）。このような性質をダックタイピングといい、これによりプログラムが効率的になる一方で、エラーやバグの原因ともなりうる。

Rustではジェネリック機構を利用することで、厳密なコンパイル時の型チェックと柔軟性を両立している。


## 固定長数値型

Rustがサポートする固定長数値型は以下の通り。

| サイズ（ビット数） | 符号なし整数 | 符号付き整数 | 浮動小数点数 |
| ------------------ | ------------ | ------------ | ------------ |
| 8                  | `u8`         | `i8`         |              |
| 16                 | `u16`        | `i16`        |              |
| 32                 | `u32`        | `i32`        | `f32`        |
| 64                 | `u64`        | `i64`        | `f64`        |
| 128                | `u128`       | `i128`       |              |
| 計算機のワード長   | `usize`      | `isize`      |              |

### 整数型

Rustの整数型に関する特徴は以下の通り。

- Rustの符号付き整数は2の補数表現となっている。
- Rustでは、バイト値に対して `u8` 型を用いる。バイナリファイルやソケットからデータを読み取ると、 `u8` の値のストリームが得られる。
- CやC++では数値と文字の型を区別しない（ `u8` と `char` は同じ）が、Rustではこれらを区別する。ただし、バイトリテラルの機能が用意されており、例えば `b'X'` は、文字"X"に対するASCIIコードの `u8` 値になる。
- `usize` と `isize` は、実行対象の計算機のアドレス空間サイズに依存しており、32ビットアーキテクチャでは32ビット、64ビットアーキテクチャでは64ビットとなる。
- `0x` 、 `0o` 、 `0b` を接頭辞としてつけると、それぞれ16進数、8進数、2進数のリテラルになる。
- 整数型から別の整数型への変換は `as` 演算子を用いて行う。RustはCやC++とは異なり、数値型の**暗黙の型変換**をほとんど行わないので、プログラマ自身が明示する必要がある。

### 浮動小数点数型

Rustは、IEEE標準準拠の単精度と倍精度の浮動書数う点数をサポートしている。 `f32` と `f64` はそれぞれ、IEEE規格が要求する型関連定数である、 `INFINITY` 、 `NEG_INFINITY` 、 `NAN` 、 `MIN` 、 `MAX` を持つ。

### チェック付き演算

**チェック付き演算**は、演算結果を `Option` 型で返却する。数学的に正しい答えが得られた場合には `Some(v)` を、そうでない場合は `None` を返す。これによって、計算結果がオーバフローした場合などの挙動を制御することができる。

演算子名に接頭辞 `check_` をつけることで利用できる。

### ラップ演算

**ラップ演算**は、オーバフローが発生した場合に、溢れた桁を無視した結果を返却する。

演算子名に接頭辞 `wrapping_` をつけることで利用できる。

### 飽和演算

**飽和演算**は、オーバフローが発生した場合に、計算結果としてその型の最大値（もしくは最小値）を返却する。

演算子名に接頭辞 `saturating_` をつけることで利用できる。

### オーバフロー演算

**オーバフロー演算**は、ラップ演算の結果（ `result` ）と、オーバフローが発生したか否かの真偽値（ `overflowed` ）を、 `(result, overflowed)` という形式のタプルで返却する。

演算子名に接頭辞 `overflowing_` をつけることで利用できる。


## 真偽値型

Rustの真偽値型である `bool` は、 `true` と `false` という2種類の値を持つ。プログラム中で行われる比較演算は、結果として真偽値型を返却する。

真偽値を表現するのに必要なメモリは1ビットであるが、Rustでは `bool` に対するポインタを作れるようにするために1バイトを使用している。


## 文字型

RustはUnicodeの1文字を表現するために32ビットの `char` 型を用いる。C++における `char` 型は1バイト=8ビットのASCII文字のみ扱える。


## タプル型

**タプル型**は、様々な方の組み合わせを表現するための型。要素へのアクセスには定数のインデックスを用いる。

```rust
let profile: (&str, usize, usize, usize) = ("ichigo", 2001, 8, 21);
println!("Birth year: {}", profile.1);
```

タプルは配列とよく似ているが、配列は同じ型の要素を複数格納するコンテナであるのに対し、タプルは異なる型の要素をまとめることができる。また、配列は変数インデックスによる要素へのアクセス( `array[i]` )ができるのに対して、タプルは定数インデックスしか用いることができない。

タプルは関数の返り値などに頻繁に用いられる。関数は1つしか値を返却することができないので、複数の値をまとめて返却したい場合はタプルを利用する。

また、構造体にするほどでもない自明な値をまとめるときにもタプルが用いられる。例えば、 `(height, width)` や `(latitude, longitude)` などである。

0要素のタプルもタプルの典型的な活用例で、 `()` のように記述され、**ユニット型**と呼ばれる。


## ポインタ型

Rustには、ポインタアドレスを表す型がいくつかある。

### 参照

**参照**は、Rustの最も基本的なポインタ型。

`String` 型の値への参照は `&String` であり、これは `String` のアドレスを保持した1ワード長のデータとなる。

RustのポインタはCとは異なり、決して `null` になることはない。また、値の所有権と生存期間の管理により、ダングリングポインタや多重開放（多重フリー）、ポインタの無効化（nullポインタ）といったバグをコンパイル時に取り除くことができる。

### 共有参照

**共有参照**は、読み取り専用の参照で、参照先の値を書き換えることはできない。ある値に対する共有参照は同時に複数取ることができる。共有参照は、 `&T` のようにして記述する。

### 可変参照

**可変参照**は、読み書き可能な参照で、参照先の値を読み書きできる。可変参照は排他的であり、ある値に対して可変参照をとったときには他のあらゆる参照（共有参照も可変参照も）とることができない。可変参照は、 `&mut T` のようにして記述する。
