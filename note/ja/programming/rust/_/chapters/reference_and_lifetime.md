# 『参照とライフタイム』ノート

（最終更新： 2023-04-18）


## 目次

1. [参照と借用](#参照と借用)
	1. [共有参照](#共有参照)
	1. [可変参照](#可変参照)
1. [参照の使い方](#参照の使い方)
	1. [暗黙的な参照解決と参照の借用](#暗黙的な参照解決と参照の借用)
	1. [参照の代入](#参照の代入)
	1. [参照への参照](#参照への参照)
1. [ライフタイム](#ライフタイム)
	1. [ボローチェッカー](#ボローチェッカー)
	1. [staticライフタイム](#staticライフタイム)
	1. [共有と変更におけるライフタイム](#共有と変更におけるライフタイム)
	1. [バッファの再確保におけるライフタイム](#バッファの再確保におけるライフタイム)
	1. [構造体とライフタイム](#構造体とライフタイム)


## 参照と借用

参照は、Rustが所有権を持たないポインタ型。参照は参照先よりも長生きしてはいけないので、これを強調するためにRustではある参照を作ることを**借用**と呼ぶ。

関数に引数を渡す時に所有権を移動してしまうと、それ以降は引数に使った値が使えなくなってしまう（**値渡し**）。そのため、関数の引数として参照を用いるのが適切な場合も多い（**参照渡し**）。

### 共有参照

**共有参照**は、読み取り専用の参照で、参照先の値を書き換えることはできない。ある値に対する共有参照は同時に複数取ることができる。共有参照は、 `&T` のようにして記述する。

### 可変参照

**可変参照**は、読み書き可能な参照で、参照先の値を読み書きできる。可変参照は排他的であり、ある値に対して可変参照をとったときには他のあらゆる参照（共有参照も可変参照も）とることができない。可変参照は、 `&mut T` のようにして記述する。

```rust
// show()は値を読んでいるだけなので、共有参照を取るようにすれば十分
fn show_table( table: &Table )
{
    // コレクション型に対して繰り返し実行すると、普通は所有権が移動されて値が消費されてしまう
    // 共有参照に対して繰り返し実行すると、個々のエントリのキーと値に対する共有参照が作られる
    for (key, values) in table
    {
        println!("key = {}:", key);

        for value in values
        {
            println!(" {}", value);
        }
    }
}

// sort()は値を書き換えるので、可変参照を取る必要がある
fn sort_table( table: &mut Table )
{
    for (_key, values) in table
    {
        values.sort();
    }
}
```


## 参照の使い方

### 暗黙的な参照解決と参照の借用

Rustでは、 `&` 演算子によって参照を明示的に作り、 `*` 演算子で参照解決を行う。また、 `.` 演算子が必要に応じて暗黙に左側のオペランドを参照解決する。さらに `.` 演算子は、必要であれば暗黙に左オペランドへの参照を借用する。

```rust
// .演算子による暗黙的な参照解決
struct Book
{
    name: &'static str,
    published: bool,
}
let book = Book { name: "my book", published: false };
let book_ref = &book;
assert_eq!(book_ref.name, "my book");    // assert_eq!((*book_ref).name, "my book");

// .演算子による暗黙的な参照の借用
let mut v = vec![5, 1, 4, 2, 3];
v.sort();                                // (&mut v).sort();
```

### 参照の代入

変数に参照を代入すると、その変数は新しい場所を指すようになる。下記のようなコードを書いた場合、参照 `r` は最初 `x` を指しているが、代入後は `y` を指すようになる。C++ではこのような書き方をすると、暗黙的に参照解決が行われてしまい、 `r` が指し示す先に `y` のポインタが代入されるという挙動になり、これは明らかに直感に反している。

```rust
let x = 10;
let y = 20;
let mut r = &x;
r = &y;
```

### 参照への参照

Rustは参照への参照を許しており、 `.` 演算子は型をチェックして何段でも参照解決を行ってくれる。

```rust
struct Position
{
    x: usize,
    y: usize,
}
let position = Position { x: 100, y: 200 };
let r = &position;
let rr = &r;
let rrr = &rr;

assert_eq!(rrr.y, 200);
```


## ライフタイム

**ライフタイム**（**生存期間**）は、Rustコンパイラが参照型に対して割り当てるもので、プログラム実行中にその参照が安全に利用できる期間を指す。

ローカル変数の参照を借用して、その変数をスコープの外に持ち出すと、ダングリングポインタとなる。ライフライムの成約により、このような参照が作られることがなくなっている。

```rust
{
    let r;
    {
        let x = 1;
        r = &x;
    }
    assert_eq!(*r, 1);       // スコープの外ではxにアクセスできない
}
```

ライフタイムのルールは以下のとおり。

- ある変数の参照は、その変数よりも長生きしてはならない
- ある変数に格納した参照は、少なくともその変数と同じだけ生きていなければならない（変数のライフタイムは、その変数から借用した参照のライフタイムを包含していなければならない）

また、Rustは変数のライフタイムとして可能な限り短い期間を想定する。

### ボローチェッカー

**ボローチェッカー**は、Rustコンパイラがライフタイムを利用して参照の安全性を保証する機能。

### staticライフタイム

**'staticライフタイム**は、プログラムの開始から終了まで存在するメモリリソースに割り当てられるライフタイム。

ある `static` な変数を更新する以下のような関数を考える。

```rust
static mut STASH: &i32 = &128;

fn update( p: &i32 )
{
    unsafe
    {
        STASH = p;
    }
}
```

このとき、関数のシグネチャは**ライフタイムパラメータ**を省略している（実際はRustのコンパイラが自動的に補完してくれるので省略可能）。これを明示的に記述すると以下のようになる。

```rust
fn update<'a>( p: &'a i32 ) { /* ... */ }
```

`'a` は任意のライフタイムであり、引数 `p` が任意のライフタイムパラメータを持っていることを示す。しかし、static変数である `STASH` に対して任意の生存期間を持つ変数 `p` を代入するのは、ライフタイムのルールに反している（変数 `p` は少なくとも `STASH` と同じだけのライフタイムを持たなければならない）。そこで、関数の引数として取りうる値のライフタイムを'staticライフタイムにすることでこの問題を解決できる。

```rust
fn update( p: &'static i32 ) { /* ... */ }
```

### 共有と変更におけるライフタイム

ライフタイムの制約により、参照がスコープから外れた変数を指す、という問題が起きないことが保証されている。次の例は、ダングリングポインタが発生する別のケースである。

```rust
let v = vec![1, 2, 3, 4, 5];
let r = &v;
let aside = v;    // ここで移動が発生する（vのライフタイムの終わり）
r[0];             // 未初期化状態となったvを使用しようとしている（rのライフタイムの終わり）
```

Rustではこのようなプログラムはエラーとなる。 `v` の参照である `r` のライフタイムが、 `v` のライフタイムよりも長くなってはいけないというルールに反しているためである。

### バッファの再確保におけるライフタイム

ベクタにおいて、その変数のもともとの容量を超える要素が加えられようとするとき、ベクタはより容量の大きいバッファを再確保しようとする。このバッファの再確保によりダングリングポインタが発生する例を考える。

```rust
// 他のスライスによってベクタを拡張する関数
fn extend( vec: &mut Vec<f32>, slice: &[f32] )
{
    for elem in slice
    {
        vec.push(*elem);
    }
}

let mut wave = Vec::new();
let head = vec![0.0, 1.0];
let tail = [0.0, -1.0];

extend(&mut wave, &head);
extend(&mut wave, &tail);

// ここでバッファの再確保が起きるとする
extend(&mut wave, &wave);
```

最後の `extend()` 呼び出し時にバッファの再確保が起きた場合に、第2引数で渡されたスライスの参照先がなくなってしまう。しかし、Rustの参照のルールにより、 `wave` の可変参照と共有参照を同時に作ることはできない。これは言い換えると、可変参照のライフタイムは他のいかなる参照のライフタイムとも重なってはいけない、と説明できる。

### 構造体とライフタイム

構造体が参照を含む場合、参照のライフタイムを指定する必要がある。次の例では、任意のライフタイム `<'elt>` に対して、ライフタイムが `<'elt>` である参照を保持する構造体を定義している。

```rust
// greatestとleastの参照のライフタイムは一致しなければいけない
struct Extrema<'elt>
{
    greatest: &'elt i32,
    least: &'elt i32,
}

fn find_extrema<'s>( slice: &'s [i32] ) -> Extrema<'s>
{
    let mut greatest = &slice[0];
    let mut least = &slice[0];

    for i in 1..slice.len()
    {
        if slice[i] > *greatest { greatest = &slice[i]; }
        if slice[i] < *least { least = &slice[i]; }
    }
    Extrema { greatest, least }
}
```
