# 『プログラミングの基礎知識』

（最終更新： 2023-02-23）


## 目次

1. [プログラミング](#プログラミング)
	1. [プログラム](#プログラム)
	1. [プログラマ](#プログラマ)
	1. [プログラミング言語](#プログラミング言語)
	1. [ソースコード](#ソースコード)
1. [機械語](#機械語)
	1. [オペコード](#オペコード)
1. [低水準言語](#低水準言語)
	1. [アセンブリ言語](#アセンブリ言語)
	1. [アセンブル](#アセンブル)
	1. [アセンブラ](#アセンブラ)
1. [高水準言語](#高水準言語)
	1. [コンパイル](#コンパイル)
	1. [コンパイラ](#コンパイラ)
	1. [コンパイラ言語](#コンパイラ言語)
	1. [インタプリタ言語](#インタプリタ言語)
	1. [JITコンパイラ](#jitコンパイラ)
	1. [スクリプト言語](#スクリプト言語)
	1. [静的型付け言語](#静的型付け言語)
	1. [動的型付け言語](#動的型付け言語)
1. [プログラミングパラダイム](#プログラミングパラダイム)
	1. [命令型プログラミング](#命令型プログラミング)
	1. [宣言型プログラミング](#宣言型プログラミング)
	1. [構造化プログラミング](#構造化プログラミング)
	1. [オブジェクト指向プログラミング](#オブジェクト指向プログラミング)
	1. [関数型プログラミング](#関数型プログラミング)
	1. [論理プログラミング](#論理プログラミング)
	1. [制約プログラミング](#制約プログラミング)
	1. [マルチパラダイム言語](#マルチパラダイム言語)
1. [プログラムの基礎と文法](#プログラムの基礎と文法)
	1. [文法](#文法)
	1. [コメント](#コメント)
	1. [エラー](#エラー)
	1. [例外](#例外)
	1. [バグ](#バグ)
	1. [デバッグ](#デバッグ)
	1. [未定義動作](#未定義動作)
	1. [識別子](#識別子)
	1. [予約語](#予約語)
1. [プログラムのメモリ管理](#プログラムのメモリ管理)
	1. [ヒープ領域の確保と解放](#ヒープ領域の確保と解放)
	1. [メモリリーク](#メモリリーク)
	1. [ダブルフリー](#ダブルフリー)
	1. [ダングリングポインタ](#ダングリングポインタ)
	1. [ガベージコレクション](#ガベージコレクション)
	1. [アロケート](#アロケート)
1. [プログラミングを始める](#プログラミングを始める)


## プログラミング

**プログラミング**は、[プログラム](#プログラム)を記述して[コンピュータ](../../../computer/_/chapters/basic_knowledge_of_computer.md#コンピュータ)へ命令を行い、目的とするタスクを解決すること。

[プログラマ](#プログラマ)には、世の中の様々なタスクや問題をプログラミングによって解決するという役割がある。毎日の単純作業のくり返しを減らしたり（表計算[ソフト](../../../computer/software/_/chapters/basic_knowledge_of_software.md#ソフトウェア)など）、ミスが許されない場面で正確に動作することが保証されたシステムを利用したり（銀行のシステムや信号機など）、さらに人間には難しいタスクの解決を行ったり（[AI](../../../artificial_intelligence/_/chapters/artificial_intelligence.md#人工知能-1)による異常検知など）と、プログラミングスキルの応用範囲は多岐にわたる。

### プログラム

**プログラム**は、[コンピュータ](../../../computer/_/chapters/basic_knowledge_of_computer.md#コンピュータ)が処理を行う手順や内容を示したもの。

### プログラマ

**プログラマ**は、[プログラム](#プログラム)を記述する職業。

### プログラミング言語

**プログラミング言語**は、[プログラム](#プログラム)を記述する際に用いられる言語。プログラミング言語に対して、人間が日常生活で用いる言語のことを**自然言語**という。

### ソースコード

**ソースコード**（**ソース**、**コード**）は、[プログラミング言語](#プログラミング言語)で書かれた[プログラム](#プログラム)。


## 機械語

**機械語**（**マシン語**、**オブジェクトコード**、**ネイティブコード**）は、[コンピュータ](../../../computer/_/chapters/basic_knowledge_of_computer.md#コンピュータ)が直接解釈できる[プログラム](#プログラム)で、[2進数](../../../basics/discrete_mathematics/_/chapters/radix.md#2進数)の羅列からなる。機械語は次の例のような[プログラム](#プログラム)となっており、人間が記述したり内容を理解するのには適していない。そのため、人間が理解しやすいように[プログラミング言語](#プログラミング言語)を用いて[ソースコード](#ソースコード)を作成し、専用の[プログラム](#プログラム)によって[ソースコード](#ソースコード)を機械語に変換するのが一般的。[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ-1)ごとに対応する機械語も異なるので注意が必要。

```
0111 1111 0100 0101 0100 1100 0100 0101 0000 0010 0000 0001 0000 0001 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0010 0000 0000 0011 1110 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000

...(以下略)
```

### オペコード

**オペコード**は、[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ-1)に与える[機械語](#機械語)の命令の識別番号。


## 低水準言語

**低水準言語**（**低級言語**）は、[プログラミング言語](#プログラミング言語)の中でも[機械語](#機械語)に近い言語のこと。低水準言語は[コンピュータ](../../../computer/_/chapters/basic_knowledge_of_computer.md#コンピュータ)資源を効率よく使うことができ、高速に動作するという利点があるが、[プログラム](#プログラム)が長くなりやすく柔軟性に乏しいことから、組込みや[ファームウェア](../../../computer/_/chapters/basic_knowledge_of_computer.md#ファームウェア)といった分野など、限られた[コンピュータ](../../../computer/_/chapters/basic_knowledge_of_computer.md#コンピュータ)資源で性能を最大限引き出すという目的がない限りは[高水準言語](#高水準言語)が用いられることがほとんどとなる。

### アセンブリ言語

**アセンブリ言語**は、ニーモニックという命令を組み合わせて記述する[プログラミング言語](#プログラミング言語)。**ニーモニック**は、[機械語](#機械語)の命令に1対1で対応する、英単語や記号で表記した命令のこと。[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ-1)ごとに対応するアセンブリ言語も異なるので注意が必要。

アセンブリ言語の一種である**Netwide Assembler**を用いて `Hello, world` を出力する[プログラム](#プログラム)を以下に示す。

```asm
section .data
    msg db      "Hello, world"      ; データセクションで文字列を宣言

section .text
    global _start                   ; プログラムのエントリポイントとして_startを呼び出し

_start:
    mov     rax, 1                  ; sys_writeシステムコール(1)をraxレジスタにセット
    mov     rdi, 1                  ; 第一引数（ファイルディスクリプタ、1は標準出力）をrdiレジスタにセット
    mov     rsi, msg                ; 第二引数（出力したい文字列）をrsiレジスタにセット
    mov     rdx, 12                 ; 第三引数（データのサイズ）をrdxレジスタにセット
    syscall                         ; システムコールを発行
    mov     rax, 60                 ; exitシステムコール(60)をraxレジスタにセット
    mov     rdi, 0                  ; 第一引数（終了コード、0は正常終了）をrdiレジスタにセット
    syscall                         ; システムコールを発行
```

### アセンブル

**アセンブル**は、[アセンブリ言語](#アセンブリ言語)で書かれた[プログラム](#プログラム)を[機械語](#機械語)に変換する操作。

### アセンブラ

**アセンブラ**は、[アセンブル](#アセンブル)を行うための[ソフトウェア](../../../computer/software/_/chapters/basic_knowledge_of_software.md#ソフトウェア)。


## 高水準言語

**高水準言語**（**高級言語**）は、[低水準言語](#低水準言語)に比べて抽象度が高く、人間にとってわかりやすい[プログラミング言語](#プログラミング言語)。[機械語](#機械語)を意識することなく記述することができ、[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ-1)に依存しない[プログラム](#プログラム)を作ることができる（[機械語](#機械語)への変換の段階で様々な[プロセッサ](../../../computer/hardware/_/chapters/processor.md#プロセッサ-1)に対応させることができるため）。

代表的な高水準言語としては、C系言語（[C](./programming_language.md#c言語), [C#](./programming_language.md#c), [C++](./programming_language.md#c-1)等）や[Java](./programming_language.md#java)、[Python](./programming_language.md#python)、[PHP](./programming_language.md#php)、[JavaScript](./programming_language.md#javascript)などがある。それぞれの言語には得手不得手があり、[C言語](./programming_language.md#c言語)であれば処理速度が高速であることから[CPU](../../../computer/hardware/_/chapters/processor.md#cpu)や[サーバ](../../../computer/_/chapters/basic_knowledge_of_computer.md#サーバ)などの低レイヤの実装に向いており、[JavaScript](./programming_language.md#javascript)であれば一般的な[Webブラウザ](../../../network/_/chapters/web.md#webブラウザ)で動作することから[Web](../../../network/_/chapters/web.md#web)フロントエンド向けとなっている。

高水準言語は種類が多く、[ソースコード](#ソースコード)の[コンパイル・](#コンパイル)実行方式や、[データ型](./data_type.md#型)の決定方式などによって分類することができる。

### コンパイル

**コンパイル**は、[高水準言語](#高水準言語)で書かれた[ソースコード](#ソースコード)を[機械語](#機械語)に変換する操作。

### コンパイラ

**コンパイラ**は、[コンパイル](#コンパイル)を行うための[ソフトウェア](../../../computer/software/_/chapters/basic_knowledge_of_software.md#ソフトウェア)。

### コンパイラ言語

**コンパイラ言語**は、プログラムを実行する前にあらかじめコンパイルを行う方式の言語。プログラムを利用する際には、機械語に変換された実行ファイルを実行する。

事前にコンパイルを済ませているため、実行前に不具合を発見できたり、実行時のコンパイルコストがないため実行速度が速いといった利点がある。一方で、実行時に起こりうる様々なパターンに対応できるようにプログラミングする必要があり、インタプリタ言語と比較しても難易度が高い言語が多い。また、コンパイル済みの実行ファイルはプロセッサに依存するため、マルチプラットフォームに対応できないという欠点もある（それぞれのプラットフォーム用にコンパイルする必要がある）。

代表的なコンパイラ言語には、C言語やSwift、Go、Rustといったものがある。

### インタプリタ言語

**インタプリタ言語**は、プログラムの実行時にソースコードを1行ずつコンパイルしながら処理を進める方式の言語。実行時に毎回コンパイルを行うコストが発生するため、実行速度はコンパイラ言語に劣る。しかし、コンパイルを行わずに実行結果をすぐに確認できるため、デバッグが容易で、開発にかかるコストは小さくなる。

代表的なインタプリタ言語には、PythonやPHP、JavaScript、Rubyなどがある。

### JITコンパイラ

**JITコンパイラ**(Just-In Time Compiler)は、ソースコードを環境に依存しない**中間コード**（**バイトコード**）に変換しておき、実行時にバイトコードをコンパイルして実行する方式をとる。実行時にコンパイルする点ではインタプリタ言語と似ているが、インタプリタ言語より高速に動作する。また、コンパイラ言語では直接機械語のコードを生成するため、プログラムが実行環境に依存してしまうが、この方式ではプログラムの実行機であるランタイム（フレームワーク）が利用できる環境であればひとつの中間コードで実行できるというメリットもある。

JITコンパイラを用いる代表的な言語には、JavaやC#などがある。

### スクリプト言語

**スクリプト言語**は、プログラミング言語のうち比較的容易に記述・実行ができる言語。定義は曖昧であるが、プログラミングの初級者にとっても学びやすく、開発スピードが早いため小規模な開発に向いている。インタプリタ言語はスクリプト言語に分類されることが多く、PythonやPHP、JavaScript、Rubyなどがスクリプト言語に含まれる。

### 静的型付け言語

**静的型付け言語**は、実行前にデータの型を決定する方式の言語。コンパイラ言語の多くは静的型付け言語となっており、プログラム中で使用するデータに対して、そのデータをどの型として扱うかを明示（**型注釈**）する必要がある。事前にデータの型を確定させておくことで、想定外の処理が行われることによる不具合を減らすことができるなど、プログラムの信頼性が向上する。

また、RustやGoのような新しい静的型付け言語では、ソースコード中に型を明示せずとも、コンパイラが文脈から自動的に型を判断する**型推論**の機能が搭載されているものもあり、ソースコードの記述量が増え冗長になるという静的型付け言語の欠点を軽減できる。

### 動的型付け言語

**動的型付け言語**は、実行時にデータの型を決定する方式の言語。型を明示する必要はなく、コンパイラが文脈から全てのデータの型を自動的に判断する。ソースコードがシンプルになり読みやすくなる一方で、データが読み込まれるたびにそのデータの型を推測する必要があるため、実行速度は静的型付け言語に劣る。また、データが想定していない型として扱われる可能性もあるため注意する必要がある。

実行時に型を決定するという抽象化の性質から、関数がとる引数の型も柔軟に判断することができるため、同じインタフェースを持つ異なるオブジェクトをひとつの関数で扱える。これを利用したプログラミングスタイルとしてダックタイピングがある。

### 汎用プログラミング言語

**汎用プログラミング言語**は、広い用途で利用される高水準言語。

### 専用プログラミング言語

**専用プログラミング言語**は、限られた分野で活躍する高水準言語。


## プログラミングパラダイム

**プログラミングパラダイム**は、プログラミングの考え方や記述方法の枠組み。

### 命令型プログラミング

**命令型プログラミング**（**手続き型プログラミング**）は、識別子をつけた命令ブロック（関数、サブルーチン、手続き、プロシージャ）の定義と呼び出しを組み合わせることでプログラム全体を組み立てることを土台としたプログラミングパラダイム。手続きは、プログラム内のあらゆるポイントから呼び出すことができ、手続き内の命令コード行の終端に到達すると、その手続きを呼び出したポイントの次の命令に制御が移される（**復帰**）。C言語やC++、PHP、Pythonなどは命令型プログラミングに分類される。

### 宣言型プログラミング

**宣言型プログラミング**は、達成したい目的を記述し、その命令の実行手順についてはコンパイラに任せるような言語。プログラムの本質がわかりやすく、記述がシンプルになるものの、複雑な処理を行うことはできない。データベースに対するクエリを記述するSQLは宣言型に準拠した言語である。

または、数学論理学に根ざした流れをくむ、関数プログラミングや論理プログラミング、制約プログラミングを総称して宣言型プログラミングと呼ぶこともある。

### 構造化プログラミング

**構造化プログラミング**は、プログラムの処理手順を明確にし、判読性を向上させることを目的としたプログラミングパラダイム。一般的には、順次、分岐、反復といった3つの制御構文によって処理の流れを記述する。また、プログラムを任意に分割した部分プログラム（サブルーチンとコードブロック）の階層的な組み合わせによる構造化も指している。C言語やC++、Java、PHPといった多くの言語は構造化プログラミングをサポートしている。

### オブジェクト指向プログラミング

**オブジェクト指向プログラミング**は、あらゆるものをオブジェクトとして表現するプログラミングパラダイム。プログラムを手順ではなく、モノの作成と操作として見る考え方。C++やJava、PHP、Pythonなどはオブジェクト指向に分類される。オブジェクト指向をサポートするプログラミング言語は大抵の場合、命令型プログラミングとの組み合わせで用いられる。

### 関数型プログラミング

**関数型プログラミング**は、数学的な関数を主軸としてプログラミングを行うスタイル。関数型プログラミングでは、**参照透過性**（入力が決まると出力が一意に決まり、他のデータへの副作用がない）を満たした関数を使って組み立てた式が主役となる。オブジェクト指向プログラミングでは状態と振る舞いをオブジェクトによって管理していたが、関数型プログラミングでは状態と振る舞いを切り離している。ClojureやElang、Haskell、Scalaなどは関数型プログラミングに分類される。

### 論理プログラミング

**論理プログラミング**は、あらかじめ事実やルールを定義しておき、最終的に問い合わせを行うことで解を得るプログラミングパラダイム。既知の理論を基にして、新たな仮説を説明できるかといったことがプログラム的に証明できる。代表的な論理プログラミング言語には、Prologがある。

### 制約プログラミング

**制約プログラミング**は、変数間の関係を制約という形で記述し、制約ソルバーにより与えた制約を満たす解を探索するプログラミングパラダイム。ツールキットのような形でライブラリとして各プログラミング言語に提供されている場合が多く、代表的なプログラミング言語は少ない。

### マルチパラダイム言語

**マルチパラダイム言語**は、複数のプログラミングパラダイムに対応するプログラミング言語の総称。命令型プログラミングや構造化プログラミングといったパラダイムは、他のパラダイムと組み合わせて用いられることが多い。


## プログラムの基礎と文法

### 文法

**文法**（**シンタックス**）は、各プログラミング言語が規定しているプログラムの書き方。文法が誤っていると、コンパイラがソースコードを正しく解析できず、エラーとなる。プログラミング言語の文法は、自然言語の文法に比べて非常に厳密であるため、プログラミングを行うときには常に正しい文法を心掛けなくてはならない。

文法は言語ごとに様々であるが、例として次のようなものがある。

- プログラムは半角アルファベットと数字、各種記号によって記述する
- `{` と `}` は対応しており、 `{}` で囲まれた部分は処理のひとつのまとまりを表す
- ひとつの文は `;` で終わらなければならない
- プログラムは上から下へと順次実行される

### コメント

**コメント**（注釈）は、ソースコード中でコンパイル時に無視される部分のこと。プログラムの内容や補足を記述したり、一時的に無効化したいプログラムを**コメントアウト**したりといった使い方がある。

一般的なプログラミング言語におけるコメントの書き方は次のようになっている。

```
; アセンブリ言語などで用いられる1行のコメント

// 高水準言語で良く用いられる1行のコメント

/*

    高水準言語でよく用いられる
    複数行に対応したコメント

*/
```

### エラー

**エラー**は、コンパイル時・実行時にプログラムが正常に処理を続行できなくなるような致命的な問題の発生により中断・終了されることを指す。シンタックスの誤りや、アルゴリズムのバグ（プログラムの欠陥）等により発生する。

代表的なエラーには次のようなものがある。

- **ゼロ除算**（整数を0で割るような演算を試みた）
- 配列の要素数より大きいインデックスにアクセスを試みた
- 存在しないファイルを参照しようとした
- ユーザが想定外の入力を行った
- データベースやサーバへの接続に失敗した

### 例外

**例外**は、プログラミング言語が想定可能なエラーのことで、例外発生時の処理をソースコード中に記述しておくことができる。プログラムが想定できないエラーが発生した場合は、プログラムがOSによって強制的に終了される。

### バグ

**バグ**は、プログラム上の誤りや不具合。文法上のエラーや、エラーではないもののプログラムが仕様通りに動作しないような欠陥のことをいう。

### デバッグ

**デバッグ**は、プログラムのバグを見つけて修正すること。

### 未定義動作

**未定義動作**は、プログラミング言語の仕様において動作が予測できないと規定されているプログラムを実行した結果のことで、C言語やC++といった言語ではいくつかの未定義動作が定められている。未定義動作を設けることにより、パフォーマンスの高いコンパイラを作成することが容易になる。一方で、未定義動作はプログラムのバグである可能性が高く、実行環境によって結果が変わることもあるため発見が難しい。

### 識別子

**識別子**（**シンボル**）は、ソースコード中でデータや処理のまとまりに対してプログラマがつける名前のこと。識別子には、そのデータの性質や状態、役割を表す名前をつけるのが一般的。

識別子の命名に関しては、各プログラミング言語ごとにルールが存在する。次に示すのは、多くのプログラミング言語に共通しているルールの一部。

- 変数名にはアルファベット、数字、アンダースコアが使用できる
- アルファベットの大文字と小文字は区別される
- 1文字目はアルファベットかアンダースコアが使用できる（数字から始まる変数名は使用できない）
- 予約語は使用できない（予約語を含む変数名は使用できる）
- 識別子中にスペースを含むことはできない（複数の単語からなる識別子において、単語間にスペースを用いるなど）

プログラミングにおいて良い識別子を命名することは、ソースコードの可読性やメンテナンス性を向上させるために非常に重要である。言語ごとのコミュニティや開発チームごとのルール・文化に従い、一般的な単語を用いた、誰が見てもわかりやすい識別子を心掛けるべきである。

### 予約語

**予約語**は、各プログラミング言語において規定されている、識別子として利用できない文字列。データの型や制御構文に用いられる単語などがこれにあたり、プログラムの構文解析の妨げになるなどの理由から使用できなくなっている。また、将来的にプログラミング言語に取り入れられる予定の機能に関するキーワードも予約語となっている場合もある。

予約語ではなくとも、他のプログラミング言語で予約語になっているものや、将来的に使用できなくなる可能性のある文字列は識別子としてふさわしくないので、避けた方がよい。

以下に示すのは、C言語の予約語の一部。

```c
auto, break, case, char, const, continue, default, do, double, else, enum,
extern, float, for, goto, if, int, long, register, return, signed, sizeof,
...
```


## プログラムのメモリ管理

プログラム中で用いられる変数や関数は、プログラムに割り当てられたメモリ領域内に格納される。グローバル変数は静的領域に、関数内で使用されるローカル変数はスタック領域に、配列やオブジェクトといった可変長のデータの実体はヒープ領域に格納される。

### ヒープ領域の確保と解放

スタック領域に格納された変数は、関数の実行が完了すると自動的に解放されるが、ヒープ領域に格納したデータは別の手段により解放する必要がある。ヒープ領域のデータを解放する手段はプログラミング言語によって異なる。C言語やC++では、プログラマが明示的にソースコード中でヒープ領域の確保・解放を宣言する必要があり、そのほかのほとんどのプログラミング言語ではガベージコレクションを用いる。また、Rust言語ではガベージコレクションを用いずにメモリの解放に関する一定のルールを設けることで、プログラマがメモリ管理に関する責任を負わなくてよいようにしている。

### メモリリーク

**メモリリーク**は、プログラムが使い終わったメモリの解放を忘れることで、使用できなくなるメモリ領域ができてしまうこと。メモリ管理に関するバグの一種。

### ダブルフリー

**ダブルフリー**（メモリの二重解放、多重フリー）は、既に解放されたヒープ領域のメモリを、再度解放しようとすること。メモリ管理に関するバグの一種。

### ダングリングポインタ

**ダングリングポインタ**は、ヒープ領域に格納されたデータのアドレスを格納したスタック領域のポインタにおいて、既に解放されたヒープ領域を指し示すポインタのこと。メモリ管理に関するバグの一種。

### ガベージコレクション

**ガベージコレクション**（**GC**）は、ヒープ領域のデータを定期的に確認し、不要になったデータを解放するプログラム。ガベージコレクションを用いる場合、ソースコード中でヒープ領域の解放を明示する必要はない。

メモリリークやダブルフリー、ダングリングポインタといったメモリに関するバグを回避するこおとができる。ただし、プログラマ自身がメモリ管理をするプログラミング言語に比べてパフォーマンスは低く、プログラムの実行に関係のないソフトウェア（ガベージコレクション）を動作させる必要があるというデメリットがある。また、ガベージコレクションが動くタイミングでソフトウェアの動作が遅くなる可能性がある。

### アロケート

**アロケート**（**アロケーション**）は、データを配置するために必要なメモリ領域を確保すること。可変長データを拡張しようとしたときに、あらかじめ確保したメモリ領域が不足した場合、改めて十分な空き領域をアロケートする必要がある。基本的にアロケートは低速な操作であるため、アロケートが発生する回数が少なくなるようにすることでプログラムの実行速度を高速化することができる場合がある。


## プログラミングを始める

プログラミングを始めるために必要なものは、各種プログラミング言語の実行環境と、プログラムを記述するためのテキストエディタのみで、基本的には特別なものは必要としない。**実行環境**は、プログラムをコンパイルして実行するための環境のこと。**テキストエディタ**には、プログラミングを便利に行うための補助機能を提供するものや、実行環境が搭載された**統合開発環境**など様々なものがあるが、PCにデフォルトでインストールされているようなもの（Windowsのメモ帳など）でも問題ない。代表的なテキストエディタには次のようなものがある。

- [サクラエディタ](https://sakura-editor.github.io/)
- [秀丸エディタ（有料）](https://hide.maruo.co.jp/software/hidemaru.html)
- [Visual Studio Code](https://code.visualstudio.com/)
- [Neovim](https://neovim.io/)
