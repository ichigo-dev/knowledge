# 『プロセスとジョブ』ノート

（最終更新： 2023-03-15）


## 目次

1. [プロセス](#プロセス)
	1. [fork](#fork)
	1. [clone](#clone)
	1. [exec](#exec)
	1. [プロセスの確認](#プロセスの確認)
	1. [プロセスツリーの確認](#プロセスツリーの確認)
	1. [プロセスのリアルタイム監視](#プロセスのリアルタイム監視)
	1. [プロセスの強制終了](#プロセスの強制終了)
	1. [メモリの監視](#メモリの監視)
1. [ジョブ](#ジョブ)
	1. [フォアグラウンドジョブ](#フォアグラウンドジョブ)
	1. [バックグラウンドジョブ](#バックグラウンドジョブ)
	1. [ジョブコントロール](#ジョブコントロール)
	1. [ジョブの確認](#ジョブの確認)
	1. [フォアグラウンドジョブとして実行](#フォアグラウンドジョブとして実行)
	1. [バックグラウンドジョブとして実行](#バックグラウンドジョブとして実行)
1. [スレッド](#スレッド)
1. [デーモン](#デーモン)
1. [initプロセス](#initプロセス)
1. [systemd](#systemd)
	1. [サービス](#サービス)
	1. [サービスの管理](#サービスの管理)
	1. [サービスの開始](#サービスの開始)
	1. [サービスの停止](#サービスの停止)
	1. [サービスの再起動](#サービスの再起動)
	1. [サービスの状態確認](#サービスの状態確認)
	1. [サービスの登録](#サービスの登録)
	1. [サービスの登録解除](#サービスの登録解除)
	1. [サービスの登録確認](#サービスの登録確認)
1. [プロセス間通信](#プロセス間通信)
	1. [ソケット](#ソケット)
	1. [共有メモリ](#共有メモリ)


## プロセス

**プロセス**は、メモリ上で実行状態にあるプログラム。Linuxカーネルはストレージ装置からメモリにプログラムを読み出し、そのメモリの内容に従ってCPUがプログラムを実行する。プロセスはシステム上で一意の**PID**によって識別される。

ひとつのプログラムやコマンドが複数のプロセスを生成したり、プロセスがさらにプロセスを生成することもある。あるプロセスによって生み出された別のプロセスは、そのプロセスの子プロセスとなる。

プロセスはオペレーティングシステムのタスクスケジューラによって制御され、実行可能状態、実行状態、待ち状態といった状態を遷移しながら処理が進められる。

### fork

**fork**は、親プロセスから子プロセスを生成するシステムコールのひとつ。親プロセスからforkが呼び出されると、システムは親プロセスの複製を作成し、それが子プロセスとなる。子プロセスは親プロセスの状態を複製することによって生成されるため、プログラムコードは親プロセスと共通となる。子プロセスは親プロセスとは独立して動作し、親プロセスとは異なるPIDを持つ。

### clone

**clone**は、親プロセスから子プロセスを生成するためのシステムコールのひとつ。forkと同様に、親プロセスの複製を子プロセスとして生成する。cloneでは、親プロセスと子プロセスの間で共有されるリソースを指定することができ、複数のプロセスを協調させることができる。

### exec

**exec**は、現在のプロセスを新しいプロセスに置き換えるシステムコール。execを使用することで、プロセスの実行中にプログラムを切り替えたりプロセスの状態を維持したままプログラムをリロードしたりすることができる。

### プロセスの確認

`ps` は、プロセスの状態を表示するためのコマンド。 `ps` は"process status"の略語。

コマンドの書式は以下の通り。

```
ps [OPTION]...
```

`ps` コマンドを実行すると、このコマンドを実行したユーザが起動しているプロセスのリストが表示される。

```sh
$ ps
    PID TTY          TIME CMD
    425 pts/0    00:00:00 zsh
    689 pts/0    00:00:00 ps
```

`ps` の主要なオプションは以下の通り。

| オプション | 概要                                               |
| ---------- | :------------------------------------------------- |
| `a`        | 全てのユーザのプロセスの状態を表示する             |
| `f`        | プロセスの親子関係をツリー上にして表示する         |
| `u`        | プロセスのユーザ名と開始時刻を表示内容に付加する   |
| `x`        | 制御端末を持たないデーモンなどのプロセスも表示する |
| `l`        | 詳細情報を表示する                                 |
| `-e`       | 全プロセスの情報を表示する　                       |

オプションは、以下の例のように複数個まとめて指定することもできる。

```sh
$ ps aux
```

### プロセスツリーの確認

`pstree` は、プロセスの親子関係をツリー形式で表示するためのコマンド。

コマンドの書式は以下の通り。

```
pstree [OPTION]...
```

`pstree` の主要なオプションは以下の通り。

| オプション | 概要                                            |
| ---------- | :---------------------------------------------- |
| `-p`       | 各プロセスのPIDを表示する                       |
| `-u`       | 各プロセスの実行ユーザ名を表示する              |
| `-h`       | ルートプロセスを表示しない                      |
| `-a`       | 各プロセスのコマンドライン引数も表示する        |
| `-n`       | 各プロセスの名前をソートせず、PIDの順に表示する |
| `-c`       | 同じ名前のプロセスをまとめて表示する            |
| `-G`       | 指定したグループIDを持つプロセスのみ表示する    |
| `-U`       | 指定したユーザIDを持つプロセスのみ表示する      |

### プロセスのリアルタイム監視

`top` は、Linuxシステムで実行されているプロセスをリアルタイムで監視するためのコマンド。 `top` コマンドで確認できる情報は以下の通り。

| ラベル | 概要                                                                                        |
| ------ | :------------------------------------------------------------------------------------------ |
| PID    | 各プロセスのPID                                                                             |
| USER   | 各プロセスを発行しているユーザ                                                              |
| PR     | プロセスの優先度                                                                            |
| NI     | プロセスの優先度を調整するために使用されるニース値                                          |
| VIRT   | プロセスが使用している仮想メモリサイズ                                                      |
| RES    | プロセスが使用している物理メモリサイズ                                                      |
| SHR    | プロセスが使用している共有メモリサイズ                                                      |
| S      | プロセスの現在の状態（D: 割込み不能、R: 実行中、S: スリープ、T: 停止中、Z: ゾンビプロセス） |
| %CPU   | プロセスが使用しているCPUの割合                                                             |
| %MEM   | プロセスが使用している物理メモリの割合                                                      |
| TIME+  | プロセスが起動している時間                                                                  |

### プロセスの強制終了

`kill` は、実行中のプロセスにシグナルを送信するコマンド。プロセスを強制終了する場合などによく用いられる。

コマンドの書式は以下の通り。

```
kill [SIGNAL] PID
```

例えば以下のコマンドを実行すると、PIDが1234のプロセスに `TERM` シグナルを送信する。

```sh
$ kill -TERM 1234
```

`kill` はプロセスを強制終了するだけでなく、プロセスを停止したり再開したりするための他のオプションもある。

また、 `pkill` はプロセス名指定でプロセスを強制終了するコマンド、 `killall` はプロセス名指定で全てのプロセスを強制終了するコマンドとなっている。

### メモリの監視

`free` は、メモリの使用状況を表示するためのコマンド。主に以下の情報を表示する。

| ラベル       | 概要                                           |
| ------------ | :--------------------------------------------- |
| `total`      | システム全体の物理メモリ量                     |
| `useed`      | 使用中の物理メモリ量                           |
| `free`       | 空き物理メモリ量                               |
| `shared`     | 共有メモリ量                                   |
| `buff/cache` | バッファやキャッシュに使われている物理メモリ量 |
| `available`  | アプリケーションに使用可能な物理メモリ量       |

コマンドの書式は以下の通り。

```
free [OPTION]...
```

`free` の主要なオプションは以下の通り。

| オプション       | 概要                                         |
| ---------------- | :------------------------------------------- |
| `-b` `--bytes`   | 結果をバイト単位で表示する                   |
| `-k` `--kilo`    | 結果をキロバイト単位で表示する（デフォルト） |
| `-m` `--mega`    | 結果をメガバイト単位で表示する               |
| `-g` `--giga`    | 結果をギガバイト単位で表示する               |
| `-h` `--human`   | より読みやすい形式で表示する                 |
| `-t` `--total`   | 全体のメモリ使用量のみを表示する             |
| `-s` `--seconds` | 指定した秒数ごとに繰り返し表示する           |
| `-c` `--count`   | 指定した回数繰り返し表示する                 |


## ジョブ

**ジョブ**は、1つのプログラムやコマンドといった実行単位のことで、1つ以上のプロセスをまとめたもの。シェルに入力された1行分が1つのジョブに対応し、ジョブは必要に応じてプロセスに分解されて処理される。

### フォアグラウンドジョブ

**フォアグラウンドジョブ**は、シェルによって起動されるジョブ。通常、コマンドを実行するとフォアグラウンドでジョブが生成され、そのジョブが終了するまではシェルはプロンプトを返さない。フォアグラウンドジョブはシェルへの入力を受け付ける状態となり、ユーザは対話的にプロセスに対してシグナルを送信することができる。

### バックグラウンドジョブ

**バックグラウンドジョブ**は、シェルとは切り離して実行されるジョブ。コマンドの末尾に `&` を追加して実行すると、そのコマンドはバックグラウンドジョブとして実行される。バックグラウンドジョブ（プロセス）にシグナルを送信するには、 `kill` コマンドを使用する。

### ジョブコントロール

フォアグラウンドジョブのコントロールに用いられるキーは以下の通り。

| キー         | 概要                                                   |
| ------------ | :----------------------------------------------------- |
| `Ctrl` + `c` | `SIGINT` シグナルを送出し、プロセスを終了する          |
| `Ctrl` + `z` | ジョブの実行を中断し、バックグラウンドジョブに退避する |

### ジョブの確認

`jobs` は、バックグラウンドにあるジョブの一覧を確認するためのコマンド。

例えば以下の例では、バックグラウンドで実行中の `sleep` コマンドの状態を `jobs` によって確認している。バックグラウンドジョブの処理が終わると、プロンプトにその旨が表示される。

```sh
$ sleep 60 &
[1] 2400

$ jobs
[1]  + running    sleep 10

$
[1]  + done       sleep 10
```

### フォアグラウンドジョブとして実行

`fg` は、ジョブをフォアグラウンドジョブとして実行するコマンド。

以下の例では、バックグラウンドで実行中の `sleep` をフォアグラウンドに切り替えている。

```sh
$ sleep 60 &
[1] 2744

$ jobs
[1]    running    sleep 20

$ fg %1
[1]    running    sleep 20
```

### バックグラウンドジョブとして実行

`bg` は、ジョブをバックグラウンドジョブとして実行するコマンド。

以下の例では、フォアグラウンドで実行していた `sleep` を `Ctrl` + `z` で一度バックグラウンドにサスペンドし、それを改めてバックグラウンドジョブとして再開している。

```sh
$ sleep 60

# Ctrl + z を入力
zsh: suspended  sleep 60

$ jobs
[1]  + suspended  sleep 60

$ bg %1
[1]    continued  sleep 60

$
[1]    done       sleep 60
```


## スレッド

**スレッド**は、1つのプロセスから生成される実行単位で、プロセス内で複数のタスクを並行して実行するなどの目的で使用される。複数のスレッドは同じプログラムコード、データ、ヒープなどを共有している。スレッドはプロセスよりも軽量で、プロセス間通信に比べてスレッド通信は高速である。


## デーモン

**デーモン**は、メインメモリ上に常駐して特定の機能を提供するプログラム。デーモンはinitプロセスやsystemdによってシステムの起動時に実行され、バックグラウンドで動作しながら処理要求があったときに処理を実行する。Webサーバやバッチプログラムなどがこれに該当し、プログラム名の末尾に `d` がつくのが慣例となっている（ `httpd` 、 `crond` など）。


## initプロセス

**initプロセス**は、Linuxシステムが起動された時に最初に実行され、システムの全てのプロセスの親プロセスとして機能するプロセス。システムのランレベルの設定や各種サービス、デーモンの起動などを行う。initプロセスのPIDは必ず1となる。

initプロセスは `/sbin/init` ファイルから起動され、起動時に設定されたランレベルに応じて必要なサービスやプロセスを開始する。通常は、ランレベルは `０` から `6` までの7段階があり、ランレベル `0` はシャットダウン、ランレベル `6` は再起動を表す。管理者はそれぞれのランレベルに合わせたスクリプトを用意して、必要なデーモンの起動処理などを記述する。

新しいLinuxディストリビューションの多くでは、initプロセスに代わってsystemdが利用される場合が多い。


## systemd

**systemd**は、Linuxシステムが起動された時に最初に実行されるプロセスで、システムのブートプロセスやサービス管理を行うシステム管理デーモン。従来のinitプロセスの代替として設計されており、プロセスの開始、監視、制御、終了等を行うことができる。systemdでは、デーモンやサービスの依存関係や起動順序、停止順序などを管理することができる。systemdのPIDは必ず1となる。

systemdでは各サービスがユニットファイルとして定義され、systemdによって自動的に管理される。また、 `systemctl` コマンドを利用してサービスのステータス確認や起動、停止、再起動、有効化、無効化などを行うことができる。

### サービス

**サービス**は、Linuxシステムが起動された時に開始されるデーモンプロセス。デーモンと同じ意味で使用される場合も多い。

### サービスの管理

`systemctl` は、systemdを制御するために使用されるコマンド。サービスの起動や停止、有効化、無効化などを行うサービスマネージャであり、システムの管理に必要なサブコマンドが用意されている。

コマンドの書式は以下の通り。

```
systemctl [OPTIONS...] COMMAND [UNIT...]
```

### サービスの開始

`systemct start` は、systemdを使用してLinuxシステム上のサービスを開始するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを開始する。

```sh
$ systemctl start httpd
```

ただし、システムを再起動した際には開始したサービスは起動されないので、自動で開始したい場合は `systemctl enable` を使用する。

### サービスの停止

`systemctl stop` は、systemdを使用してLinuxシステム上のサービスを停止するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを停止する。

```sh
$ systemctl stop httpd
```

ただし、自動的に開始されるように設定されているサービスは、システムを再起動したときに開始されてしまうので、完全に停止したい場合は `systemctl disable` を使用する。

### サービスの再起動

`systemctl restart` は、systemdを使用してLinuxシステム上のサービスを再起動するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを再起動する。

```sh
$ systemctl restart httpd
```

これは、サービスの設定ファイルを変更して、再度その内容を読み込みたい場合などによく用いられる。

### サービスの状態確認

`systemctl status` は、systemdを使用してLinuxシステム上のサービスの状態を確認するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスの状態を表示する。

```sh
$ systemctl status httpd
```

### サービスの登録

`systemctl enable` は、systemdを使用してLinuxシステム上のサービスが起動時に自動的に開始されるように登録するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが次回のシステムの起動時に自動的に開始される。

```sh
$ systemctl enable httpd
```

### サービスの登録解除

`systemctl disable` は、systemdを使用してLinuxシステム上で自動的に起動されるように登録されたサービスを解除するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが次回のシステムの起動時に自動的に開始されないようにする。

```sh
$ systemctl disable httpd
```

### サービスの登録確認

`systemctl is-enabled` は、systemdを使用して指定したサービスが自動起動に登録されているかを確認するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが登録されているかを表示する。

```sh
$ systemctl is-enabled httpd
```


## プロセス間通信

**プロセス間通信**(**IPC**: InterProcess Communication)は、実行中の複数のプロセス間でデータをやり取りするための仕組み。あるプログラムから別のプログラムへデータやメッセージを通知したり、プログラム同士で協調して処理を行うための技術や手段のことを指す。

### ソケット

**ソケット**(Socket)は、ネットワークを介してプロセス間通信を行うためのAPI。ソケットには、TCPやUDPなどのプロトコルに対応した種類がある。

サーバは以下のような手順で通信を行う。

1. socket: 待ち受け用のソケットを作成する
1. bind: 待ち受けるIPアドレスやポート番号といった情報をソケットに紐づける
1. listen: クライアントからの通信を待ち受ける
1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する
1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う

クライアントは以下のような手順で通信を行う。

1. socket: サーバとの通信用のソケットを作成する
1. connect: サーバが待ち受けているIPアドレスのポートに対して接続を試みる
1. read/write: 接続が確立したら、ソケットを介してサーバとのデータのやり取りを行う

### 共有メモリ

**共有メモリ**(Shared memory)は、
