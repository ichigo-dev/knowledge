# 『プロセスとジョブ』ノート

（最終更新： 2023-03-28）


## 目次

1. [プロセス](#プロセス)
	1. [fork](#fork)
	1. [clone](#clone)
	1. [exec](#exec)
	1. [プロセスの確認](#プロセスの確認)
	1. [プロセスツリーの確認](#プロセスツリーの確認)
	1. [プロセスのリアルタイム監視](#プロセスのリアルタイム監視)
	1. [プロセスの強制終了](#プロセスの強制終了)
	1. [メモリの監視](#メモリの監視)
1. [ジョブ](#ジョブ)
	1. [フォアグラウンドジョブ](#フォアグラウンドジョブ)
	1. [バックグラウンドジョブ](#バックグラウンドジョブ)
	1. [ジョブコントロール](#ジョブコントロール)
	1. [ジョブの確認](#ジョブの確認)
	1. [フォアグラウンドジョブとして実行](#フォアグラウンドジョブとして実行)
	1. [バックグラウンドジョブとして実行](#バックグラウンドジョブとして実行)
1. [スレッド](#スレッド)
1. [デーモン](#デーモン)
1. [initプロセス](#initプロセス)
1. [systemd](#systemd)
	1. [サービス](#サービス)
	1. [サービスの管理](#サービスの管理)
	1. [サービスの開始](#サービスの開始)
	1. [サービスの停止](#サービスの停止)
	1. [サービスの再起動](#サービスの再起動)
	1. [サービスの状態確認](#サービスの状態確認)
	1. [サービスの登録](#サービスの登録)
	1. [サービスの登録解除](#サービスの登録解除)
	1. [サービスの登録確認](#サービスの登録確認)
1. [シグナル](#シグナル)
1. [プロセス間通信](#プロセス間通信)
	1. [ソケット](#ソケット)
	1. [共有メモリ](#共有メモリ)
	1. [メッセージキュー](#メッセージキュー)
	1. [セマフォ](#セマフォ)


## プロセス

**プロセス**は、[メモリ](../../../hardware/_/chapters/memory.md#メモリ)上で[実行状態](../../../software/_/chapters/operating_system.md#実行状態)にある[プログラム](../../../../programming/_/chapters/programming.md#プログラム)。[Linux](./linux.md#linux)[カーネル](../../../software/_/chapters/operating_system.md#カーネル)はストレージ装置から[メモリ](../../../hardware/_/chapters/memory.md#メモリ)に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を読み出し、その[メモリ](../../../hardware/_/chapters/memory.md#メモリ)の内容に従って[CPU](../../../hardware/_/chapters/processor.md#cpu)が[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を実行する。プロセスはシステム上で一意の**PID**によって識別される。

ひとつの[プログラム](../../../../programming/_/chapters/programming.md#プログラム)や[コマンド](./basic_command.md#コマンド)が複数のプロセスを生成したり、プロセスがさらにプロセスを生成することもある。あるプロセスによって生み出された別のプロセスは、そのプロセスの子プロセスとなる。

プロセスは[オペレーティングシステム](../../../software/_/chapters/operating_system.md#オペレーティングシステム)の[タスクスケジューラ](../../../software/_/chapters/operating_system.md#タスク管理システム)によって制御され、[実行可能状態](../../../software/_/chapters/operating_system.md#実行可能状態)、[実行状態](../../../software/_/chapters/operating_system.md#実行状態)、[待ち状態](../../../software/_/chapters/operating_system.md#待ち状態)といった状態を遷移しながら処理が進められる。

### fork

**fork**は、親[プロセス](#プロセス)から子[プロセス](#プロセス)を生成する[システムコール](../../../software/_/chapters/operating_system.md#システムコール)のひとつ。親[プロセス](#プロセス)からforkが呼び出されると、システムは親[プロセス](#プロセス)の複製を作成し、それが子[プロセス](#プロセス)となる。子[プロセス](#プロセス)は親[プロセス](#プロセス)の状態を複製することによって生成されるため、実行される[プログラム](../../../../programming/_/chapters/programming.md#プログラム)は親[プロセス](#プロセス)と共通となる。子[プロセス](#プロセス)は親[プロセス](#プロセス)とは独立して動作し、親[プロセス](#プロセス)と異なる[PID](#プロセス)を持つ。

### clone

**clone**は、親[プロセス](#プロセス)から子[プロセス](#プロセス)を生成するための[システムコール](../../../software/_/chapters/operating_system.md#システムコール)のひとつ。[fork](#fork)と同様に、親[プロセス](#プロセス)の複製を子[プロセス](#プロセス)として生成する。cloneでは、親[プロセス](#プロセス)と子[プロセス](#プロセス)の間で共有されるリソースを指定することができ、複数の[プロセス](#プロセス)を協調させることができる。

### exec

**exec**は、現在の[プロセス](#プロセス)を新しい[プロセス](#プロセス)に置き換える[システムコール](../../../software/_/chapters/operating_system.md#システムコール)。execを使用することで、[プロセス](#プロセス)の実行中に[プログラム](../../../../programming/_/chapters/programming.md#プログラム)を切り替えたり[プロセス](#プロセス)の状態を維持したまま[プログラム](../../../../programming/_/chapters/programming.md#プログラム)をリロードしたりすることができる。

### プロセスの確認

`ps` は、[プロセス](#プロセス)の状態を表示するための[コマンド](./basic_command.md#コマンド)。 `ps` は"process status"の略語。

[コマンド](./basic_command.md#コマンド)の書式は以下の通り。

```
ps [OPTION]...
```

`ps` [コマンド](./basic_command.md#コマンド)を実行すると、この[コマンド](./basic_command.md#コマンド)を実行した[ユーザ](./user_and_permission.md#ユーザ)が起動している[プロセス](#プロセス)のリストが表示される。

```sh
$ ps
    PID TTY          TIME CMD
    425 pts/0    00:00:00 zsh
    689 pts/0    00:00:00 ps
```

`ps` の主要な[オプション](./basic_command.md#オプション)は以下の通り。

| オプション | 概要                                               |
| ---------- | :------------------------------------------------- |
| `a`        | 全てのユーザのプロセスの状態を表示する             |
| `f`        | プロセスの親子関係をツリー上にして表示する         |
| `u`        | プロセスのユーザ名と開始時刻を表示内容に付加する   |
| `x`        | 制御端末を持たないデーモンなどのプロセスも表示する |
| `l`        | 詳細情報を表示する                                 |
| `-e`       | 全プロセスの情報を表示する　                       |

[オプション](./basic_command.md#オプション)は、以下の例のように複数個まとめて指定することもできる。

```sh
$ ps aux
```

### プロセスツリーの確認

`pstree` は、[プロセス](#プロセス)の親子関係をツリー形式で表示するための[コマンド](./basic_command.md#コマンド)。

[コマンド](./basic_command.md#コマンド)の書式は以下の通り。

```
pstree [OPTION]...
```

`pstree` の主要な[オプション](./basic_command.md#オプション)は以下の通り。

| オプション | 概要                                            |
| ---------- | :---------------------------------------------- |
| `-p`       | 各プロセスのPIDを表示する                       |
| `-u`       | 各プロセスの実行ユーザ名を表示する              |
| `-h`       | ルートプロセスを表示しない                      |
| `-a`       | 各プロセスのコマンドライン引数も表示する        |
| `-n`       | 各プロセスの名前をソートせず、PIDの順に表示する |
| `-c`       | 同じ名前のプロセスをまとめて表示する            |
| `-G`       | 指定したグループIDを持つプロセスのみ表示する    |
| `-U`       | 指定したユーザIDを持つプロセスのみ表示する      |

### プロセスのリアルタイム監視

`top` は、[Linux](./linux.md#linux)システムで実行されている[プロセス](#プロセス)をリアルタイムで監視するための[コマンド](./basic_command.md#コマンド)。 `top` [コマンド](./basic_command.md#コマンド)で確認できる情報は以下の通り。

| ラベル | 概要                                                                                        |
| ------ | :------------------------------------------------------------------------------------------ |
| PID    | 各プロセスのPID                                                                             |
| USER   | 各プロセスを発行しているユーザ                                                              |
| PR     | プロセスの優先度                                                                            |
| NI     | プロセスの優先度を調整するために使用されるニース値                                          |
| VIRT   | プロセスが使用している仮想メモリサイズ                                                      |
| RES    | プロセスが使用している物理メモリサイズ                                                      |
| SHR    | プロセスが使用している共有メモリサイズ                                                      |
| S      | プロセスの現在の状態（D: 割込み不能、R: 実行中、S: スリープ、T: 停止中、Z: ゾンビプロセス） |
| %CPU   | プロセスが使用しているCPUの割合                                                             |
| %MEM   | プロセスが使用している物理メモリの割合                                                      |
| TIME+  | プロセスが起動している時間                                                                  |

### プロセスの強制終了

`kill` は、実行中の[プロセス](#プロセス)に[シグナル](#シグナル)を送信する[コマンド](./basic_command.md#コマンド)。[プロセス](#プロセス)を強制終了する場合などによく用いられる。

[コマンド](./basic_command.md#コマンド)の書式は以下の通り。

```
kill [SIGNAL] PID
```

例えば以下のコマンドを実行すると、PIDが1234のプロセスに `TERM` シグナルを送信する。

```sh
$ kill -TERM 1234
```

`kill` はプロセスを強制終了するだけでなく、プロセスを停止したり再開したりするための他のオプションもある。

また、 `pkill` はプロセス名指定でプロセスを強制終了するコマンド、 `killall` はプロセス名指定で全てのプロセスを強制終了するコマンドとなっている。

### メモリの監視

`free` は、メモリの使用状況を表示するためのコマンド。主に以下の情報を表示する。

| ラベル       | 概要                                           |
| ------------ | :--------------------------------------------- |
| `total`      | システム全体の物理メモリ量                     |
| `useed`      | 使用中の物理メモリ量                           |
| `free`       | 空き物理メモリ量                               |
| `shared`     | 共有メモリ量                                   |
| `buff/cache` | バッファやキャッシュに使われている物理メモリ量 |
| `available`  | アプリケーションに使用可能な物理メモリ量       |

コマンドの書式は以下の通り。

```
free [OPTION]...
```

`free` の主要なオプションは以下の通り。

| オプション       | 概要                                         |
| ---------------- | :------------------------------------------- |
| `-b` `--bytes`   | 結果をバイト単位で表示する                   |
| `-k` `--kilo`    | 結果をキロバイト単位で表示する（デフォルト） |
| `-m` `--mega`    | 結果をメガバイト単位で表示する               |
| `-g` `--giga`    | 結果をギガバイト単位で表示する               |
| `-h` `--human`   | より読みやすい形式で表示する                 |
| `-t` `--total`   | 全体のメモリ使用量のみを表示する             |
| `-s` `--seconds` | 指定した秒数ごとに繰り返し表示する           |
| `-c` `--count`   | 指定した回数繰り返し表示する                 |


## ジョブ

**ジョブ**は、1つのプログラムやコマンドといった実行単位のことで、1つ以上のプロセスをまとめたもの。シェルに入力された1行分が1つのジョブに対応し、ジョブは必要に応じてプロセスに分解されて処理される。

### フォアグラウンドジョブ

**フォアグラウンドジョブ**は、シェルによって起動されるジョブ。通常、コマンドを実行するとフォアグラウンドでジョブが生成され、そのジョブが終了するまではシェルはプロンプトを返さない。フォアグラウンドジョブはシェルへの入力を受け付ける状態となり、ユーザは対話的にプロセスに対してシグナルを送信することができる。

### バックグラウンドジョブ

**バックグラウンドジョブ**は、シェルとは切り離して実行されるジョブ。コマンドの末尾に `&` を追加して実行すると、そのコマンドはバックグラウンドジョブとして実行される。バックグラウンドジョブ（プロセス）にシグナルを送信するには、 `kill` コマンドを使用する。

### ジョブコントロール

フォアグラウンドジョブのコントロールに用いられるキーは以下の通り。

| キー         | 概要                                                   |
| ------------ | :----------------------------------------------------- |
| `Ctrl` + `c` | `SIGINT` シグナルを送出し、プロセスを終了する          |
| `Ctrl` + `z` | ジョブの実行を中断し、バックグラウンドジョブに退避する |

### ジョブの確認

`jobs` は、バックグラウンドにあるジョブの一覧を確認するためのコマンド。

例えば以下の例では、バックグラウンドで実行中の `sleep` コマンドの状態を `jobs` によって確認している。バックグラウンドジョブの処理が終わると、プロンプトにその旨が表示される。

```sh
$ sleep 60 &
[1] 2400

$ jobs
[1]  + running    sleep 10

$
[1]  + done       sleep 10
```

### フォアグラウンドジョブとして実行

`fg` は、ジョブをフォアグラウンドジョブとして実行するコマンド。

以下の例では、バックグラウンドで実行中の `sleep` をフォアグラウンドに切り替えている。

```sh
$ sleep 60 &
[1] 2744

$ jobs
[1]    running    sleep 20

$ fg %1
[1]    running    sleep 20
```

### バックグラウンドジョブとして実行

`bg` は、ジョブをバックグラウンドジョブとして実行するコマンド。

以下の例では、フォアグラウンドで実行していた `sleep` を `Ctrl` + `z` で一度バックグラウンドにサスペンドし、それを改めてバックグラウンドジョブとして再開している。

```sh
$ sleep 60

# Ctrl + z を入力
zsh: suspended  sleep 60

$ jobs
[1]  + suspended  sleep 60

$ bg %1
[1]    continued  sleep 60

$
[1]    done       sleep 60
```


## スレッド

**スレッド**は、1つのプロセスから生成される実行単位で、プロセス内で複数のタスクを並行して実行するなどの目的で使用される。複数のスレッドは同じプログラムコード、データ、ヒープなどを共有している。スレッドはプロセスよりも軽量で、プロセス間通信に比べてスレッド通信は高速である。


## デーモン

**デーモン**は、メインメモリ上に常駐して特定の機能を提供するプログラム。デーモンはinitプロセスやsystemdによってシステムの起動時に実行され、バックグラウンドで動作しながら処理要求があったときに処理を実行する。Webサーバやバッチプログラムなどがこれに該当し、プログラム名の末尾に `d` がつくのが慣例となっている（ `httpd` 、 `crond` など）。


## initプロセス

**initプロセス**は、Linuxシステムが起動された時に最初に実行され、システムの全てのプロセスの親プロセスとして機能するプロセス。システムのランレベルの設定や各種サービス、デーモンの起動などを行う。initプロセスのPIDは必ず1となる。

initプロセスは `/sbin/init` ファイルから起動され、起動時に設定されたランレベルに応じて必要なサービスやプロセスを開始する。通常は、ランレベルは `０` から `6` までの7段階があり、ランレベル `0` はシャットダウン、ランレベル `6` は再起動を表す。管理者はそれぞれのランレベルに合わせたスクリプトを用意して、必要なデーモンの起動処理などを記述する。

新しいLinuxディストリビューションの多くでは、initプロセスに代わってsystemdが利用される場合が多い。


## systemd

**systemd**は、Linuxシステムが起動された時に最初に実行されるプロセスで、システムのブートプロセスやサービス管理を行うシステム管理デーモン。従来のinitプロセスの代替として設計されており、プロセスの開始、監視、制御、終了等を行うことができる。systemdでは、デーモンやサービスの依存関係や起動順序、停止順序などを管理することができる。systemdのPIDは必ず1となる。

systemdでは各サービスがユニットファイルとして定義され、systemdによって自動的に管理される。また、 `systemctl` コマンドを利用してサービスのステータス確認や起動、停止、再起動、有効化、無効化などを行うことができる。

### サービス

**サービス**は、Linuxシステムが起動された時に開始されるデーモンプロセス。デーモンと同じ意味で使用される場合も多い。

### サービスの管理

`systemctl` は、systemdを制御するために使用されるコマンド。サービスの起動や停止、有効化、無効化などを行うサービスマネージャであり、システムの管理に必要なサブコマンドが用意されている。

コマンドの書式は以下の通り。

```
systemctl [OPTIONS...] COMMAND [UNIT...]
```

### サービスの開始

`systemct start` は、systemdを使用してLinuxシステム上のサービスを開始するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを開始する。

```sh
$ systemctl start httpd
```

ただし、システムを再起動した際には開始したサービスは起動されないので、自動で開始したい場合は `systemctl enable` を使用する。

### サービスの停止

`systemctl stop` は、systemdを使用してLinuxシステム上のサービスを停止するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを停止する。

```sh
$ systemctl stop httpd
```

ただし、自動的に開始されるように設定されているサービスは、システムを再起動したときに開始されてしまうので、完全に停止したい場合は `systemctl disable` を使用する。

### サービスの再起動

`systemctl restart` は、systemdを使用してLinuxシステム上のサービスを再起動するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスを再起動する。

```sh
$ systemctl restart httpd
```

これは、サービスの設定ファイルを変更して、再度その内容を読み込みたい場合などによく用いられる。

### サービスの状態確認

`systemctl status` は、systemdを使用してLinuxシステム上のサービスの状態を確認するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスの状態を表示する。

```sh
$ systemctl status httpd
```

### サービスの登録

`systemctl enable` は、systemdを使用してLinuxシステム上のサービスが起動時に自動的に開始されるように登録するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが次回のシステムの起動時に自動的に開始される。

```sh
$ systemctl enable httpd
```

### サービスの登録解除

`systemctl disable` は、systemdを使用してLinuxシステム上で自動的に起動されるように登録されたサービスを解除するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが次回のシステムの起動時に自動的に開始されないようにする。

```sh
$ systemctl disable httpd
```

### サービスの登録確認

`systemctl is-enabled` は、systemdを使用して指定したサービスが自動起動に登録されているかを確認するコマンド。

例えば以下のコマンドを実行すると、 `httpd` サービスが登録されているかを表示する。

```sh
$ systemctl is-enabled httpd
```


## シグナル

**シグナル**は、プロセスへ様々なイベントを通知するためのカーネルの機能（ソフトウェア割込み）。イベントの通知はプロセス自身や他プロセス、カーネルなど様々な場所から行うことが可能で、次のような目的で用いられる。

- プロセスにシグナルを送信して強制終了させる
- シグナルを送信してプロセスの処理を一時停止、再開させる
- シグナル受信時にユーザ定義の処理（シグナルハンドラ）を実行する

主なシグナルは以下の通り。

| シグナル番号 | シグナル名            | 概要                                                                                      |
| ------------ | --------------------- | :---------------------------------------------------------------------------------------- |
| `1`          | `HUP` (Hung up)       | プロセスを再起動するシグナル。設定ファイルの再読み込みなどに用いられる。                 |
| `2`          | `INT` (Interrupt)     | キーボードからの割込み( `Ctrl + C` )                                                      |
| `9`          | `KILL`                | プロセスを強制終了するシグナル。正常な処理を行わないため、最悪の場合ファイルが破損する。 |
| `15`         | `TERM` (Termination)  | プロセスを終了するシグナル。正常な終了処理を行う。                                       |
| `18`         | `CONT` (Continue)     | 一時停止のプロセスを再開するシグナル。                                                   |
| `19`         | `STOP`                | プロセスを一時停止するシグナル。                                                         |
| `20`         | `TSTP` (Teminal stop) | プロセスを中断するシグナル。                                                             |


## プロセス間通信

**プロセス間通信**(**IPC**: InterProcess Communication)は、実行中の複数のプロセス間でデータをやり取りするための仕組み。あるプログラムから別のプログラムへデータやメッセージを通知したり、プログラム同士で協調して処理を行うための技術や手段のことを指す。

### ソケット

**ソケット**(Socket)は、ネットワークを介してプロセス間通信を行うためのAPI。ソケットには、TCPやUDPなどのプロトコルに対応した種類がある。

サーバは以下のような手順で通信を行う。

1. socket: 待ち受け用のソケットを作成する
1. bind: 待ち受けるIPアドレスやポート番号といった情報をソケットに紐づける
1. listen: クライアントからの通信を待ち受ける
1. accept: 接続要求を受け入れ、通信用に新しいソケットを作成する
1. read/write: acceptで作成したソケットを用いて、クライアントとのデータのやり取りを行う

クライアントは以下のような手順で通信を行う。

1. socket: サーバとの通信用のソケットを作成する
1. connect: サーバが待ち受けているIPアドレスのポートに対して接続を試みる
1. read/write: 接続が確立したら、ソケットを介してサーバとのデータのやり取りを行う

### 共有メモリ

**共有メモリ**(Shared memory)は、IPCの一種で、複数のプロセスが同じメモリ領域を共有する仕組み。複数のプロセスが同じデータを更新する必要がある場合、共有メモリを使用することで高速な処理が可能となる。

共有メモリは、システム上に特定の領域をプロセスとは独立して確保しておき、プロセスと共有メモリを紐づけることで利用できる。共有メモリを扱うためのシステムコールは以下の通り。

- `shmget` : 共有メモリ領域を作成するためのシステムコール。共有メモリのサイズやアクセス権限を指定することができる。
- `shmat` : 共有メモリ領域にアタッチするためのシステムコール。共有メモリの識別子を指定して、その共有メモリ領域をプロセスのアドレス空間にマッピングする。
- `shmdt` : 共有メモリ領域をデタッチするためのシステムコール。プロセスが共有メモリが不要になったときに呼び出し、プロセスのアドレス空間から共有メモリが解放される。

### メッセージキュー

**メッセージキュー**(Message Queue)は、IPCの一種で、プロセス間でデータを送受信するための仕組み。メッセージキューでは、キューにデータを送信したり、キューからデータを取り出したりすることができる。

メッセージキューを用いると、非同期的にデータを送受信することが可能。メッセージキューを扱うためのシステムコールは以下の通り。

- `msgget` : メッセージキューを作成するためのシステムコール。作成されたメッセージキューには、一意のキーが割り当てられる。
- `msgsnd` : メッセージキューにメッセージを送信するためのシステムコール。送信されるメッセージには、メッセージタイプを指定する必要がある。
- `msgrcv` : メッセージキューからメッセージを取り出すためのシステムコール。受信されるメッセージは、指定されたメッセージタイプに一致する場合に受信される。メッセージがない場合は、指定された待ち時間が経過するか、別のプロセスがメッセージを送信するまで待機する。

### セマフォ

**セマフォ**(semaphore)は、プロセス間の同期や競合状態を解決するために使用される同期プリミティブ。セマフォは、プロセスが特定のリソースにアクセスできるかどうかを制御するために使用される。具体的には、セマフォはカウンタ変数とフラグ変数によってプロセスのアクセス制御を行う。

セマフォを扱うためのシステムコールは以下の通り。

- `semget` : セマフォを作成するために使用されるシステムコール。セマフォを取得する場合にも使用される。
- `semop` : セマフォを操作するために使用されるシステムコール。セマフォの値をインクリメントしたり、デクリメントしたりすることができる。
- `semctl` : セマフォの制御を行うためのシステムコール。セマフォの値を取得したり、設定したり、削除したりすることができる。
