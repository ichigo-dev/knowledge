# データ型


## 目次

1. [型](#型)
1. [プリミティブ型](#プリミティブ型)
	1. [文字型](#文字型)
	1. [整数型](#整数型)
	1. [固定小数点数型](#固定小数点数型)
	1. [浮動小数点数型](#浮動小数点数型)
	1. [ブーリアン型](#ブーリアン型)
	1. [ポインタ型](#ポインタ型)
	1. [参照型](#参照型)
1. [コンテナ型](#コンテナ型)
	1. [配列](#配列)
	1. [リスト](#リスト)
	1. [スタック](#スタック)
	1. [キュー](#キュー)
	1. [ハッシュテーブル](#ハッシュテーブル)
	1. [連想配列](#連想配列)
	1. [セット](#セット)
	1. [木](#木)
	1. [グラフ](#グラフ)


## 型

コンピュータが扱うデータを性質や属性によって分類したものを**データ型**という。プログラム中で使用するデータについても、それがどの型のデータであるかがはっきりしていないといけない。静的型付け言語においてはプログラマがソースコード中に型を明示することによってコンパイル時にデータの型が決まり、動的型付け言語においては実行時に型を自動的に判定する。

## プリミティブ型

多くのプログラミング言語では**プリミティブ型**（**基本データ型**、**原始型**）が標準的に用意されている。プリミティブ型に属する型はプログラミング言語においてそれ以上分解することができないシンプルな型であり、基本的にプロセッサが最も高速に演算できるデータとなる。

### 文字型

**文字型**（ `char` ）は自然言語の1文字を格納するための型。1バイトで表現できる**ASCII文字**だけでなく、文字種によって**マルチバイト文字**に対応しているものもある。文字セットとしては**UTF-8**や**Unicode**などのサポートが一般的。文字型の配列を文字列として扱う言語もある。

### 整数型

**整数型**（ `int`, `short`, `long` ）は整数値を格納するための型。1バイトが表現できる範囲は0~255(2の8乗)であるため、より大きい数値を扱えるように2バイトや4バイト、8バイトの整数型などを用意しているプログラミング言語もある。**符号付き整数**と**符号なし整数**をサポートしているものもあり、値が負にならないことが分かっている場合には符号なし整数を用いた方が使用できる数の範囲が増える。

### 固定小数点数型

**固定小数点数型**（ `fixed` ）は小数を扱うための型で、どのビットを小数点とするかをあらかじめ決めておく。データの解析は容易であるが、表現できる数値の範囲が限定されてしまうため、後述の浮動小数点数を用いる場合が多い。

### 浮動小数点数型

**浮動小数点数型**（ `float`, `double` ）は小数を扱うための型で、IEEE 754によって規定された浮動小数点方式と呼ばれる方式を用いる。

10進数において $12.345$ という数を浮動小数点数で表現すると、 $+0.012345 \times 10^3$ となる。この時 $+$ にあたる部分を符号部、 $^3$ にあたる部分を指数部、 $0.012345$ にあたる部分を仮数部という。また浮動小数点方式では、数値の有効範囲数を広げるために**正規化**（指数部を調整することで仮数部の最上位桁を0以外にする作業）を行う。前の例であれば、 $+0.12345 \times 10^2$ が正規化された浮動小数点数の表現となる。コンピュータが扱う数値は2進数であるため、**基数**（10進数であれば10、2進数であれば2など、計算の基準となる数）は2となる。

- **符号部**には、その数が正(0)であるか負(1)であるかを格納する
- **指数部**には、基数に対する指数部分を2進数表記したものを格納する（指数部が負の数の場合は**2の補数**表現を使用）
- **仮数部**には、正規化した小数点以下の値を格納する

浮動小数点数には単精度と倍精度があり、**単精度**では32ビット（符号部1ビット、指数部8ビット、仮数部23ビット）、**倍精度**では64ビット（符号部1ビット、指数部11ビット、仮数部52ビット）で表現する。

固定小数点数では限られた範囲の中であれば**誤差**なく計算することができるが、浮動小数点数では近似計算を前提としているため誤差が発生する。コンピュータでは無限小数や無理数の正確な値を扱うことができないため、有限の桁数で近似されている。10進数で表したときに有限小数であっても、2進数で表すと無限小数となる場合もあるので注意が必要（ $0.01$ など）。

### ブーリアン型

**ブーリアン型**（ `bool`, `boolean` ）は真偽値を扱うための型で、 `true` か `false` のどちらかの値が格納される。この型には対しては、論理積（ `AND` ）、論理和（ `OR` ）、排他的論理和（ `XOR` ）、同値、非同値、否定といった論理演算が可能。条件分岐において、条件式の評価結果として用いられる。

### ポインタ型

**ポインタ型**は変数や関数が置かれたメモリ上のアドレスを格納するための特殊な型。プログラム中で利用される変数や関数などのリソースはメモリ上で固有のアドレスを持っており、アドレスを知っていればそのデータにアクセスすることができる。ポインタが指す先のデータを直接読み書きすることができたり、メモリアドレスを足し引きして別のアドレスにアクセスできるというメリットがあるが、一方で予期しないアドレスのデータを変更してしまう場合があるなど深刻なバグにつながるという欠点もある。

![ポインタ](/note/programming/images/pointer.ja.jpg)

### 参照型

**参照型**はポインタ型と同様、変数や関数が置かれたメモリ上のアドレスを指す。ポインタ型と異なり、参照先に書き込むことはできない読み込み専用のデータ。また、参照先にデータが存在しない（未初期化状態）であることが禁止されている。これらの特性から、ポインタに比べて安全に利用できるという利点がある。


## コンテナ型

**コンテナ型**（**コレクション型**）は同じ型のデータを複数まとめるための抽象データ型。それぞれに特性や高速に動作する操作が異なるため、用途に応じて適切に使い分けることでプログラムの質を向上させることができる。

また、コンテナ型が持つ各要素に対する繰り返し処理の抽象化構造を**イテレータ**という。イテレータは繰り返し処理の `for` 文などにおいて利用される。

各プログラミング言語ごとに用意されている型や内部的なデータ構造が異なる場合があるので注意。

### 配列

**配列**は同じ型のデータの集合を格納するためのデータ型で、要素がメモリ上で隣り合うように並べらえれる。要素には**インデックス**（添え字）を使ってアクセスすることができる。インデックスは配列の最初の要素を0とした整数値となっている。

```c
char str[] = "Hello, world";
printf("%c\n", str[4]);    // 'o'が出力される

str[5] = '!';
printf("%s\n", str);       // "Hello! world"が出力される
```

配列にはコンパイル時に要素数が決まる**固定長配列**と、実行時に要素数を決定し要素の追加や削除ができる**可変長配列**がある。通常、固定長配列はメモリ上の**スタック領域**に格納され、可変長配列はメモリ上の**ヒープ領域**に格納される。また、ヒープ領域に確保したサイズが足りなくなった場合には**メモリの再確保**（**アロケート**）が行われる。

可変長配列の末尾に対するデータの追加・削除にかかる計算量は $O(1)$ で高速であるが、任意のインデックスに対するデータの挿入・削除にかかる計算量は $O(N)$ （挿入するインデックスから後ろのデータをすべて移動する必要があるため）とリストに比べて遅い。一方で、任意のインデックスの要素へのアクセスにかかる計算量は常に $O(1)$ と高速である。探索にかかる計算量は基本的には $O(N)$ であるが、配列がソート済みであれば二分探索を用いて $O(\log{N})$ に抑えることもできる。

中間位置へのデータ挿入が頻繁に行われたり、要素数が非常に大きくなるようなデータに対しては後述のリストを用いた方が良い場合もある。

### リスト

**リスト**（**連結リスト**、**リンクリスト**）は各ノードが任意のデータと他のノードへのポインタを持つようなデータ構造。

**単方向リスト**は各ノードが次のノードへのポインタを持つ。

**双方リスト**は各ノードが次のノードと前のノードへのポインタを持つ。

**循環リスト**は末尾のノードが先頭のノードへのポインタを持つ。

リストの任意の場所へのデータの挿入・削除にかかる計算量は $O(1)$ で高速である。一方で、要素へのアクセスにかかる計算量は $O(N)$ であり配列に比べて遅い。リストの要素へのアクセスするには、先頭の要素から順番にポインタをたどっていくしかない（メモリ上での配置が隣り合っているとは限らないため）。

### スタック

**スタック**はデータを**FILO**（First In Last Out、先入れ後出し）の構造で保持する。スタックに対してデータを追加することを**プッシュ**、スタックからデータを取り出すことを**ポップ**といい、これらを基本操作とするデータ型である。

### キュー

**キュー**はデータを**FIFO**（First In First Out、先入れ先出し）の構造で保持する。キューに対してデータを追加することを**エンキュー**、キューからデータを取り出すことを**デキュー**といい、これらを基本操作とするデータ型である。

キューに追加する要素に優先度を付け、優先度にもとづいてキュー内のデータをソートして取り出し順を変更するようなキューを**優先度付きキュー**という。

先頭、末尾の両方からデータの追加・取り出しを行うことができるようなキューを**両端キュー**（デック）という。

### ハッシュテーブル

**ハッシュテーブル**は、キーと値の組からなる**エントリ**を複数格納するデータ型。ハッシュテーブルはキーを元に生成された**ハッシュ値**をインデックスとして値を管理することで、検索や要素の追加を $O(1)$ で実現することができる。ハッシュ値を算出するための関数を**ハッシュ関数**という。

複数の異なるキーから生成されるハッシュ値が同じものになってしまうことを**衝突**という。**連鎖法**では、同じハッシュ値で解決されるデータをリンクリストで管理する。**開番地法**では、衝突が発生したときに別の関数を用いて次の候補値を算出する。

### 連想配列

**連想配列**（**連想リスト**、**連想コンテナ**、**辞書**）はインデックスとして文字列などの整数値以外のデータ型を用いることができるような配列。連想配列の実装にはハッシュテーブルや**平衡二分探索木**などが用いられる。

### セット

**セット**（**集合**）は順序のないデータの集まりであり、重複するデータが存在しないことを保証する。

### 木

**木**はノードとノード間を結ぶエッジからなる木構造のデータ。1つのノードが複数の子ノードを持ち、親ノードを持たないトップクラスのノードを**ルートノード**（根ノード）、子ノードを持つノードを**ブランチノード**（枝ノード）、子ノードを持たないノードを**リーフノード**（葉ノード）という。

各ノードが持つ子ノードの数が2つに制限された木を**二分木**、葉の深さがなるべく揃うように構築された木を**平衡木**という。

### グラフ

**グラフ**は木と同様にノードとエッジからなるデータ構造であるが、木とは異なりノード同士の親子関係を持たない。
