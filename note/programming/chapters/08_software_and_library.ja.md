# ソフトウェアとライブラリ


## 目次

1. [コンポーネント](#コンポーネント)
1. [モジュール](#モジュール)
1. [ライブラリ](#ライブラリ-1)
	1. [標準ライブラリ](#標準ライブラリ)
	1. [サードパーティライブラリ](#サードパーティライブラリ)
1. [フレームワーク](#フレームワーク)
1. [パッケージ](#パッケージ)
	1. [パッケージマネージャ](#パッケージマネージャ)
1. [ソフトウェアとアプリケーション](#ソフトウェアとアプリケーション)
	1. [ハードウェアとファームウェアとソフトウェア](#ハードウェアとファームウェアとソフトウェア)
	1. [基本ソフトウェアと応用ソフトウェア](#基本ソフトウェアと応用ソフトウェア)
1. [バージョン](#バージョン)
1. [OSS](#oss)
	1. [ライセンス](#ライセンス)
1. [デザインパターン](#デザインパターン)
1. [ソフトウェアアーキテクチャ](#ソフトウェアアーキテクチャ)
	1. [MVC](#mvc)
	1. [MVVM](#mvvm)
	1. [Flux](#flux)


## コンポーネント

**コンポーネント**は[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)の構成要素を指す用語。単体ではなく、他の構成要素と組み合わせることで機能する。[モジュール](#モジュール)よりも広義の意味で使用されることが多く、[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)だけでなくファイルや物理的な構成要素に対しても用いられる。


## モジュール

**モジュール**は[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)の中で何かひとまとまりの機能を持った部品を指す用語。単体ではなく、他の構成要素と組み合わせることで機能する。構成要素の中でも主に[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)に対して用いられる。


## ライブラリ

**ライブラリ**は汎用的な[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を再利用しやすい形でまとめたもの。[モジュール](#モジュール)などを組み合わせて、複数のシステムで必要となる汎用的な機能を繰り返し利用できるようにする。ライブラリを適切に用いることでシステム開発のコストが大幅に削減できる。

### 標準ライブラリ

**標準ライブラリ**は各[プログラミング言語](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)の仕様としてあらかじめ用意されている[ライブラリ](#ライブラリ)。[プログラミング言語](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)の更新に合わせて[ライブラリ](#ライブラリ)自体も更新される場合が多いため、[サードパーティライブラリ](#サードパーティライブラリ)に比べて信頼性が高い。一方で、汎用的な最低限の機能のみを提供していることが一般的であるため、要件によっては標準ライブラリだけでは実現が難しい場合もある。

### サードパーティライブラリ

**サードパーティライブラリ**は各[プログラミング言語](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)の開発チーム、自分が属する開発チーム以外の第三者によって実装された[ライブラリ](#ライブラリ)。あらゆる[プログラマ](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)が自由に開発できるため、様々な機能を持つものや限定的な用途にも対応した[ライブラリ](#ライブラリ)が存在する。

[プログラミング言語](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)自体の更新により[ライブラリ](#ライブラリ)が動作しなくなる（サポートが終了する）、そもそも正しく動作しない、要件を満たす機能がそろっていない、などのリスクもある。[ライブラリ](#ライブラリ)の[依存関係](#パッケージマネージャ)が増えるとシステムのメンテナンスが困難になる場合もあるため注意する。

また、[プログラミング言語](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)自体の仕様と合わせて[ライブラリ](#ライブラリ)の機能に対する理解が必要となるため、学習コストがかかる。独自実装した時のコストが学習コストに対して大きく上回る場合は利用を検討するなど、開発チーム内でルールを設けるとよい。

サードパーティライブラリを使用する場合には、[ライセンス](#ライセンス)にも注意する必要がある。


## フレームワーク

**フレームワーク**は[アプリケーション](#基本ソフトウェアと応用ソフトウェア)や[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を開発する際の骨組みとなる[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)。システム開発に必要となる様々な機能やツールをそろえており、大幅に開発コストを削減できる。フレームワークは[アーキテクチャ](ソフトウェアアーキテクチャ)の実装をベースとして、各種[ライブラリ](#ライブラリ)を組み合わせて作られているものも多い。

フレームワークを利用する際には具体的な実装を意識することなく提供された機能を利用することができるため、[プログラマ](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)は解決したいタスクに直接関わる[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)（**ビジネスロジック**）に集中して[プログラミング](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)が行える。


## ソフトウェアとアプリケーション

![コンピュータシステム](../images/computer_system.jpg)

### ハードウェアとファームウェアとソフトウェア

**ハードウェア**は[コンピュータ](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)本体やキーボードなどの物理的な機械構成要素を指す。

**ファームウェア**はハードウェアを動かすために組み込まれた[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を指し、一般的にはハードウェアとセットになっている。PCにおけるファームウェアはマザーボードを制御する役割を持ち、**BIOS**や**UEFI**などが一般的。

**ソフトウェア**はハードウェア上で動作する[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)全般を指す。

### 基本ソフトウェアと応用ソフトウェア

**OS**(Operationg System)は**基本ソフトウェア**のことであり、ユーザが[ハードウェア](#ハードウェアとファームウェアとソフトウェア)に入力したり、[ハードウェア](#ハードウェアとファームウェアとソフトウェア)からの出力をユーザに表示したり、[コンピュータ](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)にインストールされた[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の動作を管理したりといった基本的な動作を行うための[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)。PCではWindowsやLinux、MacOS、Chrome OSなどが、モバイル端末ではAndroid OSやiOSなどが一般的に普及している。応用ソフトウェアが[ハードウェア](#ハードウェアとファームウェアとソフトウェア)を意識せずに実装されているのは、基本ソフトウェアの機能を利用しているからである。基本ソフトウェアが[ファームウェア](#ハードウェアとファームウェアとソフトウェア)とのやり取りをするために利用する[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を**デバイスドライバ**といい、デバイスドライバは基本ソフトウェアに含まれている。

**アプリケーション**は**応用ソフトウェア**のことであり、ワープロソフトや表計算ソフト、画像編集用のソフトなどといった、ある特定の業務や目的を達成するための[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)。応用ソフトウェアは[ハードウェア](#ハードウェアとファームウェアとソフトウェア)資源（[メモリ](./01_basic_knowledge_of_programming.ja.md#記憶装置)など）を必要とするが、これらの管理は基本ソフトウェアによって行われているため、[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の開発者は[ハードウェア](#ハードウェアとファームウェアとソフトウェア)を意識することなく実装することができる。

OSが提供する機能ほど汎用的ではないが、OSの機能だけでは実現にコストがかかるような機能をアプリケーションに提供する[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を**ミドルウェア**という。通常はOSの機能の拡張や、アプリケーションで利用される汎用的な機能を集めたものである。代表的なミドルウェアには、アプリケーションサーバやデータベース管理システム(DBMS)などがある。


## パッケージ

**パッケージ**は[ライブラリ](#ライブラリ)や[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を配布可能な形にしたものを指す用語。あるいは単に、関連する機能を持つ[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を1つにまとめて再利用しやすくしたもの。単体で機能を提供されているものを組み合わせたものを**スイート**と呼ぶ場合もある。

### パッケージマネージャ

[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)開発においては、[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)中で用いる全ての機能を1から実装しようとすると非常に大きなコストがかかるため、様々な[パッケージ](#パッケージ)を組み合わせる場合が多い。さらに、導入した[パッケージ](#パッケージ)が別の[パッケージ](#パッケージ)を必要としている可能性もある。このように[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)が必要とする[パッケージ](#パッケージ)の関係性のことを**依存関係**といい、依存する[パッケージ](#パッケージ)が多くなると依存関係も複雑化する。さらに、[パッケージ](#パッケージ)の[バージョン](#バージョン)により[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)が動かない場合もあるため、これらすべての依存関係を把握して管理することが困難な場合もある。

**パッケージマネージャ**は[プログラム](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)が必要とする[パッケージ](#パッケージ)やその[バージョン](#バージョン)を管理したり、[パッケージ](#パッケージ)の導入を容易にしたりするためのツールである。パッケージマネージャの導入により[プログラマ](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を[パッケージ](#パッケージ)への依存関係に対する責任から解放し、依存関係の解決が容易になる。


## バージョン

[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)は一度リリースされた後も、開発者によってメンテナンスや機能追加が継続的に行われていく場合が多い。同じ名前の[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の新旧を区別する番号などのことを**バージョン**という。

[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)のバージョンが上がっても以前利用できていた機能が継続的に利用できることを**後方互換性**があるという。後方互換性を失ったソフトウェアは、[依存関係](#パッケージマネージャ)を大きく侵害してしまう恐れがあるため注意が必要である。

バージョンのつけ方は開発チームの自由であるが、一般的には3つの数字を用いて `x.y.z` のように表記する。 `z` にあたる部分は**パッチバージョン**と呼ばれ、[バグ](./01_basic_knowledge_of_programming.ja.md#エラー)の修正や誤字の修正など比較的影響の少ない変更があった場合にカウントされる。 `y` にあたる部分は**マイナーバージョン**と呼ばれ、後方互換性を保った[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)内の仕様変更や機能の追加があった場合にカウントされる。 `x` にあたる部分は**メジャーバージョン**と呼ばれ、後方互換性を保てないようなシステム自体の大規模アップデートがあった場合にカウントされる。

他にも**正式版**の[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)がリリースされる前に、機能が足りていない試作品として**アルファ版**や、一部の機能が足りておらず動作が不安定である**ベータ版**として試験的に公開される場合もある。


## OSS

**OSS**(Open Source Software)は[ソースコード](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)が公開されており、誰でも自由に改変、再利用が可能な[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)。誰でも[ソースコード](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を読むことができるため、[バグ](./01_basic_knowledge_of_programming.ja.md#エラー)の発見や機能追加のサイクルが活発で成長が早い。一方で、悪意のあるユーザも[ソースコード](./01_basic_knowledge_of_programming.ja.md#プログラミングの概要)を閲覧できてしまい、セキュリティホールが生まれやすい。

### ライセンス

**ライセンス**は[OSS](#oss)の使用許諾条件であり、[OSS](#oss)を利用する際はライセンスを遵守する必要がある。

**コピーレフト**型のライセンスは最も厳しい部類のライセンス。常に著作権の表示が必要で、[GPLライセンス](https://ja.wikipedia.org/wiki/GNU_General_Public_License)を使用すると配布物もGPLライセンスにする必要がある（GPL汚染）。

**準コピーレフト**型のライセンスを持つ[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を利用した場合は、ライセンスの伝搬は起こらない。ただし、派生する[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)にはライセンスが伝搬し、また再配布する場合には著作権表示が必要となる。

**非コピーレフト**型のライセンスは最も制限が緩い部類のライセンス。他の[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を組み合わせた場合や派生する[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)についてライセンスを伝搬しない。


## デザインパターン

**デザインパターン**は[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の開発者が蓄積した設計ノウハウに名前を付けて再利用しやすいようにしたもの。解決したい機能要件に対して、それらを解決するための設計方針がデザインパターンとなる。

有名なものに**GoF**が取り上げた23種類の[オブジェクト指向](./07_class.ja.md#オブジェクト指向)に関するデザインパターンがある。


## ソフトウェアアーキテクチャ

システムの抽象的な構造や設計を**アーキテクチャ**といい、[フレームワーク](#フレームワーク)などはアーキテクチャの具体的な実装にあたる。ソフトウェアアーキテクチャの存在により、[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)開発の複雑性を軽減することができる。

### MVC

**MVC**は[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の機能を役割ごとに分割するための[アーキテクチャ](#ソフトウェアアーキテクチャ)。[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を**Model**（モデル処理、データ処理）、**View**（ユーザに向けた表示領域）、**Controller**（入力処理、[ビジネスロジック](#フレームワーク)）の3つの役割に分けて構成する。

MVCアーキテクチャを採用した[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)では、次のような流れで処理を行う。

1. ユーザからの入力をControllerが受け取る
1. ControllerがModelにデータを渡し、Modelでデータ処理を行う
1. Modelが処理したデータをControllerを介してViewに渡す
1. Viewがデータの表示を行う

処理を役割ごとに分担することで問題を切り分けることができる反面、ModelとViewの仲介役となるControllerの負担が大きくなるというデメリットがある。

### MVVM

**MVVM**は[MVC](#mvc)と同様、[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)の持つ機能を役割ごとに分割するための[アーキテクチャ](#ソフトウェアアーキテクチャ)。ユーザの入力データと格納されたデータを**バインディング**（関連付け）するのが特徴。[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を**Model**（モデル処理、データ処理）、**View**（ユーザに向けた表示領域）、**View Model**（ModelとViewの仲介を行う）の3つの役割に分けて構成する。

1. ユーザからの入力をViewが受け取る
1. View Modelにデータが送信され、入力内容が反映される
1. View ModelがModelにデータを渡し、Modelでデータ処理を行う
1. View Modelの値が変化したことで、Viewにも変更が反映される

バインディングにより、ViewかViewModelのどちらかの値が変化するとその値が相互に反映される。

### Flux

**Flux**はデータの流れを単一方向に限定し、サイクルを繰り返すことで処理を行う[アーキテクチャ](#ソフトウェアアーキテクチャ)。[ソフトウェア](#ハードウェアとファームウェアとソフトウェア)を**Action**（ユーザの入力やサーバからのデータの受信によるイベント）、**Dispatcher**（入力を受け取りコールバックを実行）、**Stor**（Dispatcherに紐づけたコールバックによりデータを処理）、**View**（更新されたデータを表示）により構成する。
