# ライブラリ


## 目次

1. [コンポーネント](#コンポーネント)
1. [モジュール](#モジュール)
1. [ライブラリ](#ライブラリ-1)
	1. [標準ライブラリ](#標準ライブラリ)
	1. [サードパーティライブラリ](#サードパーティライブラリ)
1. [フレームワーク](#フレームワーク)
1. [パッケージ](#パッケージ)
1. [OSS](#oss)
	1. [ライセンス](#ライセンス)
1. [デザインパターン](#デザインパターン)
1. [ソフトウェアアーキテクチャ](#ソフトウェアアーキテクチャ)
	1. [MVC](#mvc)
	1. [MVVM](#mvvm)
	1. [Flux](#flux)


## コンポーネント

**コンポーネント**はプログラムの構成要素を指す用語。単体ではなく、他の構成要素と組み合わせることで機能する。モジュールよりも広義の意味で使用されることが多く、プログラムだけでなくファイルや物理的な構成要素に対しても用いられる。


## モジュール

**モジュール**はプログラムの中で何かひとまとまりの機能を持った部品を指す用語。単体ではなく、他の構成要素と組み合わせることで機能する。構成要素の中でも主にプログラムに対して用いられる。


## ライブラリ

**ライブラリ**は汎用的なプログラムを再利用しやすい形でまとめたもの。モジュールなどを組み合わせて、様々なシステムで必要となる機能を繰り返し利用できるようにする。ライブラリを適切に用いることでシステム開発のコストが大幅に削減できる。

### 標準ライブラリ

**標準ライブラリ**は各プログラミング言語の仕様としてあらかじめ用意されているライブラリ。プログラミング言語の更新に合わせてライブラリ自体も更新される場合が多いため、サードパーティライブラリに比べて信頼性が高い。一方で、汎用的な最低限の機能のみを提供していることが一般的であるため、要件によっては標準ライブラリだけでは実現が難しい場合もある。

### サードパーティライブラリ

**サードパーティライブラリ**は各プログラミング言語の開発チーム、自分の開発チーム以外の第三者によって実装されたライブラリ。あらゆるプログラマが自由に開発できるため、様々な機能を持つものや限定的な用途にも対応したライブラリが存在する。

プログラミング言語自体の更新によりライブラリが動作しなくなる（サポートが終了する）、そもそも正しく動作しない、要件を満たす機能がそろっていない、などのリスクもある。ライブラリの**依存関係**が増えるとシステムのメンテナンスが困難になる場合もあるため注意する。

また、プログラミング言語自体の仕様と合わせてライブラリの機能に対する理解が必要となるため、学習コストがかかる。独自実装した時のコストが学習コストに対して大きく上回る場合は利用を検討するなど、開発チーム内でルールを設けるとよい。

サードパーティライブラリを使用する場合には、ライセンスにも注意する必要がある。


## フレームワーク

**フレームワーク**はアプリケーションやソフトウェアを開発する際の骨組みとなるプログラム。システム開発に必要となる様々な機能やツールをそろえており、大幅に開発コストを削減できる。フレームワークはアーキテクチャの実装をベースとして、各種ライブラリを組み合わせ

フレームワークでは具体的な実装を意識することなく提供された機能を利用することができる。プログラマは解決したいタスクに直接関わるプログラム（**ビジネスロジック**）に集中してプログラミングが行える。


## パッケージ

**パッケージ**はライブラリやソフトウェアを配布可能な形にしたものを指す用語。あるいは単に、関連する機能を持つプログラムを1つにまとめて再利用しやすくしたもの。単体で機能を提供されているものを組み合わせたものを**スイート**と呼ぶ場合もある。


## OSS

**OSS**(Open Source Software)はソースコードが公開されており、誰でも自由に改変、再利用が可能なソフトウェア。誰でもソースコードを読むことができるため、バグの発見や機能追加のサイクルが活発で成長が早い。一方で、悪意のあるユーザもソースコードを閲覧できてしまい、セキュリティホールが生まれやすい。

### ライセンス

**ライセンス**はOSSの使用許諾条件であり、OSSを利用する際はライセンスを遵守する必要がある。

**コピーレフト**型のライセンスは最も厳しい部類のライセンス。常に著作権の表示が必要で、GPLライセンスを使用すると配布物もGPLライセンスにする必要がある（GPL汚染）。

**準コピーレフト**型のライセンスを持つソフトウェアを利用した場合は、ライセンスの伝搬は起こらない。ただし、派生するソフトウェアにはライセンスが伝搬し、また再配布する場合には著作権表示が必要となる。

**非コピーレフト**型のライセンスは最も制限が緩い部類のライセンス。他のソフトウェアを組み合わせた場合や派生するソフトウェアについてライセンスを伝搬しない。


## デザインパターン

**デザインパターン**はソフトウェアの開発者が蓄積した設計ノウハウに名前を付けて再利用しやすいようにしたもの。解決したい機能要件に対して、それらを解決するための設計方針がデザインパターンとなる。

有名なものに**GoF**が取り上げた23種類のオブジェクト指向に関するデザインパターンがある。


## ソフトウェアアーキテクチャ

システムの抽象的な構造や設計を**アーキテクチャ**といい、フレームワークなどはアーキテクチャの具体的な実装にあたる。ソフトウェアアーキテクチャの存在により、ソフトウェア開発の複雑性を軽減することができる。

### MVC

**MVC**はソフトウェアの機能を役割ごとに分割するためのアーキテクチャ。ソフトウェアを**Model**（モデル処理、データ処理）、**View**（ユーザに向けた表示領域）、**Controller**（入力処理、ビジネスロジック）の3つの役割に分けて構成する。

MVCアーキテクチャを採用したソフトウェアでは、次のような流れで処理を行う。

1. ユーザからの入力をControllerが受け取る
1. ControllerがModelにデータを渡し、Modelでデータ処理を行う
1. Modelが処理したデータをControllerを介してViewに渡す
1. Viewがデータの表示を行う

処理を役割ごとに分担することで問題を切り分けることができる反面、ModelとViewの仲介役となるControllerの負担が大きくなるというデメリットがある。

### MVVM

**MVVM**はMVCと同様、ソフトウェアの持つ機能を役割ごとに分割するためのアーキテクチャ。ユーザの入力データと格納されたデータを**バインディング**（関連付け）するのが特徴。ソフトウェアを**Model**（モデル処理、データ処理）、**View**（ユーザに向けた表示領域）、**View Model**（ModelとViewの仲介を行う）の3つの役割に分けて構成する。

1. ユーザからの入力をViewが受け取る
1. View Modelにデータが送信され、入力内容が反映される
1. View ModelがModelにデータを渡し、Modelでデータ処理を行う
1. View Modelの値が変化したことで、Viewにも変更が反映される

バインディングにより、ViewかViewModelのどちらかの値が変化するとその値が相互に反映される。

### Flux

**Flux**はデータの流れを単一方向に限定し、サイクルを繰り返すことで処理を行うアーキテクチャ。ソフトウェアを**Action**（ユーザの入力やサーバからのデータの受信によるイベント）、**Dispatcher**（入力を受け取りコールバックを実行）、**Stor**（Dispatcherに紐づけたコールバックによりデータを処理）、**View**（更新されたデータを表示）により構成する。
